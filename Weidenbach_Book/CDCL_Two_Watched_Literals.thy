(*  Title: CDCL with Two Watched Literals
    Author: Jasmin Blanchette <jasmin.blanchette@inria.fr>
    Author: Mathias Fleury <mathias.fleury@mpi-inf.mpg.de>
*)

theory CDCL_Two_Watched_Literals
imports CDCL_WNOT (* Have to decide which imports are the best *)
begin

(* TODO: BEGIN Move to Multiset_More *)

lemma mset_filter_compl: "mset (filter p xs) + mset (filter (Not \<circ> p) xs) = mset xs"
  apply (induct xs)
  by simp
    (metis (no_types) add_diff_cancel_left' comp_apply filter.simps(2) mset.simps(2)
       mset_compl_union)

lemma singleton_subseteq_iff[iff]: "{#x#} \<subseteq># A \<longleftrightarrow> x \<in># A"
  by (meson mset_leD mset_le_single multi_member_last)

lemma image_mset_subseteq_mono: "A \<subseteq># B \<Longrightarrow> image_mset f A \<subseteq># image_mset f B"
  by (metis image_mset_union subset_mset.le_iff_add)

lemma image_filter_ne_mset[simp]:
  "image_mset f {#x \<in># M. f x \<noteq> y#} = remove_mset (image_mset f M) y"
  by (induct M, auto, meson count_le_replicate_mset_le order_refl subset_mset.add_diff_assoc2)

lemma distinct_mset_set_mset_ident[simp]: "distinct_mset M \<Longrightarrow> mset_set (set_mset M) = M"
  apply (auto simp: multiset_eq_iff)
  apply (rename_tac x)
  apply (case_tac "count M x = 0")
   apply simp
  apply (case_tac "count M x = 1")
   apply simp
  unfolding distinct_mset_count_less_1
  by (meson le_neq_implies_less less_one)

lemma count_mset_set_le_one: "count (mset_set A) x \<le> 1"
  by (metis count_mset_set(1) elem_mset_set le_less less_eq_nat.simps(1) mset_set.infinite
    zero_multiset.rep_eq)

lemma mset_set_subseteq_mset_set[iff]:
  assumes "finite A" "finite B"
  shows "mset_set A \<subseteq># mset_set B \<longleftrightarrow> A \<subseteq> B"
(* generated by Sledgehammer *)
proof -
  { assume "\<not> mset_set A \<subseteq># mset_set B"
    have "mset_set A \<subseteq># mset_set B \<or> (\<exists>a. a \<notin> B \<and> a \<in> A)"
      using assms(2) by (metis count_mset_set(1) count_mset_set(3) count_mset_set_le_one
        elem_mset_set le_less_linear mset_less_eqI)
    then have "A \<subseteq> B \<longrightarrow> mset_set A \<subseteq># mset_set B"
      by (meson contra_subsetD) }
  then show ?thesis
    using assms by (metis (full_types) finite_set_mset_mset_set set_mset_mono)
qed

lemma distinct_finite_set_mset_subseteq_iff[iff]:
  assumes dist: "distinct_mset M" and fin: "finite N"
  shows "set_mset M \<subseteq> N \<longleftrightarrow> M \<subseteq># mset_set N"
proof
  assume "set_mset M \<subseteq> N"
  then show "M \<subseteq># mset_set N"
    by (metis dist distinct_mset_set_mset_ident fin finite_subset mset_set_subseteq_mset_set)
next
  assume "M \<subseteq># mset_set N"
  then show "set_mset M \<subseteq> N"
    by (metis contra_subsetD empty_iff finite_set_mset_mset_set infinite_set_mset_mset_set
      set_mset_mono subsetI)
qed

lemma distinct_mem_diff_mset:
  assumes dist: "distinct_mset M" and mem: "x \<in> set_mset (M - N)"
  shows "x \<notin> set_mset N"
proof -
  have "count M x = 1"
    using dist mem by (simp add: distinct_mset_def)
  then show ?thesis
    using mem by simp
qed

lemma distinct_set_mset_eq:
  assumes
    dist_m: "distinct_mset M" and
    dist_n: "distinct_mset N" and
    set_eq: "set_mset M = set_mset N"
  shows "M = N"
proof -
  have "mset_set (set_mset M) = mset_set (set_mset N)"
    using set_eq by simp
  thus ?thesis
    using dist_m dist_n by auto
qed

(* END *)

text \<open>Only the 2-watched literals have to be verified here: the backtrack level and the trail can
  remain separate.\<close>

datatype 'v twl_clause =
  TWL_Clause (watched: "'v clause") (unwatched: "'v clause")

abbreviation raw_clause :: "'v twl_clause \<Rightarrow> 'v clause" where
  "raw_clause C \<equiv> watched C + unwatched C"

datatype ('v, 'lvl, 'mark) twl_state =
  TWL_State (trail: "('v, 'lvl, 'mark) marked_lits") (init_clss: "'v twl_clause multiset")
    (learned_clss: "'v twl_clause multiset") (backtrack_lvl: 'lvl)
    (conflicting: "'v clause conflicting_clause")

abbreviation raw_init_clss where
  "raw_init_clss S \<equiv> image_mset raw_clause (init_clss S)"

abbreviation raw_learned_clsss where
  "raw_learned_clsss S \<equiv> image_mset raw_clause (learned_clss S)"

abbreviation clauses where
  "clauses S \<equiv> init_clss S + learned_clss S"

definition
  candidates_propagate :: "('v, 'lvl, 'mark) twl_state \<Rightarrow> ('v literal \<times> 'v clause) set"
where
  "candidates_propagate S =
   {(L, raw_clause C) | L C.
    C \<in># clauses S \<and> watched C - mset_set (uminus ` lits_of (trail S)) = {#L#} \<and>
    undefined_lit L (trail S)}"

definition candidates_conflict :: "('v, 'lvl, 'mark) twl_state \<Rightarrow> 'v clause set" where
  "candidates_conflict S =
   {raw_clause C | C. C \<in># clauses S \<and> watched C \<subseteq># mset_set (uminus ` lits_of (trail S))}"

(* FIXME *)
(* interpretation dpll_state trail "image_mset raw_clause o clauses"
  "\<lambda>M S. TWL_State M (init_clss S) (learned_clss S) (backtrack_lvl S) (conflicting S)"
oops *)

primrec wf_twl_cls :: "('v, 'lvl, 'mark) marked_lit list \<Rightarrow> 'v twl_clause \<Rightarrow> bool" where
  "wf_twl_cls M (TWL_Clause W UW) \<longleftrightarrow>
   distinct_mset W \<and> size W \<le> 2 \<and> (size W < 2 \<longrightarrow> set_mset UW \<subseteq> set_mset W) \<and>
   (\<forall>L \<in># W. -L \<in> lits_of M \<longrightarrow> (\<forall>L' \<in># UW. L' \<notin># W \<longrightarrow> -L' \<in> lits_of M))"

definition wf_twl_state :: "('v, 'lvl, 'mark) twl_state \<Rightarrow> bool" where
  "wf_twl_state S \<longleftrightarrow> (\<forall>C \<in># clauses S. wf_twl_cls (trail S) C)"

lemma wf_candidates_propagate_sound:
  assumes wf: "wf_twl_state S" and
    cand: "(L, C) \<in> candidates_propagate S"
  shows "trail S \<Turnstile>as CNot (mset_set (set_mset C - {L})) \<and> undefined_lit L (trail S)"
proof
  def M \<equiv> "trail S"
  def N \<equiv> "init_clss S"
  def U \<equiv> "learned_clss S"

  note MNU_defs [simp] = M_def N_def U_def

  obtain Cw where cw:
    "C = raw_clause Cw"
    "Cw \<in># N + U"
    "watched Cw - mset_set (uminus ` lits_of M) = {#L#}"
    "undefined_lit L M"
    using cand unfolding candidates_propagate_def MNU_defs by blast

  obtain W UW where cw_eq: "Cw = TWL_Clause W UW"
    by (case_tac Cw, blast)

  have l_w: "L \<in># W"
    by (metis Multiset.diff_le_self cw(3) cw_eq mset_leD multi_member_last twl_clause.sel(1))

  have wf_c: "wf_twl_cls M Cw"
    using wf \<open>Cw \<in># N + U\<close> unfolding wf_twl_state_def by simp

  have w_nw:
    "distinct_mset W"
    "size W < 2 \<Longrightarrow> set_mset UW \<subseteq> set_mset W"
    "\<And>L L'. L \<in># W \<Longrightarrow> -L \<in> lits_of M \<Longrightarrow> L' \<in># UW \<Longrightarrow> L' \<notin># W \<Longrightarrow> -L' \<in> lits_of M"
   using wf_c unfolding cw_eq by auto

  have "\<forall>L' \<in> set_mset C - {L}. -L' \<in> lits_of M"
  proof (cases "size W < 2")
    case True
    moreover have "size W \<noteq> 0"
      using cw(3) cw_eq by auto
    ultimately have "size W = 1"
      by linarith
    then have w: "W = {#L#}"
      by (metis (no_types, lifting) Multiset.diff_le_self cw(3) cw_eq single_not_empty
        size_1_singleton_mset subset_mset.add_diff_inverse union_is_single twl_clause.sel(1))
    from True have "set_mset UW \<subseteq> set_mset W"
      using w_nw(2) by blast
    then show ?thesis
      using w cw(1) cw_eq by auto
  next
    case sz2: False
    show ?thesis
    proof
      fix L'
      assume l': "L' \<in> set_mset C - {L}"
      have ex_la: "\<exists>La. La \<noteq> L \<and> La \<in># W"
      proof (cases W)
        case empty
        thus ?thesis
          using l_w by auto
      next
        case lb: (add W' Lb)
        show ?thesis
        proof (cases W')
          case empty
          thus ?thesis
            using lb sz2 by simp
        next
          case lc: (add W'' Lc)
          thus ?thesis
            by (metis add_gr_0 count_union distinct_mset_single_add lb union_single_eq_member
              w_nw(1))
        qed
      qed
      then obtain La where la: "La \<noteq> L" "La \<in># W"
        by blast
      then have "La \<in># mset_set (uminus ` lits_of M)"
        using cw(3)[unfolded cw_eq, simplified, folded M_def]
        by (metis count_diff count_single diff_zero not_gr0)
      then have nla: "-La \<in> lits_of M"
        by auto
      then show "-L' \<in> lits_of M"
      (* generated by Sledgehammer in two iterations *)
      proof -
        have f1: "L' \<in> set_mset C"
          using l' by blast
        have f2: "L' \<notin> {L}"
          using l' by fastforce
        have "\<And>l L. - (l::'a literal) \<in> L \<or> l \<notin> uminus ` L"
          by force
        then have "\<And>l. - l \<in> lits_of M \<or> count {#L#} l = count (C - UW) l"
          by (metis (no_types) add_diff_cancel_right' count_diff count_mset_set(3) cw(1) cw(3)
                cw_eq diff_zero twl_clause.sel(2))
        then show ?thesis
          by (smt comm_monoid_add_class.add_0 cw(1) cw_eq diff_union_cancelR ex_la f1 f2 insertCI
            less_numeral_extra(3) mem_set_mset_iff plus_multiset.rep_eq single.rep_eq
            twl_clause.sel(1) twl_clause.sel(2) w_nw(3))
      qed
    qed
  qed
  then show "trail S \<Turnstile>as CNot (mset_set (set_mset C - {L}))"
    unfolding true_annots_def by auto

  show "undefined_lit L (trail S)"
    using cw(4) M_def by blast
qed

lemma wf_candidates_propagate_complete:
  assumes wf: "wf_twl_state S" and
    c_mem: "C \<in># image_mset raw_clause (clauses S)" and
    l_mem: "L \<in># C" and
    unsat: "trail S \<Turnstile>as CNot (mset_set (set_mset C - {L}))" and
    undef: "undefined_lit L (trail S)"
  shows "(L, C) \<in> candidates_propagate S"
proof -
  def M \<equiv> "trail S"
  def N \<equiv> "init_clss S"
  def U \<equiv> "learned_clss S"

  note MNU_defs [simp] = M_def N_def U_def

  obtain Cw where cw: "C = raw_clause Cw" "Cw \<in># N + U"
    using c_mem by force

  obtain W UW where cw_eq: "Cw = TWL_Clause W UW"
    by (case_tac Cw, blast)

  have wf_c: "wf_twl_cls M Cw"
    using wf cw(2) unfolding wf_twl_state_def by simp

  have w_nw:
    "distinct_mset W"
    "size W < 2 \<Longrightarrow> set_mset UW \<subseteq> set_mset W"
    "\<And>L L'. L \<in># W \<Longrightarrow> -L \<in> lits_of M \<Longrightarrow> L' \<in># UW \<Longrightarrow> L' \<notin># W \<Longrightarrow> -L' \<in> lits_of M"
   using wf_c unfolding cw_eq by auto

  have unit_set: "set_mset (W - mset_set (uminus ` lits_of M)) = {L}"
  proof
    show "set_mset (W - mset_set (uminus ` lits_of M)) \<subseteq> {L}"
    proof
      fix L'
      assume l': "L' \<in> set_mset (W - mset_set (uminus ` lits_of M))"
      hence l'_mem_w: "L' \<in> set_mset W"
        by auto
      have "L' \<notin> uminus ` lits_of M"
        using distinct_mem_diff_mset[OF w_nw(1) l'] by simp
      then have "\<not> M \<Turnstile>a {#-L'#}"
        using image_iff by fastforce
      moreover have "L' \<in># C"
        using cw(1) cw_eq l'_mem_w by auto
      ultimately have "L' = L"
        unfolding M_def by (metis unsat[unfolded CNot_def true_annots_def, simplified])
      then show "L' \<in> {L}"
        by simp
    qed
  next
    show "{L} \<subseteq> set_mset (W - mset_set (uminus ` lits_of M))"
    proof clarify
      have "L \<in># W"
      proof (cases W)
        case empty
        thus ?thesis
          using w_nw(2) cw(1) cw_eq l_mem by auto
      next
        case (add W' La)
        thus ?thesis
        proof (cases "La = L")
          case True
          thus ?thesis
            using add by simp
        next
          case False
          have "-La \<in> lits_of M"
            using False add cw(1) cw_eq unsat[unfolded CNot_def true_annots_def, simplified]
            by fastforce
          then show ?thesis
            by (metis M_def Marked_Propagated_in_iff_in_lits_of add add.left_neutral count_union
              cw(1) cw_eq gr0I l_mem twl_clause.sel(1) twl_clause.sel(2) undef union_single_eq_member
              w_nw(3))
        qed
      qed
      moreover have "L \<notin># mset_set (uminus ` lits_of M)"
        using Marked_Propagated_in_iff_in_lits_of undef by auto
      ultimately show "L \<in> set_mset (W - mset_set (uminus ` lits_of M))"
        by auto
    qed
  qed
  have unit: "W - mset_set (uminus ` lits_of M) = {#L#}"
    by (metis distinct_mset_minus distinct_mset_set_mset_ident distinct_mset_singleton
      set_mset_single unit_set w_nw(1))

  show ?thesis
    unfolding candidates_propagate_def using unit undef cw cw_eq by fastforce
qed

lemma wf_candidates_conflict_sound:
  assumes wf: "wf_twl_state S" and
    cand: "C \<in> candidates_conflict S"
  shows "trail S \<Turnstile>as CNot C \<and> C \<in># image_mset raw_clause (clauses S)"
proof
  def M \<equiv> "trail S"
  def N \<equiv> "init_clss S"
  def U \<equiv> "learned_clss S"

  note MNU_defs [simp] = M_def N_def U_def

  obtain Cw where cw:
    "C = raw_clause Cw"
    "Cw \<in># N + U"
    "watched Cw \<subseteq># mset_set (uminus ` lits_of (trail S))"
    using cand[unfolded candidates_conflict_def, simplified] by auto

  obtain W UW where cw_eq: "Cw = TWL_Clause W UW"
    by (case_tac Cw, blast)

  have wf_c: "wf_twl_cls M Cw"
    using wf cw(2) unfolding wf_twl_state_def by simp

  have w_nw:
    "distinct_mset W"
    "size W < 2 \<Longrightarrow> set_mset UW \<subseteq> set_mset W"
    "\<And>L L'. L \<in># W \<Longrightarrow> -L \<in> lits_of M \<Longrightarrow> L' \<in># UW \<Longrightarrow> L' \<notin># W \<Longrightarrow> -L' \<in> lits_of M"
   using wf_c unfolding cw_eq by auto

  have "\<forall>L \<in># C. -L \<in> lits_of M"
  proof (cases "W = {#}")
    case True
    then have "C = {#}"
      using cw(1) cw_eq w_nw(2) by auto
    then show ?thesis
      by simp
  next
    case False
    then obtain La where la: "La \<in># W"
      using multiset_eq_iff by force
    show ?thesis
    proof
      fix L
      assume l: "L \<in># C"
      show "-L \<in> lits_of M"
      proof (cases "L \<in># W")
        case True
        thus ?thesis
          using cw(3) cw_eq by fastforce
      next
        case False
        thus ?thesis
          by (smt M_def l add_diff_cancel_left' count_diff cw(1) cw(3) la cw_eq
            diff_zero elem_mset_set finite_imageI finite_lits_of_def gr0I imageE mset_leD
            uminus_of_uminus_id twl_clause.sel(1) twl_clause.sel(2) w_nw(3))
      qed
    qed
  qed
  then show "trail S \<Turnstile>as CNot C"
    unfolding CNot_def true_annots_def by auto

  show "C \<in># image_mset raw_clause (clauses S)"
    using cw by auto
qed

lemma wf_candidates_conflict_complete:
  assumes wf: "wf_twl_state S" and
    c_mem: "C \<in># image_mset raw_clause (clauses S)" and
    unsat: "trail S \<Turnstile>as CNot C"
  shows "C \<in> candidates_conflict S"
proof -
  def M \<equiv> "trail S"
  def N \<equiv> "init_clss S"
  def U \<equiv> "learned_clss S"

  note MNU_defs [simp] = M_def N_def U_def

  obtain Cw where cw: "C = raw_clause Cw" "Cw \<in># N + U"
    using c_mem by force

  obtain W UW where cw_eq: "Cw = TWL_Clause W UW"
    by (case_tac Cw, blast)

  have wf_c: "wf_twl_cls M Cw"
    using wf cw(2) unfolding wf_twl_state_def by simp

  have w_nw:
    "distinct_mset W"
    "size W < 2 \<Longrightarrow> set_mset UW \<subseteq> set_mset W"
    "\<And>L L'. L \<in># W \<Longrightarrow> -L \<in> lits_of M \<Longrightarrow> L' \<in># UW \<Longrightarrow> L' \<notin># W \<Longrightarrow> -L' \<in> lits_of M"
   using wf_c unfolding cw_eq by auto

  have "\<And>L. L \<in># C \<Longrightarrow> -L \<in> lits_of M"
    unfolding M_def using unsat[unfolded CNot_def true_annots_def, simplified] by blast
  then have "set_mset C \<subseteq> uminus ` lits_of M"
    by (metis imageI mem_set_mset_iff subsetI uminus_of_uminus_id)
  then have "set_mset W \<subseteq> uminus ` lits_of M"
    using cw(1) cw_eq by auto
  then have subset: "W \<subseteq># mset_set (uminus ` lits_of M)"
    by (simp add: w_nw(1))

  have "W = watched Cw"
    using cw_eq twl_clause.sel(1) by simp
  then show ?thesis
    using MNU_defs cw(1) cw(2) subset candidates_conflict_def by blast
qed

locale abstract_twl =
  fixes
    watch :: "('v, nat, 'v clause) twl_state \<Rightarrow> 'v clause \<Rightarrow> 'v twl_clause" and
    rewatch :: "('v, nat, 'v literal multiset) marked_lit \<Rightarrow> ('v, nat, 'v clause) twl_state \<Rightarrow>
      'v twl_clause \<Rightarrow> 'v twl_clause" and
    linearize :: "'v clauses \<Rightarrow> 'v clause list" and
    restart_learned :: "('v, nat, 'v clause) twl_state \<Rightarrow> 'v twl_clause multiset"
  assumes
    clause_watch: "raw_clause (watch S C) = C" and
    wf_watch: "wf_twl_cls (trail S) (watch S C)" and
    clause_rewatch: "raw_clause (rewatch L S C') = raw_clause C'" and
    wf_rewatch: "wf_twl_cls (L # trail S) (rewatch L S C')" and
    linearize: "mset (linearize N) = N" and
    restart_learned: "restart_learned S \<subseteq># learned_clss S"
begin

definition
  cons_trail :: "('v, nat, 'v clause) marked_lit \<Rightarrow> ('v, nat, 'v clause) twl_state \<Rightarrow> 
    ('v, nat, 'v clause) twl_state"
where
  "cons_trail L S =
   TWL_State (L # trail S) (image_mset (rewatch L S) (init_clss S))
     (image_mset (rewatch L S) (learned_clss S)) (backtrack_lvl S) (conflicting S)"

definition
  add_init_cls :: "'v clause \<Rightarrow> ('v, nat, 'v clause) twl_state \<Rightarrow>
    ('v, nat, 'v clause) twl_state"
where
  "add_init_cls C S =
   TWL_State (trail S) ({#watch S C#} + init_clss S) (learned_clss S) (backtrack_lvl S)
     (conflicting S)"

definition
  add_learned_cls :: "'v clause \<Rightarrow> ('v, nat, 'v clause) twl_state \<Rightarrow> 
    ('v, nat, 'v clause) twl_state"
where
  "add_learned_cls C S =
   TWL_State (trail S) (init_clss S) ({#watch S C#} + learned_clss S) (backtrack_lvl S)
     (conflicting S)"

definition
  remove_cls :: "'v clause \<Rightarrow> ('v, nat, 'v clause) twl_state \<Rightarrow> ('v, nat, 'v clause) twl_state"
where
  "remove_cls C S =
   TWL_State (trail S) (filter_mset (\<lambda>D. raw_clause D \<noteq> C) (init_clss S))
     (filter_mset (\<lambda>D. raw_clause D \<noteq> C) (learned_clss S)) (backtrack_lvl S)
     (conflicting S)"

definition init_state :: "'v clauses \<Rightarrow> ('v, nat, 'v clause) twl_state" where
  "init_state N = fold add_init_cls (linearize N) (TWL_State [] {#} {#} 0 C_True)"

lemma unchanged_fold_add_init_cls:
  "trail (fold add_init_cls Cs (TWL_State M N U k C)) = M"
  "learned_clss (fold add_init_cls Cs (TWL_State M N U k C)) = U"
  "backtrack_lvl (fold add_init_cls Cs (TWL_State M N U k C)) = k"
  "conflicting (fold add_init_cls Cs (TWL_State M N U k C)) = C"
  by (induct Cs arbitrary: N) (auto simp: add_init_cls_def)

lemma unchanged_init_state[simp]:
  "trail (init_state N) = []"
  "learned_clss (init_state N) = {#}"
  "backtrack_lvl (init_state N) = 0"
  "conflicting (init_state N) = C_True"
  unfolding init_state_def by (rule unchanged_fold_add_init_cls)+

lemma clauses_init_fold_add_init:
  "image_mset raw_clause (init_clss (fold add_init_cls Cs (TWL_State M N U k C))) =
   mset Cs + image_mset raw_clause N"
  by (induct Cs arbitrary: N) (auto simp: add.assoc add_init_cls_def clause_watch)

lemma init_clss_init_state[simp]: "image_mset raw_clause (init_clss (init_state N)) = N"
  unfolding init_state_def by (simp add: clauses_init_fold_add_init linearize)

definition update_backtrack_lvl where
  "update_backtrack_lvl k S =
   TWL_State (trail S) (init_clss S) (learned_clss S) k (conflicting S)"

definition update_conflicting where
  "update_conflicting C S = TWL_State (trail S) (init_clss S) (learned_clss S) (backtrack_lvl S) C"

definition tl_trail where
  "tl_trail S =
   TWL_State (tl (trail S)) (init_clss S) (learned_clss S) (backtrack_lvl S) (conflicting S)"

definition restart where
  "restart S = TWL_State [] (init_clss S) (restart_learned S) 0 C_True"

sublocale cw_state trail raw_init_clss raw_learned_clsss backtrack_lvl conflicting
  cons_trail tl_trail add_init_cls add_learned_cls remove_cls update_backtrack_lvl
  update_conflicting init_state restart
  apply unfold_locales
  apply (simp_all add: add_init_cls_def add_learned_cls_def clause_rewatch clause_watch
    cons_trail_def remove_cls_def restart_def tl_trail_def update_backtrack_lvl_def
    update_conflicting_def)
  apply (rule image_mset_subseteq_mono[OF restart_learned])

  (*
    FIXME: The last proof obligation seems too strong.
  *)
oops

end

interpretation cdcl\<^sub>N\<^sub>O\<^sub>T_merge_bj_learn _ _ _ _ (* propagate_conds is in candidates *) _ _ _
  (* backjump_conds is candidate_conflict *)
oops

definition pull :: "('a \<Rightarrow> bool) \<Rightarrow> 'a list \<Rightarrow> 'a list" where
  "pull p xs = filter p xs @ filter (Not \<circ> p) xs"

lemma set_pull[simp]: "set (pull p xs) = set xs"
  unfolding pull_def by auto

lemma mset_pull[simp]: "mset (pull p xs) = mset xs"
  by (simp add: pull_def mset_filter_compl)

definition watch_nat :: "(nat, nat, nat clause) twl_state \<Rightarrow> nat clause \<Rightarrow> nat twl_clause" where
  "watch_nat S C =
   (let
      W = take 2 (pull (\<lambda>L. - L \<notin> lits_of (trail S)) (sorted_list_of_set (set_mset C)));
      UW = sorted_list_of_multiset (C - mset W)
    in TWL_Clause (mset W) (mset UW))"

definition
  rewatch_nat ::
  "(nat, nat, nat literal multiset) marked_lit \<Rightarrow> (nat, nat, nat clause) twl_state \<Rightarrow> nat twl_clause \<Rightarrow> nat twl_clause"
where
  "rewatch_nat L S C =
   (if - lit_of L \<in># watched C then
      case filter (\<lambda>L'. L' \<notin># watched C \<and> - L' \<notin> lits_of (L # trail S))
          (sorted_list_of_multiset (unwatched C)) of
        [] \<Rightarrow> C
      | L' # _ \<Rightarrow>
        TWL_Clause (watched C - {#- lit_of L#} + {#L'#}) (unwatched C - {#L'#} + {#- lit_of L#})
    else
      C)"

lemma mset_set_set_mset_subseteq[simp]: "mset_set (set_mset A) \<subseteq># A"
  by (metis count_mset_set(1) count_mset_set(3) finite_set_mset le_less_linear less_one
    mem_set_mset_iff mset_less_eqI not_gr0)

lemma mset_sorted_list_of_set[simp]:
  "mset (sorted_list_of_set A) = mset_set A"
  by (metis mset_sorted_list_of_multiset sorted_list_of_mset_set)

lemma mset_take_subseteq: "mset (take n xs) \<subseteq># mset xs"
  apply (induct xs arbitrary: n)
   apply simp
  by (case_tac n) simp_all

lemma mset_take_pull_sorted_list_of_set_subseteq:
  "mset (take n (pull p (sorted_list_of_set (set_mset A)))) \<subseteq># A"
  by (metis mset_pull mset_set_set_mset_subseteq mset_sorted_list_of_set mset_take_subseteq
    subset_mset.dual_order.trans)

lemma clause_watch_nat: "raw_clause (watch_nat S C) = C"
  by (simp add: watch_nat_def Let_def)
    (rule subset_mset.add_diff_inverse[OF mset_take_pull_sorted_list_of_set_subseteq])

lemma distinct_pull[simp]: "distinct (pull p xs) = distinct xs"
  unfolding pull_def by (induct xs) auto

lemma falsified_watiched_imp_unwatched_falsified:
  assumes
    watched: "L \<in> set (take n (pull (Not \<circ> fls) (sorted_list_of_set (set_mset C))))" and
    falsified: "fls L" and
    not_watched: "L' \<notin> set (take n (pull (Not \<circ> fls) (sorted_list_of_set (set_mset C))))" and
    unwatched: "L' \<in># C - mset (take n (pull (Not \<circ> fls) (sorted_list_of_set (set_mset C))))"
  shows "fls L'"
proof -
  let ?Ls = "sorted_list_of_set (set_mset C)"
  let ?W = "take n (pull (Not \<circ> fls) ?Ls)"

  have "n > length (filter (Not \<circ> fls) ?Ls)"
    using watched falsified
    unfolding pull_def comp_def
    apply auto
     using in_set_takeD apply fastforce
    by (metis gr0I length_greater_0_conv length_pos_if_in_set take_0 zero_less_diff)
  then have "\<And>L. L \<in> set ?Ls \<Longrightarrow> \<not> fls L \<Longrightarrow> L \<in> set ?W"
    unfolding pull_def by auto
  then show ?thesis
    by (metis Multiset.diff_le_self finite_set_mset mem_set_mset_iff mset_leD not_watched
      sorted_list_of_set unwatched)
qed

lemma wf_watch_nat: "wf_twl_cls (trail S) (watch_nat S C)"
  apply (simp only: watch_nat_def Let_def partition_filter_conv case_prod_beta fst_conv snd_conv)
  unfolding wf_twl_cls.simps
  apply (intro conjI)
     apply clarsimp+
  using falsified_watiched_imp_unwatched_falsified[unfolded comp_def]
  by (metis count_diff zero_less_diff)

lemma filter_sorted_list_of_multiset_eqD:
  assumes "[x \<leftarrow> sorted_list_of_multiset A. p x] = x # xs" (is "?comp = _")
  shows "x \<in># A"
proof -
  have "x \<in> set ?comp"
    using assms by simp
  then have "x \<in> set (sorted_list_of_multiset A)"
    by simp
  then show "x \<in># A"
    by simp
qed

lemma clause_rewatch_nat: "raw_clause (rewatch_nat L S C) = raw_clause C"
  apply (auto simp: rewatch_nat_def Let_def split: list.split)
  apply (subst subset_mset.add_diff_assoc2, simp)
  apply (subst subset_mset.add_diff_assoc2, simp)
  apply (subst subset_mset.add_diff_assoc2)
   apply (auto dest: filter_sorted_list_of_multiset_eqD)
  by (metis (no_types, lifting) add.assoc add_diff_cancel_right' filter_sorted_list_of_multiset_eqD
    insert_DiffM mset_leD mset_le_add_left)

lemma filter_sorted_list_of_multiset_Nil:
  "[x \<leftarrow> sorted_list_of_multiset M. p x] = [] \<longleftrightarrow> (\<forall>x \<in># M. \<not> p x)"
  by auto (metis empty_iff filter_set list.set(1) mem_set_mset_iff member_filter
    set_sorted_list_of_multiset)

lemma filter_sorted_list_of_multiset_ConsD:
  "[x \<leftarrow> sorted_list_of_multiset M. p x] = x # xs \<Longrightarrow> p x"
  by (metis filter_set insert_iff list.set(2) member_filter)

lemma wf_rewatch_nat':
  assumes wf: "wf_twl_cls (trail S) C"
  shows "wf_twl_cls (L # trail S) (rewatch_nat L S C)"
using filter_sorted_list_of_multiset_Nil[simp]
proof (cases "- lit_of L \<in># watched C")
  case falsified: True

  let ?unwatched_nonfalsified =
    "[L' \<leftarrow> sorted_list_of_multiset (unwatched C). L' \<notin># watched C \<and> - L' \<notin> lits_of (L # trail S)]"

  show ?thesis
  proof (cases ?unwatched_nonfalsified)
    case Nil
    show ?thesis
      unfolding rewatch_nat_def
      using falsified Nil apply auto
apply (case_tac C)
apply auto

      sorry
  next
    case (Cons L' Ls)
    show ?thesis
      using wf
      unfolding rewatch_nat_def
      using falsified Cons apply (auto dest!: filter_sorted_list_of_multiset_ConsD)
      apply (case_tac C)
      apply (auto simp: distinct_mset_single_add)
      apply (case_tac C)
apply auto
apply (simp add: size_Diff_singleton)
apply (metis not_less_eq_eq numeral_2_eq_2 size_Suc_Diff1)

      sorry
  qed
next
  case False
  have "wf_twl_cls (L # trail S) C"
    using wf
    apply (case_tac C)
    apply auto
     apply (metis False twl_clause.sel(1) uminus_of_uminus_id)
    by (metis False twl_clause.sel(1) uminus_of_uminus_id)
  then show ?thesis
    unfolding rewatch_nat_def using False by simp
qed

lemma wf_rewatch_nat_TOO_STRONG: "wf_twl_cls (L # trail S) (rewatch_nat L S C)"
  unfolding rewatch_nat_def
  (* FIXME: UNPROVABLE: what if "\<not> wf_twl_cls (trail S) C"? *)
  sorry

(*TODO: remove when multiset is of sort linord again*)
instantiation multiset :: (linorder) linorder
begin

definition less_multiset :: "'a :: linorder multiset \<Rightarrow> 'a multiset \<Rightarrow> bool" where
  "M' < M \<longleftrightarrow> M' #<# M"

definition less_eq_multiset :: "'a multiset \<Rightarrow> 'a multiset \<Rightarrow> bool" where
  "M' \<le> M \<longleftrightarrow> M' #<=# M"

instance
  by standard (auto simp: less_eq_multiset_def less_multiset_def)
end

(* implementation of watch etc. *)
interpretation abstract_twl watch_nat rewatch_nat sorted_list_of_multiset learned_clss
  apply unfold_locales
  apply (rule clause_watch_nat)
  apply (rule wf_watch_nat)
  apply (rule clause_rewatch_nat)
  apply (rule wf_rewatch_nat_TOO_STRONG)
  apply (rule mset_sorted_list_of_multiset)
  apply (rule subset_mset.order_refl)
  done

(* interpretation cdcl_cw_ops
oops
 *)

end
