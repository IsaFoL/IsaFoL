(*  Title: CDCL with Two Watched Literals
    Author: Jasmin Blanchette <jasmin.blanchette@inria.fr>
    Author: Mathias Fleury <mathias.fleury@mpi-inf.mpg.de>
*)

theory CDCL_Two_Watched_Literals
imports CDCL_WNOT (* Have to decide which imports are the best *)
begin

(* TODO: BEGIN Move to Multiset_More *)

lemma image_mset_subseteq_mono: "A \<subseteq># B \<Longrightarrow> image_mset f A \<subseteq># image_mset f B"
  by (metis image_mset_union subset_mset.le_iff_add)

lemma image_filter_ne_mset[simp]:
  "image_mset f {#x \<in># M. f x \<noteq> y#} = remove_mset (image_mset f M) y"
  by (induct M, auto, meson count_le_replicate_mset_le order_refl subset_mset.add_diff_assoc2)

lemma distinct_mset_set_mset_ident[simp]: "distinct_mset M \<Longrightarrow> mset_set (set_mset M) = M"
  apply (auto simp: multiset_eq_iff)
  apply (rename_tac x)
  apply (case_tac "count M x = 0")
   apply simp
  apply (case_tac "count M x = 1")
   apply simp
  unfolding distinct_mset_count_less_1
  by (meson le_neq_implies_less less_one)

lemma count_mset_set_le_one: "count (mset_set A) x \<le> 1"
  by (metis count_mset_set(1) elem_mset_set le_less less_eq_nat.simps(1) mset_set.infinite
    zero_multiset.rep_eq)

lemma mset_set_subseteq_mset_set[iff]:
  assumes "finite A" "finite B"
  shows "mset_set A \<subseteq># mset_set B \<longleftrightarrow> A \<subseteq> B"
(* generated by Sledgehammer *)
proof -
  { assume "\<not> mset_set A \<subseteq># mset_set B"
    have "mset_set A \<subseteq># mset_set B \<or> (\<exists>a. a \<notin> B \<and> a \<in> A)"
      using assms(2) by (metis count_mset_set(1) count_mset_set(3) count_mset_set_le_one
        elem_mset_set le_less_linear mset_less_eqI)
    then have "A \<subseteq> B \<longrightarrow> mset_set A \<subseteq># mset_set B"
      by (meson contra_subsetD) }
  then show ?thesis
    using assms by (metis (full_types) finite_set_mset_mset_set set_mset_mono)
qed

lemma distinct_finite_set_mset_subseteq_iff[iff]:
  assumes dist: "distinct_mset M" and fin: "finite N"
  shows "set_mset M \<subseteq> N \<longleftrightarrow> M \<subseteq># mset_set N"
proof
  assume "set_mset M \<subseteq> N"
  then show "M \<subseteq># mset_set N"
    by (metis dist distinct_mset_set_mset_ident fin finite_subset mset_set_subseteq_mset_set)
next
  assume "M \<subseteq># mset_set N"
  then show "set_mset M \<subseteq> N"
    by (metis contra_subsetD empty_iff finite_set_mset_mset_set infinite_set_mset_mset_set
      set_mset_mono subsetI)
qed

lemma distinct_mem_diff_mset:
  assumes dist: "distinct_mset M" and mem: "x \<in> set_mset (M - N)"
  shows "x \<notin> set_mset N"
proof -
  have "count M x = 1"
    using dist mem by (simp add: distinct_mset_def)
  then show ?thesis
    using mem by simp
qed

lemma distinct_set_mset_eq:
  assumes
    dist_m: "distinct_mset M" and
    dist_n: "distinct_mset N" and
    set_eq: "set_mset M = set_mset N"
  shows "M = N"
proof -
  have "mset_set (set_mset M) = mset_set (set_mset N)"
    using set_eq by simp
  thus ?thesis
    using dist_m dist_n by auto
qed

(* END *)

text \<open>Only the 2-watched literals have to be verified here: the backtrack level and the trail can
  remain separate.\<close>

datatype 'v twl_clause =
  W_Clause (watched: "'v clause") (not_watched: "'v clause")

abbreviation raw_clause :: "'v twl_clause \<Rightarrow> 'v clause" where
  "raw_clause C \<equiv> watched C + not_watched C"

datatype ('v, 'lvl, 'mark) twl_state =
  TWL_State (trail: "('v, 'lvl, 'mark) marked_lits") (init_clss: "'v twl_clause multiset")
    (learned_clss: "'v twl_clause multiset") (backtrack_lvl: 'lvl)
    (conflicting: "'v clause conflicting_clause")

abbreviation raw_init_clss where
  "raw_init_clss S \<equiv> image_mset raw_clause (init_clss S)"

abbreviation raw_learned_clsss where
  "raw_learned_clsss S \<equiv> image_mset raw_clause (learned_clss S)"

abbreviation clauses where
  "clauses S \<equiv> init_clss S + learned_clss S"

definition
  candidates_propagate :: "('v, 'lvl, 'mark) twl_state \<Rightarrow> ('v literal \<times> 'v clause) set"
where
  "candidates_propagate S =
   {(L, raw_clause C) | L C.
    C \<in># clauses S \<and> watched C - mset_set (uminus ` lits_of (trail S)) = {#L#} \<and>
    undefined_lit L (trail S)}"

definition candidates_conflict :: "('v, 'lvl, 'mark) twl_state \<Rightarrow> 'v clause set" where
  "candidates_conflict S =
   {raw_clause C | C. C \<in># clauses S \<and> watched C \<subseteq># mset_set (uminus ` lits_of (trail S))}"

(* FIXME *)
(* interpretation dpll_state trail "image_mset raw_clause o clauses"
  "\<lambda>M S. TWL_State M (init_clss S) (learned_clss S) (backtrack_lvl S) (conflicting S)"
oops *)

primrec wf_twl_cls :: "('v, 'lvl, 'mark) marked_lit list \<Rightarrow> 'v twl_clause \<Rightarrow> bool" where
  "wf_twl_cls M (W_Clause W NW) \<longleftrightarrow>
   distinct_mset W \<and> size W \<le> 2 \<and> (size W < 2 \<longrightarrow> set_mset NW \<subseteq> set_mset W) \<and>
   (\<forall>L \<in># W. -L \<in> lits_of M \<longrightarrow> (\<forall>L' \<in># NW. -L' \<in> lits_of M))"

definition wf_twl_state :: "('v, 'lvl, 'mark) twl_state \<Rightarrow> bool" where
  "wf_twl_state S \<longleftrightarrow> (\<forall>C \<in># clauses S. wf_twl_cls (trail S) C)"

lemma wf_candidates_propagate_sound:
  assumes wf: "wf_twl_state S" and
    cand: "(L, C) \<in> candidates_propagate S"
  shows "trail S \<Turnstile>as CNot (mset_set (set_mset C - {L})) \<and> undefined_lit L (trail S)"
proof
  def M \<equiv> "trail S"
  def N \<equiv> "init_clss S"
  def U \<equiv> "learned_clss S"

  note MNU_defs [simp] = M_def N_def U_def

  obtain Cw where cw:
    "C = raw_clause Cw"
    "Cw \<in># N + U"
    "watched Cw - mset_set (uminus ` lits_of M) = {#L#}"
    "undefined_lit L M"
    using cand unfolding candidates_propagate_def MNU_defs by blast

  obtain W NW where cw_eq: "Cw = W_Clause W NW"
    by (case_tac Cw, blast)

  have l_w: "L \<in># W"
    by (metis Multiset.diff_le_self cw(3) cw_eq mset_leD multi_member_last twl_clause.sel(1))

  have wf_c: "wf_twl_cls M Cw"
    using wf \<open>Cw \<in># N + U\<close> unfolding wf_twl_state_def by simp

  have w_nw:
    "distinct_mset W"
    "size W < 2 \<Longrightarrow> set_mset NW \<subseteq> set_mset W"
    "\<And>L L'. L \<in># W \<Longrightarrow> -L \<in> lits_of M \<Longrightarrow> L' \<in># NW \<Longrightarrow> -L' \<in> lits_of M"
   using wf_c unfolding cw_eq by auto

  have "\<forall>L' \<in> set_mset C - {L}. -L' \<in> lits_of M"
  proof (cases "size W < 2")
    case True
    moreover have "size W \<noteq> 0"
      using cw(3) cw_eq by auto
    ultimately have "size W = 1"
      by linarith
    then have w: "W = {#L#}"
      by (metis (no_types, lifting) Multiset.diff_le_self cw(3) cw_eq single_not_empty
        size_1_singleton_mset subset_mset.add_diff_inverse union_is_single twl_clause.sel(1))
    from True have "set_mset NW \<subseteq> set_mset W"
      using w_nw(2) by blast
    then show ?thesis
      using w cw(1) cw_eq by auto
  next
    case sz2: False
    show ?thesis
    proof
      fix L'
      assume l': "L' \<in> set_mset C - {L}"
      have ex_la: "\<exists>La. La \<noteq> L \<and> La \<in># W"
      proof (cases W)
        case empty
        thus ?thesis
          using l_w by auto
      next
        case lb: (add W' Lb)
        show ?thesis
        proof (cases W')
          case empty
          thus ?thesis
            using lb sz2 by simp
        next
          case lc: (add W'' Lc)
          thus ?thesis
            by (metis add_gr_0 count_union distinct_mset_single_add lb union_single_eq_member
              w_nw(1))
        qed
      qed
      then obtain La where la: "La \<noteq> L" "La \<in># W"
        by blast
      then have "La \<in># mset_set (uminus ` lits_of M)"
        using cw(3)[unfolded cw_eq, simplified, folded M_def]
        by (metis count_diff count_single diff_zero not_gr0)
      then have nla: "-La \<in> lits_of M"
        by auto
      then show "-L' \<in> lits_of M"
      (* generated by Sledgehammer *)
      proof -
        have f1: "L' \<in> set_mset C"
          using l' by blast
        have f2: "L' \<notin> {L}"
          using l' by fastforce
        have "\<And>l L. - (l::'a literal) \<in> L \<or> l \<notin> uminus ` L"
          by force
        then have "\<And>l. - l \<in> lits_of M \<or> count {#L#} l = count (C - NW) l"
          by (metis (no_types) add_diff_cancel_right' count_diff count_mset_set(3) cw(1) cw(3)
                cw_eq diff_zero twl_clause.sel(2))
        then show ?thesis
          using f2 f1 by (metis nla count_diff diff_zero la(2) mem_set_mset_iff not_gr0
            set_mset_single w_nw(3))
      qed
    qed
  qed
  then show "trail S \<Turnstile>as CNot (mset_set (set_mset C - {L}))"
    unfolding true_annots_def by auto

  show "undefined_lit L (trail S)"
    using cw(4) M_def by blast
qed

lemma wf_candidates_propagate_complete:
  assumes wf: "wf_twl_state S" and
    c_mem: "C \<in># image_mset raw_clause (clauses S)" and
    l_mem: "L \<in># C" and
    unsat: "trail S \<Turnstile>as CNot (mset_set (set_mset C - {L}))" and
    undef: "undefined_lit L (trail S)"
  shows "(L, C) \<in> candidates_propagate S"
proof -
  def M \<equiv> "trail S"
  def N \<equiv> "init_clss S"
  def U \<equiv> "learned_clss S"

  note MNU_defs [simp] = M_def N_def U_def

  obtain Cw where cw: "C = raw_clause Cw" "Cw \<in># N + U"
    using c_mem by force

  obtain W NW where cw_eq: "Cw = W_Clause W NW"
    by (case_tac Cw, blast)

  have wf_c: "wf_twl_cls M Cw"
    using wf cw(2) unfolding wf_twl_state_def by simp

  have w_nw:
    "distinct_mset W"
    "size W < 2 \<Longrightarrow> set_mset NW \<subseteq> set_mset W"
    "\<And>L L'. L \<in># W \<Longrightarrow> -L \<in> lits_of M \<Longrightarrow> L' \<in># NW \<Longrightarrow> -L' \<in> lits_of M"
   using wf_c unfolding cw_eq by auto

  have unit_set: "set_mset (W - mset_set (uminus ` lits_of M)) = {L}"
  proof
    show "set_mset (W - mset_set (uminus ` lits_of M)) \<subseteq> {L}"
    proof
      fix L'
      assume l': "L' \<in> set_mset (W - mset_set (uminus ` lits_of M))"
      hence l'_mem_w: "L' \<in> set_mset W"
        by auto
      have "L' \<notin> uminus ` lits_of M"
        using distinct_mem_diff_mset[OF w_nw(1) l'] by simp
      then have "\<not> M \<Turnstile>a {#-L'#}"
        using image_iff by fastforce
      moreover have "L' \<in># C"
        using cw(1) cw_eq l'_mem_w by auto
      ultimately have "L' = L"
        unfolding M_def by (metis unsat[unfolded CNot_def true_annots_def, simplified])
      then show "L' \<in> {L}"
        by simp
    qed
  next
    show "{L} \<subseteq> set_mset (W - mset_set (uminus ` lits_of M))"
    proof clarify
      have "L \<in># W"
      proof (cases W)
        case empty
        thus ?thesis
          using w_nw(2) cw(1) cw_eq l_mem by auto
      next
        case (add W' La)
        thus ?thesis
        proof (cases "La = L")
          case True
          thus ?thesis
            using add by simp
        next
          case False
          have "-La \<in> lits_of M"
            using False add cw(1) cw_eq unsat[unfolded CNot_def true_annots_def, simplified]
            by fastforce
          then show ?thesis
            by (metis M_def Marked_Propagated_in_iff_in_lits_of add add.left_neutral cw(1)
              count_union cw_eq l_mem mset_le_add_left mset_le_insertD not_gr0 undef
              twl_clause.sel w_nw(3))
        qed
      qed
      moreover have "L \<notin># mset_set (uminus ` lits_of M)"
        using Marked_Propagated_in_iff_in_lits_of undef by auto
      ultimately show "L \<in> set_mset (W - mset_set (uminus ` lits_of M))"
        by auto
    qed
  qed
  have unit: "W - mset_set (uminus ` lits_of M) = {#L#}"
    by (metis distinct_mset_minus distinct_mset_set_mset_ident distinct_mset_singleton
      set_mset_single unit_set w_nw(1))

  show ?thesis
    unfolding candidates_propagate_def using unit undef cw cw_eq by fastforce
qed

lemma wf_candidates_conflict_sound:
  assumes wf: "wf_twl_state S" and
    cand: "C \<in> candidates_conflict S"
  shows "trail S \<Turnstile>as CNot C \<and> C \<in># image_mset raw_clause (clauses S)"
proof
  def M \<equiv> "trail S"
  def N \<equiv> "init_clss S"
  def U \<equiv> "learned_clss S"

  note MNU_defs [simp] = M_def N_def U_def

  obtain Cw where cw:
    "C = raw_clause Cw"
    "Cw \<in># N + U"
    "watched Cw \<subseteq># mset_set (uminus ` lits_of (trail S))"
    using cand[unfolded candidates_conflict_def, simplified] by auto

  obtain W NW where cw_eq: "Cw = W_Clause W NW"
    by (case_tac Cw, blast)

  have wf_c: "wf_twl_cls M Cw"
    using wf cw(2) unfolding wf_twl_state_def by simp

  have w_nw:
    "distinct_mset W"
    "size W < 2 \<Longrightarrow> set_mset NW \<subseteq> set_mset W"
    "\<And>L L'. L \<in># W \<Longrightarrow> -L \<in> lits_of M \<Longrightarrow> L' \<in># NW \<Longrightarrow> -L' \<in> lits_of M"
   using wf_c unfolding cw_eq by auto

  have "\<forall>L \<in># C. -L \<in> lits_of M"
  proof (cases "W = {#}")
    case True
    then have "C = {#}"
      using cw(1) cw_eq w_nw(2) by auto
    then show ?thesis
      by simp
  next
    case False
    then obtain La where la: "La \<in># W"
      using multiset_eq_iff by force
    show ?thesis
    proof
      fix L
      assume l: "L \<in># C"
      show "-L \<in> lits_of M"
      proof (cases "L \<in># W")
        case True
        thus ?thesis
          using cw(3) cw_eq by fastforce
      next
        case False
        thus ?thesis
          by (smt M_def l add_diff_cancel_left' count_diff cw(1) cw(3) la cw_eq
            diff_zero elem_mset_set finite_imageI finite_lits_of_def gr0I imageE mset_leD
            uminus_of_uminus_id twl_clause.sel(1) twl_clause.sel(2) w_nw(3))
      qed
    qed
  qed
  then show "trail S \<Turnstile>as CNot C"
    unfolding CNot_def true_annots_def by auto

  show "C \<in># image_mset raw_clause (clauses S)"
    using cw by auto
qed

lemma wf_candidates_conflict_complete:
  assumes wf: "wf_twl_state S" and
    c_mem: "C \<in># image_mset raw_clause (clauses S)" and
    unsat: "trail S \<Turnstile>as CNot C"
  shows "C \<in> candidates_conflict S"
proof -
  def M \<equiv> "trail S"
  def N \<equiv> "init_clss S"
  def U \<equiv> "learned_clss S"

  note MNU_defs [simp] = M_def N_def U_def

  obtain Cw where cw: "C = raw_clause Cw" "Cw \<in># N + U"
    using c_mem by force

  obtain W NW where cw_eq: "Cw = W_Clause W NW"
    by (case_tac Cw, blast)

  have wf_c: "wf_twl_cls M Cw"
    using wf cw(2) unfolding wf_twl_state_def by simp

  have w_nw:
    "distinct_mset W"
    "size W < 2 \<Longrightarrow> set_mset NW \<subseteq> set_mset W"
    "\<And>L L'. L \<in># W \<Longrightarrow> -L \<in> lits_of M \<Longrightarrow> L' \<in># NW \<Longrightarrow> -L' \<in> lits_of M"
   using wf_c unfolding cw_eq by auto

  have "\<And>L. L \<in># C \<Longrightarrow> -L \<in> lits_of M"
    unfolding M_def using unsat[unfolded CNot_def true_annots_def, simplified] by blast
  then have "set_mset C \<subseteq> uminus ` lits_of M"
    by (metis imageI mem_set_mset_iff subsetI uminus_of_uminus_id)
  then have "set_mset W \<subseteq> uminus ` lits_of M"
    using cw(1) cw_eq by auto
  then have subset: "W \<subseteq># mset_set (uminus ` lits_of M)"
    by (simp add: w_nw(1))

  have "W = watched Cw"
    using cw_eq twl_clause.sel(1) by simp
  then show ?thesis
    using MNU_defs cw(1) cw(2) subset candidates_conflict_def by blast
qed

locale structure_2_WL =
  fixes 
    watch :: "('v, nat, 'v clause) twl_state \<Rightarrow> 'v clause \<Rightarrow> 'v twl_clause" and
    linearize :: "'v clauses \<Rightarrow> 'v clause list" and
    restart_learned :: "('v, nat, 'v clause) twl_state \<Rightarrow> 'v twl_clause multiset"
  assumes
    clause_watch: "raw_clause (watch S C) = C" and
    wf_watch: "wf_twl_cls (trail S) (watch S C)" and
    linearize: "mset (linearize N) = N" and
    restart_learned: "restart_learned S \<subseteq># learned_cls S"
begin

definition
  cons_trail :: "('v, nat, 'v clause) marked_lit \<Rightarrow> ('v, nat, 'v clause) twl_state \<Rightarrow> 
    ('v, nat, 'v clause) twl_state"
where
  (* FIXME *)
  "cons_trail L S =
   TWL_State (L # trail S) (init_clss S) (learned_clss S) (backtrack_lvl S) (conflicting S)"

definition
  add_init_cls :: "'v clause \<Rightarrow> ('v, nat, 'v clause) twl_state \<Rightarrow>
    ('v, nat, 'v clause) twl_state"
where
  (* FIXME *)
  "add_init_cls C S =
   TWL_State (trail S) ({#watch S C#} + init_clss S) (learned_clss S) (backtrack_lvl S)
     (conflicting S)"

definition
  add_learned_cls :: "'v clause \<Rightarrow> ('v, nat, 'v clause) twl_state \<Rightarrow> 
    ('v, nat, 'v clause) twl_state"
where
  (* FIXME *)
  "add_learned_cls C S =
   TWL_State (trail S) (init_clss S) ({#watch S C#} + learned_clss S) (backtrack_lvl S)
     (conflicting S)"

definition
  remove_cls :: "'v clause \<Rightarrow> ('v, nat, 'v clause) twl_state \<Rightarrow> ('v, nat, 'v clause) twl_state"
where
  "remove_cls C S =
   TWL_State (trail S) (filter_mset (\<lambda>D. raw_clause D \<noteq> C) (init_clss S))
     (filter_mset (\<lambda>D. raw_clause D \<noteq> C) (learned_clss S)) (backtrack_lvl S)
     (conflicting S)"

definition init_state :: "'v clauses \<Rightarrow> ('v, nat, 'v clause) twl_state" where
  "init_state N = fold add_init_cls (linearize N) (TWL_State [] {#} {#} 0 C_True)"

lemma unchanged_fold_add_init_cls:
  "trail (fold add_init_cls Cs (TWL_State M N U k C)) = M"
  "learned_clss (fold add_init_cls Cs (TWL_State M N U k C)) = U"
  "backtrack_lvl (fold add_init_cls Cs (TWL_State M N U k C)) = k"
  "conflicting (fold add_init_cls Cs (TWL_State M N U k C)) = C"
  by (induct Cs arbitrary: N) (auto simp: add_init_cls_def)

lemma unchanged_init_state[simp]:
  "trail (init_state N) = []"
  "learned_clss (init_state N) = {#}"
  "backtrack_lvl (init_state N) = 0"
  "conflicting (init_state N) = C_True"
  unfolding init_state_def by (rule unchanged_fold_add_init_cls)+

lemma clauses_init_fold_add_init:
  "image_mset raw_clause (init_clss (fold add_init_cls Cs (TWL_State M N U k C))) =
   mset Cs + image_mset raw_clause N"
  by (induct Cs arbitrary: N) (auto simp: add.assoc add_init_cls_def clause_watch)

lemma init_clss_init_state[simp]: "image_mset raw_clause (init_clss (init_state N)) = N"
  unfolding init_state_def by (simp add: clauses_init_fold_add_init linearize)

definition update_backtrack_lvl where
  "update_backtrack_lvl k S =
   TWL_State (trail S) (init_clss S) (learned_clss S) k (conflicting S)"

definition update_conflicting where
  "update_conflicting C S =
   TWL_State (trail S) (init_clss S) (learned_clss S) (backtrack_lvl S) C"

definition tl_trail where
  "tl_trail S =
   TWL_State (tl (trail S)) (init_clss S) (learned_clss S) (backtrack_lvl S) (conflicting S)"

definition restart where
  "restart S = TWL_State [] (init_clss S) (restart_learned S) 0 C_True"

sublocale cw_state trail raw_init_clss raw_learned_clsss backtrack_lvl conflicting
  cons_trail tl_trail add_init_cls add_learned_cls remove_cls update_backtrack_lvl
  update_conflicting init_state restart
  apply unfold_locales
  apply (simp_all add: add_init_cls_def add_learned_cls_def clause_watch cons_trail_def
    remove_cls_def restart_def tl_trail_def update_backtrack_lvl_def update_conflicting_def)
  apply (rule image_mset_subseteq_mono[OF restart_learned])

  (*
    FIXME: The last proof obligation seems too strong.
  *)
oops

(* implementation of watch *)
interpretation structure_2_WL
oops

interpretation cdcl\<^sub>N\<^sub>O\<^sub>T_merge_bj_learn _ _ _ _ (* propagate_conds is in candidates *) _ _ _
  (* backjump_conds is candidate_conflict *)
oops

(* implementation of watch *)
interpretation structure_2_WL
oops

interpretation cw_state
oops

(* interpretation cdcl_cw_ops
oops
 *)
end
end
