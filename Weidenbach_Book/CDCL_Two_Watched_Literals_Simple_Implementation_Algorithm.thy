theory CDCL_Two_Watched_Literals_Simple_Implementation_Algorithm
  imports
    CDCL_Two_Watched_Literals_Simple_Implementation
    "$AFP/Refine_Imperative_HOL/IICF/IICF"
begin

lemma bind_refine_spec: \<open>(\<And>x. \<Phi> x \<Longrightarrow> f x \<le> \<Down> R M) \<Longrightarrow> M' \<le> SPEC \<Phi> \<Longrightarrow> M' \<bind> f \<le> \<Down> R M\<close>
  by (auto simp add: pw_le_iff refine_pw_simps)

lemma case_prod_bind:
  assumes \<open>\<And>x1 x2. x= (x1, x2) \<Longrightarrow> f x1 x2 \<le> \<Down> R I\<close>
  shows \<open>(case x of (x1, x2) \<Rightarrow> f x1 x2) \<le> \<Down> R I\<close>
  using assms by (cases x) auto

text \<open>
  This very simple tactics remove duplicate variables generated by some tactic like \<open>refine_rcg\<close>.
  For example, if the problem contains \<^term>\<open>(i, C) = (xa, xb)\<close>, then only \<^term>\<open>i\<close> and
  \<^term>\<open>C\<close> will remain.
  \<close>

method remove_dummy_vars =
  (unfold prod.inject; simp only: prod.inject; elim conjE;
    hypsubst; simp only: triv_forall_equality)

definition unit_propagation_inner_loop_body :: "'v literal \<times> 'v literal multiset twl_clause \<Rightarrow>
  'v twl_st \<Rightarrow> 'v twl_st nres"  where
  \<open>unit_propagation_inner_loop_body C' S = do {
    let (M, N, U, D, NP, UP, WS, Q) = S;
    let (L, C) = C';
    L' \<leftarrow> SPEC (\<lambda>K. K \<in># watched C - {#L#});
    ASSERT (watched C = {#L, L'#});
    if L' \<in> lits_of_l M
    then RETURN S
    else
      if \<forall>L \<in># unwatched C. -L \<in> lits_of_l M
      then
        if -L' \<in> lits_of_l M
        then do {RETURN (M, N, U, Some (clause C), NP, UP, {#}, {#})}
        else do {RETURN (Propagated L' (clause C) # M, N, U, D, NP, UP, WS, add_mset (-L') Q)}
      else do {
        K \<leftarrow> SPEC (\<lambda>L. L \<in># unwatched C \<and> -L \<notin> lits_of_l M);
        let (N', U') = update_clauses (N, U) C L K;
        RETURN (M, N', U', D, NP, UP, WS, Q)
      }
    }
\<close>

term FOREACHci
definition unit_propagation_inner_loop :: "'v twl_st \<Rightarrow> 'v twl_st nres"  where
  \<open>unit_propagation_inner_loop S\<^sub>0 =
    WHILE\<^sub>T\<^bsup>\<lambda>S. twl_cp_invs S \<and> cdcl_twl_cp\<^sup>*\<^sup>* S\<^sub>0 S\<^esup>
      (\<lambda>S. working_queue S \<noteq> {#})
      (\<lambda>S. do {
        C \<leftarrow> SPEC (\<lambda>C. C \<in># working_queue S);
        let S' = set_working_queue (working_queue S - {#C#}) S;
        unit_propagation_inner_loop_body C S'
      })
      S\<^sub>0
\<close>

lemma unit_propagation_inner_loop_body[THEN order_trans, refine_vcg]:
  fixes S :: \<open>'v twl_st\<close>
  assumes
    \<open>working_queue S \<noteq> {#}\<close> and
    \<open>x \<in># working_queue S\<close> and
    inv: \<open>twl_cp_invs S\<close> and
    confl: \<open>get_conflict S = None\<close>
  shows \<open>unit_propagation_inner_loop_body x (set_working_queue (remove1_mset x (working_queue S)) S)
    \<le> SPEC (\<lambda>S'. twl_cp_invs S' \<and> cdcl_twl_cp\<^sup>*\<^sup>* S S' \<and> (S', S) \<in> measure (size \<circ> working_queue))\<close>
proof -
  obtain M N U D NP UP WS Q where
    S: \<open>S = (M, N, U, D, NP, UP, WS, Q)\<close>
    by (cases S) auto
  note [[goals_limit=3]]
  show ?thesis
    using assms unfolding unit_propagation_inner_loop_body_def S
  proof (refine_vcg; (unfold prod.inject working_queue.simps set_working_queue.simps ball_simps)?;
      clarify?; unfold triv_forall_equality)
    fix C :: \<open>'v clause twl_clause\<close> and L L' :: \<open>'v literal\<close>
    assume
      \<open>WS \<noteq> {#}\<close> and
      WS: \<open>(L, C) \<in># WS\<close> and
      twl_inv: \<open>twl_cp_invs (M, N, U, D, NP, UP, WS, Q)\<close> and
      L': \<open>L' \<in># remove1_mset L (watched C)\<close> and
      \<open>x = (L, C)\<close>
    have \<open>C \<in># N + U\<close> and struct: \<open>struct_wf_twl_cls C\<close> and L_C: \<open>L \<in># watched C\<close>
      using twl_inv WS unfolding twl_cp_invs_def twl_st_inv.simps by fastforce+
    show watched: \<open>watched C = {#L, L'#}\<close>
      by (cases C) (use struct L_C L' in \<open>auto simp: size_2_iff\<close>)

    define WS' where \<open>WS' = WS - {#(L, C)#}\<close>
    have WS_WS': \<open>WS = add_mset (L, C) WS'\<close>
      using WS unfolding WS'_def by auto
    have D: \<open>D = None\<close>
      using confl S by auto
    { -- \<open>if \<^term>\<open>L' \<in> lits_of_l M\<close>, then:\<close>
      assume L': \<open>L' \<in> lits_of_l M\<close>
      let ?S = \<open>(M, N, U, D, NP, UP, WS, Q)\<close>
      let ?S' = \<open>(M, N, U, None, NP, UP, add_mset (L, C) WS', Q)\<close>
      let ?T = \<open> (M, N, U, D, NP, UP, remove1_mset (L, C) WS, Q)\<close>
      let ?T' = \<open>(M, N, U, None, NP, UP, WS', Q)\<close>

      have cdcl: \<open>cdcl_twl_cp ?S' ?T'\<close>
        by (rule cdcl_twl_cp.delete_from_working) (use L' watched in simp_all)

      show \<open>twl_cp_invs ?T\<close>
        using cdcl inv D  unfolding S WS_WS' by (force intro: cdcl_twl_cp_twl_cp_invs)
      show \<open>cdcl_twl_cp\<^sup>*\<^sup>* ?S ?T\<close>
        using D WS_WS' cdcl by auto

      show \<open>(?T, ?S) \<in> measure (size \<circ> working_queue)\<close>
        by (simp add: WS'_def[symmetric] WS_WS')
    }
    -- \<open>if \<^term>\<open>L' \<in> lits_of_l M\<close>, else:\<close>
    assume L': \<open>L' \<notin> lits_of_l M\<close>
    {
      { -- \<open>if \<^term>\<open>\<forall>L \<in># unwatched C. -L \<in> lits_of_l M\<close>, then\<close>
        assume unwatched: \<open>\<forall>L\<in>#unwatched C. - L \<in> lits_of_l M\<close>

        { -- \<open>if \<^term>\<open>-L' \<in> lits_of_l M \<close> then\<close>
          let ?S = \<open>(M, N, U, D, NP, UP, WS, Q)\<close>
          let ?S' = \<open>(M, N, U, None, NP, UP, add_mset (L, C) WS', Q)\<close>
          let ?T = \<open> (M, N, U, D, NP, UP, {#}, {#})\<close>
          let ?T' = \<open>(M, N, U, Some (clause C), NP, UP, {#}, {#})\<close>
          assume uL': \<open>-L' \<in> lits_of_l M\<close>
          have cdcl: \<open>cdcl_twl_cp ?S' ?T'\<close>
            by (rule cdcl_twl_cp.conflict) (use uL' L' watched unwatched in simp_all)

          show \<open>twl_cp_invs ?T'\<close>
            using cdcl inv D  unfolding S WS_WS' by (force intro: cdcl_twl_cp_twl_cp_invs)
          show \<open>cdcl_twl_cp\<^sup>*\<^sup>* ?S ?T'\<close>
            using D WS_WS' cdcl by auto


          show \<open>(?T', ?S) \<in> measure (size \<circ> working_queue)\<close>
            by (simp add: WS'_def[symmetric] WS_WS')
        }


        { -- \<open>if \<^term>\<open>-L' \<in> lits_of_l M \<close> else\<close>
          let ?S = \<open>(M, N, U, D, NP, UP, WS, Q)\<close>
          let ?T = \<open>(Propagated L' (clause C) # M, N, U, D, NP, UP, remove1_mset (L, C) WS, add_mset (- L') Q)\<close>
          let ?S' = \<open>(M, N, U, None, NP, UP, add_mset (L, C) WS', Q)\<close>
          let ?T' = \<open>(Propagated L' (clause C) # M, N, U, None, NP, UP, WS', add_mset (- L') Q)\<close>
          assume uL': \<open>- L' \<notin> lits_of_l M\<close>

          have undef: \<open>undefined_lit M L'\<close>
            using uL' L' by (auto simp: defined_lit_map lits_of_def atm_of_eq_atm_of)

          have cdcl: \<open>cdcl_twl_cp ?S' ?T'\<close>
            by (rule cdcl_twl_cp.propagate) (use uL' L' undef watched unwatched in simp_all)

          show \<open>twl_cp_invs ?T\<close>
            using cdcl inv D  unfolding S WS_WS' by (force intro: cdcl_twl_cp_twl_cp_invs)

          show \<open>cdcl_twl_cp\<^sup>*\<^sup>* ?S ?T\<close>
            using cdcl D WS_WS' by force

          show \<open>(?T, ?S) \<in> measure (size \<circ> working_queue)\<close>
            by (simp add: WS'_def[symmetric] WS_WS')
        }
      }

      -- \<open>if \<^term>\<open>\<forall>L \<in># unwatched C. -L \<in> lits_of_l M\<close>, else\<close>
      { fix K and N' U' :: \<open>'v literal multiset twl_clause multiset\<close>
        let ?S = \<open>(M, N, U, D, NP, UP, WS, Q)\<close>
        let ?T = \<open>(M, N', U', D, NP, UP, remove1_mset (L, C) WS, Q)\<close>
        let ?S' = \<open>(M, N, U, None, NP, UP, add_mset (L, C) WS', Q)\<close>
        let ?T' = \<open>(M, N', U', None, NP, UP, WS', Q)\<close>

        assume K: \<open>K \<in># unwatched C\<close> and
          uK: \<open>- K \<notin> lits_of_l M\<close> and
          update: \<open>update_clauses (N, U) C L K = (N', U')\<close>
        have uL: \<open>- L \<in> lits_of_l M\<close>
          using inv unfolding twl_cp_invs_def S WS_WS' by auto
        have undef_def_K: \<open>undefined_lit M K \<or> K \<in> lits_of_l M\<close>
          using Decided_Propagated_in_iff_in_lits_of_l uK by blast
        have cdcl: \<open>cdcl_twl_cp ?S' ?T'\<close>
          by (rule cdcl_twl_cp.update_clause)
            (use uL L' K uK update[symmetric] watched undef_def_K in simp_all)
        show \<open>twl_cp_invs ?T\<close>
          using cdcl inv D  unfolding S WS_WS' by (force intro: cdcl_twl_cp_twl_cp_invs)

        show \<open>cdcl_twl_cp\<^sup>*\<^sup>* ?S ?T\<close>
          using D WS_WS' cdcl by auto
        show \<open>(?T, ?S) \<in> measure (size \<circ> working_queue)\<close>
          by (simp add: WS'_def[symmetric] WS_WS')
      }
    }
    qed
qed

lemma unit_propagation_inner_loop[THEN order_trans, refine_vcg]:
  assumes \<open>twl_cp_invs S\<close>
  shows \<open>unit_propagation_inner_loop S \<le> SPEC (\<lambda>S'. twl_cp_invs S' \<and> cdcl_twl_cp\<^sup>*\<^sup>* S S')\<close>
  unfolding unit_propagation_inner_loop_def
  apply (refine_vcg WHILEIT_rule[where R = \<open>measure (size o working_queue)\<close>])
          apply (auto simp: assms)
  apply (simp add: twl_cp_invs_def)
  done

definition unit_propagation_outer_loop :: "'v twl_st \<Rightarrow> 'v twl_st nres"  where
  \<open>unit_propagation_outer_loop S\<^sub>0 =
    WHILE\<^sub>T\<^bsup>\<lambda>S. twl_cp_invs S \<and> cdcl_twl_cp\<^sup>*\<^sup>* S\<^sub>0 S \<and> working_queue S = {#}\<^esup>
      (\<lambda>S. pending S \<noteq> {#})
      (\<lambda>S. do {
        L \<leftarrow> SPEC (\<lambda>L. L \<in># pending S);
        let S' = set_working_queue {#(L, C)|C \<in># get_clauses S. L \<in># watched C#}
           (set_pending (pending S - {#L#}) S);
        ASSERT(cdcl_twl_cp S S');
        unit_propagation_inner_loop S'
      })
      S\<^sub>0
\<close>

lemma unit_propagation_outer_loop:
  assumes \<open>twl_cp_invs S\<close> and \<open>working_queue S = {#}\<close> and confl: \<open>get_conflict S = None\<close>
  shows \<open>unit_propagation_outer_loop S \<le> SPEC (\<lambda>S'. twl_cp_invs S' \<and> cdcl_twl_cp\<^sup>*\<^sup>* S S' \<and>
    get_conflict S = None)\<close>
  unfolding unit_propagation_outer_loop_def
  apply (refine_vcg WHILEIT_rule[where R = \<open>measure (size o working_queue)\<close>])
             apply (simp_all add: assms)[4]
  apply (cases S)
  using confl apply (auto dest!: multi_member_split intro!: cdcl_twl_cp.pop
      simp del: filter_union_mset)[]
  using cdcl_twl_cp.pop
  sorry

type_synonym 'v working_queue_list = "('v literal \<times> 'v literal list twl_clause) multiset"
type_synonym 'v lit_queue_list = "'v literal list"

type_synonym 'v clause_list = "'v literal list"
type_synonym 'v clauses_list = "'v literal list"

type_synonym 'v twl_st_list =
  "('v, 'v clause) ann_lits \<times> 'v literal list twl_clause multiset \<times> 'v clause_list twl_clause multiset \<times>
    'v clause_list option \<times> 'v clauses \<times> 'v clauses \<times> 'v working_queue_list \<times> 'v lit_queue"

fun get_clauses_list :: "'v twl_st_list \<Rightarrow> 'v literal list twl_clause multiset" where
  \<open>get_clauses_list (M, N, U, D, NP, UP, WS, Q) = N + U\<close>

definition valued where
  \<open>valued M L =
     RETURN (if undefined_lit M L then None else if L \<in> lits_of_l M then Some True else Some False)\<close>

lemma valued_spec:
  \<open>valued M L \<le> SPEC(\<lambda>v. case v of None \<Rightarrow> undefined_lit M L
    | Some True \<Rightarrow> L \<in> lits_of_l M | Some False \<Rightarrow> -L \<in> lits_of_l M)\<close>
  unfolding valued_def
  by (refine_vcg) (auto simp: defined_lit_map lits_of_def atm_of_eq_atm_of split: option.splits)

definition find_unwatched where
\<open>find_unwatched M C = do {
  WHILE\<^sub>T\<^bsup>\<lambda>(found, i). i \<le> length C \<and> (\<forall>j<i. -(C!j) \<in> lits_of_l M) \<and>
    (found = Some False \<longrightarrow> (undefined_lit M (C!i) \<and> i < length C)) \<and>
    (found = Some True \<longrightarrow> (C!i \<in> lits_of_l M \<and> i < length C)) \<^esup>
    (\<lambda>(found, i). found = None \<and> i < length C)
    (\<lambda>(_, i). do {
      v \<leftarrow> valued M (C!i);
      case v of
        None \<Rightarrow> do { RETURN (Some False, i)}
      | Some True \<Rightarrow> do { RETURN (Some True, i)}
      | Some False \<Rightarrow> do { RETURN (None, i+1)}
      }
    )
    (None, 0::nat)
  }
\<close>
thm rtrancl.induct  rtranclp.induct
lemma (in transfer) transfer_bool[refine_transfer]:
  assumes "\<alpha> fa \<le> Fa"
  assumes "\<alpha> fb \<le> Fb"
  shows "\<alpha> (case_bool fa fb x) \<le> case_bool Fa Fb x"
  using assms by (auto split: bool.split)

(* Example of code generation *)
schematic_goal find_unwatched_impl: "RETURN ?c \<le> find_unwatched M C"
  unfolding find_unwatched_def valued_def
  apply (refine_transfer)
  done

concrete_definition find_unwatched_impl uses find_unwatched_impl
prepare_code_thms find_unwatched_impl_def
export_code find_unwatched_impl in SML
(* End of code generation *)

lemma find_unwatched:
  \<open>find_unwatched M C \<le> SPEC (\<lambda>(found, i).
      (found = None \<longrightarrow> (\<forall>L\<in>set C. -L \<in> lits_of_l M)) \<and>
      (found = Some False \<longrightarrow> (i < length C \<and> undefined_lit M (C!i))) \<and>
      (found = Some True \<longrightarrow> (i < length C \<and> C!i \<in> lits_of_l M)))\<close>
  unfolding find_unwatched_def
  apply (rule WHILEIT_rule[where R = \<open>measure (\<lambda>(found, i). Suc (length C) - i +
        If (found = None) 1 0)\<close>])
     apply simp_all[2]

  subgoal for s unfolding valued_def
    apply refine_vcg
    apply (auto simp: Decided_Propagated_in_iff_in_lits_of_l dest: less_SucE
        split: bool.split if_splits)
    done
  subgoal for s
    apply (cases s, cases \<open>fst s\<close>)
     apply (simp add: all_set_conv_nth)+
    done
  done

fun update_clause_list where
"update_clause_list (TWL_Clause W UW) i j =
  TWL_Clause (list_update W i (UW!j)) (list_update UW j (W!i))"

fun update_clauses_list ::
    "'a list twl_clause multiset \<times> 'a list twl_clause multiset \<Rightarrow>
    'a list twl_clause \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow>
    'a list twl_clause multiset \<times> 'a list twl_clause multiset" where
"update_clauses_list (N, U) D i j =
  (if D \<in># N then (add_mset (update_clause_list D i j) (remove1_mset D N), U)
       else (N, add_mset (update_clause_list D i j) (remove1_mset D U)))"

definition unit_propagation_inner_loop_body_list :: "nat \<times> 'v literal list twl_clause \<Rightarrow>
  'v twl_st_list \<Rightarrow> 'v twl_st_list nres"  where
  \<open>unit_propagation_inner_loop_body_list C' S = do {
    let (M, N, U, D, NP, UP, WS, Q) = S;
    let (i, C) = C';
    let L = (watched C) ! i;
    let L' = (watched C) ! (1 - i);
    ASSERT(L' \<in># mset (watched C) - {#L#});
    ASSERT (mset (watched C) = {#L, L'#});
    val_L' \<leftarrow> valued M L';
    if val_L' = Some True
    then RETURN S
    else do{
      (found, j) \<leftarrow> find_unwatched M (unwatched C);
      ASSERT (found = None \<longleftrightarrow> (\<forall>L\<in>#mset (unwatched C). - L \<in> lits_of_l M));
      if found = None
      then
        if -L' \<in> lits_of_l M
        then do {RETURN (M, N, U, Some ((watched C) @ (unwatched C)), NP, UP, {#}, {#})}
        else do {RETURN (Propagated L' (mset (watched C) + mset (unwatched C)) # M, N, U, D, NP, UP, WS, add_mset (-L') Q)}
      else do {
        let K = unwatched C ! j;
        let (N', U') = update_clauses_list (N, U) C i j;
        RETURN (M, N', U', D, NP, UP, WS, Q)
      }
    }
   }
\<close>

fun twl_clause_of where
  \<open>twl_clause_of (TWL_Clause W UW) = TWL_Clause (mset W) (mset UW)\<close>

fun twl_st_of :: \<open>'v twl_st_list  \<Rightarrow> 'v twl_st\<close>where
\<open>twl_st_of (M, N, U, C, NP, UP, WS, Q) =
(M, twl_clause_of `# N, twl_clause_of `# U, map_option mset C, NP, UP,
  (\<lambda>(a, b). (a, twl_clause_of b)) `# WS, Q)
\<close>

lemma distinct_mset_distinct_twl_clause_of:
  \<open>distinct_mset (clause `# twl_clause_of `# N) \<Longrightarrow> distinct_mset N\<close>
  by (induction N) auto


lemma unit_propagation_inner_loop_body_list:
  \<open>(uncurry unit_propagation_inner_loop_body_list, uncurry unit_propagation_inner_loop_body) \<in>
    {(((i, C), S), ((L', C'), S')). L' = watched C ! i \<and> C' = twl_clause_of C \<and> (i = 0 \<or> i = 1) \<and>
    S' = twl_st_of S \<and> twl_cp_invs S' \<and> (L', C') \<in># working_queue S' \<and> C \<in># get_clauses_list S} \<rightarrow>
    \<langle>{(S, S'). S' = twl_st_of S}\<rangle> nres_rel\<close>
proof -
  {
    fix i :: nat and C :: \<open>'a literal list twl_clause\<close> and S' :: \<open>'a twl_st\<close> and S :: \<open>'a twl_st_list\<close>
    let ?L = \<open>watched C ! i\<close>
    let ?L' = \<open>watched C ! (Suc 0 - i)\<close>
    let ?C' = \<open>twl_clause_of C\<close>
    obtain M N U D NP UP WS Q where S: \<open>S = (M, N, U, D, NP, UP, WS, Q)\<close>
      by (cases S) auto
    have S'_S: \<open>twl_st_of S = (M, twl_clause_of `# N, twl_clause_of `# U, map_option mset D,
      NP, UP, (\<lambda>(a, b). (a, twl_clause_of b)) `# WS, Q)\<close>
      unfolding S by auto
    assume
      WS: \<open>(?L, ?C') \<in># working_queue S'\<close> and
      S': \<open>S' = twl_st_of S\<close> and
      i: \<open>i = 0 \<or> i = 1\<close> and
      invs: \<open>twl_cp_invs (twl_st_of S)\<close> and
      C_N_U: \<open>C \<in># get_clauses_list S\<close>

    have inv: \<open>twl_st_inv (twl_st_of S)\<close> and valid: \<open>valid_annotation (twl_st_of S)\<close> and
      cdcl_inv: \<open>cdcl\<^sub>W_restart_mset.cdcl\<^sub>W_all_struct_inv (convert_to_state (twl_st_of S))\<close>
      using invs WS apply (auto simp: twl_cp_invs_def)
      done

    have n_d: \<open>no_dup M\<close>
      using cdcl_inv unfolding cdcl\<^sub>W_restart_mset.cdcl\<^sub>W_all_struct_inv_def
        cdcl\<^sub>W_restart_mset.cdcl\<^sub>W_M_level_inv_def S by (auto simp: trail.simps)
    then have consistent: \<open>- L \<notin> lits_of_l M\<close> if \<open>L \<in> lits_of_l M\<close> for L
      using consistent_interp_def distinct_consistent_interp that by blast

    have cons_M: \<open>consistent_interp (lits_of_l M)\<close>
      using n_d distinct_consistent_interp by fast

    have C'_N_U: \<open>?C' \<in># twl_clause_of `# (N + U)\<close>
      using WS valid S' by (auto simp: S twl_cp_invs_def split: prod.splits)
    then have struct: \<open>struct_wf_twl_cls ?C'\<close>
      using inv S' by (auto simp: twl_st_inv.simps S)

    have watched_C': \<open>watched ?C' = {#?L, ?L'#}\<close>
      using struct i by (cases C) (auto simp: length_list_2)
    then have mset_watched_C: \<open>mset (watched C) = {#watched C ! i, watched C ! (Suc 0 - i)#}\<close>
      by (cases C) auto
    have unwatched_twl_clause_of[simp]: \<open>set_mset (unwatched (twl_clause_of C)) = set (unwatched C)\<close>
      by (cases C) auto
    have in_set_unwatched_conv: \<open>(\<forall>j<length (unwatched C). defined_lit M (unwatched C ! j)) \<longleftrightarrow>
       (\<forall>L \<in># mset (unwatched C). defined_lit M L)\<close>
       for C :: \<open>'b literal list twl_clause\<close> and M :: \<open>('b, 'c) ann_lit list\<close>
      unfolding set_mset_mset by (metis in_set_conv_nth)
    have twl_clause_of_update_C[simp]: \<open>twl_clause_of (update_clause_list C i j) = update_clause (twl_clause_of C) ?L (unwatched C ! j)\<close>
      if \<open>j < length (unwatched C)\<close> for j
      by (cases C) (use i that struct in \<open>auto simp: mset_eq_size_2 length_list_2 mset_update\<close>)
    have update_clause[simp]: \<open>add_mset ?L (add_mset ?L' (mset (unwatched C))) = clause (twl_clause_of C)\<close>
      using watched_C' by (cases C) simp

    have dist: \<open>distinct_mset (clause `# twl_clause_of `# (N + U) + NP + UP)\<close>
      using invs unfolding twl_cp_invs_def S
      by (simp add: clauses_def ac_simps)
    then have dist: \<open>distinct_mset (clause `# twl_clause_of `# (N + U))\<close>
      using distinct_mset_add by blast
    have distinct_cls_N: \<open>C' = C \<and> C' \<in># N\<close> if \<open>twl_clause_of C' = twl_clause_of C\<close> and \<open>C' \<in># N\<close> for C'
      by (metis (no_types, lifting) C_N_U S UnCI dist
          distinct_mset_add_mset distinct_mset_distinct_twl_clause_of that set_mset_union
          get_clauses_list.simps image_mset_add_mset in_remove1_mset_neq insert_DiffM)

    have distinct_cls_U: \<open>C' = C \<and> C' \<in># U\<close> if \<open>twl_clause_of C' = twl_clause_of C\<close> and \<open>C' \<in># U\<close> for C'
      by (metis (no_types, lifting) C_N_U S UnCI dist
          distinct_mset_add_mset distinct_mset_distinct_twl_clause_of that set_mset_union
          get_clauses_list.simps image_mset_add_mset in_remove1_mset_neq insert_DiffM)
    have C_N_N: \<open>twl_clause_of `# remove1_mset C N = remove1_mset (twl_clause_of C) (twl_clause_of `# N)\<close>
      if \<open>C \<in># N\<close>
      by (auto simp: that image_mset_remove1_mset_if)
    have C_U_U: \<open>twl_clause_of `# remove1_mset C U = remove1_mset (twl_clause_of C) (twl_clause_of `# U)\<close>
      if \<open>C \<notin># N\<close>
      using that C'_N_U C_N_U by (auto simp: image_mset_remove1_mset_if remove_1_mset_id_iff_notin
          id_remove_1_mset_iff_notin S)
    have \<open>unit_propagation_inner_loop_body_list (i, C) S \<le>
      \<Down> {(S, S'). S' = twl_st_of S} (unit_propagation_inner_loop_body
      (?L, twl_clause_of C) (twl_st_of S))\<close>
      unfolding unit_propagation_inner_loop_body_list_def unit_propagation_inner_loop_body_def S
        S'_S[unfolded S]
      apply (rewrite at \<open>let _ = watched _ ! _ in _\<close> Let_def)
      supply [[goals_limit = 1]]
      apply (refine_rcg bind_refine_spec[where M' = \<open>find_unwatched _ _\<close>, OF _ find_unwatched]
          bind_refine_spec[where M' = \<open>valued _ _\<close>, OF _ valued_spec];
          remove_dummy_vars)
                 prefer 6
      subgoal
        apply (rule iffI)
         apply (auto dest: nth_mem simp: Decided_Propagated_in_iff_in_lits_of_l consistent; fail)[]
        apply (rule ccontr)
        apply (use cons_M in \<open>auto simp: Decided_Propagated_in_iff_in_lits_of_l
            consistent_interp_def dest: nth_mem; fail\<close>)[]
        done
                prefer 10
      subgoal
        apply clarsimp
        apply (auto simp add: consistent Decided_Propagated_in_iff_in_lits_of_l)[]
        done
               prefer 10
      subgoal
        apply (clarsimp)
        apply (auto simp add: consistent Decided_Propagated_in_iff_in_lits_of_l C_N_N C_N_U
            C_U_U
            dest!: sym[of \<open>twl_clause_of C\<close>] distinct_cls_N
            split: if_splits)[]
        done
              apply (vc_solve simp: mset_watched_C watched_C' in_set_unwatched_conv
          Decided_Propagated_in_iff_in_lits_of_l
          consistent split: option.splits bool.splits)
      done
  }

  then show ?thesis
    apply (auto simp add: fun_rel_def_internal nres_rel_def_internal nres_rel_def
        simp del: twl_st_of.simps) done
qed

end