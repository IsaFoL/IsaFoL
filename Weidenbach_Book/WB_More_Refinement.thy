theory WB_More_Refinement
  imports
    Refine_Imperative_HOL.IICF
    Weidenbach_Book_Base.WB_List_More
    "HOL-Eisbach.Eisbach"
    "HOL-Eisbach.Eisbach_Tools"
begin

subsection \<open>Some Tooling for Refinement\<close>

text \<open>
  The following very simple tactics remove duplicate variables generated by some tactic like
  \<open>refine_rcg\<close>. For example, if the problem contains \<^term>\<open>(i, C) = (xa, xb)\<close>, then only
  \<^term>\<open>i\<close> and \<^term>\<open>C\<close> will remain. It can also prove trivial goals where the goals already
  appears in the assumptions.
  \<close>

method remove_dummy_vars uses simp =
  ((unfold prod.inject)?; (simp only: prod.inject)?; (elim conjE)?;
    hypsubst?; (simp only: triv_forall_equality simps)?)


subsubsection \<open>From @{text \<rightarrow>} to @{text \<Down>}\<close>

lemma Ball2_split_def: \<open>(\<forall>(x, y) \<in> A. P x y) \<longleftrightarrow> (\<forall>x y. (x, y) \<in> A \<longrightarrow> P x y)\<close>
  by blast

method find_cases_and_split =
  (match conclusion in \<open>?P (case x of (_, _) \<Rightarrow> _)\<close> for x \<Rightarrow> \<open>cases x\<close>)
lemma \<open>f x y = uncurry f (x, y)\<close>
  by (auto simp: uncurry_def)
method curry_goal =
  (match conclusion in \<open>f x y\<close> for f x y \<Rightarrow> \<open>unfold do_uncurry\<close>)
lemma uncurry_fst_snd: \<open>uncurry f x = f (fst x) (snd x)\<close>
  by (cases x) (auto simp: uncurry_def)

lemma H: \<open>\<forall>x. P x (fst x) (snd x) \<equiv> \<forall>x y. P (x,y) x y\<close>
  by auto

ML \<open>
signature MORE_REFINEMENT = sig
  val down_converse: Proof.context -> thm -> thm
end

structure More_Refinement: MORE_REFINEMENT = struct
  val unfold_refine = (fn context => Local_Defs.unfold (context)
   @{thms refine_rel_defs nres_rel_def in_pair_collect_simp})
  val unfold_Ball = (fn context => Local_Defs.unfold (context)
    @{thms Ball2_split_def all_to_meta})
  val replace_ALL_by_meta = (fn context => fn thm => Object_Logic.rulify context thm)
  val down_converse = (fn context =>
    replace_ALL_by_meta context o (unfold_Ball context) o (unfold_refine context))
end
\<close>

attribute_setup "to_\<Down>" = \<open>
    Scan.succeed (Thm.rule_attribute [] (More_Refinement.down_converse o Context.proof_of))
  \<close> "convert theorem from @{text \<rightarrow>}-form to @{text \<Down>}-form."

method "to_\<Down>" =
   (unfold refine_rel_defs nres_rel_def in_pair_collect_simp;
   unfold Ball2_split_def all_to_meta;
   intro allI impI)


subsubsection \<open>Merge Post-Conditions\<close>

lemma Down_add_assumption_middle:
  assumes
    \<open>nofail U\<close> and
    \<open>V \<le> \<Down> {(T1, T0). Q T1 T0 \<and> P T1 \<and> Q' T1 T0} U\<close> and
    \<open>W \<le> \<Down> {(T2, T1). R T2 T1} V\<close>
  shows \<open>W \<le> \<Down> {(T2, T1). R T2 T1 \<and> P T1} V\<close>
  using assms unfolding nres_rel_def fun_rel_def pw_le_iff pw_conc_inres pw_conc_nofail
  by blast

lemma Down_del_assumption_middle:
  assumes
    \<open>S1 \<le> \<Down> {(T1, T0). Q T1 T0 \<and> P T1 \<and> Q' T1 T0} S0\<close>
  shows \<open>S1 \<le> \<Down> {(T1, T0). Q T1 T0 \<and> Q' T1 T0} S0\<close>
  using assms unfolding nres_rel_def fun_rel_def pw_le_iff pw_conc_inres pw_conc_nofail
  by blast

lemma Down_add_assumption_beginning:
  assumes
    \<open>nofail U\<close> and
    \<open>V \<le> \<Down> {(T1, T0). P T1 \<and> Q' T1 T0} U\<close> and
    \<open>W \<le> \<Down> {(T2, T1). R T2 T1} V\<close>
  shows \<open>W \<le> \<Down> {(T2, T1). R T2 T1 \<and> P T1} V\<close>
  using assms unfolding nres_rel_def fun_rel_def pw_le_iff pw_conc_inres pw_conc_nofail
  by blast

lemma Down_add_assumption_beginning_single:
  assumes
    \<open>nofail U\<close> and
    \<open>V \<le> \<Down> {(T1, T0). P T1} U\<close> and
    \<open>W \<le> \<Down> {(T2, T1). R T2 T1} V\<close>
  shows \<open>W \<le> \<Down> {(T2, T1). R T2 T1 \<and> P T1} V\<close>
  using assms unfolding nres_rel_def fun_rel_def pw_le_iff pw_conc_inres pw_conc_nofail
  by blast

lemma Down_del_assumption_beginning:
  fixes U :: \<open>'a nres\<close> and V :: \<open>'b nres\<close> and Q Q' :: \<open>'b \<Rightarrow> 'a \<Rightarrow> bool\<close>
  assumes
    \<open>V \<le> \<Down> {(T1, T0). Q T1 T0 \<and> Q' T1 T0} U\<close>
  shows \<open>V \<le> \<Down> {(T1, T0). Q' T1 T0} U\<close>
  using assms unfolding nres_rel_def fun_rel_def pw_le_iff pw_conc_inres pw_conc_nofail
  by blast

method unify_Down_invs2_normalisation_post =
  ((unfold meta_same_imp_rule True_implies_equals conj_assoc)?)

method unify_Down_invs2 =
  (match premises in
      \<comment> \<open>if the relation 2-1 has not assumption, we add True. Then we call out method again and
           this time it will match since it has an assumption.\<close>
      I: \<open>S1 \<le> \<Down> R10 S0\<close> and
      J[thin]: \<open>S2 \<le> \<Down> R21 S1\<close>
       for S1:: \<open>'b nres\<close> and S0 :: \<open>'a nres\<close> and S2 :: \<open>'c nres\<close> and R10 R21 \<Rightarrow>
        \<open>insert True_implies_equals[where P = \<open>S2 \<le> \<Down> R21 S1\<close>, symmetric,
           THEN equal_elim_rule1, OF J]\<close>
    \<bar> I[thin]: \<open>S1 \<le> \<Down> {(T1, T0). P T1} S0\<close> (multi) and
      J[thin]: _ for S1:: \<open>'b nres\<close> and S0 :: \<open>'a nres\<close> and P :: \<open>'b \<Rightarrow> bool\<close> \<Rightarrow>
       \<open>match J[uncurry] in
         J[curry]: \<open>_ \<Longrightarrow> S2 \<le> \<Down> {(T2, T1). R T2 T1} S1\<close> for S2 :: \<open>'c nres\<close> and R \<Rightarrow>
          \<open>insert Down_add_assumption_beginning_single[where P = P and R = R and
               W = S2 and V = S1 and U = S0, OF _ I J];
           unify_Down_invs2_normalisation_post\<close>
       \<bar> _ \<Rightarrow> \<open>fail\<close>\<close>
   \<bar> I[thin]: \<open>S1 \<le> \<Down> {(T1, T0). P T1 \<and> Q' T1 T0} S0\<close> (multi) and
     J[thin]: _ for S1:: \<open>'b nres\<close> and S0 :: \<open>'a nres\<close> and Q' and P :: \<open>'b \<Rightarrow> bool\<close> \<Rightarrow>
       \<open>match J[uncurry] in
         J[curry]: \<open>_ \<Longrightarrow> S2 \<le> \<Down> {(T2, T1). R T2 T1} S1\<close> for S2 :: \<open>'c nres\<close> and R \<Rightarrow>
          \<open>insert Down_add_assumption_beginning[where Q' = Q' and P = P and R = R and
              W = S2 and V = S1 and U = S0,
              OF _ I J];
           insert Down_del_assumption_beginning[where Q = \<open>\<lambda>S _. P S\<close> and Q' = Q' and V = S1 and
             U = S0, OF I];
          unify_Down_invs2_normalisation_post\<close>
       \<bar> _ \<Rightarrow> \<open>fail\<close>\<close>
   \<bar> I[thin]: \<open>S1 \<le> \<Down> {(T1, T0). Q T0 T1\<and> Q' T1 T0} S0\<close> (multi) and
     J: _ for S1:: \<open>'b nres\<close> and S0 :: \<open>'a nres\<close> and Q Q' \<Rightarrow>
       \<open>match J[uncurry] in
         J[curry]: \<open>_ \<Longrightarrow> S2 \<le> \<Down> {(T2, T1). R T2 T1} S1\<close> for S2 :: \<open>'c nres\<close> and R \<Rightarrow>
          \<open>insert Down_del_assumption_beginning[where Q = \<open>\<lambda> x y. Q y x\<close> and Q' = Q', OF I];
           unify_Down_invs2_normalisation_post\<close>
       \<bar> _ \<Rightarrow> \<open>fail\<close>\<close>
  )

text \<open>Example:\<close>
lemma
  assumes
    \<open>nofail S0\<close> and
    1: \<open>S1 \<le> \<Down> {(T1, T0). Q T1 T0 \<and> P T1 \<and> P' T1 \<and> P''' T1 \<and> Q' T1 T0 \<and> P42 T1} S0\<close> and
    2: \<open>S2 \<le> \<Down> {(T2, T1). R T2 T1} S1\<close>
  shows \<open>S2
     \<le> \<Down> {(T2, T1).
           R T2 T1 \<and>
           P T1 \<and> P' T1 \<and> P''' T1 \<and> P42 T1}
         S1\<close>
  using assms apply -
  apply unify_Down_invs2+
  apply fast
  done

subsubsection \<open>Inversion Tactics\<close>

lemma refinement_trans_long:
  \<open>A = A' \<Longrightarrow> B = B' \<Longrightarrow> R \<subseteq> R' \<Longrightarrow> A \<le> \<Down> R B \<Longrightarrow> A' \<le> \<Down> R' B'\<close>
  by (meson pw_ref_iff subsetCE)

lemma mem_set_trans:
  \<open>A \<subseteq> B \<Longrightarrow> a \<in> A \<Longrightarrow> a \<in> B\<close>
  by auto

lemma fun_rel_syn_invert:
  \<open>a = a' \<Longrightarrow> b \<subseteq> b' \<Longrightarrow> a \<rightarrow> b \<subseteq> a' \<rightarrow> b'\<close>
  by (auto simp: refine_rel_defs)

lemma nres_rel_mono:
  \<open>a \<subseteq> a'  \<Longrightarrow> \<langle>a\<rangle> nres_rel \<subseteq> \<langle>a'\<rangle> nres_rel\<close>
  by (fastforce simp: refine_rel_defs nres_rel_def pw_ref_iff)

method match_spec =
  (match conclusion in \<open>(f, g) \<in> R\<close> for f g R \<Rightarrow>
    \<open>print_term f; match premises in I[thin]: \<open>(f, g) \<in> R'\<close> for R'
       \<Rightarrow> \<open>print_term R'; rule mem_set_trans[OF _ I]\<close>\<close>)

method match_fun_rel =
  ((match conclusion in
       \<open>_ \<rightarrow> _ \<subseteq> _ \<rightarrow> _\<close> \<Rightarrow> \<open>rule fun_rel_mono\<close>
     \<bar> \<open>\<langle>_\<rangle>nres_rel \<subseteq> \<langle>_\<rangle>nres_rel\<close> \<Rightarrow> \<open>rule nres_rel_mono\<close>
     \<bar> \<open>[_]\<^sub>f _ \<rightarrow> _ \<subseteq> [_]\<^sub>f _ \<rightarrow> _\<close> \<Rightarrow> \<open>rule fref_mono\<close>
   )+)

lemma weaken_SPEC2: \<open>m' \<le> SPEC \<Phi> \<Longrightarrow> m = m' \<Longrightarrow> (\<And>x. \<Phi> x \<Longrightarrow> \<Psi> x) \<Longrightarrow> m \<le> SPEC \<Psi>\<close>
  using weaken_SPEC by auto

method match_spec_trans =
  (match conclusion in \<open>f \<le> SPEC R\<close> for f :: \<open>'a nres\<close> and R :: \<open>'a \<Rightarrow> bool\<close> \<Rightarrow>
    \<open>print_term f; match premises in I: \<open>_ \<Longrightarrow> _ \<Longrightarrow> f' \<le> SPEC R'\<close> for f' :: \<open>'a nres\<close> and R' :: \<open>'a \<Rightarrow> bool\<close>
       \<Rightarrow> \<open>print_term f'; rule weaken_SPEC2[of f' R' f R]\<close>\<close>)

subsection \<open>More Notations\<close>

abbreviation comp4 (infixl "oooo" 55) where "f oooo g \<equiv> \<lambda>x. f ooo (g x)"
abbreviation comp5 (infixl "ooooo" 55) where "f ooooo g \<equiv> \<lambda>x. f oooo (g x)"
abbreviation comp6 (infixl "oooooo" 55) where "f oooooo g \<equiv> \<lambda>x. f oooo (g x)"
abbreviation comp7 (infixl "ooooooo" 55) where "f ooooooo g \<equiv> \<lambda>x. f oooo (g x)"
abbreviation comp8 (infixl "oooooooo" 55) where "f oooooooo g \<equiv> \<lambda>x. f oooo (g x)"

notation
  comp4 (infixl "\<circ>\<circ>\<circ>" 55) and
  comp5 (infixl "\<circ>\<circ>\<circ>\<circ>" 55) and
  comp6 (infixl "\<circ>\<circ>\<circ>\<circ>\<circ>" 55) and
  comp7 (infixl "\<circ>\<circ>\<circ>\<circ>\<circ>\<circ>" 55) and
  comp8 (infixl "\<circ>\<circ>\<circ>\<circ>\<circ>\<circ>\<circ>" 55)

notation prod_assn (infixr "*a" 90)


subsection \<open>More Theorems for Refinement\<close>


lemma SPEC_add_information: \<open>P \<Longrightarrow> A \<le> SPEC Q \<Longrightarrow> A \<le> SPEC(\<lambda>x. Q x \<and> P)\<close>
  by auto

lemma bind_refine_spec: \<open>(\<And>x. \<Phi> x \<Longrightarrow> f x \<le> \<Down> R M) \<Longrightarrow> M' \<le> SPEC \<Phi> \<Longrightarrow> M' \<bind> f \<le> \<Down> R M\<close>
  by (auto simp add: pw_le_iff refine_pw_simps)

lemma case_prod_bind:
  assumes \<open>\<And>x1 x2. x = (x1, x2) \<Longrightarrow> f x1 x2 \<le> \<Down> R I\<close>
  shows \<open>(case x of (x1, x2) \<Rightarrow> f x1 x2) \<le> \<Down> R I\<close>
  using assms by (cases x) auto


lemma (in transfer) transfer_bool[refine_transfer]:
  assumes "\<alpha> fa \<le> Fa"
  assumes "\<alpha> fb \<le> Fb"
  shows "\<alpha> (case_bool fa fb x) \<le> case_bool Fa Fb x"
  using assms by (auto split: bool.split)

lemma hrp_comp_Id2[simp]: \<open>hrp_comp A Id = A\<close>
  unfolding hrp_comp_def by auto

lemma hn_ctxt_prod_assn_prod:
  \<open>hn_ctxt (prod_assn R S) (a, b) (a', b') = hn_ctxt R a a' * hn_ctxt S b b'\<close>
  unfolding hn_ctxt_def
  by auto

lemma list_assn_map_list_assn: \<open>list_assn g (map f x) xi = list_assn (\<lambda>a c. g (f a) c) x xi\<close>
  apply (induction x arbitrary: xi)
  subgoal by auto
  subgoal for a x xi
    by (cases xi) auto
  done

lemma RES_RETURN_RES: \<open>RES \<Phi> \<bind> (\<lambda>T. RETURN (f T)) = RES (f ` \<Phi>)\<close>
  by (simp add: bind_RES_RETURN_eq setcompr_eq_image)

lemma bind_refine_res: \<open>(\<And>x. x \<in> \<Phi> \<Longrightarrow> f x \<le> \<Down> R M) \<Longrightarrow> M' \<le> RES \<Phi> \<Longrightarrow> M' \<bind> f \<le> \<Down> R M\<close>
  by (auto simp add: pw_le_iff refine_pw_simps)

lemma RECT_WHILEI_body_add_post_condition:
    \<open>REC\<^sub>T (WHILEI_body op \<bind> RETURN I' b' f) x' =
     (REC\<^sub>T (WHILEI_body op \<bind> RETURN (\<lambda>x'. I' x' \<and> (b' x' \<longrightarrow> f x' = FAIL \<or> f x' \<le> SPEC I')) b' f) x')\<close>
  (is \<open>REC\<^sub>T ?f x' = REC\<^sub>T ?f' x'\<close>)
proof -
  have le: \<open>flatf_gfp ?f x' \<le> flatf_gfp ?f' x'\<close> for x'
  proof (induct arbitrary: x' rule: flatf_ord.fixp_induct[where b = top and
        f = ?f'])
    case 1
    then show ?case
      unfolding fun_lub_def pw_le_iff
      by (rule ccpo.admissibleI)
        (smt chain_fun flat_lub_in_chain mem_Collect_eq nofail_simps(1))
  next
    case 2
    then show ?case by (auto simp: WHILEI_mono_ge)
  next
    case 3
    then show ?case by simp
  next
    case (4 x)
    have  \<open>(RES X \<bind> f \<le> M) = (\<forall>x\<in>X. f x \<le> M)\<close> for x f M X
      using intro_spec_refine_iff[of _ _ \<open>Id\<close>] by auto
    thm bind_refine_RES(2)[of _ Id, simplified]
    have [simp]: \<open>flatf_mono FAIL (WHILEI_body op \<bind> RETURN I' b' f)\<close>
      by (simp add: WHILEI_mono_ge)

    have \<open>flatf_gfp ?f x' = ?f (?f (flatf_gfp ?f)) x'\<close>
      apply (subst flatf_ord.fixp_unfold)
       apply (solves \<open>simp\<close>)
      apply (subst flatf_ord.fixp_unfold)
       apply (solves \<open>simp\<close>)
      ..
    also have \<open>\<dots> = WHILEI_body op \<bind> RETURN (\<lambda>x'. I' x' \<and> (b' x' \<longrightarrow> f x' = FAIL \<or> f x' \<le> SPEC I')) b' f (WHILEI_body op \<bind> RETURN I' b' f (flatf_gfp (WHILEI_body op \<bind> RETURN I' b' f))) x'\<close>
      apply (subst (1) WHILEI_body_def, subst (1) WHILEI_body_def)
      apply (subst (2) WHILEI_body_def, subst (2) WHILEI_body_def)
      apply simp_all
      apply (cases \<open>f x'\<close>)
       apply (auto simp: RES_RETURN_RES nofail_def[symmetric] pw_RES_bind_choose
           intro!: (* bind_refine_RES(2)[of , simplified]  *)
          split: if_splits
          cong: if_cong)
      done
    also have \<open>\<dots> =  WHILEI_body op \<bind> RETURN (\<lambda>x'. I' x' \<and> (b' x' \<longrightarrow> f x' = FAIL \<or> f x' \<le> SPEC I')) b' f ((flatf_gfp (WHILEI_body op \<bind> RETURN I' b' f))) x'\<close>
      apply (subst (2) flatf_ord.fixp_unfold)
       apply (solves \<open>simp\<close>)
      ..
    finally have unfold1: \<open>flatf_gfp (WHILEI_body op \<bind> RETURN I' b' f) x' =
         ?f' (flatf_gfp (WHILEI_body op \<bind> RETURN I' b' f)) x'\<close>
      .
    have [intro!]: \<open>(\<And>x. g x \<le>(h:: 'a \<Rightarrow> 'a nres) x) \<Longrightarrow> fx \<bind> g \<le> fx \<bind> h\<close> for g h fx fy
      by (refine_rcg bind_refine'[where R = \<open>Id\<close>, simplified]) fast
    show ?case
      apply (subst unfold1)
      using 4 unfolding WHILEI_body_def by auto
  qed

  have ge: \<open>flatf_gfp ?f x' \<ge>  flatf_gfp ?f' x'\<close> for x'
  proof (induct arbitrary: x' rule: flatf_ord.fixp_induct[where b = top and
        f = ?f])
    case 1
    then show ?case
      unfolding fun_lub_def pw_le_iff
      by (rule ccpo.admissibleI) (smt chain_fun flat_lub_in_chain mem_Collect_eq nofail_simps(1))
  next
    case 2
    then show ?case by (auto simp: WHILEI_mono_ge)
  next
    case 3
    then show ?case by simp
  next
    case (4 x)
    have  \<open>(RES X \<bind> f \<le> M) = (\<forall>x\<in>X. f x \<le> M)\<close> for x f M X
      using intro_spec_refine_iff[of _ _ \<open>Id\<close>] by auto
    thm bind_refine_RES(2)[of _ Id, simplified]
    have [simp]: \<open>flatf_mono FAIL ?f'\<close>
      by (simp add: WHILEI_mono_ge)
    have H: \<open>A = FAIL \<longleftrightarrow> \<not>nofail A\<close> for A by (auto simp: nofail_def)
    have \<open>flatf_gfp ?f' x' = ?f' (?f' (flatf_gfp ?f')) x'\<close>
      apply (subst flatf_ord.fixp_unfold)
       apply (solves \<open>simp\<close>)
      apply (subst flatf_ord.fixp_unfold)
       apply (solves \<open>simp\<close>)
      ..
    also have \<open>\<dots> = ?f (?f' (flatf_gfp ?f')) x'\<close>
      apply (subst (1) WHILEI_body_def, subst (1) WHILEI_body_def)
      apply (subst (2) WHILEI_body_def, subst (2) WHILEI_body_def)
      apply simp_all
      apply (cases \<open>f x'\<close>)
       apply (auto simp: RES_RETURN_RES nofail_def[symmetric] pw_RES_bind_choose
          eq_commute[of \<open>FAIL\<close>] H
          split: if_splits
          cong: if_cong)
      done
    also have \<open>\<dots> = ?f (flatf_gfp ?f') x'\<close>
      apply (subst (2) flatf_ord.fixp_unfold)
       apply (solves \<open>simp\<close>)
      ..
    finally have unfold1: \<open>flatf_gfp ?f' x' =
         ?f (flatf_gfp ?f') x'\<close>
      .
    have [intro!]: \<open>(\<And>x. g x \<le>(h:: 'a \<Rightarrow> 'a nres) x) \<Longrightarrow> fx \<bind> g \<le> fx \<bind> h\<close> for g h fx fy
      by (refine_rcg bind_refine'[where R = \<open>Id\<close>, simplified]) fast
    show ?case
      apply (subst unfold1)
      using 4
      unfolding WHILEI_body_def
      by (auto intro: bind_refine'[where R = \<open>Id\<close>, simplified])
  qed
  show ?thesis
    unfolding RECT_def
    using le[of x'] ge[of x'] by (auto simp: WHILEI_body_trimono)
qed

lemma WHILEIT_add_post_condition: \<open>(WHILEIT I' b' f' x') = (WHILEIT (\<lambda>x'. I' x' \<and> (b' x' \<longrightarrow> f' x' = FAIL \<or> f' x' \<le> SPEC I')) b' f' x')\<close>
  unfolding WHILEIT_def
  apply (subst RECT_WHILEI_body_add_post_condition)
  ..

lemma WHILEIT_rule_stronger_inv:
  assumes
    \<open>wf R\<close> and
    \<open>I s\<close> and
    \<open>I' s\<close>
    \<open>\<And>s. I s \<Longrightarrow> I' s \<Longrightarrow> b s \<Longrightarrow> f s \<le> SPEC (\<lambda>s'. I s' \<and>  I' s' \<and> (s', s) \<in> R)\<close> and
   \<open>\<And>s. I s \<Longrightarrow> I' s \<Longrightarrow> \<not> b s \<Longrightarrow> \<Phi> s\<close>
 shows \<open>WHILE\<^sub>T\<^bsup>I\<^esup> b f s \<le> SPEC \<Phi>\<close>
proof -
  have \<open>WHILE\<^sub>T\<^bsup>I\<^esup> b f s \<le> WHILE\<^sub>T\<^bsup>\<lambda>s. I s \<and> I' s\<^esup> b f s\<close>
    by (metis (mono_tags, lifting) WHILEIT_weaken)
  also have \<open>WHILE\<^sub>T\<^bsup>\<lambda>s. I s \<and> I' s\<^esup> b f s \<le> SPEC \<Phi>\<close>
    by (rule WHILEIT_rule) (use assms in \<open>auto simp: \<close>)
  finally show ?thesis .
qed

lemma RES_RETURN_RES2:
   \<open>SPEC \<Phi> \<bind> (\<lambda>(T, T'). RETURN (f T T')) = RES (uncurry f ` {T. \<Phi> T})\<close>
  using RES_RETURN_RES[of \<open>Collect \<Phi>\<close> \<open>uncurry f\<close>]
  apply (subst (asm)(2) split_prod_bound)
  by auto

text \<open>
  This theorem is useful to debug situation where sepref is not able to synthesize a program (with
  the ``[[unify\_trace\_failure]]'' for rule and the \<^text>\<open>to_hnr\<close>).
\<close>
lemma Pair_hnr: \<open>(uncurry (return oo (\<lambda>a b. Pair a b)), uncurry (RETURN oo (\<lambda>a b. Pair a b))) \<in>
    A\<^sup>d *\<^sub>a B\<^sup>d \<rightarrow>\<^sub>a prod_assn A B\<close>
  by sepref_to_hoare sep_auto


subsubsection \<open>More Simplification Theorems\<close>

lemma ex_assn_swap: \<open>(\<exists>\<^sub>Aa b. P a b) = (\<exists>\<^sub>Ab a. P a b)\<close>
  by (meson ent_ex_postI ent_ex_preI ent_iffI ent_refl)

lemma ent_ex_up_swap: \<open>(\<exists>\<^sub>Aaa. \<up> (P aa)) = (\<up>(\<exists>aa. P aa))\<close>
  by (smt ent_ex_postI ent_ex_preI ent_iffI ent_pure_pre_iff ent_refl mult.left_neutral)

lemma ex_assn_def_pure_eq_middle3:
  \<open>(\<exists>\<^sub>Aba b bb. f b ba bb * \<up> (ba = h b bb) * P b ba bb) = (\<exists>\<^sub>Ab bb. f b (h b bb) bb * P b (h b bb) bb)\<close>
  \<open>(\<exists>\<^sub>Ab ba bb. f b ba bb * \<up> (ba = h b bb) * P b ba bb) = (\<exists>\<^sub>Ab bb. f b (h b bb) bb * P b (h b bb) bb)\<close>
  \<open>(\<exists>\<^sub>Ab bb ba. f b ba bb * \<up> (ba = h b bb) * P b ba bb) = (\<exists>\<^sub>Ab bb. f b (h b bb) bb * P b (h b bb) bb)\<close>
  \<open>(\<exists>\<^sub>Aba b bb. f b ba bb * \<up> (ba = h b bb \<and> Q b ba bb)) = (\<exists>\<^sub>Ab bb. f b (h b bb) bb * \<up>(Q b (h b bb) bb))\<close>
  \<open>(\<exists>\<^sub>Ab ba bb. f b ba bb * \<up> (ba = h b bb \<and> Q b ba bb)) = (\<exists>\<^sub>Ab bb. f b (h b bb) bb * \<up>(Q b (h b bb) bb))\<close>
  \<open>(\<exists>\<^sub>Ab bb ba. f b ba bb * \<up> (ba = h b bb \<and> Q b ba bb)) = (\<exists>\<^sub>Ab bb. f b (h b bb) bb * \<up>(Q b (h b bb) bb))\<close>
  by (subst ex_assn_def, subst (3) ex_assn_def, auto)+

lemma ex_assn_def_pure_eq_middle2:
  \<open>(\<exists>\<^sub>Aba b. f b ba * \<up> (ba = h b) * P b ba) = (\<exists>\<^sub>Ab . f b (h b) * P b (h b))\<close>
  \<open>(\<exists>\<^sub>Ab ba. f b ba * \<up> (ba = h b) * P b ba) = (\<exists>\<^sub>Ab . f b (h b) * P b (h b))\<close>
  \<open>(\<exists>\<^sub>Ab ba. f b ba * \<up> (ba = h b \<and> Q b ba)) = (\<exists>\<^sub>Ab. f b (h b) * \<up>(Q b (h b)))\<close>
  \<open>(\<exists>\<^sub>A ba b. f b ba * \<up> (ba = h b \<and> Q b ba)) = (\<exists>\<^sub>Ab. f b (h b) * \<up>(Q b (h b)))\<close>
  by (subst ex_assn_def, subst (2) ex_assn_def, auto)+

lemma ex_assn_skip_first2:
  \<open>(\<exists>\<^sub>Aba bb. f bb * \<up>(P ba bb)) = (\<exists>\<^sub>Abb. f bb * \<up>(\<exists>ba. P ba bb))\<close>
  \<open>(\<exists>\<^sub>Abb ba. f bb * \<up>(P ba bb)) = (\<exists>\<^sub>Abb. f bb * \<up>(\<exists>ba. P ba bb))\<close>
  apply (subst ex_assn_swap)
  by (subst ex_assn_def, subst (2) ex_assn_def, auto)+

lemma nofail_Down_nofail: \<open>nofail gS \<Longrightarrow> fS \<le> \<Down> R gS \<Longrightarrow> nofail fS\<close>
  using pw_ref_iff by blast


subsection \<open>Some Refinement\<close>

lemma fr_refl': \<open>A \<Longrightarrow>\<^sub>A B \<Longrightarrow> C * A \<Longrightarrow>\<^sub>A C * B\<close>
  unfolding assn_times_comm[of C]
  by (rule Automation.fr_refl)

lemma Collect_eq_comp: \<open>{(c, a). a = f c} O {(x, y). P x y} = {(c, y). P (f c) y}\<close>
  by auto

lemma Collect_eq_comp_right:
  \<open>{(x, y). P x y} O {(c, a). a = f c} = {(x, c). \<exists>y. P x y \<and> c = f y} \<close>
  by auto

lemma
  shows list_mset_assn_add_mset_Nil:
     \<open>list_mset_assn R (add_mset q Q) [] = false\<close> and
   list_mset_assn_empty_Cons:
    \<open>list_mset_assn R {#} (x # xs) = false\<close>
  unfolding list_mset_assn_def list_mset_rel_def mset_rel_def pure_def p2rel_def
    rel2p_def rel_mset_def br_def
  by (sep_auto simp: Collect_eq_comp)+


lemma list_mset_assn_add_mset_cons_in:
  assumes
    assn: \<open>A \<Turnstile> list_mset_assn R N (ab # list)\<close>
  shows \<open>\<exists>ab'. (ab, ab') \<in> the_pure R \<and> ab' \<in># N \<and> A \<Turnstile> list_mset_assn R (remove1_mset ab' N) (list)\<close>
proof -
  have H: \<open>(\<forall>x x'. (x' = x) = ((x', x) \<in> P')) \<longleftrightarrow> P' = Id\<close> for P'
    by (auto simp: the_pure_def)
  have [simp]: \<open>the_pure (\<lambda>a c. \<up> (c = a)) = Id\<close>
    by (auto simp: the_pure_def H)
  have [iff]: \<open>(ab # list, y) \<in> list_mset_rel \<longleftrightarrow> y = add_mset ab (mset list)\<close> for y ab list
    by (auto simp: list_mset_rel_def br_def)
  obtain N' xs where
    N_N': \<open>N = mset N'\<close> and
    \<open>mset xs = add_mset ab (mset list)\<close> and
    \<open>list_all2 (rel2p (the_pure R)) xs N'\<close>
    using assn by (cases A) (auto simp: list_mset_assn_def mset_rel_def p2rel_def rel_mset_def
        rel2p_def)
  then obtain N'' where
    \<open>list_all2 (rel2p (the_pure R)) (ab # list) N''\<close> and
    \<open>mset N'' = mset N'\<close>
    using list_all2_reorder_left_invariance[of \<open>rel2p (the_pure R)\<close> xs N'
          \<open>ab # list\<close>, unfolded eq_commute[of \<open>mset (ab # list)\<close>]] by auto
  then obtain n N''' where
    n: \<open>add_mset n (mset N''') = mset N''\<close> and
    \<open>(ab, n) \<in> the_pure R\<close> and
    \<open>list_all2 (rel2p (the_pure R)) list N'''\<close>
    by (auto simp: list_all2_Cons1 rel2p_def)
  moreover have \<open>n \<in> set N''\<close>
    using n unfolding mset.simps[symmetric] eq_commute[of \<open>add_mset _ _\<close>] apply -
    by (drule mset_eq_setD) auto
  ultimately have \<open>(ab, n) \<in> the_pure R\<close> and
    \<open>n \<in> set N''\<close> and
    \<open>mset list = mset list\<close> and
    \<open>mset N''' = remove1_mset n (mset N'')\<close> and
    \<open>list_all2 (rel2p (the_pure R)) list N'''\<close>
    by (auto dest: mset_eq_setD simp: eq_commute[of \<open>add_mset _ _\<close>])
  show ?thesis -- \<open>TODO tune proof\<close>
    unfolding list_mset_assn_def mset_rel_def p2rel_def rel_mset_def
      list.rel_eq list_mset_rel_def
      br_def
    apply (simp add: Collect_eq_comp n[symmetric] N_N')
    using assn
    apply (cases A)
    apply (auto simp: list_mset_assn_def mset_rel_def p2rel_def rel_mset_def
        add_mset_eq_add_mset list.rel_eq)
    apply (drule list_all2_reorder_left_invariance[of \<open>rel2p (the_pure R)\<close> _ _
          \<open>ab # list\<close>, unfolded eq_commute[of \<open>mset (ab # list)\<close>]])
     apply simp
    apply (auto simp: list_all2_Cons1 list_mset_rel_def br_def Collect_eq_comp
        dest: mset_eq_setD)
    by (metis \<open>(ab, n) \<in> the_pure R\<close> \<open>list_all2 (rel2p (the_pure R)) list N'''\<close>
        \<open>mset N'' = mset N'\<close> \<open>mset N''' = remove1_mset n (mset N'')\<close> \<open>n \<in> set N''\<close> set_mset_mset)
qed

lemma list_mset_assn_empty_nil: \<open>list_mset_assn R {#} [] = emp\<close>
  by (auto simp: list_mset_assn_def list_mset_rel_def mset_rel_def
      br_def p2rel_def rel2p_def Collect_eq_comp rel_mset_def
      pure_def)

lemma no_fail_spec_le_RETURN_itself: \<open>nofail f \<Longrightarrow> f \<le> SPEC(\<lambda>x. RETURN x \<le> f)\<close>
  by (metis RES_rule nres_order_simps(21) the_RES_inv)

text \<open>
  This theorems links two forms:
  \<^item> the form where access is done via \<^term>\<open>nth\<close>. This form is useful for refinement towards
  arrays.
  \<^item> the form where access is done via recursion over lists. This form is useful to prove properties
  via induction: this is the target of a first refinement.
\<close>
lemma WHILE\<^sub>T_nth_WHILE\<^sub>T_list:
  \<open>WHILE\<^sub>T\<^bsup>\<lambda>(brk, i). P (nths xs {i..<length xs}) \<and> i \<le> length xs\<^esup>
     (\<lambda>(brk, i). \<not>brk \<and> i < length xs)
     (\<lambda>(brk, i).
        do {
          ASSERT (i < length xs);
          RETURN (f (xs!i), i+1)
        })
     (False, 0)
   \<le> \<Down> {((b', i), (b, ys)). b' = b \<and> ys = nths xs {i..<length xs} \<and> i \<le> length xs}
    (WHILE\<^sub>T\<^bsup>\<lambda>(brk, ys). P ys\<^esup>
      (\<lambda>(brk, ys). \<not>brk \<and> ys \<noteq> [])
      (\<lambda>(brk, ys). RETURN (f (hd ys), tl ys))
      (False, xs))
     \<close>
  apply (refine_vcg)
  subgoal by (simp add: atLeast0LessThan)
  subgoal by auto
  subgoal by auto
  subgoal by (auto simp: nths_empty_iff)
  subgoal by (auto simp: nths_upt_Suc)
  subgoal by (auto simp: nths_upt_Suc)
  done

lemma op_list_contains:
  \<open>(WHILE\<^sub>T\<^bsup>\<lambda>(brk, ys). True\<^esup>
      (\<lambda>(brk, ys). \<not>brk \<and> ys \<noteq> [])
      (\<lambda>(brk, ys). RETURN (l = hd ys, tl ys))
      (False, xs))
   \<le> \<Down> (Collect (case_prod (\<lambda>(b', ys). op = b'))) (RETURN (l \<in> set xs))\<close>
  (is \<open>WHILE\<^sub>T\<^bsup>?pre\<^esup> ?stop ?body ?init \<le> \<Down> ?inv _\<close>)
proof -
  define inv pre where \<open>inv \<equiv> ?inv\<close> and \<open>pre = ?pre\<close>

  have [simp]: \<open>pre (False, a # xs)\<close> for a xs
    unfolding pre_def by auto
  show ?thesis
    unfolding inv_def[symmetric] pre_def[symmetric]
    apply (induction xs)
    subgoal by (subst WHILEIT_unfold) (simp add: inv_def pre_def)
    subgoal premises IH for a xs
      apply (cases \<open>l = a\<close>)
      subgoal by (solves \<open>simp add: WHILEIT_unfold inv_def pre_def\<close>)
      subgoal apply (subst WHILEIT_unfold)
        using IH[unfolded pre_def[symmetric] inv_def[symmetric]]
        by simp
      done
    done
qed

definition list_contains_WHILE where
  \<open>list_contains_WHILE l xs =
     WHILE\<^sub>T\<^bsup>\<lambda>(brk, i). True \<and> i \<le> length xs\<^esup>
       (\<lambda>(brk, i). \<not> brk \<and> i < length xs)
       (\<lambda>(brk, i).
         ASSERT (i < length xs) \<bind>
         (\<lambda>_. RETURN (l = xs ! i, i + 1)))
       (False, 0)\<close>

lemma \<open>list_contains_WHILE l xs \<le>
      \<Down> ({((b', i), b, ys). b' = b \<and>  ys = nths xs {i..<length xs} \<and> i \<le> length xs} O
          Collect (case_prod (\<lambda>(b', ys). op = b')))
        (RETURN (l \<in> set xs))\<close>
  (is \<open>_ \<le> \<Down> ?A _\<close>)
proof -
  show \<open>list_contains_WHILE l xs \<le>
      \<Down> ({((b', i), b, ys). b' = b \<and>  ys = nths xs {i..<length xs} \<and> i \<le> length xs} O
          Collect (case_prod (\<lambda>(b', ys). op = b')))
        (RETURN (l \<in> set xs))\<close>
    (is \<open>_ \<le> \<Down> ?B _\<close>)
    unfolding list_contains_WHILE_def op_list_contains_def
    using ref_two_step[OF WHILE\<^sub>T_nth_WHILE\<^sub>T_list[of \<open>\<lambda>_. True\<close> xs \<open>op = l\<close>]
        op_list_contains, unfolded conc_fun_chain]
    by simp
qed

sepref_thm list_contains_WHILE
  is \<open>uncurry (\<lambda>(l::nat) xs. do{ b \<leftarrow> list_contains_WHILE l xs; RETURN (fst b)})\<close>
  :: \<open>nat_assn\<^sup>k *\<^sub>a (array_assn id_assn)\<^sup>k \<rightarrow>\<^sub>a bool_assn\<close>
  unfolding list_contains_WHILE_def
  by sepref

lemma union_mset_list_Nil[simp]: \<open>union_mset_list [] bi = bi\<close>
  by (auto simp: union_mset_list_def)
declare union_mset_list_def[code]

text \<open>A more general theorem is \<^emph>\<open>very\<close> hard to write (if it is possible at all).\<close>
lemma union_mset_list_op_union: \<open>(uncurry (RETURN oo union_mset_list), uncurry (RETURN oo op \<union>#)) \<in>
  (list_mset_rel O \<langle>Id\<rangle>mset_rel) \<times>\<^sub>r (list_mset_rel O \<langle>Id\<rangle>mset_rel) \<rightarrow>\<^sub>f
    \<langle>list_mset_rel O \<langle>Id\<rangle>mset_rel\<rangle>nres_rel\<close>
  by (auto simp: list_mset_rel_def fref_def
      br_def mset_rel_def Collect_eq_comp rel_mset_def p2rel_def nres_rel_def
      rel2p_def[abs_def] union_mset_list[symmetric] list.rel_eq ex_mset)

lemma union_mset_list_union_mset_list: \<open>(uncurry (return oo union_mset_list), uncurry (RETURN oo union_mset_list)) \<in>
   id_assn\<^sup>k *\<^sub>a id_assn\<^sup>k \<rightarrow>\<^sub>a id_assn\<close>
  by sepref_to_hoare sep_auto

lemma union_mset_list_op_union_hnr[sepref_fr_rules]:
  \<open>(uncurry (return \<circ>\<circ> union_mset_list), uncurry (RETURN \<circ>\<circ> op \<union>#))
  \<in> (list_mset_assn id_assn)\<^sup>k *\<^sub>a (list_mset_assn id_assn)\<^sup>k \<rightarrow>\<^sub>a list_mset_assn id_assn\<close>
proof -
  have I: \<open>\<langle>Id\<rangle>mset_rel = \<langle>the_pure id_assn\<rangle>mset_rel\<close>
    by auto
  show ?thesis
    using union_mset_list_union_mset_list[FCOMP union_mset_list_op_union,
        unfolded list_mset_assn_def[symmetric] I] .
qed

lemma refine_add_invariants':
  assumes
    \<open>f S \<le> \<Down> {(S, S'). Q' S S' \<and> Q S} gS\<close> and
    \<open>y \<le> \<Down> {((i, S), S'). P i S S'} (f S)\<close> and
    \<open>nofail gS\<close>
  shows \<open>y \<le> \<Down> {((i, S), S'). P i S S' \<and> Q S'} (f S)\<close>
  using assms unfolding pw_le_iff pw_conc_inres pw_conc_nofail
  by force

lemma "weaken_\<Down>": \<open>R' \<subseteq> R \<Longrightarrow> f \<le> \<Down> R' g \<Longrightarrow> f \<le> \<Down> R g\<close>
  by (meson pw_ref_iff subset_eq)

method match_Down =
  (match conclusion in \<open>f \<le> \<Down> R g\<close> for f g R \<Rightarrow>
    \<open>match premises in I: \<open>f \<le> \<Down> R' g\<close> for R'
       \<Rightarrow> \<open>rule "weaken_\<Down>"[OF _ I]\<close>\<close>)


lemma refine_SPEC_refine_Down:
  \<open>f \<le> SPEC C \<longleftrightarrow> f \<le> \<Down> {(T', T). T = T' \<and> C T'} (SPEC C)\<close>
  apply (rule iffI)
  subgoal
    by (rule SPEC_refine)  auto
  subgoal
    by (metis (no_types, lifting) RETURN_ref_SPECD SPEC_cons_rule dual_order.trans
        in_pair_collect_simp no_fail_spec_le_RETURN_itself nofail_Down_nofail nofail_simps(2))
  done



subsection \<open>More declarations\<close>

(* TODO: only input notation? *)
notation prod_rel_syn (infixl "\<times>\<^sub>f" 70)

lemma is_Nil_is_empty[sepref_fr_rules]:
  \<open>(return o is_Nil, RETURN o Multiset.is_empty) \<in> (list_mset_assn R)\<^sup>k \<rightarrow>\<^sub>a bool_assn\<close>
  apply sepref_to_hoare
  apply (rename_tac x xi)
    apply (case_tac x)
   by (sep_auto simp: Multiset.is_empty_def list_mset_assn_empty_Cons list_mset_assn_add_mset_Nil
      split: list.splits)+

lemma diff_add_mset_remove1: \<open>NO_MATCH {#} N \<Longrightarrow> M - add_mset a N = remove1_mset a (M - N)\<close>
  by auto

lemma list_all2_remove:
  assumes
    uniq: \<open>IS_RIGHT_UNIQUE (p2rel R)\<close> \<open>IS_LEFT_UNIQUE (p2rel R)\<close> and
    Ra: \<open>R a aa\<close> and
    all: \<open>list_all2 R xs ys\<close>
  shows
  \<open>\<exists>xs'. mset xs' = remove1_mset a (mset xs) \<and>
            (\<exists>ys'. mset ys' = remove1_mset aa (mset ys) \<and> list_all2 R xs' ys')\<close>
  using all
proof (induction xs ys rule: list_all2_induct)
  case Nil
  then show ?case by auto
next
  case (Cons x y xs ys) note IH = this(3) and p = this(1, 2)

  have ax: \<open>{#a, x#} = {#x, a#}\<close>
    by auto
  have rem1: \<open>remove1_mset a (remove1_mset x M) = remove1_mset x (remove1_mset a M)\<close> for M
    by (auto simp: ax)
  have H: \<open>x = a \<longleftrightarrow> y = aa\<close>
    using uniq Ra p unfolding single_valued_def IS_LEFT_UNIQUE_def p2rel_def by blast

  obtain xs' ys' where
   \<open>mset xs' = remove1_mset a (mset xs)\<close> and
   \<open>mset ys' = remove1_mset aa (mset ys)\<close> and
   \<open>list_all2 R xs' ys'\<close>
   using IH p by auto
  then show ?case
   apply (cases \<open>x \<noteq> a\<close>)
   subgoal
     using p
     by (auto intro!: exI[of _ \<open>x#xs'\<close>] exI[of _ \<open>y#ys'\<close>]
         simp: diff_add_mset_remove1 rem1 add_mset_remove_trivial_If in_remove1_mset_neq H
         simp del: diff_diff_add_mset)
   subgoal
     using p
     by (fastforce simp: diff_add_mset_remove1 rem1 add_mset_remove_trivial_If in_remove1_mset_neq
         remove_1_mset_id_iff_notin H
         simp del: diff_diff_add_mset)
   done
qed

lemma remove1_remove1_mset:
  assumes uniq: \<open>IS_RIGHT_UNIQUE R\<close> \<open>IS_LEFT_UNIQUE R\<close>
  shows \<open>(uncurry (RETURN oo remove1), uncurry (RETURN oo remove1_mset)) \<in>
    R \<times>\<^sub>r (list_mset_rel O \<langle>R\<rangle> mset_rel) \<rightarrow>\<^sub>f
    \<langle>list_mset_rel O \<langle>R\<rangle> mset_rel\<rangle> nres_rel\<close>
  using list_all2_remove[of \<open>rel2p R\<close>] assms
  by (intro frefI nres_relI) (fastforce simp: list_mset_rel_def br_def mset_rel_def p2rel_def
      rel2p_def[abs_def] rel_mset_def Collect_eq_comp)

lemma
  Nil_list_mset_rel_iff:
    \<open>([], aaa) \<in> list_mset_rel \<longleftrightarrow> aaa = {#}\<close> and
  empty_list_mset_rel_iff:
    \<open>(a, {#}) \<in> list_mset_rel \<longleftrightarrow> a = []\<close>
  by (auto simp: list_mset_rel_def br_def)

lemma ex_assn_up_eq2: \<open>(\<exists>\<^sub>Aba. f ba * \<up> (ba = c)) = (f c)\<close>
  by (simp add: ex_assn_def)

lemma list_rel_update:
  fixes R :: \<open>'a \<Rightarrow> 'b :: {heap}\<Rightarrow> assn\<close>
  assumes rel: \<open>(xs, ys) \<in> \<langle>the_pure R\<rangle>list_rel\<close> and
   h: \<open>h \<Turnstile> A * R b bi\<close> and
   p: \<open>is_pure R\<close>
  shows \<open>(list_update xs ba bi, list_update ys ba b) \<in> \<langle>the_pure R\<rangle>list_rel\<close>
proof -
  obtain R' where R: \<open>the_pure R = R'\<close> and R': \<open>R = pure R'\<close>
    using p by fastforce
  have [simp]: \<open>(bi, b) \<in> the_pure R\<close>
    using h p by (auto simp: mod_star_conv R R')
  have \<open>length xs = length ys\<close>
    using assms list_rel_imp_same_length by blast

  then show ?thesis
    using rel
    by (induction xs ys arbitrary: ba rule: list_induct2) (auto split: nat.splits)
qed


definition list_rel_mset_rel where list_rel_mset_rel_internal:
\<open>list_rel_mset_rel \<equiv> \<lambda>R. \<langle>R\<rangle>list_rel O list_mset_rel\<close>

lemma list_rel_mset_rel_def[refine_rel_defs]:
  \<open>\<langle>R\<rangle>list_rel_mset_rel = \<langle>R\<rangle>list_rel O list_mset_rel\<close>
  unfolding relAPP_def list_rel_mset_rel_internal ..

lemma list_mset_assn_pure_conv:
  \<open>list_mset_assn (pure R) = pure (list_rel_mset_rel R)\<close>
  apply (intro ext)
  using list_all2_reorder_left_invariance
  by (fastforce
    simp: list_rel_mset_rel_def list_mset_assn_def
      mset_rel_def rel2p_def[abs_def] rel_mset_def p2rel_def
      list_mset_rel_def[abs_def] Collect_eq_comp br_def
      list_rel_mset_rel_internal list_rel_def Collect_eq_comp_right
    intro!: arg_cong[of _ _ \<open>\<lambda>b. pure b _ _\<close>])

lemma ex_assn_pair_split: \<open>(\<exists>\<^sub>Ab. P b) = (\<exists>\<^sub>Aa b. P (a, b))\<close>
  by (subst ex_assn_def, subst (1) ex_assn_def, auto)+

lemma snd_hnr_pure:
   \<open>CONSTRAINT is_pure B \<Longrightarrow> (return \<circ> snd, RETURN \<circ> snd) \<in> (prod_assn A B)\<^sup>k \<rightarrow>\<^sub>a B\<close>
  apply sepref_to_hoare
  apply sep_auto
  by (metis SLN_def SLN_left assn_times_comm ent_pure_pre_iff_sng ent_refl ent_star_mono
      ent_true is_pure_assn_def is_pure_iff_pure_assn)

lemma (in -) list_assn_list_mset_rel_eq_list_mset_assn:
  assumes p: \<open>is_pure R\<close>
  shows \<open>hr_comp (list_assn R) list_mset_rel = list_mset_assn R\<close>
proof -
  define R' where \<open>R' = the_pure R\<close>
  then have R: \<open>R = pure R'\<close>
    using p by auto
  show ?thesis
    apply (auto simp: list_mset_assn_def
        list_assn_pure_conv
        relcomp.simps hr_comp_pure mset_rel_def br_def
        p2rel_def rel2p_def[abs_def] rel_mset_def R list_mset_rel_def list_rel_def)
      using list_all2_reorder_left_invariance by fastforce
  qed


subsection \<open>More Functions, Relations, and Theorems\<close>

lemma id_ref: \<open>(return o id, RETURN o id) \<in> R\<^sup>d \<rightarrow>\<^sub>a R\<close>
  by sepref_to_hoare sep_auto

definition emptied_list :: \<open>'a list \<Rightarrow> 'a list\<close> where
  \<open>emptied_list l = []\<close>

text \<open>This functions deletes all elements of a resizable array, without resizing it.\<close>
definition emptied_arl :: \<open>'a array_list \<Rightarrow> 'a array_list\<close> where
\<open>emptied_arl = (\<lambda>(a, n). (a, 0))\<close>

lemma emptied_arl_refine[sepref_fr_rules]:
  shows \<open>(return o emptied_arl, RETURN o emptied_list) \<in> (arl_assn R)\<^sup>d \<rightarrow>\<^sub>a arl_assn R\<close>
  unfolding emptied_arl_def emptied_list_def
  by sepref_to_hoare (sep_auto simp: arl_assn_def hr_comp_def is_array_list_def)

lemma bool_assn_alt_def: \<open>bool_assn a b = \<up> (a = b)\<close>
  unfolding pure_def by auto

lemma nempty_list_mset_rel_iff: \<open>M \<noteq> {#} \<Longrightarrow>
  (xs, M) \<in> list_mset_rel \<longleftrightarrow> (xs \<noteq> [] \<and> hd xs \<in># M \<and>
         (tl xs, remove1_mset (hd xs) M) \<in> list_mset_rel)\<close>
  by (cases xs) (auto simp: list_mset_rel_def br_def dest!: multi_member_split)

lemma Down_itself_via_SPEC:
  assumes \<open>I \<le> SPEC P\<close> and \<open>\<And>x. P x \<Longrightarrow> (x, x) \<in> R\<close>
  shows \<open>I \<le> \<Down> R I\<close>
  using assms by (meson inres_SPEC pw_ref_I)

lemma bind_if_inverse:
  \<open>do {
    S \<leftarrow> H;
    if b then f S else g S
    } =
    (if b then do {S \<leftarrow> H; f S} else do {S \<leftarrow> H; g S})
  \<close> for H :: \<open>'a nres\<close>
  by auto

lemma hfref_imp2: "(\<And>x y. S x y \<Longrightarrow>\<^sub>t S' x y) \<Longrightarrow> [P]\<^sub>a RR \<rightarrow> S \<subseteq> [P]\<^sub>a RR \<rightarrow> S'"
    apply clarsimp
    apply (erule hfref_cons)
    apply (simp_all add: hrp_imp_def)
    done

lemma hr_comp_mono_entails: \<open>B \<subseteq> C \<Longrightarrow> hr_comp a B x y \<Longrightarrow>\<^sub>A hr_comp a C x y\<close>
  unfolding hr_comp_def entails_def
  by auto

lemma hfref_imp_mono_result:
  "B \<subseteq> C \<Longrightarrow> [P]\<^sub>a RR \<rightarrow> hr_comp a B \<subseteq> [P]\<^sub>a RR \<rightarrow> hr_comp a C"
  unfolding hfref_def hn_refine_def
  apply clarify
  subgoal for aa b c aaa
    apply (rule cons_post_rule[of _ _
          \<open>\<lambda>r. snd RR aaa c * (\<exists>\<^sub>Ax. hr_comp a B x r * \<up> (RETURN x \<le> b aaa)) * true\<close>])
     apply (solves auto)
    using hr_comp_mono_entails[of B C a ]
    apply (auto intro!: ent_ex_preI)
    apply (rule_tac x=xa in ent_ex_postI)
    apply (auto intro!: ent_star_mono ac_simps)
    done
  done

lemma hfref_imp_mono_result2:
  "(\<And>x. P L x \<Longrightarrow> B L \<subseteq> C L) \<Longrightarrow> [P L]\<^sub>a RR \<rightarrow> hr_comp a (B L) \<subseteq> [P L]\<^sub>a RR \<rightarrow> hr_comp a (C L)"
  unfolding hfref_def hn_refine_def
  apply clarify
  subgoal for aa b c aaa
    apply (rule cons_post_rule[of _ _
          \<open>\<lambda>r. snd RR aaa c * (\<exists>\<^sub>Ax. hr_comp a (B L) x r * \<up> (RETURN x \<le> b aaa)) * true\<close>])
     apply (solves auto)
    using hr_comp_mono_entails[of \<open>B L\<close> \<open>C L\<close> a ]
    apply (auto intro!: ent_ex_preI)
    apply (rule_tac x=xa in ent_ex_postI)
    apply (auto intro!: ent_star_mono ac_simps)
    done
  done

lemma hfref_weaken_change_pre:
  assumes "(f,h) \<in> hfref P R S"
  assumes "\<And>x. P x \<Longrightarrow> (fst R x, snd R x) = (fst R' x, snd R' x)"
  assumes "\<And>y x. S y x \<Longrightarrow>\<^sub>t S' y x"
  shows "(f,h) \<in> hfref P R' S'"
proof -
  have \<open>(f,h) \<in> hfref P R' S\<close>
    using assms
    by (auto simp: hfref_def)
  then show ?thesis
    using hfref_imp2[of S S' P R'] assms(3) by auto
qed

lemma RES_RES_RETURN_RES: \<open>RES A \<bind> (\<lambda>T. RES (f T)) = RES (\<Union>(f ` A))\<close>
  by (auto simp:  pw_eq_iff refine_pw_simps)

lemma RES_RES2_RETURN_RES: \<open>RES A \<bind> (\<lambda>(T, T'). RES (f T T')) = RES (\<Union>(uncurry f ` A))\<close>
  by (auto simp:  pw_eq_iff refine_pw_simps uncurry_def)

subsection \<open>Sorting\<close>

text \<open>Remark that we do not \<^emph>\<open>prove\<close> that the sorting in correct, since we do not care about the
 correctness, only the fact that it is reordered. (Based on wikipedia's algorithm.)\<close>
definition insert_sort_inner :: \<open>('a list \<Rightarrow> nat \<Rightarrow> 'b :: ord) \<Rightarrow> 'a list \<Rightarrow>  nat \<Rightarrow> 'a list nres\<close> where
  \<open>insert_sort_inner f xs i = do {
     (j, ys) \<leftarrow> WHILE\<^sub>T\<^bsup>\<lambda>(j, ys). j \<ge> 0 \<and> mset xs = mset ys \<and> j < length ys\<^esup>
         (\<lambda>(j, ys). j > 0 \<and> f ys j > f ys i)
         (\<lambda>(j, ys). do {
             ASSERT(j < length ys);
             ASSERT(j > 0);
             ASSERT(j-1 < length ys);
             let xs = swap ys j (j - 1);
             RETURN (j-1, xs)
           }
         )
        (i, xs);
     RETURN ys
  }\<close>


definition reorder_remove :: \<open>'b \<Rightarrow> 'a list \<Rightarrow> 'a list nres\<close> where
\<open>reorder_remove _ removed = SPEC (\<lambda>removed'. mset removed' = mset removed)\<close>

definition insert_sort :: \<open>('a list \<Rightarrow> nat \<Rightarrow> 'b :: ord) \<Rightarrow> 'a list \<Rightarrow> 'a list nres\<close> where
  \<open>insert_sort f xs = do {
     (i, ys) \<leftarrow> WHILE\<^sub>T\<^bsup>\<lambda>(i, ys). (ys = [] \<or> i \<le> length ys) \<and> mset xs = mset ys\<^esup>
        (\<lambda>(i, ys). i < length ys)
        (\<lambda>(i, ys). do {
            ASSERT(i < length ys);
            ys \<leftarrow> insert_sort_inner f ys i;
            RETURN (i+1, ys)
          })
        (1, xs);
     RETURN ys
  }\<close>

lemma insert_sort_inner:
   \<open>(uncurry (insert_sort_inner f), uncurry (\<lambda>m m'. reorder_remove m' m)) \<in>
      [\<lambda>(xs, i). i < length xs]\<^sub>f \<langle>Id:: ('a \<times> 'a) set\<rangle>list_rel \<times>\<^sub>r nat_rel \<rightarrow> \<langle>Id\<rangle> nres_rel\<close>
  unfolding insert_sort_inner_def uncurry_def reorder_remove_def
  apply (intro frefI nres_relI)
  apply clarify
  apply (refine_vcg WHILEIT_rule[where R = \<open>measure (\<lambda>(i, _). i)\<close>])
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by (auto dest: mset_eq_length)
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  done

lemma insert_sort_reorder_remove: \<open>(insert_sort f, reorder_remove vm) \<in> \<langle>Id\<rangle>list_rel \<rightarrow>\<^sub>f \<langle>Id\<rangle> nres_rel\<close>
proof -
  have H: \<open>ba < length aa \<Longrightarrow> insert_sort_inner f aa ba \<le> SPEC (\<lambda>m'. mset m' = mset aa)\<close>
    for ba aa b
    using insert_sort_inner[unfolded fref_def nres_rel_def reorder_remove_def, simplified, rule_format]
    by fast
  show ?thesis
    unfolding insert_sort_def reorder_remove_def
    apply (intro frefI nres_relI)
    apply (refine_vcg WHILEIT_rule[where R = \<open>measure (\<lambda>(i, ys). length ys - i)\<close>] H)
    subgoal by auto
    subgoal by auto
    subgoal by auto
    subgoal by auto
    subgoal by (auto dest: mset_eq_length)
    subgoal by auto
    subgoal by (auto dest!: mset_eq_length)
    subgoal by auto
    done
qed

end