theory WB_More_Refinement
  imports
    Refine_Imperative_HOL.IICF
    Weidenbach_Book_Base.WB_List_More
begin

text \<open>This lemma cannot be moved to \<^theory>\<open>Weidenbach_Book_Base.WB_List_More\<close>, because the syntax
 \<^term>\<open>CARD('a)\<close> does not exist there.\<close>
lemma finite_length_le_CARD:
  assumes \<open>distinct (xs :: 'a :: finite list)\<close>
  shows \<open>length xs \<le> CARD('a)\<close>
proof -
  have \<open>set xs \<subseteq> UNIV\<close>
    by auto
  show ?thesis
    by (metis assms card_ge_UNIV distinct_card le_cases)
qed


no_notation Ref.update ("_ := _" 62)

subsection \<open>Some Tooling for Refinement\<close>

text \<open>
  The following very simple tactics remove duplicate variables generated by some tactic like
  \<open>refine_rcg\<close>. For example, if the problem contains \<^term>\<open>(i, C) = (xa, xb)\<close>, then only
  \<^term>\<open>i\<close> and \<^term>\<open>C\<close> will remain. It can also prove trivial goals where the goals already
  appears in the assumptions.
  \<close>

method remove_dummy_vars uses simp =
  ((unfold prod.inject)?; (simp only: prod.inject)?; (elim conjE)?;
    hypsubst?; (simp only: triv_forall_equality simps)?)


subsubsection \<open>From @{text \<rightarrow>} to @{text \<Down>}\<close>

lemma Ball2_split_def: \<open>(\<forall>(x, y) \<in> A. P x y) \<longleftrightarrow> (\<forall>x y. (x, y) \<in> A \<longrightarrow> P x y)\<close>
  by blast

lemma in_pair_collect_simp: "(a,b)\<in>{(a,b). P a b} \<longleftrightarrow> P a b"
  by auto

ML \<open>
signature MORE_REFINEMENT = sig
  val down_converse: Proof.context -> thm -> thm
end

structure More_Refinement: MORE_REFINEMENT = struct
  val unfold_refine = (fn context => Local_Defs.unfold (context)
   @{thms refine_rel_defs nres_rel_def in_pair_collect_simp})
  val unfold_Ball = (fn context => Local_Defs.unfold (context)
    @{thms Ball2_split_def all_to_meta})
  val replace_ALL_by_meta = (fn context => fn thm => Object_Logic.rulify context thm)
  val down_converse = (fn context =>
    replace_ALL_by_meta context o (unfold_Ball context) o (unfold_refine context))
end
\<close>

attribute_setup "to_\<Down>" = \<open>
    Scan.succeed (Thm.rule_attribute [] (More_Refinement.down_converse o Context.proof_of))
  \<close> "convert theorem from @{text \<rightarrow>}-form to @{text \<Down>}-form."

method "to_\<Down>" =
   (unfold refine_rel_defs nres_rel_def in_pair_collect_simp;
   unfold Ball2_split_def all_to_meta;
   intro allI impI)


subsubsection \<open>Merge Post-Conditions\<close>

lemma Down_add_assumption_middle:
  assumes
    \<open>nofail U\<close> and
    \<open>V \<le> \<Down> {(T1, T0). Q T1 T0 \<and> P T1 \<and> Q' T1 T0} U\<close> and
    \<open>W \<le> \<Down> {(T2, T1). R T2 T1} V\<close>
  shows \<open>W \<le> \<Down> {(T2, T1). R T2 T1 \<and> P T1} V\<close>
  using assms unfolding nres_rel_def fun_rel_def pw_le_iff pw_conc_inres pw_conc_nofail
  by blast

lemma Down_del_assumption_middle:
  assumes
    \<open>S1 \<le> \<Down> {(T1, T0). Q T1 T0 \<and> P T1 \<and> Q' T1 T0} S0\<close>
  shows \<open>S1 \<le> \<Down> {(T1, T0). Q T1 T0 \<and> Q' T1 T0} S0\<close>
  using assms unfolding nres_rel_def fun_rel_def pw_le_iff pw_conc_inres pw_conc_nofail
  by blast

lemma Down_add_assumption_beginning:
  assumes
    \<open>nofail U\<close> and
    \<open>V \<le> \<Down> {(T1, T0). P T1 \<and> Q' T1 T0} U\<close> and
    \<open>W \<le> \<Down> {(T2, T1). R T2 T1} V\<close>
  shows \<open>W \<le> \<Down> {(T2, T1). R T2 T1 \<and> P T1} V\<close>
  using assms unfolding nres_rel_def fun_rel_def pw_le_iff pw_conc_inres pw_conc_nofail
  by blast

lemma Down_add_assumption_beginning_single:
  assumes
    \<open>nofail U\<close> and
    \<open>V \<le> \<Down> {(T1, T0). P T1} U\<close> and
    \<open>W \<le> \<Down> {(T2, T1). R T2 T1} V\<close>
  shows \<open>W \<le> \<Down> {(T2, T1). R T2 T1 \<and> P T1} V\<close>
  using assms unfolding nres_rel_def fun_rel_def pw_le_iff pw_conc_inres pw_conc_nofail
  by blast

lemma Down_del_assumption_beginning:
  fixes U :: \<open>'a nres\<close> and V :: \<open>'b nres\<close> and Q Q' :: \<open>'b \<Rightarrow> 'a \<Rightarrow> bool\<close>
  assumes
    \<open>V \<le> \<Down> {(T1, T0). Q T1 T0 \<and> Q' T1 T0} U\<close>
  shows \<open>V \<le> \<Down> {(T1, T0). Q' T1 T0} U\<close>
  using assms unfolding nres_rel_def fun_rel_def pw_le_iff pw_conc_inres pw_conc_nofail
  by blast

method unify_Down_invs2_normalisation_post =
  ((unfold meta_same_imp_rule True_implies_equals conj_assoc)?)

method unify_Down_invs2 =
  (match premises in
      \<comment> \<open>if the relation 2-1 has not assumption, we add True. Then we call out method again and
           this time it will match since it has an assumption.\<close>
      I: \<open>S1 \<le> \<Down> R10 S0\<close> and
      J[thin]: \<open>S2 \<le> \<Down> R21 S1\<close>
       for S1:: \<open>'b nres\<close> and S0 :: \<open>'a nres\<close> and S2 :: \<open>'c nres\<close> and R10 R21 \<Rightarrow>
        \<open>insert True_implies_equals[where P = \<open>S2 \<le> \<Down> R21 S1\<close>, symmetric,
           THEN equal_elim_rule1, OF J]\<close>
    \<bar> I[thin]: \<open>S1 \<le> \<Down> {(T1, T0). P T1} S0\<close> (multi) and
      J[thin]: _ for S1:: \<open>'b nres\<close> and S0 :: \<open>'a nres\<close> and P :: \<open>'b \<Rightarrow> bool\<close> \<Rightarrow>
       \<open>match J[uncurry] in
         J[curry]: \<open>_ \<Longrightarrow> S2 \<le> \<Down> {(T2, T1). R T2 T1} S1\<close> for S2 :: \<open>'c nres\<close> and R \<Rightarrow>
          \<open>insert Down_add_assumption_beginning_single[where P = P and R = R and
               W = S2 and V = S1 and U = S0, OF _ I J];
           unify_Down_invs2_normalisation_post\<close>
       \<bar> _ \<Rightarrow> \<open>fail\<close>\<close>
   \<bar> I[thin]: \<open>S1 \<le> \<Down> {(T1, T0). P T1 \<and> Q' T1 T0} S0\<close> (multi) and
     J[thin]: _ for S1:: \<open>'b nres\<close> and S0 :: \<open>'a nres\<close> and Q' and P :: \<open>'b \<Rightarrow> bool\<close> \<Rightarrow>
       \<open>match J[uncurry] in
         J[curry]: \<open>_ \<Longrightarrow> S2 \<le> \<Down> {(T2, T1). R T2 T1} S1\<close> for S2 :: \<open>'c nres\<close> and R \<Rightarrow>
          \<open>insert Down_add_assumption_beginning[where Q' = Q' and P = P and R = R and
              W = S2 and V = S1 and U = S0,
              OF _ I J];
           insert Down_del_assumption_beginning[where Q = \<open>\<lambda>S _. P S\<close> and Q' = Q' and V = S1 and
             U = S0, OF I];
          unify_Down_invs2_normalisation_post\<close>
       \<bar> _ \<Rightarrow> \<open>fail\<close>\<close>
   \<bar> I[thin]: \<open>S1 \<le> \<Down> {(T1, T0). Q T0 T1\<and> Q' T1 T0} S0\<close> (multi) and
     J: _ for S1:: \<open>'b nres\<close> and S0 :: \<open>'a nres\<close> and Q Q' \<Rightarrow>
       \<open>match J[uncurry] in
         J[curry]: \<open>_ \<Longrightarrow> S2 \<le> \<Down> {(T2, T1). R T2 T1} S1\<close> for S2 :: \<open>'c nres\<close> and R \<Rightarrow>
          \<open>insert Down_del_assumption_beginning[where Q = \<open>\<lambda> x y. Q y x\<close> and Q' = Q', OF I];
           unify_Down_invs2_normalisation_post\<close>
       \<bar> _ \<Rightarrow> \<open>fail\<close>\<close>
  )

text \<open>Example:\<close>
lemma
  assumes
    \<open>nofail S0\<close> and
    1: \<open>S1 \<le> \<Down> {(T1, T0). Q T1 T0 \<and> P T1 \<and> P' T1 \<and> P''' T1 \<and> Q' T1 T0 \<and> P42 T1} S0\<close> and
    2: \<open>S2 \<le> \<Down> {(T2, T1). R T2 T1} S1\<close>
  shows \<open>S2
     \<le> \<Down> {(T2, T1).
           R T2 T1 \<and>
           P T1 \<and> P' T1 \<and> P''' T1 \<and> P42 T1}
         S1\<close>
  using assms apply -
  apply unify_Down_invs2+
  apply fast
  done

subsubsection \<open>Inversion Tactics\<close>

lemma refinement_trans_long:
  \<open>A = A' \<Longrightarrow> B = B' \<Longrightarrow> R \<subseteq> R' \<Longrightarrow> A \<le> \<Down> R B \<Longrightarrow> A' \<le> \<Down> R' B'\<close>
  by (meson pw_ref_iff subsetCE)

lemma mem_set_trans:
  \<open>A \<subseteq> B \<Longrightarrow> a \<in> A \<Longrightarrow> a \<in> B\<close>
  by auto

lemma fun_rel_syn_invert:
  \<open>a = a' \<Longrightarrow> b \<subseteq> b' \<Longrightarrow> a \<rightarrow> b \<subseteq> a' \<rightarrow> b'\<close>
  by (auto simp: refine_rel_defs)

lemma fref_syn_invert:
  \<open>a = a' \<Longrightarrow> b \<subseteq> b' \<Longrightarrow> a \<rightarrow>\<^sub>f b \<subseteq> a' \<rightarrow>\<^sub>f b'\<close>
  unfolding fref_param1[symmetric]
  by (rule fun_rel_syn_invert)

lemma nres_rel_mono:
  \<open>a \<subseteq> a'  \<Longrightarrow> \<langle>a\<rangle> nres_rel \<subseteq> \<langle>a'\<rangle> nres_rel\<close>
  by (fastforce simp: refine_rel_defs nres_rel_def pw_ref_iff)

method match_spec =
  (match conclusion in \<open>(f, g) \<in> R\<close> for f g R \<Rightarrow>
    \<open>print_term f; match premises in I[thin]: \<open>(f, g) \<in> R'\<close> for R'
       \<Rightarrow> \<open>print_term R'; rule mem_set_trans[OF _ I]\<close>\<close>)

method match_fun_rel =
  ((match conclusion in
       \<open>_ \<rightarrow> _ \<subseteq> _ \<rightarrow> _\<close> \<Rightarrow> \<open>rule fun_rel_mono\<close>
     \<bar> \<open>_ \<rightarrow>\<^sub>f _ \<subseteq> _ \<rightarrow>\<^sub>f _\<close> \<Rightarrow> \<open>rule fref_syn_invert\<close>
     \<bar> \<open>\<langle>_\<rangle>nres_rel \<subseteq> \<langle>_\<rangle>nres_rel\<close> \<Rightarrow> \<open>rule nres_rel_mono\<close>
     \<bar> \<open>[_]\<^sub>f _ \<rightarrow> _ \<subseteq> [_]\<^sub>f _ \<rightarrow> _\<close> \<Rightarrow> \<open>rule fref_mono\<close>
   )+)

lemma weaken_SPEC2: \<open>m' \<le> SPEC \<Phi> \<Longrightarrow> m = m' \<Longrightarrow> (\<And>x. \<Phi> x \<Longrightarrow> \<Psi> x) \<Longrightarrow> m \<le> SPEC \<Psi>\<close>
  using weaken_SPEC by auto

method match_spec_trans =
  (match conclusion in \<open>f \<le> SPEC R\<close> for f :: \<open>'a nres\<close> and R :: \<open>'a \<Rightarrow> bool\<close> \<Rightarrow>
    \<open>print_term f; match premises in I: \<open>_ \<Longrightarrow> _ \<Longrightarrow> f' \<le> SPEC R'\<close> for f' :: \<open>'a nres\<close> and R' :: \<open>'a \<Rightarrow> bool\<close>
       \<Rightarrow> \<open>print_term f'; rule weaken_SPEC2[of f' R' f R]\<close>\<close>)

subsection \<open>More Notations\<close>

abbreviation comp4  (infixl "oooo" 55)       where "f oooo g \<equiv>       \<lambda>x. f ooo (g x)"
abbreviation comp5  (infixl "ooooo" 55)      where "f ooooo g \<equiv>      \<lambda>x. f oooo (g x)"
abbreviation comp6  (infixl "oooooo" 55)     where "f oooooo g \<equiv>     \<lambda>x. f ooooo (g x)"
abbreviation comp7  (infixl "ooooooo" 55)    where "f ooooooo g \<equiv>    \<lambda>x. f oooooo (g x)"
abbreviation comp8  (infixl "oooooooo" 55)   where "f oooooooo g \<equiv>   \<lambda>x. f ooooooo (g x)"
abbreviation comp9  (infixl "ooooooooo" 55)  where "f ooooooooo g \<equiv>  \<lambda>x. f oooooooo (g x)"
abbreviation comp10 (infixl "oooooooooo" 55) where "f oooooooooo g \<equiv> \<lambda>x. f ooooooooo (g x)"

notation
  comp4 (infixl "\<circ>\<circ>\<circ>" 55) and
  comp5 (infixl "\<circ>\<circ>\<circ>\<circ>" 55) and
  comp6 (infixl "\<circ>\<circ>\<circ>\<circ>\<circ>" 55) and
  comp7 (infixl "\<circ>\<circ>\<circ>\<circ>\<circ>\<circ>" 55) and
  comp8 (infixl "\<circ>\<circ>\<circ>\<circ>\<circ>\<circ>\<circ>" 55) and
  comp9 (infixl "\<circ>\<circ>\<circ>\<circ>\<circ>\<circ>\<circ>\<circ>" 55) and
  comp9 (infixl "\<circ>\<circ>\<circ>\<circ>\<circ>\<circ>\<circ>\<circ>\<circ>" 55)

notation prod_assn (infixr "*a" 90)

lemma norm_RETURN_o[to_hnr_post]:
  "\<And>f. (RETURN oooo f)$x$y$z$a = (RETURN$(f$x$y$z$a))"
  "\<And>f. (RETURN ooooo f)$x$y$z$a$b = (RETURN$(f$x$y$z$a$b))"
  "\<And>f. (RETURN oooooo f)$x$y$z$a$b$c = (RETURN$(f$x$y$z$a$b$c))"
  "\<And>f. (RETURN ooooooo f)$x$y$z$a$b$c$d = (RETURN$(f$x$y$z$a$b$c$d))"
  "\<And>f. (RETURN oooooooo f)$x$y$z$a$b$c$d$e = (RETURN$(f$x$y$z$a$b$c$d$e))"
  "\<And>f. (RETURN ooooooooo f)$x$y$z$a$b$c$d$e$g = (RETURN$(f$x$y$z$a$b$c$d$e$g))"
  "\<And>f. (RETURN oooooooooo f)$x$y$z$a$b$c$d$e$g$h= (RETURN$(f$x$y$z$a$b$c$d$e$g$h))"
  by auto

lemma norm_return_o[to_hnr_post]:
  "\<And>f. (return oooo f)$x$y$z$a = (return$(f$x$y$z$a))"
  "\<And>f. (return ooooo f)$x$y$z$a$b = (return$(f$x$y$z$a$b))"
  "\<And>f. (return oooooo f)$x$y$z$a$b$c = (return$(f$x$y$z$a$b$c))"
  "\<And>f. (return ooooooo f)$x$y$z$a$b$c$d = (return$(f$x$y$z$a$b$c$d))"
  "\<And>f. (return oooooooo f)$x$y$z$a$b$c$d$e = (return$(f$x$y$z$a$b$c$d$e))"
  "\<And>f. (return ooooooooo f)$x$y$z$a$b$c$d$e$g = (return$(f$x$y$z$a$b$c$d$e$g))"
  "\<And>f. (return oooooooooo f)$x$y$z$a$b$c$d$e$g$h= (return$(f$x$y$z$a$b$c$d$e$g$h))"
    by auto


subsection \<open>More Theorems for Refinement\<close>

lemma prod_assn_id_assn_destroy: \<open>R\<^sup>d *\<^sub>a id_assn\<^sup>d = (R *a id_assn)\<^sup>d\<close>
  by (auto simp: hfprod_def prod_assn_def[abs_def] invalid_assn_def pure_def intro!: ext)

lemma SPEC_add_information: \<open>P \<Longrightarrow> A \<le> SPEC Q \<Longrightarrow> A \<le> SPEC(\<lambda>x. Q x \<and> P)\<close>
  by auto

lemma bind_refine_spec: \<open>(\<And>x. \<Phi> x \<Longrightarrow> f x \<le> \<Down> R M) \<Longrightarrow> M' \<le> SPEC \<Phi> \<Longrightarrow> M' \<bind> f \<le> \<Down> R M\<close>
  by (auto simp add: pw_le_iff refine_pw_simps)

lemma intro_spec_iff:
  \<open>(RES X \<bind> f \<le> M) = (\<forall>x\<in>X. f x \<le> M)\<close>
  using intro_spec_refine_iff[of X f Id M] by auto

lemma case_prod_bind:
  assumes \<open>\<And>x1 x2. x = (x1, x2) \<Longrightarrow> f x1 x2 \<le> \<Down> R I\<close>
  shows \<open>(case x of (x1, x2) \<Rightarrow> f x1 x2) \<le> \<Down> R I\<close>
  using assms by (cases x) auto

lemma (in transfer) transfer_bool[refine_transfer]:
  assumes "\<alpha> fa \<le> Fa"
  assumes "\<alpha> fb \<le> Fb"
  shows "\<alpha> (case_bool fa fb x) \<le> case_bool Fa Fb x"
  using assms by (auto split: bool.split)

lemma ref_two_step': \<open>A \<le> B \<Longrightarrow> \<Down> R A \<le>  \<Down> R B\<close>
  by (auto intro: ref_two_step)

lemma hrp_comp_Id2[simp]: \<open>hrp_comp A Id = A\<close>
  unfolding hrp_comp_def by auto

lemma hn_ctxt_prod_assn_prod:
  \<open>hn_ctxt (R *a S) (a, b) (a', b') = hn_ctxt R a a' * hn_ctxt S b b'\<close>
  unfolding hn_ctxt_def
  by auto

lemma list_assn_map_list_assn: \<open>list_assn g (map f x) xi = list_assn (\<lambda>a c. g (f a) c) x xi\<close>
  apply (induction x arbitrary: xi)
  subgoal by auto
  subgoal for a x xi
    by (cases xi) auto
  done

lemma RES_RETURN_RES: \<open>RES \<Phi> \<bind> (\<lambda>T. RETURN (f T)) = RES (f ` \<Phi>)\<close>
  by (simp add: bind_RES_RETURN_eq setcompr_eq_image)

lemma RES_RES_RETURN_RES: \<open>RES A \<bind> (\<lambda>T. RES (f T)) = RES (\<Union>(f ` A))\<close>
  by (auto simp:  pw_eq_iff refine_pw_simps)

lemma RES_RES2_RETURN_RES: \<open>RES A \<bind> (\<lambda>(T, T'). RES (f T T')) = RES (\<Union>(uncurry f ` A))\<close>
  by (auto simp:  pw_eq_iff refine_pw_simps uncurry_def)

lemma RES_RES3_RETURN_RES:
   \<open>RES A \<bind> (\<lambda>(T, T', T''). RES (f T T' T'')) = RES (\<Union>((\<lambda>(a, b, c). f a b c) ` A))\<close>
  by (auto simp:  pw_eq_iff refine_pw_simps uncurry_def)

lemma RES_RETURN_RES3:
   \<open>SPEC \<Phi> \<bind> (\<lambda>(T, T', T''). RETURN (f T T' T'')) = RES ((\<lambda>(a, b, c). f a b c) ` {T. \<Phi> T})\<close>
  using RES_RETURN_RES[of \<open>Collect \<Phi>\<close> \<open>\<lambda>(a, b, c). f a b c\<close>]
  apply (subst (asm)(2) split_prod_bound)
  apply (subst (asm)(3) split_prod_bound)
  by auto

lemma RES_RES_RETURN_RES2: \<open>RES A \<bind> (\<lambda>(T, T'). RETURN (f T T')) = RES (uncurry f ` A)\<close>
  by (auto simp:  pw_eq_iff refine_pw_simps uncurry_def)

lemma bind_refine_res: \<open>(\<And>x. x \<in> \<Phi> \<Longrightarrow> f x \<le> \<Down> R M) \<Longrightarrow> M' \<le> RES \<Phi> \<Longrightarrow> M' \<bind> f \<le> \<Down> R M\<close>
  by (auto simp add: pw_le_iff refine_pw_simps)

lemma RES_RETURN_RES_RES2:
   \<open>RES \<Phi> \<bind> (\<lambda>(T, T'). RETURN (f T T')) = RES (uncurry f ` \<Phi>)\<close>
  using RES_RES2_RETURN_RES[of \<open>\<Phi>\<close> \<open>\<lambda>T T'. {f T T'}\<close>]
  apply (subst (asm)(2) split_prod_bound)
  by (auto simp: RETURN_def uncurry_def)

text \<open>
  This theorem adds the invariant at the beginning of next iteration to the current invariant,
  i.e., the invariant is added as a post-condition on the current iteration.

  This is useful to reduce duplication in theorems while refining.
\<close>

lemma RECT_WHILEI_body_add_post_condition:
    \<open>REC\<^sub>T (WHILEI_body (\<bind>) RETURN I' b' f) x' =
     (REC\<^sub>T (WHILEI_body (\<bind>) RETURN (\<lambda>x'. I' x' \<and> (b' x' \<longrightarrow> f x' = FAIL \<or> f x' \<le> SPEC I')) b' f) x')\<close>
  (is \<open>REC\<^sub>T ?f x' = REC\<^sub>T ?f' x'\<close>)
proof -
  have le: \<open>flatf_gfp ?f x' \<le> flatf_gfp ?f' x'\<close> for x'
  proof (induct arbitrary: x' rule: flatf_ord.fixp_induct[where b = top and
        f = ?f'])
    case 1
    then show ?case
      unfolding fun_lub_def pw_le_iff
      by (rule ccpo.admissibleI)
        (smt chain_fun flat_lub_in_chain mem_Collect_eq nofail_simps(1))
  next
    case 2
    then show ?case by (auto simp: WHILEI_mono_ge)
  next
    case 3
    then show ?case by simp
  next
    case (4 x)
    have  \<open>(RES X \<bind> f \<le> M) = (\<forall>x\<in>X. f x \<le> M)\<close> for x f M X
      using intro_spec_refine_iff[of _ _ \<open>Id\<close>] by auto
    thm bind_refine_RES(2)[of _ Id, simplified]
    have [simp]: \<open>flatf_mono FAIL (WHILEI_body (\<bind>) RETURN I' b' f)\<close>
      by (simp add: WHILEI_mono_ge)

    have \<open>flatf_gfp ?f x' = ?f (?f (flatf_gfp ?f)) x'\<close>
      apply (subst flatf_ord.fixp_unfold)
       apply (solves \<open>simp\<close>)
      apply (subst flatf_ord.fixp_unfold)
       apply (solves \<open>simp\<close>)
      ..
    also have \<open>\<dots> = WHILEI_body (\<bind>) RETURN (\<lambda>x'. I' x' \<and> (b' x' \<longrightarrow> f x' = FAIL \<or> f x' \<le> SPEC I')) b' f (WHILEI_body (\<bind>) RETURN I' b' f (flatf_gfp (WHILEI_body (\<bind>) RETURN I' b' f))) x'\<close>
      apply (subst (1) WHILEI_body_def, subst (1) WHILEI_body_def)
      apply (subst (2) WHILEI_body_def, subst (2) WHILEI_body_def)
      apply simp_all
      apply (cases \<open>f x'\<close>)
       apply (auto simp: RES_RETURN_RES nofail_def[symmetric] pw_RES_bind_choose
          split: if_splits)
      done
    also have \<open>\<dots> =  WHILEI_body (\<bind>) RETURN (\<lambda>x'. I' x' \<and> (b' x' \<longrightarrow> f x' = FAIL \<or> f x' \<le> SPEC I')) b' f ((flatf_gfp (WHILEI_body (\<bind>) RETURN I' b' f))) x'\<close>
      apply (subst (2) flatf_ord.fixp_unfold)
       apply (solves \<open>simp\<close>)
      ..
    finally have unfold1: \<open>flatf_gfp (WHILEI_body (\<bind>) RETURN I' b' f) x' =
         ?f' (flatf_gfp (WHILEI_body (\<bind>) RETURN I' b' f)) x'\<close>
      .
    have [intro!]: \<open>(\<And>x. g x \<le> (h:: 'a \<Rightarrow> 'a nres) x) \<Longrightarrow> fx \<bind> g \<le> fx \<bind> h\<close> for g h fx fy
      by (refine_rcg bind_refine'[where R = \<open>Id\<close>, simplified]) fast
    show ?case
      apply (subst unfold1)
      using 4 unfolding WHILEI_body_def by auto
  qed

  have ge: \<open>flatf_gfp ?f x' \<ge>  flatf_gfp ?f' x'\<close> for x'
  proof (induct arbitrary: x' rule: flatf_ord.fixp_induct[where b = top and
        f = ?f])
    case 1
    then show ?case
      unfolding fun_lub_def pw_le_iff
      by (rule ccpo.admissibleI) (smt chain_fun flat_lub_in_chain mem_Collect_eq nofail_simps(1))
  next
    case 2
    then show ?case by (auto simp: WHILEI_mono_ge)
  next
    case 3
    then show ?case by simp
  next
    case (4 x)
    have  \<open>(RES X \<bind> f \<le> M) = (\<forall>x\<in>X. f x \<le> M)\<close> for x f M X
      using intro_spec_refine_iff[of _ _ \<open>Id\<close>] by auto
    thm bind_refine_RES(2)[of _ Id, simplified]
    have [simp]: \<open>flatf_mono FAIL ?f'\<close>
      by (simp add: WHILEI_mono_ge)
    have H: \<open>A = FAIL \<longleftrightarrow> \<not>nofail A\<close> for A by (auto simp: nofail_def)
    have \<open>flatf_gfp ?f' x' = ?f' (?f' (flatf_gfp ?f')) x'\<close>
      apply (subst flatf_ord.fixp_unfold)
       apply (solves \<open>simp\<close>)
      apply (subst flatf_ord.fixp_unfold)
       apply (solves \<open>simp\<close>)
      ..
    also have \<open>\<dots> = ?f (?f' (flatf_gfp ?f')) x'\<close>
      apply (subst (1) WHILEI_body_def, subst (1) WHILEI_body_def)
      apply (subst (2) WHILEI_body_def, subst (2) WHILEI_body_def)
      apply simp_all
      apply (cases \<open>f x'\<close>)
       apply (auto simp: RES_RETURN_RES nofail_def[symmetric] pw_RES_bind_choose
          eq_commute[of \<open>FAIL\<close>] H
          split: if_splits
          cong: if_cong)
      done
    also have \<open>\<dots> = ?f (flatf_gfp ?f') x'\<close>
      apply (subst (2) flatf_ord.fixp_unfold)
       apply (solves \<open>simp\<close>)
      ..
    finally have unfold1: \<open>flatf_gfp ?f' x' =
         ?f (flatf_gfp ?f') x'\<close>
      .
    have [intro!]: \<open>(\<And>x. g x \<le>(h:: 'a \<Rightarrow> 'a nres) x) \<Longrightarrow> fx \<bind> g \<le> fx \<bind> h\<close> for g h fx fy
      by (refine_rcg bind_refine'[where R = \<open>Id\<close>, simplified]) fast
    show ?case
      apply (subst unfold1)
      using 4
      unfolding WHILEI_body_def
      by (auto intro: bind_refine'[where R = \<open>Id\<close>, simplified])
  qed
  show ?thesis
    unfolding RECT_def
    using le[of x'] ge[of x'] by (auto simp: WHILEI_body_trimono)
qed

lemma WHILEIT_add_post_condition:
 \<open>(WHILEIT I' b' f' x') =
  (WHILEIT (\<lambda>x'. I' x' \<and> (b' x' \<longrightarrow> f' x' = FAIL \<or> f' x' \<le> SPEC I'))
    b' f' x')\<close>
  unfolding WHILEIT_def
  apply (subst RECT_WHILEI_body_add_post_condition)
  ..

lemma WHILEIT_rule_stronger_inv:
  assumes
    \<open>wf R\<close> and
    \<open>I s\<close> and
    \<open>I' s\<close> and
    \<open>\<And>s. I s \<Longrightarrow> I' s \<Longrightarrow> b s \<Longrightarrow> f s \<le> SPEC (\<lambda>s'. I s' \<and>  I' s' \<and> (s', s) \<in> R)\<close> and
    \<open>\<And>s. I s \<Longrightarrow> I' s \<Longrightarrow> \<not> b s \<Longrightarrow> \<Phi> s\<close>
 shows \<open>WHILE\<^sub>T\<^bsup>I\<^esup> b f s \<le> SPEC \<Phi>\<close>
proof -
  have \<open>WHILE\<^sub>T\<^bsup>I\<^esup> b f s \<le> WHILE\<^sub>T\<^bsup>\<lambda>s. I s \<and> I' s\<^esup> b f s\<close>
    by (metis (mono_tags, lifting) WHILEIT_weaken)
  also have \<open>WHILE\<^sub>T\<^bsup>\<lambda>s. I s \<and> I' s\<^esup> b f s \<le> SPEC \<Phi>\<close>
    by (rule WHILEIT_rule) (use assms in \<open>auto simp: \<close>)
  finally show ?thesis .
qed

lemma RES_RETURN_RES2:
   \<open>SPEC \<Phi> \<bind> (\<lambda>(T, T'). RETURN (f T T')) = RES (uncurry f ` {T. \<Phi> T})\<close>
  using RES_RETURN_RES[of \<open>Collect \<Phi>\<close> \<open>uncurry f\<close>]
  apply (subst (asm)(2) split_prod_bound)
  by auto

lemma WHILEIT_rule_stronger_inv_RES:
  assumes
    \<open>wf R\<close> and
    \<open>I s\<close> and
    \<open>I' s\<close>
    \<open>\<And>s. I s \<Longrightarrow> I' s \<Longrightarrow> b s \<Longrightarrow> f s \<le> SPEC (\<lambda>s'. I s' \<and>  I' s' \<and> (s', s) \<in> R)\<close> and
   \<open>\<And>s. I s \<Longrightarrow> I' s \<Longrightarrow> \<not> b s \<Longrightarrow> s \<in> \<Phi>\<close>
 shows \<open>WHILE\<^sub>T\<^bsup>I\<^esup> b f s \<le> RES \<Phi>\<close>
proof -
  have RES_SPEC: \<open>RES \<Phi> = SPEC(\<lambda>s. s \<in> \<Phi>)\<close>
    by auto
  have \<open>WHILE\<^sub>T\<^bsup>I\<^esup> b f s \<le> WHILE\<^sub>T\<^bsup>\<lambda>s. I s \<and> I' s\<^esup> b f s\<close>
    by (metis (mono_tags, lifting) WHILEIT_weaken)
  also have \<open>WHILE\<^sub>T\<^bsup>\<lambda>s. I s \<and> I' s\<^esup> b f s \<le> RES \<Phi>\<close>
    unfolding RES_SPEC
    by (rule WHILEIT_rule) (use assms in \<open>auto simp: \<close>)
  finally show ?thesis .
qed

text \<open>
  This theorem is useful to debug situation where sepref is not able to synthesize a program (with
  the ``[[unify\_trace\_failure]]'' to trace what fails in rule rule and the \<^text>\<open>to_hnr\<close> to
  ensure the theorem has the correct form).
\<close>
lemma Pair_hnr: \<open>(uncurry (return oo (\<lambda>a b. Pair a b)), uncurry (RETURN oo (\<lambda>a b. Pair a b))) \<in>
    A\<^sup>d *\<^sub>a B\<^sup>d \<rightarrow>\<^sub>a prod_assn A B\<close>
  by sepref_to_hoare sep_auto

lemma fref_weaken_pre_weaken:
  assumes "\<And>x. P x \<longrightarrow> P' x"
  assumes "(f,h) \<in> fref P' R S"
  assumes \<open>S \<subseteq> S'\<close>
  shows "(f,h) \<in> fref P R S'"
  using fref_weaken_pre[OF assms(1,2)]
  using assms(3) fref_cons by blast

lemma bind_rule_complete_RES: \<open>(M \<bind> f \<le> RES \<Phi>) = (M \<le> SPEC (\<lambda>x. f x \<le> RES \<Phi>))\<close>
  by (auto simp: pw_le_iff refine_pw_simps)

text \<open>This version works only for \<^emph>\<open>pure\<close> refinement relations:\<close>
lemma the_hnr_keep:
  \<open>CONSTRAINT is_pure A \<Longrightarrow> (return o the, RETURN o the) \<in> [\<lambda>D. D \<noteq> None]\<^sub>a (option_assn A)\<^sup>k \<rightarrow> A\<close>
  using pure_option[of A]
  by sepref_to_hoare
   (sep_auto simp: option_assn_alt_def is_pure_def split: option.splits)

lemma fref_to_Down:
  \<open>(f, g) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x'. P x' \<Longrightarrow> (x, x') \<in> A \<Longrightarrow> f x \<le> \<Down> B (g x'))\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_curry_left:
  fixes f:: \<open>'a \<Rightarrow> 'b \<Rightarrow> 'c nres\<close> and
    A::\<open>(('a \<times> 'b) \<times> 'd) set\<close>
  shows
    \<open>(uncurry f, g) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
      (\<And>a b x'. P x' \<Longrightarrow> ((a, b), x') \<in> A \<Longrightarrow> f a b \<le> \<Down> B (g x'))\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_curry:
  \<open>(uncurry f, uncurry g) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x' y y'. P (x', y') \<Longrightarrow> ((x, y), (x', y')) \<in> A \<Longrightarrow> f x y \<le> \<Down> B (g x' y'))\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_curry2:
  \<open>(uncurry2 f, uncurry2 g) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x' y y' z z'. P ((x', y'), z') \<Longrightarrow> (((x, y), z), ((x', y'), z')) \<in> A\<Longrightarrow>
         f x y z \<le> \<Down> B (g x' y' z'))\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_curry2':
  \<open>(uncurry2 f, uncurry2 g) \<in> A \<rightarrow>\<^sub>f \<langle>B\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x' y y' z z'. (((x, y), z), ((x', y'), z')) \<in> A \<Longrightarrow>
         f x y z \<le> \<Down> B (g x' y' z'))\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_curry3:
  \<open>(uncurry3 f, uncurry3 g) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x' y y' z z' a a'. P (((x', y'), z'), a') \<Longrightarrow>
        ((((x, y), z), a), (((x', y'), z'), a')) \<in> A \<Longrightarrow>
         f x y z a \<le> \<Down> B (g x' y' z' a'))\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_curry4:
  \<open>(uncurry4 f, uncurry4 g) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x' y y' z z' a a' b b'. P ((((x', y'), z'), a'), b') \<Longrightarrow>
        (((((x, y), z), a), b), ((((x', y'), z'), a'), b')) \<in> A \<Longrightarrow>
         f x y z a b \<le> \<Down> B (g x' y' z' a' b'))\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_curry5:
  \<open>(uncurry5 f, uncurry5 g) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x' y y' z z' a a' b b' c c'. P (((((x', y'), z'), a'), b'), c') \<Longrightarrow>
        ((((((x, y), z), a), b), c), (((((x', y'), z'), a'), b'), c')) \<in> A \<Longrightarrow>
         f x y z a b c \<le> \<Down> B (g x' y' z' a' b' c'))\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_curry6:
  \<open>(uncurry6 f, uncurry6 g) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x' y y' z z' a a' b b' c c' d d'. P ((((((x', y'), z'), a'), b'), c'), d') \<Longrightarrow>
        (((((((x, y), z), a), b), c), d), ((((((x', y'), z'), a'), b'), c'), d')) \<in> A \<Longrightarrow>
         f x y z a b c d \<le> \<Down> B (g x' y' z' a' b' c' d'))\<close>
  unfolding fref_def uncurry_def nres_rel_def by auto

lemma fref_to_Down_curry7:
  \<open>(uncurry7 f, uncurry7 g) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x' y y' z z' a a' b b' c c' d d' e e'. P (((((((x', y'), z'), a'), b'), c'), d'), e') \<Longrightarrow>
        ((((((((x, y), z), a), b), c), d), e), (((((((x', y'), z'), a'), b'), c'), d'), e')) \<in> A \<Longrightarrow>
         f x y z a b c d e \<le> \<Down> B (g x' y' z' a' b' c' d' e'))\<close>
  unfolding fref_def uncurry_def nres_rel_def by auto

lemma fref_to_Down_explode:
  \<open>(f a, g a) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x' b. P x' \<Longrightarrow> (x, x') \<in> A \<Longrightarrow> b = a \<Longrightarrow> f a x \<le> \<Down> B (g b x'))\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_curry_no_nres_Id:
  \<open>(uncurry (RETURN oo f), uncurry (RETURN oo g)) \<in> [P]\<^sub>f A \<rightarrow> \<langle>Id\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x' y y'. P (x', y') \<Longrightarrow> ((x, y), (x', y')) \<in> A \<Longrightarrow> f x y = g x' y')\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_no_nres:
  \<open>((RETURN o f), (RETURN o g)) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x'. P (x') \<Longrightarrow> (x, x') \<in> A \<Longrightarrow> (f x, g x') \<in> B)\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_curry_no_nres:
  \<open>(uncurry (RETURN oo f), uncurry (RETURN oo g)) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x' y y'. P (x', y') \<Longrightarrow> ((x, y), (x', y')) \<in> A \<Longrightarrow> (f x y, g x' y') \<in> B)\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma RES_RETURN_RES4:
   \<open>SPEC \<Phi> \<bind> (\<lambda>(T, T', T'', T'''). RETURN (f T T' T'' T''')) =
      RES ((\<lambda>(a, b, c, d). f a b c d) ` {T. \<Phi> T})\<close>
  using RES_RETURN_RES[of \<open>Collect \<Phi>\<close> \<open>\<lambda>(a, b, c, d). f a b c d\<close>]
  apply (subst (asm)(2) split_prod_bound)
  apply (subst (asm)(3) split_prod_bound)
  apply (subst (asm)(4) split_prod_bound)
  by auto

declare RETURN_as_SPEC_refine[refine2 del]


lemma fref_to_Down_unRET_uncurry_Id:
  \<open>(uncurry (RETURN oo f), uncurry (RETURN oo g)) \<in> [P]\<^sub>f A \<rightarrow> \<langle>Id\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x' y y'. P (x', y') \<Longrightarrow> ((x, y), (x', y')) \<in> A \<Longrightarrow> f x y = (g x' y'))\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto
lemma fref_to_Down_unRET_uncurry:
  \<open>(uncurry (RETURN oo f), uncurry (RETURN oo g)) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x' y y'. P (x', y') \<Longrightarrow> ((x, y), (x', y')) \<in> A \<Longrightarrow> (f x y, g x' y') \<in> B)\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_unRET_Id:
  \<open>((RETURN o f), (RETURN o g)) \<in> [P]\<^sub>f A \<rightarrow> \<langle>Id\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x'. P x' \<Longrightarrow> (x, x') \<in> A \<Longrightarrow> f x = (g x'))\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_unRET:
  \<open>((RETURN o f), (RETURN o g)) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
     (\<And>x x'. P x' \<Longrightarrow> (x, x') \<in> A \<Longrightarrow> (f x, g x') \<in> B)\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_unRET_uncurry2:
  fixes f :: \<open>'a \<Rightarrow> 'b \<Rightarrow> 'c \<Rightarrow> 'f\<close>
    and g :: \<open>'a2 \<Rightarrow> 'b2 \<Rightarrow> 'c2 \<Rightarrow> 'g\<close>
  shows
    \<open>(uncurry2 (RETURN ooo f), uncurry2 (RETURN ooo g)) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
       (\<And>(x :: 'a) x' y y' (z :: 'c) (z' :: 'c2).
         P ((x', y'), z') \<Longrightarrow> (((x, y), z), ((x', y'), z')) \<in> A \<Longrightarrow>
         (f x y z, g x' y' z') \<in> B)\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_unRET_uncurry3:
  shows
    \<open>(uncurry3 (RETURN oooo f), uncurry3 (RETURN oooo g)) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
       (\<And>(x :: 'a) x' y y' (z :: 'c) (z' :: 'c2) a a'.
         P (((x', y'), z'), a') \<Longrightarrow> ((((x, y), z), a), (((x', y'), z'), a')) \<in> A \<Longrightarrow>
         (f x y z a, g x' y' z' a') \<in> B)\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto

lemma fref_to_Down_unRET_uncurry4:
  shows
    \<open>(uncurry4 (RETURN ooooo f), uncurry4 (RETURN ooooo g)) \<in> [P]\<^sub>f A \<rightarrow> \<langle>B\<rangle>nres_rel \<Longrightarrow>
       (\<And>(x :: 'a) x' y y' (z :: 'c) (z' :: 'c2) a a' b b'.
         P ((((x', y'), z'), a'), b') \<Longrightarrow> (((((x, y), z), a), b), ((((x', y'), z'), a'), b')) \<in> A \<Longrightarrow>
         (f x y z a b, g x' y' z' a' b') \<in> B)\<close>
  unfolding fref_def uncurry_def nres_rel_def
  by auto


subsubsection \<open>More Simplification Theorems\<close>

lemma ex_assn_swap: \<open>(\<exists>\<^sub>Aa b. P a b) = (\<exists>\<^sub>Ab a. P a b)\<close>
  by (meson ent_ex_postI ent_ex_preI ent_iffI ent_refl)

lemma ent_ex_up_swap: \<open>(\<exists>\<^sub>Aaa. \<up> (P aa)) = (\<up>(\<exists>aa. P aa))\<close>
  by (smt ent_ex_postI ent_ex_preI ent_iffI ent_pure_pre_iff ent_refl mult.left_neutral)

lemma ex_assn_def_pure_eq_middle3:
  \<open>(\<exists>\<^sub>Aba b bb. f b ba bb * \<up> (ba = h b bb) * P b ba bb) = (\<exists>\<^sub>Ab bb. f b (h b bb) bb * P b (h b bb) bb)\<close>
  \<open>(\<exists>\<^sub>Ab ba bb. f b ba bb * \<up> (ba = h b bb) * P b ba bb) = (\<exists>\<^sub>Ab bb. f b (h b bb) bb * P b (h b bb) bb)\<close>
  \<open>(\<exists>\<^sub>Ab bb ba. f b ba bb * \<up> (ba = h b bb) * P b ba bb) = (\<exists>\<^sub>Ab bb. f b (h b bb) bb * P b (h b bb) bb)\<close>
  \<open>(\<exists>\<^sub>Aba b bb. f b ba bb * \<up> (ba = h b bb \<and> Q b ba bb)) = (\<exists>\<^sub>Ab bb. f b (h b bb) bb * \<up>(Q b (h b bb) bb))\<close>
  \<open>(\<exists>\<^sub>Ab ba bb. f b ba bb * \<up> (ba = h b bb \<and> Q b ba bb)) = (\<exists>\<^sub>Ab bb. f b (h b bb) bb * \<up>(Q b (h b bb) bb))\<close>
  \<open>(\<exists>\<^sub>Ab bb ba. f b ba bb * \<up> (ba = h b bb \<and> Q b ba bb)) = (\<exists>\<^sub>Ab bb. f b (h b bb) bb * \<up>(Q b (h b bb) bb))\<close>
  by (subst ex_assn_def, subst (3) ex_assn_def, auto)+

lemma ex_assn_def_pure_eq_middle2:
  \<open>(\<exists>\<^sub>Aba b. f b ba * \<up> (ba = h b) * P b ba) = (\<exists>\<^sub>Ab . f b (h b) * P b (h b))\<close>
  \<open>(\<exists>\<^sub>Ab ba. f b ba * \<up> (ba = h b) * P b ba) = (\<exists>\<^sub>Ab . f b (h b) * P b (h b))\<close>
  \<open>(\<exists>\<^sub>Ab ba. f b ba * \<up> (ba = h b \<and> Q b ba)) = (\<exists>\<^sub>Ab. f b (h b) * \<up>(Q b (h b)))\<close>
  \<open>(\<exists>\<^sub>A ba b. f b ba * \<up> (ba = h b \<and> Q b ba)) = (\<exists>\<^sub>Ab. f b (h b) * \<up>(Q b (h b)))\<close>
  by (subst ex_assn_def, subst (2) ex_assn_def, auto)+

lemma ex_assn_skip_first2:
  \<open>(\<exists>\<^sub>Aba bb. f bb * \<up>(P ba bb)) = (\<exists>\<^sub>Abb. f bb * \<up>(\<exists>ba. P ba bb))\<close>
  \<open>(\<exists>\<^sub>Abb ba. f bb * \<up>(P ba bb)) = (\<exists>\<^sub>Abb. f bb * \<up>(\<exists>ba. P ba bb))\<close>
  apply (subst ex_assn_swap)
  by (subst ex_assn_def, subst (2) ex_assn_def, auto)+

lemma nofail_Down_nofail: \<open>nofail gS \<Longrightarrow> fS \<le> \<Down> R gS \<Longrightarrow> nofail fS\<close>
  using pw_ref_iff by blast

text \<open>This is the refinement version of @{thm WHILEIT_add_post_condition}.\<close>
lemma WHILEIT_refine_with_post:
  assumes R0: "I' x' \<Longrightarrow> (x,x')\<in>R"
  assumes IREF: "\<And>x x'. \<lbrakk> (x,x')\<in>R; I' x' \<rbrakk> \<Longrightarrow> I x"
  assumes COND_REF: "\<And>x x'. \<lbrakk> (x,x')\<in>R; I x; I' x' \<rbrakk> \<Longrightarrow> b x = b' x'"
  assumes STEP_REF:
    "\<And>x x'. \<lbrakk> (x,x')\<in>R; b x; b' x'; I x; I' x'; f' x' \<le> SPEC I' \<rbrakk> \<Longrightarrow> f x \<le> \<Down>R (f' x')"
  shows "WHILEIT I b f x \<le>\<Down>R (WHILEIT I' b' f' x')"
  apply (subst (2) WHILEIT_add_post_condition)
  apply (rule WHILEIT_refine)
  subgoal using R0 by blast
  subgoal using IREF by blast
  subgoal using COND_REF by blast
  subgoal using STEP_REF by auto
  done


subsection \<open>Some Refinement\<close>

lemma fr_refl': \<open>A \<Longrightarrow>\<^sub>A B \<Longrightarrow> C * A \<Longrightarrow>\<^sub>A C * B\<close>
  unfolding assn_times_comm[of C]
  by (rule Automation.fr_refl)

lemma Collect_eq_comp: \<open>{(c, a). a = f c} O {(x, y). P x y} = {(c, y). P (f c) y}\<close>
  by auto

lemma Collect_eq_comp_right:
  \<open>{(x, y). P x y} O {(c, a). a = f c} = {(x, c). \<exists>y. P x y \<and> c = f y} \<close>
  by auto

lemma
  shows list_mset_assn_add_mset_Nil:
     \<open>list_mset_assn R (add_mset q Q) [] = false\<close> and
   list_mset_assn_empty_Cons:
    \<open>list_mset_assn R {#} (x # xs) = false\<close>
  unfolding list_mset_assn_def list_mset_rel_def mset_rel_def pure_def p2rel_def
    rel2p_def rel_mset_def br_def
  by (sep_auto simp: Collect_eq_comp)+


lemma list_mset_assn_add_mset_cons_in:
  assumes
    assn: \<open>A \<Turnstile> list_mset_assn R N (ab # list)\<close>
  shows \<open>\<exists>ab'. (ab, ab') \<in> the_pure R \<and> ab' \<in># N \<and> A \<Turnstile> list_mset_assn R (remove1_mset ab' N) (list)\<close>
proof -
  have H: \<open>(\<forall>x x'. (x' = x) = ((x', x) \<in> P')) \<longleftrightarrow> P' = Id\<close> for P'
    by (auto simp: the_pure_def)
  have [simp]: \<open>the_pure (\<lambda>a c. \<up> (c = a)) = Id\<close>
    by (auto simp: the_pure_def H)
  have [iff]: \<open>(ab # list, y) \<in> list_mset_rel \<longleftrightarrow> y = add_mset ab (mset list)\<close> for y ab list
    by (auto simp: list_mset_rel_def br_def)
  obtain N' xs where
    N_N': \<open>N = mset N'\<close> and
    \<open>mset xs = add_mset ab (mset list)\<close> and
    \<open>list_all2 (rel2p (the_pure R)) xs N'\<close>
    using assn by (cases A) (auto simp: list_mset_assn_def mset_rel_def p2rel_def rel_mset_def
        rel2p_def)
  then obtain N'' where
    \<open>list_all2 (rel2p (the_pure R)) (ab # list) N''\<close> and
    \<open>mset N'' = mset N'\<close>
    using list_all2_reorder_left_invariance[of \<open>rel2p (the_pure R)\<close> xs N'
          \<open>ab # list\<close>, unfolded eq_commute[of \<open>mset (ab # list)\<close>]] by auto
  then obtain n N''' where
    n: \<open>add_mset n (mset N''') = mset N''\<close> and
    \<open>(ab, n) \<in> the_pure R\<close> and
    \<open>list_all2 (rel2p (the_pure R)) list N'''\<close>
    by (auto simp: list_all2_Cons1 rel2p_def)
  moreover have \<open>n \<in> set N''\<close>
    using n unfolding mset.simps[symmetric] eq_commute[of \<open>add_mset _ _\<close>] apply -
    by (drule mset_eq_setD) auto
  ultimately have \<open>(ab, n) \<in> the_pure R\<close> and
    \<open>n \<in> set N''\<close> and
    \<open>mset list = mset list\<close> and
    \<open>mset N''' = remove1_mset n (mset N'')\<close> and
    \<open>list_all2 (rel2p (the_pure R)) list N'''\<close>
    by (auto dest: mset_eq_setD simp: eq_commute[of \<open>add_mset _ _\<close>])
  show ?thesis
    unfolding list_mset_assn_def mset_rel_def p2rel_def rel_mset_def
      list.rel_eq list_mset_rel_def
      br_def N_N'
    using assn \<open>(ab, n) \<in> the_pure R\<close>  \<open>n \<in> set N''\<close>  \<open>mset N'' = mset N'\<close>
      \<open>list_all2 (rel2p (the_pure R)) list N'''\<close>
        \<open>mset N'' = mset N'\<close> \<open>mset N''' = remove1_mset n (mset N'')\<close>
    by (cases A) (auto simp: list_mset_assn_def mset_rel_def p2rel_def rel_mset_def
        add_mset_eq_add_mset list.rel_eq
        intro!: exI[of _ n]
        dest: mset_eq_setD)
qed

lemma list_mset_assn_empty_nil: \<open>list_mset_assn R {#} [] = emp\<close>
  by (auto simp: list_mset_assn_def list_mset_rel_def mset_rel_def
      br_def p2rel_def rel2p_def Collect_eq_comp rel_mset_def
      pure_def)

lemma no_fail_spec_le_RETURN_itself: \<open>nofail f \<Longrightarrow> f \<le> SPEC(\<lambda>x. RETURN x \<le> f)\<close>
  by (metis RES_rule nres_order_simps(21) the_RES_inv)

lemma refine_add_invariants':
  assumes
    \<open>f S \<le> \<Down> {(S, S'). Q' S S' \<and> Q S} gS\<close> and
    \<open>y \<le> \<Down> {((i, S), S'). P i S S'} (f S)\<close> and
    \<open>nofail gS\<close>
  shows \<open>y \<le> \<Down> {((i, S), S'). P i S S' \<and> Q S'} (f S)\<close>
  using assms unfolding pw_le_iff pw_conc_inres pw_conc_nofail
  by force

lemma "weaken_\<Down>": \<open>R' \<subseteq> R \<Longrightarrow> f \<le> \<Down> R' g \<Longrightarrow> f \<le> \<Down> R g\<close>
  by (meson pw_ref_iff subset_eq)

method match_Down =
  (match conclusion in \<open>f \<le> \<Down> R g\<close> for f g R \<Rightarrow>
    \<open>match premises in I: \<open>f \<le> \<Down> R' g\<close> for R'
       \<Rightarrow> \<open>rule "weaken_\<Down>"[OF _ I]\<close>\<close>)


lemma refine_SPEC_refine_Down:
  \<open>f \<le> SPEC C \<longleftrightarrow> f \<le> \<Down> {(T', T). T = T' \<and> C T'} (SPEC C)\<close>
  apply (rule iffI)
  subgoal
    by (rule SPEC_refine)  auto
  subgoal
    by (metis (no_types, lifting) RETURN_ref_SPECD SPEC_cons_rule dual_order.trans
        in_pair_collect_simp no_fail_spec_le_RETURN_itself nofail_Down_nofail nofail_simps(2))
  done



subsection \<open>More declarations\<close>

(* TODO: only input notation? *)
notation prod_rel_syn (infixl "\<times>\<^sub>f" 70)

lemma is_Nil_is_empty[sepref_fr_rules]:
  \<open>(return o is_Nil, RETURN o Multiset.is_empty) \<in> (list_mset_assn R)\<^sup>k \<rightarrow>\<^sub>a bool_assn\<close>
  apply sepref_to_hoare
  apply (rename_tac x xi)
    apply (case_tac x)
   by (sep_auto simp: Multiset.is_empty_def list_mset_assn_empty_Cons list_mset_assn_add_mset_Nil
      split: list.splits)+

lemma diff_add_mset_remove1: \<open>NO_MATCH {#} N \<Longrightarrow> M - add_mset a N = remove1_mset a (M - N)\<close>
  by auto

lemma list_all2_remove:
  assumes
    uniq: \<open>IS_RIGHT_UNIQUE (p2rel R)\<close> \<open>IS_LEFT_UNIQUE (p2rel R)\<close> and
    Ra: \<open>R a aa\<close> and
    all: \<open>list_all2 R xs ys\<close>
  shows
  \<open>\<exists>xs'. mset xs' = remove1_mset a (mset xs) \<and>
            (\<exists>ys'. mset ys' = remove1_mset aa (mset ys) \<and> list_all2 R xs' ys')\<close>
  using all
proof (induction xs ys rule: list_all2_induct)
  case Nil
  then show ?case by auto
next
  case (Cons x y xs ys) note IH = this(3) and p = this(1, 2)

  have ax: \<open>{#a, x#} = {#x, a#}\<close>
    by auto
  have rem1: \<open>remove1_mset a (remove1_mset x M) = remove1_mset x (remove1_mset a M)\<close> for M
    by (auto simp: ax)
  have H: \<open>x = a \<longleftrightarrow> y = aa\<close>
    using uniq Ra p unfolding single_valued_def IS_LEFT_UNIQUE_def p2rel_def by blast

  obtain xs' ys' where
   \<open>mset xs' = remove1_mset a (mset xs)\<close> and
   \<open>mset ys' = remove1_mset aa (mset ys)\<close> and
   \<open>list_all2 R xs' ys'\<close>
   using IH p by auto
  then show ?case
   apply (cases \<open>x \<noteq> a\<close>)
   subgoal
     using p
     by (auto intro!: exI[of _ \<open>x#xs'\<close>] exI[of _ \<open>y#ys'\<close>]
         simp: diff_add_mset_remove1 rem1 add_mset_remove_trivial_If in_remove1_mset_neq H
         simp del: diff_diff_add_mset)
   subgoal
     using p
     by (fastforce simp: diff_add_mset_remove1 rem1 add_mset_remove_trivial_If in_remove1_mset_neq
         remove_1_mset_id_iff_notin H
         simp del: diff_diff_add_mset)
   done
qed

lemma remove1_remove1_mset:
  assumes uniq: \<open>IS_RIGHT_UNIQUE R\<close> \<open>IS_LEFT_UNIQUE R\<close>
  shows \<open>(uncurry (RETURN oo remove1), uncurry (RETURN oo remove1_mset)) \<in>
    R \<times>\<^sub>r (list_mset_rel O \<langle>R\<rangle> mset_rel) \<rightarrow>\<^sub>f
    \<langle>list_mset_rel O \<langle>R\<rangle> mset_rel\<rangle> nres_rel\<close>
  using list_all2_remove[of \<open>rel2p R\<close>] assms
  by (intro frefI nres_relI) (fastforce simp: list_mset_rel_def br_def mset_rel_def p2rel_def
      rel2p_def[abs_def] rel_mset_def Collect_eq_comp)

lemma
  Nil_list_mset_rel_iff:
    \<open>([], aaa) \<in> list_mset_rel \<longleftrightarrow> aaa = {#}\<close> and
  empty_list_mset_rel_iff:
    \<open>(a, {#}) \<in> list_mset_rel \<longleftrightarrow> a = []\<close>
  by (auto simp: list_mset_rel_def br_def)

lemma ex_assn_up_eq2: \<open>(\<exists>\<^sub>Aba. f ba * \<up> (ba = c)) = (f c)\<close>
  by (simp add: ex_assn_def)

lemma ex_assn_pair_split: \<open>(\<exists>\<^sub>Ab. P b) = (\<exists>\<^sub>Aa b. P (a, b))\<close>
  by (subst ex_assn_def, subst (1) ex_assn_def, auto)+

lemma snd_hnr_pure:
   \<open>CONSTRAINT is_pure B \<Longrightarrow> (return \<circ> snd, RETURN \<circ> snd) \<in> A\<^sup>d *\<^sub>a B\<^sup>k \<rightarrow>\<^sub>a B\<close>
  apply sepref_to_hoare
  apply sep_auto
  by (metis SLN_def SLN_left assn_times_comm ent_pure_pre_iff_sng ent_refl ent_star_mono
      ent_true is_pure_assn_def is_pure_iff_pure_assn)


subsection \<open>List relation\<close>

lemma list_rel_take:
  \<open>(ba, ab) \<in> \<langle>A\<rangle>list_rel \<Longrightarrow> (take b ba, take b ab) \<in> \<langle>A\<rangle>list_rel\<close>
  by (auto simp: list_rel_def)

lemma list_rel_update':
  fixes R
  assumes rel: \<open>(xs, ys) \<in> \<langle>R\<rangle>list_rel\<close> and
   h: \<open>(bi, b) \<in> R\<close>
  shows \<open>(list_update xs ba bi, list_update ys ba b) \<in> \<langle>R\<rangle>list_rel\<close>
proof -
  have [simp]: \<open>(bi, b) \<in> R\<close>
    using h by auto
  have \<open>length xs = length ys\<close>
    using assms list_rel_imp_same_length by blast

  then show ?thesis
    using rel
    by (induction xs ys arbitrary: ba rule: list_induct2) (auto split: nat.splits)
qed

lemma list_rel_update:
  fixes R :: \<open>'a \<Rightarrow> 'b :: {heap}\<Rightarrow> assn\<close>
  assumes rel: \<open>(xs, ys) \<in> \<langle>the_pure R\<rangle>list_rel\<close> and
   h: \<open>h \<Turnstile> A * R b bi\<close> and
   p: \<open>is_pure R\<close>
  shows \<open>(list_update xs ba bi, list_update ys ba b) \<in> \<langle>the_pure R\<rangle>list_rel\<close>
proof -
  obtain R' where R: \<open>the_pure R = R'\<close> and R': \<open>R = pure R'\<close>
    using p by fastforce
  have [simp]: \<open>(bi, b) \<in> the_pure R\<close>
    using h p by (auto simp: mod_star_conv R R')
  have \<open>length xs = length ys\<close>
    using assms list_rel_imp_same_length by blast

  then show ?thesis
    using rel
    by (induction xs ys arbitrary: ba rule: list_induct2) (auto split: nat.splits)
qed


lemma list_rel_in_find_correspondanceE:
  assumes \<open>(M, M') \<in> \<langle>R\<rangle>list_rel\<close> and \<open>L \<in> set M\<close>
  obtains L' where \<open>(L, L') \<in> R\<close> and \<open>L' \<in> set M'\<close>
  using assms[unfolded in_set_conv_decomp] by (auto simp: list_rel_append1
      elim!: list_relE3)

definition list_rel_mset_rel where list_rel_mset_rel_internal:
\<open>list_rel_mset_rel \<equiv> \<lambda>R. \<langle>R\<rangle>list_rel O list_mset_rel\<close>

lemma list_rel_mset_rel_def[refine_rel_defs]:
  \<open>\<langle>R\<rangle>list_rel_mset_rel = \<langle>R\<rangle>list_rel O list_mset_rel\<close>
  unfolding relAPP_def list_rel_mset_rel_internal ..

lemma list_mset_assn_pure_conv:
  \<open>list_mset_assn (pure R) = pure (\<langle>R\<rangle>list_rel_mset_rel)\<close>
  apply (intro ext)
  using list_all2_reorder_left_invariance
  by (fastforce
    simp: list_rel_mset_rel_def list_mset_assn_def
      mset_rel_def rel2p_def[abs_def] rel_mset_def p2rel_def
      list_mset_rel_def[abs_def] Collect_eq_comp br_def
      list_rel_def Collect_eq_comp_right
    intro!: arg_cong[of _ _ \<open>\<lambda>b. pure b _ _\<close>])

lemma list_assn_list_mset_rel_eq_list_mset_assn:
  assumes p: \<open>is_pure R\<close>
  shows \<open>hr_comp (list_assn R) list_mset_rel = list_mset_assn R\<close>
proof -
  define R' where \<open>R' = the_pure R\<close>
  then have R: \<open>R = pure R'\<close>
    using p by auto
  show ?thesis
    apply (auto simp: list_mset_assn_def
        list_assn_pure_conv
        relcomp.simps hr_comp_pure mset_rel_def br_def
        p2rel_def rel2p_def[abs_def] rel_mset_def R list_mset_rel_def list_rel_def)
      using list_all2_reorder_left_invariance by fastforce
  qed

lemma list_rel_mset_rel_imp_same_length: \<open>(a, b) \<in> \<langle>R\<rangle>list_rel_mset_rel \<Longrightarrow> length a = size b\<close>
  by (auto simp: list_rel_mset_rel_def list_mset_rel_def br_def
      dest: list_rel_imp_same_length)


subsection \<open>More Functions, Relations, and Theorems\<close>

lemma id_ref: \<open>(return o id, RETURN o id) \<in> R\<^sup>d \<rightarrow>\<^sub>a R\<close>
  by sepref_to_hoare sep_auto

definition emptied_list :: \<open>'a list \<Rightarrow> 'a list\<close> where
  \<open>emptied_list l = []\<close>

text \<open>This functions deletes all elements of a resizable array, without resizing it.\<close>
definition emptied_arl :: \<open>'a array_list \<Rightarrow> 'a array_list\<close> where
\<open>emptied_arl = (\<lambda>(a, n). (a, 0))\<close>

lemma emptied_arl_refine[sepref_fr_rules]:
  \<open>(return o emptied_arl, RETURN o emptied_list) \<in> (arl_assn R)\<^sup>d \<rightarrow>\<^sub>a arl_assn R\<close>
  unfolding emptied_arl_def emptied_list_def
  by sepref_to_hoare (sep_auto simp: arl_assn_def hr_comp_def is_array_list_def)

lemma bool_assn_alt_def: \<open>bool_assn a b = \<up> (a = b)\<close>
  unfolding pure_def by auto

lemma nempty_list_mset_rel_iff: \<open>M \<noteq> {#} \<Longrightarrow>
  (xs, M) \<in> list_mset_rel \<longleftrightarrow> (xs \<noteq> [] \<and> hd xs \<in># M \<and>
         (tl xs, remove1_mset (hd xs) M) \<in> list_mset_rel)\<close>
  by (cases xs) (auto simp: list_mset_rel_def br_def dest!: multi_member_split)

lemma Down_itself_via_SPEC:
  assumes \<open>I \<le> SPEC P\<close> and \<open>\<And>x. P x \<Longrightarrow> (x, x) \<in> R\<close>
  shows \<open>I \<le> \<Down> R I\<close>
  using assms by (meson inres_SPEC pw_ref_I)

lemma bind_if_inverse:
  \<open>do {
    S \<leftarrow> H;
    if b then f S else g S
    } =
    (if b then do {S \<leftarrow> H; f S} else do {S \<leftarrow> H; g S})
  \<close> for H :: \<open>'a nres\<close>
  by auto

lemma hfref_imp2: "(\<And>x y. S x y \<Longrightarrow>\<^sub>t S' x y) \<Longrightarrow> [P]\<^sub>a RR \<rightarrow> S \<subseteq> [P]\<^sub>a RR \<rightarrow> S'"
    apply clarsimp
    apply (erule hfref_cons)
    apply (simp_all add: hrp_imp_def)
    done

lemma hr_comp_mono_entails: \<open>B \<subseteq> C \<Longrightarrow> hr_comp a B x y \<Longrightarrow>\<^sub>A hr_comp a C x y\<close>
  unfolding hr_comp_def entails_def
  by auto

lemma hfref_imp_mono_result:
  "B \<subseteq> C \<Longrightarrow> [P]\<^sub>a RR \<rightarrow> hr_comp a B \<subseteq> [P]\<^sub>a RR \<rightarrow> hr_comp a C"
  unfolding hfref_def hn_refine_def
  apply clarify
  subgoal for aa b c aaa
    apply (rule cons_post_rule[of _ _
          \<open>\<lambda>r. snd RR aaa c * (\<exists>\<^sub>Ax. hr_comp a B x r * \<up> (RETURN x \<le> b aaa)) * true\<close>])
     apply (solves auto)
    using hr_comp_mono_entails[of B C a ]
    apply (auto intro!: ent_ex_preI)
    apply (rule_tac x=xa in ent_ex_postI)
    apply (auto intro!: ent_star_mono ac_simps)
    done
  done

lemma hfref_imp_mono_result2:
  "(\<And>x. P L x \<Longrightarrow> B L \<subseteq> C L) \<Longrightarrow> [P L]\<^sub>a RR \<rightarrow> hr_comp a (B L) \<subseteq> [P L]\<^sub>a RR \<rightarrow> hr_comp a (C L)"
  unfolding hfref_def hn_refine_def
  apply clarify
  subgoal for aa b c aaa
    apply (rule cons_post_rule[of _ _
          \<open>\<lambda>r. snd RR aaa c * (\<exists>\<^sub>Ax. hr_comp a (B L) x r * \<up> (RETURN x \<le> b aaa)) * true\<close>])
     apply (solves auto)
    using hr_comp_mono_entails[of \<open>B L\<close> \<open>C L\<close> a ]
    apply (auto intro!: ent_ex_preI)
    apply (rule_tac x=xa in ent_ex_postI)
    apply (auto intro!: ent_star_mono ac_simps)
    done
  done

lemma hfref_weaken_change_pre:
  assumes "(f,h) \<in> hfref P R S"
  assumes "\<And>x. P x \<Longrightarrow> (fst R x, snd R x) = (fst R' x, snd R' x)"
  assumes "\<And>y x. S y x \<Longrightarrow>\<^sub>t S' y x"
  shows "(f,h) \<in> hfref P R' S'"
proof -
  have \<open>(f,h) \<in> hfref P R' S\<close>
    using assms
    by (auto simp: hfref_def)
  then show ?thesis
    using hfref_imp2[of S S' P R'] assms(3) by auto
qed


subsubsection \<open>Ghost parameters\<close>
text \<open>
  This is a trick to recover from consumption of a variable (\<^term>\<open>\<A>\<^sub>i\<^sub>n\<close>) that is passed as
  argument and destroyed by the initialisation: We copy it as a zero-cost
  (by creating a \<^term>\<open>()\<close>), because we don't need it in the code and only in the specification.

  This is a way to have ghost parameters, without having them: The parameter is replaced by \<^term>\<open>()\<close>
  and we hope that the compiler will do the right thing.
\<close>
definition virtual_copy where
  [simp]: \<open>virtual_copy = id\<close>

definition virtual_copy_rel where
  \<open>virtual_copy_rel = {(c, b). c = ()}\<close>

abbreviation ghost_assn where
  \<open>ghost_assn \<equiv> hr_comp unit_assn virtual_copy_rel\<close>

lemma [sepref_fr_rules]:
 \<open>(return o (\<lambda>_. ()), RETURN o virtual_copy) \<in> R\<^sup>k \<rightarrow>\<^sub>a ghost_assn\<close>
 by sepref_to_hoare (sep_auto simp: virtual_copy_rel_def)

lemma bind_cong_nres: \<open>(\<And>x. g x = g' x) \<Longrightarrow> (do {a \<leftarrow> f :: 'a nres;  g a}) = (do {a \<leftarrow> f :: 'a nres;  g' a})\<close>
  by auto

lemma case_prod_cong:
  \<open>(\<And>a b. f a b = g a b) \<Longrightarrow> (case x of (a, b) \<Rightarrow> f a b) = (case x of (a, b) \<Rightarrow> g a b)\<close>
  by (cases x) auto

lemma if_replace_cond: \<open>(if b then P b else Q b) = (if b then P True else Q False)\<close>
  by auto

lemma nfoldli_cong2:
  assumes
    le: \<open>length l = length l'\<close> and
    \<sigma>: \<open>\<sigma> = \<sigma>'\<close> and
    c: \<open>c = c'\<close> and
    H: \<open>\<And>\<sigma> x. x < length l \<Longrightarrow> c' \<sigma> \<Longrightarrow> f (l ! x) \<sigma> = f' (l' ! x) \<sigma>\<close>
  shows \<open>nfoldli l c f \<sigma> = nfoldli l' c' f' \<sigma>'\<close>
proof -
  show ?thesis
    using le H unfolding c[symmetric] \<sigma>[symmetric]
  proof (induction l arbitrary: l' \<sigma>)
    case Nil
    then show ?case by simp
  next
    case (Cons a l l'') note IH=this(1) and le = this(2) and H = this(3)
    show ?case
      using le H[of \<open>Suc _\<close>] H[of 0] IH[of \<open>tl l''\<close> \<open>_\<close>]
      by (cases l'')
        (auto intro: bind_cong_nres)
  qed
qed

lemma nfoldli_nfoldli_list_nth:
  \<open>nfoldli xs c P a = nfoldli [0..<length xs] c (\<lambda>i. P (xs ! i)) a\<close>
proof (induction xs arbitrary: a)
  case Nil
  then show ?case by auto
next
  case (Cons x xs) note IH = this(1)
  have 1: \<open>[0..<length (x # xs)] = 0 # [1..<length (x#xs)]\<close>
    by (subst upt_rec)  simp
  have 2: \<open>[1..<length (x#xs)] = map Suc [0..<length xs]\<close>
    by (induction xs) auto
  have AB: \<open>nfoldli [0..<length (x # xs)] c (\<lambda>i. P ((x # xs) ! i)) a =
      nfoldli (0 # [1..<length (x#xs)]) c (\<lambda>i. P ((x # xs) ! i)) a\<close>
      (is \<open>?A = ?B\<close>)
    unfolding 1 ..
  {
    assume [simp]: \<open>c a\<close>
    have \<open>nfoldli (0 # [1..<length (x#xs)]) c (\<lambda>i. P ((x # xs) ! i)) a =
       do {
         \<sigma> \<leftarrow> (P x a);
         nfoldli [1..<length (x#xs)] c (\<lambda>i. P ((x # xs) ! i)) \<sigma>
        }\<close>
      by simp
    moreover have \<open>nfoldli [1..<length (x#xs)] c (\<lambda>i. P ((x # xs) ! i)) \<sigma>  =
       nfoldli [0..<length xs] c (\<lambda>i. P (xs ! i)) \<sigma>\<close> for \<sigma>
      unfolding 2
      by (rule nfoldli_cong2) auto
    ultimately have \<open>?A = do {
         \<sigma> \<leftarrow> (P x a);
         nfoldli [0..<length xs] c (\<lambda>i. P (xs ! i))  \<sigma>
        }\<close>
      using AB
      by (auto intro: bind_cong_nres)
  }
  moreover {
    assume [simp]: \<open>\<not>c a\<close>
    have \<open>?B = RETURN a\<close>
      by simp
  }
  ultimately show ?case by (auto simp: IH intro: bind_cong_nres)
qed


lemma foldli_cong2:
  assumes
    le: \<open>length l = length l'\<close> and
    \<sigma>: \<open>\<sigma> = \<sigma>'\<close> and
    c: \<open>c = c'\<close> and
    H: \<open>\<And>\<sigma> x. x < length l \<Longrightarrow> c' \<sigma> \<Longrightarrow> f (l ! x) \<sigma> = f' (l' ! x) \<sigma>\<close>
  shows \<open>foldli l c f \<sigma> = foldli l' c' f' \<sigma>'\<close>
proof -
  show ?thesis
    using le H unfolding c[symmetric] \<sigma>[symmetric]
  proof (induction l arbitrary: l' \<sigma>)
    case Nil
    then show ?case by simp
  next
    case (Cons a l l'') note IH=this(1) and le = this(2) and H = this(3)
    show ?case
      using le H[of \<open>Suc _\<close>] H[of 0] IH[of \<open>tl l''\<close> \<open>f' (hd l'') \<sigma>\<close>]
      by (cases l'') auto
  qed
qed

lemma foldli_foldli_list_nth:
  \<open>foldli xs c P a = foldli [0..<length xs] c (\<lambda>i. P (xs ! i)) a\<close>
proof (induction xs arbitrary: a)
  case Nil
  then show ?case by auto
next
  case (Cons x xs) note IH = this(1)
  have 1: \<open>[0..<length (x # xs)] = 0 # [1..<length (x#xs)]\<close>
    by (subst upt_rec)  simp
  have 2: \<open>[1..<length (x#xs)] = map Suc [0..<length xs]\<close>
    by (induction xs) auto
  have AB: \<open>foldli [0..<length (x # xs)] c (\<lambda>i. P ((x # xs) ! i)) a =
      foldli (0 # [1..<length (x#xs)]) c (\<lambda>i. P ((x # xs) ! i)) a\<close>
      (is \<open>?A = ?B\<close>)
    unfolding 1 ..
  {
    assume [simp]: \<open>c a\<close>
    have \<open>foldli (0 # [1..<length (x#xs)]) c (\<lambda>i. P ((x # xs) ! i)) a =
       foldli [1..<length (x#xs)] c (\<lambda>i. P ((x # xs) ! i)) (P x a)\<close>
      by simp
    also have \<open>\<dots>  = foldli [0..<length xs] c (\<lambda>i. P (xs ! i)) (P x a)\<close>
      unfolding 2
      by (rule foldli_cong2) auto
    finally have \<open>?A = foldli [0..<length xs] c (\<lambda>i. P (xs ! i)) (P x a)\<close>
      using AB
      by simp
  }
  moreover {
    assume [simp]: \<open>\<not>c a\<close>
    have \<open>?B = a\<close>
      by simp
  }
  ultimately show ?case by (auto simp: IH)
qed


lemma (in -)WHILEIT_rule_stronger_inv_RES':
  assumes
    \<open>wf R\<close> and
    \<open>I s\<close> and
    \<open>I' s\<close>
    \<open>\<And>s. I s \<Longrightarrow> I' s \<Longrightarrow> b s \<Longrightarrow> f s \<le> SPEC (\<lambda>s'. I s' \<and>  I' s' \<and> (s', s) \<in> R)\<close> and
   \<open>\<And>s. I s \<Longrightarrow> I' s \<Longrightarrow> \<not> b s \<Longrightarrow> RETURN s \<le> \<Down> H (RES \<Phi>)\<close>
 shows \<open>WHILE\<^sub>T\<^bsup>I\<^esup> b f s \<le> \<Down> H (RES \<Phi>)\<close>
proof -
  have RES_SPEC: \<open>RES \<Phi> = SPEC(\<lambda>s. s \<in> \<Phi>)\<close>
    by auto
  have \<open>WHILE\<^sub>T\<^bsup>I\<^esup> b f s \<le> WHILE\<^sub>T\<^bsup>\<lambda>s. I s \<and> I' s\<^esup> b f s\<close>
    by (metis (mono_tags, lifting) WHILEIT_weaken)
  also have \<open>WHILE\<^sub>T\<^bsup>\<lambda>s. I s \<and> I' s\<^esup> b f s \<le> \<Down> H (RES \<Phi>)\<close>
    unfolding RES_SPEC conc_fun_SPEC
    apply (rule WHILEIT_rule[OF assms(1)])
    subgoal using assms(2,3) by auto
    subgoal using assms(4) by auto
    subgoal using assms(5) unfolding RES_SPEC conc_fun_SPEC by auto
    done
  finally show ?thesis .
qed

lemma RES_RES13_RETURN_RES: \<open>do {
  (M, N, D, Q, W, vm, \<phi>, clvls, cach, lbd, outl, stats, fast_ema, slow_ema, ccount,
       vdom, avdom, lcount) \<leftarrow> RES A;
  RES (f M N D Q W vm \<phi> clvls cach lbd outl stats fast_ema slow_ema ccount
      vdom avdom lcount)
} = RES (\<Union>(M, N, D, Q, W, vm, \<phi>, clvls, cach, lbd, outl, stats, fast_ema, slow_ema, ccount,
       vdom, avdom, lcount)\<in>A. f M N D Q W vm \<phi> clvls cach lbd outl stats fast_ema slow_ema ccount
      vdom avdom lcount)\<close>
  by (force simp:  pw_eq_iff refine_pw_simps uncurry_def)

lemma id_mset_list_assn_list_mset_assn:
  assumes \<open>CONSTRAINT is_pure R\<close>
  shows \<open>(return o id, RETURN o mset) \<in> (list_assn R)\<^sup>d \<rightarrow>\<^sub>a list_mset_assn R\<close>
proof -
  obtain R' where R: \<open>R = pure R'\<close>
    using assms is_pure_conv unfolding CONSTRAINT_def by blast
  then have R': \<open>the_pure R = R'\<close>
    unfolding R by auto
  show ?thesis
    apply (subst R)
    apply (subst list_assn_pure_conv)
    apply sepref_to_hoare
    by (sep_auto simp: list_mset_assn_def R' pure_def list_mset_rel_def mset_rel_def
       p2rel_def rel2p_def[abs_def] rel_mset_def br_def Collect_eq_comp list_rel_def)
qed

lemma RES_SPEC_conv: \<open>RES P = SPEC (\<lambda>v. v \<in> P)\<close>
  by auto

lemma add_invar_refineI_P: \<open>A \<le> \<Down> {(x,y). R x y} B \<Longrightarrow> (nofail A \<Longrightarrow>A \<le> SPEC P) \<Longrightarrow> A \<le> \<Down> {(x,y). R x y \<and> P x} B\<close>
  using add_invar_refineI[of \<open>\<lambda>_. A\<close> _  _ \<open>\<lambda>_. B\<close> P, where R=\<open>{(x,y). R x y}\<close> and I=P]
  by auto


subsection \<open>Sorting\<close>

text \<open>Remark that we do not \<^emph>\<open>prove\<close> that the sorting in correct, since we do not care about the
 correctness, only the fact that it is reordered. (Based on wikipedia's algorithm.)
Typically \<^term>\<open>R\<close> would be \<^term>\<open>(<)\<close>\<close>
definition insert_sort_inner :: \<open>('b \<Rightarrow> 'b \<Rightarrow> bool) \<Rightarrow> ('a list \<Rightarrow> nat \<Rightarrow> 'b) \<Rightarrow> 'a list \<Rightarrow>  nat \<Rightarrow> 'a list nres\<close> where
  \<open>insert_sort_inner R f xs i = do {
     (j, ys) \<leftarrow> WHILE\<^sub>T\<^bsup>\<lambda>(j, ys). j \<ge> 0 \<and> mset xs = mset ys \<and> j < length ys\<^esup>
         (\<lambda>(j, ys). j > 0 \<and> R (f ys j) (f ys (j - 1)))
         (\<lambda>(j, ys). do {
             ASSERT(j < length ys);
             ASSERT(j > 0);
             ASSERT(j-1 < length ys);
             let xs = swap ys j (j - 1);
             RETURN (j-1, xs)
           }
         )
        (i, xs);
     RETURN ys
  }\<close>


(* A check: *)
lemma \<open>RETURN [Suc 0, 2, 0] = insert_sort_inner (<) (\<lambda>remove n. remove ! n) [2::nat, 1, 0] 1\<close>
  by (simp add: WHILEIT_unfold insert_sort_inner_def swap_def)

definition reorder_remove :: \<open>'b \<Rightarrow> 'a list \<Rightarrow> 'a list nres\<close> where
\<open>reorder_remove _ removed = SPEC (\<lambda>removed'. mset removed' = mset removed)\<close>

definition insert_sort :: \<open>('b \<Rightarrow> 'b \<Rightarrow> bool) \<Rightarrow> ('a list \<Rightarrow> nat \<Rightarrow> 'b) \<Rightarrow> 'a list \<Rightarrow> 'a list nres\<close> where
  \<open>insert_sort R f xs = do {
     (i, ys) \<leftarrow> WHILE\<^sub>T\<^bsup>\<lambda>(i, ys). (ys = [] \<or> i \<le> length ys) \<and> mset xs = mset ys\<^esup>
        (\<lambda>(i, ys). i < length ys)
        (\<lambda>(i, ys). do {
            ASSERT(i < length ys);
            ys \<leftarrow> insert_sort_inner R f ys i;
            RETURN (i+1, ys)
          })
        (1, xs);
     RETURN ys
  }\<close>

lemma insert_sort_inner:
   \<open>(uncurry (insert_sort_inner R f), uncurry (\<lambda>m m'. reorder_remove m' m)) \<in>
      [\<lambda>(xs, i). i < length xs]\<^sub>f \<langle>Id:: ('a \<times> 'a) set\<rangle>list_rel \<times>\<^sub>r nat_rel \<rightarrow> \<langle>Id\<rangle> nres_rel\<close>
  unfolding insert_sort_inner_def uncurry_def reorder_remove_def
  apply (intro frefI nres_relI)
  apply clarify
  apply (refine_vcg WHILEIT_rule[where R = \<open>measure (\<lambda>(i, _). i)\<close>])
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by (auto dest: mset_eq_length)
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  done

lemma insert_sort_reorder_remove:
  \<open>(insert_sort R f, reorder_remove vm) \<in> \<langle>Id\<rangle>list_rel \<rightarrow>\<^sub>f \<langle>Id\<rangle> nres_rel\<close>
proof -
  have H: \<open>ba < length aa \<Longrightarrow> insert_sort_inner R f aa ba \<le> SPEC (\<lambda>m'. mset m' = mset aa)\<close>
    for ba aa
    using insert_sort_inner[unfolded fref_def nres_rel_def reorder_remove_def, simplified]
    by fast
  show ?thesis
    unfolding insert_sort_def reorder_remove_def
    apply (intro frefI nres_relI)
    apply (refine_vcg WHILEIT_rule[where R = \<open>measure (\<lambda>(i, ys). length ys - i)\<close>] H)
    subgoal by auto
    subgoal by auto
    subgoal by auto
    subgoal by auto
    subgoal by (auto dest: mset_eq_length)
    subgoal by auto
    subgoal by (auto dest!: mset_eq_length)
    subgoal by auto
    done
qed

definition arl_replicate where
 "arl_replicate init_cap x \<equiv> do {
    let n = max init_cap minimum_capacity;
    a \<leftarrow> Array.new n x;
    return (a,init_cap)
  }"

definition \<open>op_arl_replicate = op_list_replicate\<close>
lemma arl_fold_custom_replicate:
  \<open>replicate = op_arl_replicate\<close>
  unfolding op_arl_replicate_def op_list_replicate_def ..

lemma list_replicate_arl_hnr[sepref_fr_rules]:
  assumes p: \<open>CONSTRAINT is_pure R\<close>
  shows \<open>(uncurry arl_replicate, uncurry (RETURN oo op_arl_replicate)) \<in> nat_assn\<^sup>k *\<^sub>a R\<^sup>k \<rightarrow>\<^sub>a arl_assn R\<close>
proof -
  obtain R' where
     R'[symmetric]: \<open>R' = the_pure R\<close> and
     R_R': \<open>R = pure R'\<close>
    using assms by fastforce
  have [simp]: \<open>pure R' b bi = \<up>((bi, b) \<in> R')\<close> for b bi
    by (auto simp: pure_def)
  have [simp]: \<open>min a (max a 16) = a\<close> for a :: nat
    by auto
  show ?thesis
    using assms unfolding op_arl_replicate_def
    by sepref_to_hoare
      (sep_auto simp: arl_replicate_def arl_assn_def hr_comp_def R' R_R' list_rel_def
        is_array_list_def minimum_capacity_def
        intro!: list_all2_replicate)
qed

lemma option_bool_assn_direct_eq_hnr:
  \<open>(uncurry (return oo (=)), uncurry (RETURN oo (=))) \<in>
    (option_assn bool_assn)\<^sup>k *\<^sub>a (option_assn bool_assn)\<^sup>k \<rightarrow>\<^sub>a bool_assn\<close>
  by sepref_to_hoare (sep_auto simp: option_assn_alt_def split:option.splits)

text \<open>This function does not change the size of the underlying array.\<close>
definition take1 where
  \<open>take1 xs = take 1 xs\<close>

lemma take1_hnr[sepref_fr_rules]:
  \<open>(return o (\<lambda>(a, _). (a, 1::nat)), RETURN o take1) \<in> [\<lambda>xs. xs \<noteq> []]\<^sub>a (arl_assn R)\<^sup>d \<rightarrow> arl_assn R\<close>
  apply sepref_to_hoare
  apply (sep_auto simp: arl_assn_def hr_comp_def take1_def list_rel_def
      is_array_list_def)
  apply (case_tac b; case_tac x; case_tac l')
   apply (auto)
  done

text \<open>The following two abbreviation are variants from \<^term>\<open>uncurry4\<close> and
   \<^term>\<open>uncurry6\<close>. The problem is that \<^term>\<open>uncurry2 (uncurry2 f)\<close> and
   \<^term>\<open>uncurry (uncurry3 f)\<close> are the same term, but only the latter is folded
   to \<^term>\<open>uncurry4\<close>.\<close>
abbreviation uncurry4' where
  "uncurry4' f \<equiv> uncurry2 (uncurry2 f)"

abbreviation uncurry6' where
  "uncurry6' f \<equiv> uncurry2 (uncurry4' f)"

lemma Down_id_eq: "\<Down> Id a = a"
  by auto


definition find_in_list_between :: \<open>('a \<Rightarrow> bool) \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> 'a list \<Rightarrow> nat option nres\<close> where
  \<open>find_in_list_between P a b C = do {
      (x, _) \<leftarrow> WHILE\<^sub>T\<^bsup>\<lambda>(found, i). i \<ge> a \<and> i \<le> length C \<and> i \<le> b \<and> (\<forall>j\<in>{a..<i}. \<not>P (C!j)) \<and>
        (\<forall>j. found = Some j \<longrightarrow> (i = j \<and> P (C ! j) \<and> j < b \<and> j \<ge> a))\<^esup>
        (\<lambda>(found, i). found = None \<and> i < b)
        (\<lambda>(_, i). do {
          ASSERT(i < length C);
          if P (C!i) then RETURN (Some i, i) else RETURN (None, i+1)
        })
        (None, a);
      RETURN x
  }\<close>

lemma find_in_list_between_spec:
  assumes \<open>a \<le> length C\<close> and \<open>b \<le> length C\<close> and \<open>a \<le> b\<close>
  shows
    \<open>find_in_list_between P a b C \<le> SPEC(\<lambda>i.
       (i \<noteq> None \<longrightarrow>  P (C ! the i) \<and> the i \<ge> a \<and> the i < b) \<and>
       (i = None \<longrightarrow> (\<forall>j. j \<ge> a \<longrightarrow> j < b \<longrightarrow> \<not>P (C!j))))\<close>
  unfolding find_in_list_between_def
  apply (refine_vcg WHILEIT_rule[where R = \<open>measure (\<lambda>(f, i). Suc (length C) - (i + (if f = None then 0 else 1)))\<close>])
  subgoal by auto
  subgoal by auto
  subgoal using assms by auto
  subgoal using assms by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal using assms by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by (auto simp: less_Suc_eq)
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  subgoal by auto
  done

end
