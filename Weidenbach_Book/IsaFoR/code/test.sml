
structure Uint : sig
  val set_bit : Word.word -> IntInf.int -> bool -> Word.word
  val shiftl : Word.word -> IntInf.int -> Word.word
  val shiftr : Word.word -> IntInf.int -> Word.word
  val shiftr_signed : Word.word -> IntInf.int -> Word.word
  val test_bit : Word.word -> IntInf.int -> bool
end = struct

fun set_bit x n b =
  let val mask = Word.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))
  in if b then Word.orb (x, mask)
     else Word.andb (x, Word.notb mask)
  end

fun shiftl x n =
  Word.<< (x, Word.fromLargeInt (IntInf.toLarge n))

fun shiftr x n =
  Word.>> (x, Word.fromLargeInt (IntInf.toLarge n))

fun shiftr_signed x n =
  Word.~>> (x, Word.fromLargeInt (IntInf.toLarge n))

fun test_bit x n =
  Word.andb (x, Word.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))) <> Word.fromInt 0

end; (* struct Uint *)

(* Test that words can handle numbers between 0 and 31 *)
val _ = if 5 <= Word.wordSize then () else raise (Fail ("wordSize less than 5"));

structure Uint32 : sig
  val set_bit : Word32.word -> IntInf.int -> bool -> Word32.word
  val shiftl : Word32.word -> IntInf.int -> Word32.word
  val shiftr : Word32.word -> IntInf.int -> Word32.word
  val shiftr_signed : Word32.word -> IntInf.int -> Word32.word
  val test_bit : Word32.word -> IntInf.int -> bool
end = struct

fun set_bit x n b =
  let val mask = Word32.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))
  in if b then Word32.orb (x, mask)
     else Word32.andb (x, Word32.notb mask)
  end

fun shiftl x n =
  Word32.<< (x, Word.fromLargeInt (IntInf.toLarge n))

fun shiftr x n =
  Word32.>> (x, Word.fromLargeInt (IntInf.toLarge n))

fun shiftr_signed x n =
  Word32.~>> (x, Word.fromLargeInt (IntInf.toLarge n))

fun test_bit x n =
  Word32.andb (x, Word32.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))) <> Word32.fromInt 0

end; (* struct Uint32 *)

(* Test that words can handle numbers between 0 and 63 *)
val _ = if 6 <= Word.wordSize then () else raise (Fail ("wordSize less than 6"));

structure Uint64 : sig
  eqtype uint64;
  val zero : uint64;
  val one : uint64;
  val fromInt : IntInf.int -> uint64;
  val toInt : uint64 -> IntInf.int;
  val toLarge : uint64 -> LargeWord.word;
  val fromLarge : LargeWord.word -> uint64
  val plus : uint64 -> uint64 -> uint64;
  val minus : uint64 -> uint64 -> uint64;
  val times : uint64 -> uint64 -> uint64;
  val divide : uint64 -> uint64 -> uint64;
  val modulus : uint64 -> uint64 -> uint64;
  val negate : uint64 -> uint64;
  val less_eq : uint64 -> uint64 -> bool;
  val less : uint64 -> uint64 -> bool;
  val notb : uint64 -> uint64;
  val andb : uint64 -> uint64 -> uint64;
  val orb : uint64 -> uint64 -> uint64;
  val xorb : uint64 -> uint64 -> uint64;
  val shiftl : uint64 -> IntInf.int -> uint64;
  val shiftr : uint64 -> IntInf.int -> uint64;
  val shiftr_signed : uint64 -> IntInf.int -> uint64;
  val set_bit : uint64 -> IntInf.int -> bool -> uint64;
  val test_bit : uint64 -> IntInf.int -> bool;
end = struct

type uint64 = Word64.word;

val zero = (0wx0 : uint64);

val one = (0wx1 : uint64);

fun fromInt x = Word64.fromLargeInt (IntInf.toLarge x);

fun toInt x = IntInf.fromLarge (Word64.toLargeInt x);

fun fromLarge x = Word64.fromLarge x;

fun toLarge x = Word64.toLarge x;

fun plus x y = Word64.+(x, y);

fun minus x y = Word64.-(x, y);

fun negate x = Word64.~(x);

fun times x y = Word64.*(x, y);

fun divide x y = Word64.div(x, y);

fun modulus x y = Word64.mod(x, y);

fun less_eq x y = Word64.<=(x, y);

fun less x y = Word64.<(x, y);

fun set_bit x n b =
  let val mask = Word64.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))
  in if b then Word64.orb (x, mask)
     else Word64.andb (x, Word64.notb mask)
  end

fun shiftl x n =
  Word64.<< (x, Word.fromLargeInt (IntInf.toLarge n))

fun shiftr x n =
  Word64.>> (x, Word.fromLargeInt (IntInf.toLarge n))

fun shiftr_signed x n =
  Word64.~>> (x, Word.fromLargeInt (IntInf.toLarge n))

fun test_bit x n =
  Word64.andb (x, Word64.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))) <> Word64.fromInt 0

val notb = Word64.notb

fun andb x y = Word64.andb(x, y);

fun orb x y = Word64.orb(x, y);

fun xorb x y = Word64.xorb(x, y);

end (*struct Uint64*)



structure STArray = struct

datatype 'a Cell = Invalid | Value of 'a array;

exception AccessedOldVersion;

type 'a array = 'a Cell Unsynchronized.ref;

fun fromList l = Unsynchronized.ref (Value (Array.fromList l));
fun array (size, v) = Unsynchronized.ref (Value (Array.array (size,v)));
fun tabulate (size, f) = Unsynchronized.ref (Value (Array.tabulate(size, f)));
fun sub (Unsynchronized.ref Invalid, idx) = raise AccessedOldVersion |
    sub (Unsynchronized.ref (Value a), idx) = Array.sub (a,idx);
fun update (aref,idx,v) =
  case aref of
    (Unsynchronized.ref Invalid) => raise AccessedOldVersion |
    (Unsynchronized.ref (Value a)) => (
      aref := Invalid;
      Array.update (a,idx,v);
      Unsynchronized.ref (Value a)
    );

fun length (Unsynchronized.ref Invalid) = raise AccessedOldVersion |
    length (Unsynchronized.ref (Value a)) = Array.length a

fun grow (aref, i, x) = case aref of
  (Unsynchronized.ref Invalid) => raise AccessedOldVersion |
  (Unsynchronized.ref (Value a)) => (
    let val len=Array.length a;
        val na = Array.array (len+i,x)
    in
      aref := Invalid;
      Array.copy {src=a, dst=na, di=0};
      Unsynchronized.ref (Value na)
    end
    );

fun shrink (aref, sz) = case aref of
  (Unsynchronized.ref Invalid) => raise AccessedOldVersion |
  (Unsynchronized.ref (Value a)) => (
    if sz > Array.length a then
      raise Size
    else (
      aref:=Invalid;
      Unsynchronized.ref (Value (Array.tabulate (sz,fn i => Array.sub (a,i))))
    )
  );

structure IsabelleMapping = struct
type 'a ArrayType = 'a array;

fun new_array (a:'a) (n:IntInf.int) = array (IntInf.toInt n, a);

fun array_length (a:'a ArrayType) = IntInf.fromInt (length a);

fun array_get (a:'a ArrayType) (i:IntInf.int) = sub (a, IntInf.toInt i);

fun array_set (a:'a ArrayType) (i:IntInf.int) (e:'a) = update (a, IntInf.toInt i, e);

fun array_of_list (xs:'a list) = fromList xs;

fun array_grow (a:'a ArrayType) (i:IntInf.int) (x:'a) = grow (a, IntInf.toInt i, x);

fun array_shrink (a:'a ArrayType) (sz:IntInf.int) = shrink (a,IntInf.toInt sz);

end;

end;

structure FArray = struct
  datatype 'a Cell = Value of 'a Array.array | Upd of (int*'a*'a Cell Unsynchronized.ref);

  type 'a array = 'a Cell Unsynchronized.ref;

  fun array (size,v) = Unsynchronized.ref (Value (Array.array (size,v)));
  fun tabulate (size, f) = Unsynchronized.ref (Value (Array.tabulate(size, f)));
  fun fromList l = Unsynchronized.ref (Value (Array.fromList l));

  fun sub (Unsynchronized.ref (Value a), idx) = Array.sub (a,idx) |
      sub (Unsynchronized.ref (Upd (i,v,cr)),idx) =
        if i=idx then v
        else sub (cr,idx);

  fun length (Unsynchronized.ref (Value a)) = Array.length a |
      length (Unsynchronized.ref (Upd (i,v,cr))) = length cr;

  fun realize_aux (aref, v) =
    case aref of
      (Unsynchronized.ref (Value a)) => (
        let
          val len = Array.length a;
          val a' = Array.array (len,v);
        in
          Array.copy {src=a, dst=a', di=0};
          Unsynchronized.ref (Value a')
        end
      ) |
      (Unsynchronized.ref (Upd (i,v,cr))) => (
        let val res=realize_aux (cr,v) in
          case res of
            (Unsynchronized.ref (Value a)) => (Array.update (a,i,v); res)
        end
      );

  fun realize aref =
    case aref of
      (Unsynchronized.ref (Value _)) => aref |
      (Unsynchronized.ref (Upd (i,v,cr))) => realize_aux(aref,v);

  fun update (aref,idx,v) =
    case aref of
      (Unsynchronized.ref (Value a)) => (
        let val nref=Unsynchronized.ref (Value a) in
          aref := Upd (idx,Array.sub(a,idx),nref);
          Array.update (a,idx,v);
          nref
        end
      ) |
      (Unsynchronized.ref (Upd _)) =>
        let val ra = realize_aux(aref,v) in
          case ra of
            (Unsynchronized.ref (Value a)) => Array.update (a,idx,v);
          ra
        end
      ;

  fun grow (aref, inc, x) = case aref of
    (Unsynchronized.ref (Value a)) => (
      let val len=Array.length a;
          val na = Array.array (len+inc,x)
      in
        Array.copy {src=a, dst=na, di=0};
        Unsynchronized.ref (Value na)
      end
      )
  | (Unsynchronized.ref (Upd _)) => (
    grow (realize aref, inc, x)
  );

  fun shrink (aref, sz) = case aref of
    (Unsynchronized.ref (Value a)) => (
      if sz > Array.length a then
        raise Size
      else (
        Unsynchronized.ref (Value (Array.tabulate (sz,fn i => Array.sub (a,i))))
      )
    ) |
    (Unsynchronized.ref (Upd _)) => (
      shrink (realize aref,sz)
    );

structure IsabelleMapping = struct
type 'a ArrayType = 'a array;

fun new_array (a:'a) (n:IntInf.int) = array (IntInf.toInt n, a);

fun array_length (a:'a ArrayType) = IntInf.fromInt (length a);

fun array_get (a:'a ArrayType) (i:IntInf.int) = sub (a, IntInf.toInt i);

fun array_set (a:'a ArrayType) (i:IntInf.int) (e:'a) = update (a, IntInf.toInt i, e);

fun array_of_list (xs:'a list) = fromList xs;

fun array_grow (a:'a ArrayType) (i:IntInf.int) (x:'a) = grow (a, IntInf.toInt i, x);

fun array_shrink (a:'a ArrayType) (sz:IntInf.int) = shrink (a,IntInf.toInt sz);

fun array_get_oo (d:'a) (a:'a ArrayType) (i:IntInf.int) =
  sub (a,IntInf.toInt i) handle Subscript => d

fun array_set_oo (d:(unit->'a ArrayType)) (a:'a ArrayType) (i:IntInf.int) (e:'a) =
  update (a, IntInf.toInt i, e) handle Subscript => d ()

end;
end;





   fun array_blit src si dst di len = (
      src=dst andalso raise Fail ("array_blit: Same arrays");
      ArraySlice.copy {
        di = IntInf.toInt di,
        src = ArraySlice.slice (src,IntInf.toInt si,SOME (IntInf.toInt len)),
        dst = dst})

    fun array_nth_oo v a i () = Array.sub(a,IntInf.toInt i) handle Subscript => v | Overflow => v
    fun array_upd_oo f i x a () = 
      (Array.update(a,IntInf.toInt i,x); a) handle Subscript => f () | Overflow => f ()

    


  structure Statistics : sig
    type stat_entry = string * (unit -> bool) * (unit -> string)
  
    val register_stat : stat_entry -> unit
    val get_active_stats : unit -> (string * string) list
    val pretty_stats : (string * string) list -> string

  end = struct
    type stat_entry = string * (unit -> bool) * (unit -> string)
    val stats : stat_entry list Unsynchronized.ref = Unsynchronized.ref []
  
    fun register_stat e = stats := e :: !stats

    fun get_active_stats () = let
      fun flt [] = []
        | flt ((n,a,s)::l) = if a () then (n,s ()) :: flt l else flt l

    in flt (!stats)
    end

    fun pretty_stats [] = ""
      | pretty_stats ((n,s)::l) = "=== " ^ n ^ " ===\n" ^ s ^ "\n" ^ pretty_stats l
  end

(* Argh! Functors not compatible with ML_val command!
  functor Timer () : sig 
    val reset : unit -> unit
    val start : unit -> unit
    val stop : unit -> unit
    val set : Time.time -> unit
    val get : unit -> Time.time
    val pretty : unit -> string
  end = struct

    open Time;

    val time : Time.time Unsynchronized.ref = Unsynchronized.ref Time.zeroTime
    val running : bool Unsynchronized.ref = Unsynchronized.ref false
    val start_time : Time.time Unsynchronized.ref = Unsynchronized.ref Time.zeroTime
        
    fun reset () = (
      time := Time.zeroTime;
      running := false;
      start_time := Time.zeroTime
    )

    fun start () = 
      if !running then 
        () 
      else (
        running := true;
        start_time := Time.now ()
      )

    fun this_runs_time () = 
      if !running then 
        Time.now () - !start_time 
      else 
        Time.zeroTime

    fun stop () = (
      time := !time + this_runs_time ();
      running := false
    )

    fun get () = !time + this_runs_time ()
    fun set t = time := t - this_runs_time ()
  
    fun pretty () = Time.toString (!time) ^ "s"
  end
  *)



structure Bits_Integer : sig
  val set_bit : IntInf.int -> IntInf.int -> bool -> IntInf.int
  val shiftl : IntInf.int -> IntInf.int -> IntInf.int
  val shiftr : IntInf.int -> IntInf.int -> IntInf.int
  val test_bit : IntInf.int -> IntInf.int -> bool
end = struct

val maxWord = IntInf.pow (2, Word.wordSize);

fun set_bit x n b =
  if n < maxWord then
    if b then IntInf.orb (x, IntInf.<< (1, Word.fromLargeInt (IntInf.toLarge n)))
    else IntInf.andb (x, IntInf.notb (IntInf.<< (1, Word.fromLargeInt (IntInf.toLarge n))))
  else raise (Fail ("Bit index too large: " ^ IntInf.toString n));

fun shiftl x n =
  if n < maxWord then IntInf.<< (x, Word.fromLargeInt (IntInf.toLarge n))
  else raise (Fail ("Shift operand too large: " ^ IntInf.toString n));

fun shiftr x n =
  if n < maxWord then IntInf.~>> (x, Word.fromLargeInt (IntInf.toLarge n))
  else raise (Fail ("Shift operand too large: " ^ IntInf.toString n));

fun test_bit x n =
  if n < maxWord then IntInf.andb (x, IntInf.<< (1, Word.fromLargeInt (IntInf.toLarge n))) <> 0
  else raise (Fail ("Bit index too large: " ^ IntInf.toString n));

end; (*struct Bits_Integer*)

structure Ceta : sig
  type num
  type nat
  type ('a, 'b) sum
  type ('a, 'b) term
  type ('a, 'b) lab
  type xml
  type 'a xml_error
  type ('a, 'b) claim
  type ('a, 'b) input
  type ('a, 'b, 'c) proof
  type cert_result
  type ('b, 'a) tp
  type ('b, 'a) dpp
  type ('b, 'a) ac_dpp
  type ('a, 'b, 'c, 'd) tp_ops_ext
  type ('a, 'b, 'c, 'd) dpp_ops_ext
  type ('a, 'b, 'c, 'd) ac_tp_ops_ext
  type ('a, 'b, 'c, 'd) ac_dpp_ops_ext
  val certify_proof :
    bool ->
      (char list) option ->
        ((((char list), (nat list)) lab, (char list)) claim, (char list)) sum ->
          char list -> cert_result
end = struct

datatype int = Int_of_integer of IntInf.int;

fun integer_of_int (Int_of_integer k) = k;

fun times_inta k l =
  Int_of_integer (IntInf.* (integer_of_int k, integer_of_int l));

val zero_inta : int = Int_of_integer (0 : IntInf.int);

datatype num = One | Bit0 of num | Bit1 of num;

val one_inta : int = Int_of_integer (1 : IntInf.int);

type 'a times = {times : 'a -> 'a -> 'a};
val times = #times : 'a times -> 'a -> 'a -> 'a;

fun apsnd f (x, y) = (x, f y);

fun divmod_integer k l =
  (if ((k : IntInf.int) = (0 : IntInf.int))
    then ((0 : IntInf.int), (0 : IntInf.int))
    else (if IntInf.< ((0 : IntInf.int), l)
           then (if IntInf.< ((0 : IntInf.int), k) then IntInf.divMod ( k, l )
                  else let
                         val (r, s) = IntInf.divMod ( (IntInf.~ k), l );
                       in
                         (if ((s : IntInf.int) = (0 : IntInf.int))
                           then (IntInf.~ r, (0 : IntInf.int))
                           else (IntInf.- (IntInf.~ r, (1 : IntInf.int)),
                                  IntInf.- (l, s)))
                       end)
           else (if ((l : IntInf.int) = (0 : IntInf.int))
                  then ((0 : IntInf.int), k)
                  else apsnd IntInf.~
                         (if IntInf.< (k, (0 : IntInf.int))
                           then IntInf.divMod ( (IntInf.~ k), (IntInf.~ l) )
                           else let
                                  val (r, s) =
                                    IntInf.divMod ( k, (IntInf.~ l) );
                                in
                                  (if ((s : IntInf.int) = (0 : IntInf.int))
                                    then (IntInf.~ r, (0 : IntInf.int))
                                    else (IntInf.- (IntInf.~
              r, (1 : IntInf.int)),
   IntInf.- (IntInf.~ l, s)))
                                end))));

fun fst (x1, x2) = x1;

fun divide_integer k l = fst (divmod_integer k l);

fun snd (x1, x2) = x2;

fun modulo_integer k l = snd (divmod_integer k l);

fun gcd_integer k l =
  IntInf.abs
    (if ((l : IntInf.int) = (0 : IntInf.int)) then k
      else gcd_integer l (modulo_integer (IntInf.abs k) (IntInf.abs l)));

fun lcm_integer a b =
  divide_integer (IntInf.* (IntInf.abs a, IntInf.abs b)) (gcd_integer a b);

fun lcm_inta (Int_of_integer x) (Int_of_integer y) =
  Int_of_integer (lcm_integer x y);

fun gcd_intc (Int_of_integer x) (Int_of_integer y) =
  Int_of_integer (gcd_integer x y);

datatype color = R | B;

datatype ('a, 'b) rbta = Emptya |
  Branch of color * ('a, 'b) rbta * 'a * 'b * ('a, 'b) rbta;

datatype ordera = Eq | Lt | Gt;

type 'a ccompare = {ccompare : ('a -> 'a -> ordera) option};
val ccompare = #ccompare : 'a ccompare -> ('a -> 'a -> ordera) option;

datatype ('b, 'a) mapping_rbt = Mapping_RBTa of ('b, 'a) rbta;

type 'a ceq = {ceq : ('a -> 'a -> bool) option};
val ceq = #ceq : 'a ceq -> ('a -> 'a -> bool) option;

datatype 'a set_dlist = Abs_dlist of 'a list;

datatype 'a set = Collect_set of ('a -> bool) | DList_set of 'a set_dlist |
  RBT_set of ('a, unit) mapping_rbt | Set_Monad of 'a list |
  Complement of 'a set;

type 'a zero = {zerob : 'a};
val zerob = #zerob : 'a zero -> 'a;

type 'a one = {onea : 'a};
val onea = #onea : 'a one -> 'a;

type 'a dvd = {times_dvd : 'a times};
val times_dvd = #times_dvd : 'a dvd -> 'a times;

type 'a gcda =
  {one_gcd : 'a one, zero_gcd : 'a zero, dvd_gcd : 'a dvd,
    gcda : 'a -> 'a -> 'a, lcma : 'a -> 'a -> 'a};
val one_gcd = #one_gcd : 'a gcda -> 'a one;
val zero_gcd = #zero_gcd : 'a gcda -> 'a zero;
val dvd_gcd = #dvd_gcd : 'a gcda -> 'a dvd;
val gcda = #gcda : 'a gcda -> 'a -> 'a -> 'a;
val lcma = #lcma : 'a gcda -> 'a -> 'a -> 'a;

type 'a gcd = {gcd_Gcd : 'a gcda, gcd : 'a set -> 'a, lcm : 'a set -> 'a};
val gcd_Gcd = #gcd_Gcd : 'a gcd -> 'a gcda;
val gcd = #gcd : 'a gcd -> 'a set -> 'a;
val lcm = #lcm : 'a gcd -> 'a set -> 'a;

fun dummy_Lcm A_ x = lcm A_ x;

fun dummy_Gcd _ = raise Fail "Code_Abort_Gcd.dummy_Gcd";

fun gcd_intb x = dummy_Gcd x;

val zero_int = {zerob = zero_inta} : int zero;

val one_int = {onea = one_inta} : int one;

val times_int = {times = times_inta} : int times;

val dvd_int = {times_dvd = times_int} : int dvd;

val gcd_inta =
  {one_gcd = one_int, zero_gcd = zero_int, dvd_gcd = dvd_int, gcda = gcd_intc,
    lcma = lcm_inta}
  : int gcda;

fun gcd_int () = {gcd_Gcd = gcd_inta, gcd = gcd_intb, lcm = lcm_int} : int gcd
and lcm_int x = dummy_Lcm (gcd_int ()) x;
val gcd_int = gcd_int ();

fun equal_inta k l = (((integer_of_int k) : IntInf.int) = (integer_of_int l));

type 'a equal = {equal : 'a -> 'a -> bool};
val equal = #equal : 'a equal -> 'a -> 'a -> bool;

val equal_int = {equal = equal_inta} : int equal;

fun uminus_inta k = Int_of_integer (IntInf.~ (integer_of_int k));

datatype nat = Nat of IntInf.int;

fun integer_of_nat (Nat x) = x;

fun modulo_nata m n =
  Nat (modulo_integer (integer_of_nat m) (integer_of_nat n));

fun divide_nata m n =
  Nat (divide_integer (integer_of_nat m) (integer_of_nat n));

fun equal_nata m n = (((integer_of_nat m) : IntInf.int) = (integer_of_nat n));

type 'a ord = {less_eq : 'a -> 'a -> bool, less : 'a -> 'a -> bool};
val less_eq = #less_eq : 'a ord -> 'a -> 'a -> bool;
val less = #less : 'a ord -> 'a -> 'a -> bool;

fun max A_ a b = (if less_eq A_ a b then b else a);

val ord_integer =
  {less_eq = (fn a => fn b => IntInf.<= (a, b)),
    less = (fn a => fn b => IntInf.< (a, b))}
  : IntInf.int ord;

fun nat_of_integer k = Nat (max ord_integer (0 : IntInf.int) k);

val zero_nata : nat = Nat (0 : IntInf.int);

val one_nata : nat = Nat (1 : IntInf.int);

fun string_of_digit n =
  (if equal_nata n zero_nata then [#"0"]
    else (if equal_nata n one_nata then [#"1"]
           else (if equal_nata n (nat_of_integer (2 : IntInf.int)) then [#"2"]
                  else (if equal_nata n (nat_of_integer (3 : IntInf.int))
                         then [#"3"]
                         else (if equal_nata n (nat_of_integer (4 : IntInf.int))
                                then [#"4"]
                                else (if equal_nata n
   (nat_of_integer (5 : IntInf.int))
                                       then [#"5"]
                                       else (if equal_nata n
          (nat_of_integer (6 : IntInf.int))
      then [#"6"]
      else (if equal_nata n (nat_of_integer (7 : IntInf.int)) then [#"7"]
             else (if equal_nata n (nat_of_integer (8 : IntInf.int)) then [#"8"]
                    else [#"9"])))))))));

fun less_nat m n = IntInf.< (integer_of_nat m, integer_of_nat n);

fun shows_string x = (fn a => x @ a);

fun showsp_nat p n =
  (if less_nat n (nat_of_integer (10 : IntInf.int))
    then shows_string (string_of_digit n)
    else showsp_nat p (divide_nata n (nat_of_integer (10 : IntInf.int))) o
           shows_string
             (string_of_digit
               (modulo_nata n (nat_of_integer (10 : IntInf.int)))));

fun less_int k l = IntInf.< (integer_of_int k, integer_of_int l);

fun nat k = Nat (max ord_integer (0 : IntInf.int) (integer_of_int k));

fun showsp_int p i =
  (if less_int i zero_inta
    then shows_string [#"-"] o showsp_nat p (nat (uminus_inta i))
    else showsp_nat p (nat i));

fun shows_prec_int x = showsp_int x;

fun shows_sep s sep [] = shows_string []
  | shows_sep s sep [x] = s x
  | shows_sep s sep (x :: v :: va) = s x o sep o shows_sep s sep (v :: va);

fun null [] = true
  | null (x :: xs) = false;

fun shows_list_gen showsx e l s r xs =
  (if null xs then shows_string e
    else shows_string l o shows_sep showsx (shows_string s) xs o
           shows_string r);

fun showsp_list s p xs =
  shows_list_gen (s zero_nata) [#"[", #"]"] [#"["] [#",", #" "] [#"]"] xs;

fun shows_list_int x = showsp_list shows_prec_int zero_nata x;

type 'a show =
  {shows_prec : nat -> 'a -> char list -> char list,
    shows_list : 'a list -> char list -> char list};
val shows_prec = #shows_prec : 'a show -> nat -> 'a -> char list -> char list;
val shows_list = #shows_list : 'a show -> 'a list -> char list -> char list;

val show_int = {shows_prec = shows_prec_int, shows_list = shows_list_int} :
  int show;

fun abs_inta i = (if less_int i zero_inta then uminus_inta i else i);

type 'a abs = {abs : 'a -> 'a};
val abs = #abs : 'a abs -> 'a -> 'a;

val abs_int = {abs = abs_inta} : int abs;

fun sgn_inta i =
  (if equal_inta i zero_inta then zero_inta
    else (if less_int zero_inta i then one_inta else uminus_inta one_inta));

type 'a sgn = {sgn : 'a -> 'a};
val sgn = #sgn : 'a sgn -> 'a -> 'a;

val sgn_int = {sgn = sgn_inta} : int sgn;

fun minus_inta k l =
  Int_of_integer (IntInf.- (integer_of_int k, integer_of_int l));

fun plus_inta k l =
  Int_of_integer (IntInf.+ (integer_of_int k, integer_of_int l));

type 'a uminus = {uminus : 'a -> 'a};
val uminus = #uminus : 'a uminus -> 'a -> 'a;

type 'a minus = {minus : 'a -> 'a -> 'a};
val minus = #minus : 'a minus -> 'a -> 'a -> 'a;

type 'a plus = {plus : 'a -> 'a -> 'a};
val plus = #plus : 'a plus -> 'a -> 'a -> 'a;

type 'a semigroup_add = {plus_semigroup_add : 'a plus};
val plus_semigroup_add = #plus_semigroup_add : 'a semigroup_add -> 'a plus;

type 'a cancel_semigroup_add =
  {semigroup_add_cancel_semigroup_add : 'a semigroup_add};
val semigroup_add_cancel_semigroup_add = #semigroup_add_cancel_semigroup_add :
  'a cancel_semigroup_add -> 'a semigroup_add;

type 'a ab_semigroup_add = {semigroup_add_ab_semigroup_add : 'a semigroup_add};
val semigroup_add_ab_semigroup_add = #semigroup_add_ab_semigroup_add :
  'a ab_semigroup_add -> 'a semigroup_add;

type 'a cancel_ab_semigroup_add =
  {ab_semigroup_add_cancel_ab_semigroup_add : 'a ab_semigroup_add,
    cancel_semigroup_add_cancel_ab_semigroup_add : 'a cancel_semigroup_add,
    minus_cancel_ab_semigroup_add : 'a minus};
val ab_semigroup_add_cancel_ab_semigroup_add =
  #ab_semigroup_add_cancel_ab_semigroup_add :
  'a cancel_ab_semigroup_add -> 'a ab_semigroup_add;
val cancel_semigroup_add_cancel_ab_semigroup_add =
  #cancel_semigroup_add_cancel_ab_semigroup_add :
  'a cancel_ab_semigroup_add -> 'a cancel_semigroup_add;
val minus_cancel_ab_semigroup_add = #minus_cancel_ab_semigroup_add :
  'a cancel_ab_semigroup_add -> 'a minus;

type 'a monoid_add =
  {semigroup_add_monoid_add : 'a semigroup_add, zero_monoid_add : 'a zero};
val semigroup_add_monoid_add = #semigroup_add_monoid_add :
  'a monoid_add -> 'a semigroup_add;
val zero_monoid_add = #zero_monoid_add : 'a monoid_add -> 'a zero;

type 'a comm_monoid_add =
  {ab_semigroup_add_comm_monoid_add : 'a ab_semigroup_add,
    monoid_add_comm_monoid_add : 'a monoid_add};
val ab_semigroup_add_comm_monoid_add = #ab_semigroup_add_comm_monoid_add :
  'a comm_monoid_add -> 'a ab_semigroup_add;
val monoid_add_comm_monoid_add = #monoid_add_comm_monoid_add :
  'a comm_monoid_add -> 'a monoid_add;

type 'a cancel_comm_monoid_add =
  {cancel_ab_semigroup_add_cancel_comm_monoid_add : 'a cancel_ab_semigroup_add,
    comm_monoid_add_cancel_comm_monoid_add : 'a comm_monoid_add};
val cancel_ab_semigroup_add_cancel_comm_monoid_add =
  #cancel_ab_semigroup_add_cancel_comm_monoid_add :
  'a cancel_comm_monoid_add -> 'a cancel_ab_semigroup_add;
val comm_monoid_add_cancel_comm_monoid_add =
  #comm_monoid_add_cancel_comm_monoid_add :
  'a cancel_comm_monoid_add -> 'a comm_monoid_add;

type 'a mult_zero = {times_mult_zero : 'a times, zero_mult_zero : 'a zero};
val times_mult_zero = #times_mult_zero : 'a mult_zero -> 'a times;
val zero_mult_zero = #zero_mult_zero : 'a mult_zero -> 'a zero;

type 'a semigroup_mult = {times_semigroup_mult : 'a times};
val times_semigroup_mult = #times_semigroup_mult :
  'a semigroup_mult -> 'a times;

type 'a semiring =
  {ab_semigroup_add_semiring : 'a ab_semigroup_add,
    semigroup_mult_semiring : 'a semigroup_mult};
val ab_semigroup_add_semiring = #ab_semigroup_add_semiring :
  'a semiring -> 'a ab_semigroup_add;
val semigroup_mult_semiring = #semigroup_mult_semiring :
  'a semiring -> 'a semigroup_mult;

type 'a semiring_0 =
  {comm_monoid_add_semiring_0 : 'a comm_monoid_add,
    mult_zero_semiring_0 : 'a mult_zero, semiring_semiring_0 : 'a semiring};
val comm_monoid_add_semiring_0 = #comm_monoid_add_semiring_0 :
  'a semiring_0 -> 'a comm_monoid_add;
val mult_zero_semiring_0 = #mult_zero_semiring_0 :
  'a semiring_0 -> 'a mult_zero;
val semiring_semiring_0 = #semiring_semiring_0 : 'a semiring_0 -> 'a semiring;

type 'a semiring_0_cancel =
  {cancel_comm_monoid_add_semiring_0_cancel : 'a cancel_comm_monoid_add,
    semiring_0_semiring_0_cancel : 'a semiring_0};
val cancel_comm_monoid_add_semiring_0_cancel =
  #cancel_comm_monoid_add_semiring_0_cancel :
  'a semiring_0_cancel -> 'a cancel_comm_monoid_add;
val semiring_0_semiring_0_cancel = #semiring_0_semiring_0_cancel :
  'a semiring_0_cancel -> 'a semiring_0;

type 'a ab_semigroup_mult =
  {semigroup_mult_ab_semigroup_mult : 'a semigroup_mult};
val semigroup_mult_ab_semigroup_mult = #semigroup_mult_ab_semigroup_mult :
  'a ab_semigroup_mult -> 'a semigroup_mult;

type 'a comm_semiring =
  {ab_semigroup_mult_comm_semiring : 'a ab_semigroup_mult,
    semiring_comm_semiring : 'a semiring};
val ab_semigroup_mult_comm_semiring = #ab_semigroup_mult_comm_semiring :
  'a comm_semiring -> 'a ab_semigroup_mult;
val semiring_comm_semiring = #semiring_comm_semiring :
  'a comm_semiring -> 'a semiring;

type 'a comm_semiring_0 =
  {comm_semiring_comm_semiring_0 : 'a comm_semiring,
    semiring_0_comm_semiring_0 : 'a semiring_0};
val comm_semiring_comm_semiring_0 = #comm_semiring_comm_semiring_0 :
  'a comm_semiring_0 -> 'a comm_semiring;
val semiring_0_comm_semiring_0 = #semiring_0_comm_semiring_0 :
  'a comm_semiring_0 -> 'a semiring_0;

type 'a comm_semiring_0_cancel =
  {comm_semiring_0_comm_semiring_0_cancel : 'a comm_semiring_0,
    semiring_0_cancel_comm_semiring_0_cancel : 'a semiring_0_cancel};
val comm_semiring_0_comm_semiring_0_cancel =
  #comm_semiring_0_comm_semiring_0_cancel :
  'a comm_semiring_0_cancel -> 'a comm_semiring_0;
val semiring_0_cancel_comm_semiring_0_cancel =
  #semiring_0_cancel_comm_semiring_0_cancel :
  'a comm_semiring_0_cancel -> 'a semiring_0_cancel;

type 'a power = {one_power : 'a one, times_power : 'a times};
val one_power = #one_power : 'a power -> 'a one;
val times_power = #times_power : 'a power -> 'a times;

type 'a monoid_mult =
  {semigroup_mult_monoid_mult : 'a semigroup_mult,
    power_monoid_mult : 'a power};
val semigroup_mult_monoid_mult = #semigroup_mult_monoid_mult :
  'a monoid_mult -> 'a semigroup_mult;
val power_monoid_mult = #power_monoid_mult : 'a monoid_mult -> 'a power;

type 'a numeral =
  {one_numeral : 'a one, semigroup_add_numeral : 'a semigroup_add};
val one_numeral = #one_numeral : 'a numeral -> 'a one;
val semigroup_add_numeral = #semigroup_add_numeral :
  'a numeral -> 'a semigroup_add;

type 'a semiring_numeral =
  {monoid_mult_semiring_numeral : 'a monoid_mult,
    numeral_semiring_numeral : 'a numeral,
    semiring_semiring_numeral : 'a semiring};
val monoid_mult_semiring_numeral = #monoid_mult_semiring_numeral :
  'a semiring_numeral -> 'a monoid_mult;
val numeral_semiring_numeral = #numeral_semiring_numeral :
  'a semiring_numeral -> 'a numeral;
val semiring_semiring_numeral = #semiring_semiring_numeral :
  'a semiring_numeral -> 'a semiring;

type 'a zero_neq_one = {one_zero_neq_one : 'a one, zero_zero_neq_one : 'a zero};
val one_zero_neq_one = #one_zero_neq_one : 'a zero_neq_one -> 'a one;
val zero_zero_neq_one = #zero_zero_neq_one : 'a zero_neq_one -> 'a zero;

type 'a semiring_1 =
  {semiring_numeral_semiring_1 : 'a semiring_numeral,
    semiring_0_semiring_1 : 'a semiring_0,
    zero_neq_one_semiring_1 : 'a zero_neq_one};
val semiring_numeral_semiring_1 = #semiring_numeral_semiring_1 :
  'a semiring_1 -> 'a semiring_numeral;
val semiring_0_semiring_1 = #semiring_0_semiring_1 :
  'a semiring_1 -> 'a semiring_0;
val zero_neq_one_semiring_1 = #zero_neq_one_semiring_1 :
  'a semiring_1 -> 'a zero_neq_one;

type 'a semiring_1_cancel =
  {semiring_0_cancel_semiring_1_cancel : 'a semiring_0_cancel,
    semiring_1_semiring_1_cancel : 'a semiring_1};
val semiring_0_cancel_semiring_1_cancel = #semiring_0_cancel_semiring_1_cancel :
  'a semiring_1_cancel -> 'a semiring_0_cancel;
val semiring_1_semiring_1_cancel = #semiring_1_semiring_1_cancel :
  'a semiring_1_cancel -> 'a semiring_1;

type 'a comm_monoid_mult =
  {ab_semigroup_mult_comm_monoid_mult : 'a ab_semigroup_mult,
    monoid_mult_comm_monoid_mult : 'a monoid_mult,
    dvd_comm_monoid_mult : 'a dvd};
val ab_semigroup_mult_comm_monoid_mult = #ab_semigroup_mult_comm_monoid_mult :
  'a comm_monoid_mult -> 'a ab_semigroup_mult;
val monoid_mult_comm_monoid_mult = #monoid_mult_comm_monoid_mult :
  'a comm_monoid_mult -> 'a monoid_mult;
val dvd_comm_monoid_mult = #dvd_comm_monoid_mult :
  'a comm_monoid_mult -> 'a dvd;

type 'a comm_semiring_1 =
  {comm_monoid_mult_comm_semiring_1 : 'a comm_monoid_mult,
    comm_semiring_0_comm_semiring_1 : 'a comm_semiring_0,
    semiring_1_comm_semiring_1 : 'a semiring_1};
val comm_monoid_mult_comm_semiring_1 = #comm_monoid_mult_comm_semiring_1 :
  'a comm_semiring_1 -> 'a comm_monoid_mult;
val comm_semiring_0_comm_semiring_1 = #comm_semiring_0_comm_semiring_1 :
  'a comm_semiring_1 -> 'a comm_semiring_0;
val semiring_1_comm_semiring_1 = #semiring_1_comm_semiring_1 :
  'a comm_semiring_1 -> 'a semiring_1;

type 'a comm_semiring_1_cancel =
  {comm_semiring_0_cancel_comm_semiring_1_cancel : 'a comm_semiring_0_cancel,
    comm_semiring_1_comm_semiring_1_cancel : 'a comm_semiring_1,
    semiring_1_cancel_comm_semiring_1_cancel : 'a semiring_1_cancel};
val comm_semiring_0_cancel_comm_semiring_1_cancel =
  #comm_semiring_0_cancel_comm_semiring_1_cancel :
  'a comm_semiring_1_cancel -> 'a comm_semiring_0_cancel;
val comm_semiring_1_comm_semiring_1_cancel =
  #comm_semiring_1_comm_semiring_1_cancel :
  'a comm_semiring_1_cancel -> 'a comm_semiring_1;
val semiring_1_cancel_comm_semiring_1_cancel =
  #semiring_1_cancel_comm_semiring_1_cancel :
  'a comm_semiring_1_cancel -> 'a semiring_1_cancel;

type 'a comm_semiring_1_cancel_crossproduct =
  {comm_semiring_1_cancel_comm_semiring_1_cancel_crossproduct :
     'a comm_semiring_1_cancel};
val comm_semiring_1_cancel_comm_semiring_1_cancel_crossproduct =
  #comm_semiring_1_cancel_comm_semiring_1_cancel_crossproduct :
  'a comm_semiring_1_cancel_crossproduct -> 'a comm_semiring_1_cancel;

type 'a semiring_no_zero_divisors =
  {semiring_0_semiring_no_zero_divisors : 'a semiring_0};
val semiring_0_semiring_no_zero_divisors = #semiring_0_semiring_no_zero_divisors
  : 'a semiring_no_zero_divisors -> 'a semiring_0;

type 'a semiring_1_no_zero_divisors =
  {semiring_1_semiring_1_no_zero_divisors : 'a semiring_1,
    semiring_no_zero_divisors_semiring_1_no_zero_divisors :
      'a semiring_no_zero_divisors};
val semiring_1_semiring_1_no_zero_divisors =
  #semiring_1_semiring_1_no_zero_divisors :
  'a semiring_1_no_zero_divisors -> 'a semiring_1;
val semiring_no_zero_divisors_semiring_1_no_zero_divisors =
  #semiring_no_zero_divisors_semiring_1_no_zero_divisors :
  'a semiring_1_no_zero_divisors -> 'a semiring_no_zero_divisors;

type 'a semiring_no_zero_divisors_cancel =
  {semiring_no_zero_divisors_semiring_no_zero_divisors_cancel :
     'a semiring_no_zero_divisors};
val semiring_no_zero_divisors_semiring_no_zero_divisors_cancel =
  #semiring_no_zero_divisors_semiring_no_zero_divisors_cancel :
  'a semiring_no_zero_divisors_cancel -> 'a semiring_no_zero_divisors;

type 'a group_add =
  {cancel_semigroup_add_group_add : 'a cancel_semigroup_add,
    minus_group_add : 'a minus, monoid_add_group_add : 'a monoid_add,
    uminus_group_add : 'a uminus};
val cancel_semigroup_add_group_add = #cancel_semigroup_add_group_add :
  'a group_add -> 'a cancel_semigroup_add;
val minus_group_add = #minus_group_add : 'a group_add -> 'a minus;
val monoid_add_group_add = #monoid_add_group_add :
  'a group_add -> 'a monoid_add;
val uminus_group_add = #uminus_group_add : 'a group_add -> 'a uminus;

type 'a ab_group_add =
  {cancel_comm_monoid_add_ab_group_add : 'a cancel_comm_monoid_add,
    group_add_ab_group_add : 'a group_add};
val cancel_comm_monoid_add_ab_group_add = #cancel_comm_monoid_add_ab_group_add :
  'a ab_group_add -> 'a cancel_comm_monoid_add;
val group_add_ab_group_add = #group_add_ab_group_add :
  'a ab_group_add -> 'a group_add;

type 'a ring =
  {ab_group_add_ring : 'a ab_group_add,
    semiring_0_cancel_ring : 'a semiring_0_cancel};
val ab_group_add_ring = #ab_group_add_ring : 'a ring -> 'a ab_group_add;
val semiring_0_cancel_ring = #semiring_0_cancel_ring :
  'a ring -> 'a semiring_0_cancel;

type 'a ring_no_zero_divisors =
  {ring_ring_no_zero_divisors : 'a ring,
    semiring_no_zero_divisors_cancel_ring_no_zero_divisors :
      'a semiring_no_zero_divisors_cancel};
val ring_ring_no_zero_divisors = #ring_ring_no_zero_divisors :
  'a ring_no_zero_divisors -> 'a ring;
val semiring_no_zero_divisors_cancel_ring_no_zero_divisors =
  #semiring_no_zero_divisors_cancel_ring_no_zero_divisors :
  'a ring_no_zero_divisors -> 'a semiring_no_zero_divisors_cancel;

type 'a neg_numeral =
  {group_add_neg_numeral : 'a group_add, numeral_neg_numeral : 'a numeral};
val group_add_neg_numeral = #group_add_neg_numeral :
  'a neg_numeral -> 'a group_add;
val numeral_neg_numeral = #numeral_neg_numeral : 'a neg_numeral -> 'a numeral;

type 'a ring_1 =
  {neg_numeral_ring_1 : 'a neg_numeral, ring_ring_1 : 'a ring,
    semiring_1_cancel_ring_1 : 'a semiring_1_cancel};
val neg_numeral_ring_1 = #neg_numeral_ring_1 : 'a ring_1 -> 'a neg_numeral;
val ring_ring_1 = #ring_ring_1 : 'a ring_1 -> 'a ring;
val semiring_1_cancel_ring_1 = #semiring_1_cancel_ring_1 :
  'a ring_1 -> 'a semiring_1_cancel;

type 'a ring_1_no_zero_divisors =
  {ring_1_ring_1_no_zero_divisors : 'a ring_1,
    ring_no_zero_divisors_ring_1_no_zero_divisors : 'a ring_no_zero_divisors,
    semiring_1_no_zero_divisors_ring_1_no_zero_divisors :
      'a semiring_1_no_zero_divisors};
val ring_1_ring_1_no_zero_divisors = #ring_1_ring_1_no_zero_divisors :
  'a ring_1_no_zero_divisors -> 'a ring_1;
val ring_no_zero_divisors_ring_1_no_zero_divisors =
  #ring_no_zero_divisors_ring_1_no_zero_divisors :
  'a ring_1_no_zero_divisors -> 'a ring_no_zero_divisors;
val semiring_1_no_zero_divisors_ring_1_no_zero_divisors =
  #semiring_1_no_zero_divisors_ring_1_no_zero_divisors :
  'a ring_1_no_zero_divisors -> 'a semiring_1_no_zero_divisors;

type 'a comm_ring =
  {comm_semiring_0_cancel_comm_ring : 'a comm_semiring_0_cancel,
    ring_comm_ring : 'a ring};
val comm_semiring_0_cancel_comm_ring = #comm_semiring_0_cancel_comm_ring :
  'a comm_ring -> 'a comm_semiring_0_cancel;
val ring_comm_ring = #ring_comm_ring : 'a comm_ring -> 'a ring;

type 'a comm_ring_1 =
  {comm_ring_comm_ring_1 : 'a comm_ring,
    comm_semiring_1_cancel_comm_ring_1 : 'a comm_semiring_1_cancel,
    ring_1_comm_ring_1 : 'a ring_1};
val comm_ring_comm_ring_1 = #comm_ring_comm_ring_1 :
  'a comm_ring_1 -> 'a comm_ring;
val comm_semiring_1_cancel_comm_ring_1 = #comm_semiring_1_cancel_comm_ring_1 :
  'a comm_ring_1 -> 'a comm_semiring_1_cancel;
val ring_1_comm_ring_1 = #ring_1_comm_ring_1 : 'a comm_ring_1 -> 'a ring_1;

type 'a semidom =
  {comm_semiring_1_cancel_semidom : 'a comm_semiring_1_cancel,
    semiring_1_no_zero_divisors_semidom : 'a semiring_1_no_zero_divisors};
val comm_semiring_1_cancel_semidom = #comm_semiring_1_cancel_semidom :
  'a semidom -> 'a comm_semiring_1_cancel;
val semiring_1_no_zero_divisors_semidom = #semiring_1_no_zero_divisors_semidom :
  'a semidom -> 'a semiring_1_no_zero_divisors;

type 'a idom =
  {comm_ring_1_idom : 'a comm_ring_1,
    ring_1_no_zero_divisors_idom : 'a ring_1_no_zero_divisors,
    semidom_idom : 'a semidom,
    comm_semiring_1_cancel_crossproduct_idom :
      'a comm_semiring_1_cancel_crossproduct};
val comm_ring_1_idom = #comm_ring_1_idom : 'a idom -> 'a comm_ring_1;
val ring_1_no_zero_divisors_idom = #ring_1_no_zero_divisors_idom :
  'a idom -> 'a ring_1_no_zero_divisors;
val semidom_idom = #semidom_idom : 'a idom -> 'a semidom;
val comm_semiring_1_cancel_crossproduct_idom =
  #comm_semiring_1_cancel_crossproduct_idom :
  'a idom -> 'a comm_semiring_1_cancel_crossproduct;

val plus_int = {plus = plus_inta} : int plus;

val semigroup_add_int = {plus_semigroup_add = plus_int} : int semigroup_add;

val cancel_semigroup_add_int =
  {semigroup_add_cancel_semigroup_add = semigroup_add_int} :
  int cancel_semigroup_add;

val ab_semigroup_add_int = {semigroup_add_ab_semigroup_add = semigroup_add_int}
  : int ab_semigroup_add;

val minus_int = {minus = minus_inta} : int minus;

val cancel_ab_semigroup_add_int =
  {ab_semigroup_add_cancel_ab_semigroup_add = ab_semigroup_add_int,
    cancel_semigroup_add_cancel_ab_semigroup_add = cancel_semigroup_add_int,
    minus_cancel_ab_semigroup_add = minus_int}
  : int cancel_ab_semigroup_add;

val monoid_add_int =
  {semigroup_add_monoid_add = semigroup_add_int, zero_monoid_add = zero_int} :
  int monoid_add;

val comm_monoid_add_int =
  {ab_semigroup_add_comm_monoid_add = ab_semigroup_add_int,
    monoid_add_comm_monoid_add = monoid_add_int}
  : int comm_monoid_add;

val cancel_comm_monoid_add_int =
  {cancel_ab_semigroup_add_cancel_comm_monoid_add = cancel_ab_semigroup_add_int,
    comm_monoid_add_cancel_comm_monoid_add = comm_monoid_add_int}
  : int cancel_comm_monoid_add;

val mult_zero_int = {times_mult_zero = times_int, zero_mult_zero = zero_int} :
  int mult_zero;

val semigroup_mult_int = {times_semigroup_mult = times_int} :
  int semigroup_mult;

val semiring_int =
  {ab_semigroup_add_semiring = ab_semigroup_add_int,
    semigroup_mult_semiring = semigroup_mult_int}
  : int semiring;

val semiring_0_int =
  {comm_monoid_add_semiring_0 = comm_monoid_add_int,
    mult_zero_semiring_0 = mult_zero_int, semiring_semiring_0 = semiring_int}
  : int semiring_0;

val semiring_0_cancel_int =
  {cancel_comm_monoid_add_semiring_0_cancel = cancel_comm_monoid_add_int,
    semiring_0_semiring_0_cancel = semiring_0_int}
  : int semiring_0_cancel;

val ab_semigroup_mult_int =
  {semigroup_mult_ab_semigroup_mult = semigroup_mult_int} :
  int ab_semigroup_mult;

val comm_semiring_int =
  {ab_semigroup_mult_comm_semiring = ab_semigroup_mult_int,
    semiring_comm_semiring = semiring_int}
  : int comm_semiring;

val comm_semiring_0_int =
  {comm_semiring_comm_semiring_0 = comm_semiring_int,
    semiring_0_comm_semiring_0 = semiring_0_int}
  : int comm_semiring_0;

val comm_semiring_0_cancel_int =
  {comm_semiring_0_comm_semiring_0_cancel = comm_semiring_0_int,
    semiring_0_cancel_comm_semiring_0_cancel = semiring_0_cancel_int}
  : int comm_semiring_0_cancel;

val power_int = {one_power = one_int, times_power = times_int} : int power;

val monoid_mult_int =
  {semigroup_mult_monoid_mult = semigroup_mult_int,
    power_monoid_mult = power_int}
  : int monoid_mult;

val numeral_int =
  {one_numeral = one_int, semigroup_add_numeral = semigroup_add_int} :
  int numeral;

val semiring_numeral_int =
  {monoid_mult_semiring_numeral = monoid_mult_int,
    numeral_semiring_numeral = numeral_int,
    semiring_semiring_numeral = semiring_int}
  : int semiring_numeral;

val zero_neq_one_int =
  {one_zero_neq_one = one_int, zero_zero_neq_one = zero_int} : int zero_neq_one;

val semiring_1_int =
  {semiring_numeral_semiring_1 = semiring_numeral_int,
    semiring_0_semiring_1 = semiring_0_int,
    zero_neq_one_semiring_1 = zero_neq_one_int}
  : int semiring_1;

val semiring_1_cancel_int =
  {semiring_0_cancel_semiring_1_cancel = semiring_0_cancel_int,
    semiring_1_semiring_1_cancel = semiring_1_int}
  : int semiring_1_cancel;

val comm_monoid_mult_int =
  {ab_semigroup_mult_comm_monoid_mult = ab_semigroup_mult_int,
    monoid_mult_comm_monoid_mult = monoid_mult_int,
    dvd_comm_monoid_mult = dvd_int}
  : int comm_monoid_mult;

val comm_semiring_1_int =
  {comm_monoid_mult_comm_semiring_1 = comm_monoid_mult_int,
    comm_semiring_0_comm_semiring_1 = comm_semiring_0_int,
    semiring_1_comm_semiring_1 = semiring_1_int}
  : int comm_semiring_1;

val comm_semiring_1_cancel_int =
  {comm_semiring_0_cancel_comm_semiring_1_cancel = comm_semiring_0_cancel_int,
    comm_semiring_1_comm_semiring_1_cancel = comm_semiring_1_int,
    semiring_1_cancel_comm_semiring_1_cancel = semiring_1_cancel_int}
  : int comm_semiring_1_cancel;

val comm_semiring_1_cancel_crossproduct_int =
  {comm_semiring_1_cancel_comm_semiring_1_cancel_crossproduct =
     comm_semiring_1_cancel_int}
  : int comm_semiring_1_cancel_crossproduct;

val semiring_no_zero_divisors_int =
  {semiring_0_semiring_no_zero_divisors = semiring_0_int} :
  int semiring_no_zero_divisors;

val semiring_1_no_zero_divisors_int =
  {semiring_1_semiring_1_no_zero_divisors = semiring_1_int,
    semiring_no_zero_divisors_semiring_1_no_zero_divisors =
      semiring_no_zero_divisors_int}
  : int semiring_1_no_zero_divisors;

val semiring_no_zero_divisors_cancel_int =
  {semiring_no_zero_divisors_semiring_no_zero_divisors_cancel =
     semiring_no_zero_divisors_int}
  : int semiring_no_zero_divisors_cancel;

val uminus_int = {uminus = uminus_inta} : int uminus;

val group_add_int =
  {cancel_semigroup_add_group_add = cancel_semigroup_add_int,
    minus_group_add = minus_int, monoid_add_group_add = monoid_add_int,
    uminus_group_add = uminus_int}
  : int group_add;

val ab_group_add_int =
  {cancel_comm_monoid_add_ab_group_add = cancel_comm_monoid_add_int,
    group_add_ab_group_add = group_add_int}
  : int ab_group_add;

val ring_int =
  {ab_group_add_ring = ab_group_add_int,
    semiring_0_cancel_ring = semiring_0_cancel_int}
  : int ring;

val ring_no_zero_divisors_int =
  {ring_ring_no_zero_divisors = ring_int,
    semiring_no_zero_divisors_cancel_ring_no_zero_divisors =
      semiring_no_zero_divisors_cancel_int}
  : int ring_no_zero_divisors;

val neg_numeral_int =
  {group_add_neg_numeral = group_add_int, numeral_neg_numeral = numeral_int} :
  int neg_numeral;

val ring_1_int =
  {neg_numeral_ring_1 = neg_numeral_int, ring_ring_1 = ring_int,
    semiring_1_cancel_ring_1 = semiring_1_cancel_int}
  : int ring_1;

val ring_1_no_zero_divisors_int =
  {ring_1_ring_1_no_zero_divisors = ring_1_int,
    ring_no_zero_divisors_ring_1_no_zero_divisors = ring_no_zero_divisors_int,
    semiring_1_no_zero_divisors_ring_1_no_zero_divisors =
      semiring_1_no_zero_divisors_int}
  : int ring_1_no_zero_divisors;

val comm_ring_int =
  {comm_semiring_0_cancel_comm_ring = comm_semiring_0_cancel_int,
    ring_comm_ring = ring_int}
  : int comm_ring;

val comm_ring_1_int =
  {comm_ring_comm_ring_1 = comm_ring_int,
    comm_semiring_1_cancel_comm_ring_1 = comm_semiring_1_cancel_int,
    ring_1_comm_ring_1 = ring_1_int}
  : int comm_ring_1;

val semidom_int =
  {comm_semiring_1_cancel_semidom = comm_semiring_1_cancel_int,
    semiring_1_no_zero_divisors_semidom = semiring_1_no_zero_divisors_int}
  : int semidom;

val idom_int =
  {comm_ring_1_idom = comm_ring_1_int,
    ring_1_no_zero_divisors_idom = ring_1_no_zero_divisors_int,
    semidom_idom = semidom_int,
    comm_semiring_1_cancel_crossproduct_idom =
      comm_semiring_1_cancel_crossproduct_int}
  : int idom;

fun normalize_int x = abs_inta x;

fun unit_factor_inta x = sgn_inta x;

type 'a divide = {divide : 'a -> 'a -> 'a};
val divide = #divide : 'a divide -> 'a -> 'a -> 'a;

type 'a semidom_divide =
  {divide_semidom_divide : 'a divide, semidom_semidom_divide : 'a semidom,
    semiring_no_zero_divisors_cancel_semidom_divide :
      'a semiring_no_zero_divisors_cancel};
val divide_semidom_divide = #divide_semidom_divide :
  'a semidom_divide -> 'a divide;
val semidom_semidom_divide = #semidom_semidom_divide :
  'a semidom_divide -> 'a semidom;
val semiring_no_zero_divisors_cancel_semidom_divide =
  #semiring_no_zero_divisors_cancel_semidom_divide :
  'a semidom_divide -> 'a semiring_no_zero_divisors_cancel;

type 'a unit_factor = {unit_factor : 'a -> 'a};
val unit_factor = #unit_factor : 'a unit_factor -> 'a -> 'a;

type 'a semidom_divide_unit_factor =
  {semidom_divide_semidom_divide_unit_factor : 'a semidom_divide,
    unit_factor_semidom_divide_unit_factor : 'a unit_factor};
val semidom_divide_semidom_divide_unit_factor =
  #semidom_divide_semidom_divide_unit_factor :
  'a semidom_divide_unit_factor -> 'a semidom_divide;
val unit_factor_semidom_divide_unit_factor =
  #unit_factor_semidom_divide_unit_factor :
  'a semidom_divide_unit_factor -> 'a unit_factor;

type 'a algebraic_semidom =
  {semidom_divide_algebraic_semidom : 'a semidom_divide};
val semidom_divide_algebraic_semidom = #semidom_divide_algebraic_semidom :
  'a algebraic_semidom -> 'a semidom_divide;

type 'a normalization_semidom =
  {algebraic_semidom_normalization_semidom : 'a algebraic_semidom,
    semidom_divide_unit_factor_normalization_semidom :
      'a semidom_divide_unit_factor,
    normalizeb : 'a -> 'a};
val algebraic_semidom_normalization_semidom =
  #algebraic_semidom_normalization_semidom :
  'a normalization_semidom -> 'a algebraic_semidom;
val semidom_divide_unit_factor_normalization_semidom =
  #semidom_divide_unit_factor_normalization_semidom :
  'a normalization_semidom -> 'a semidom_divide_unit_factor;
val normalizeb = #normalizeb : 'a normalization_semidom -> 'a -> 'a;

fun divide_inta k l =
  Int_of_integer (divide_integer (integer_of_int k) (integer_of_int l));

type 'a comm_monoid_gcd =
  {gcd_comm_monoid_gcd : 'a gcda,
    comm_semiring_1_comm_monoid_gcd : 'a comm_semiring_1};
val gcd_comm_monoid_gcd = #gcd_comm_monoid_gcd : 'a comm_monoid_gcd -> 'a gcda;
val comm_semiring_1_comm_monoid_gcd = #comm_semiring_1_comm_monoid_gcd :
  'a comm_monoid_gcd -> 'a comm_semiring_1;

type 'a idom_gcd =
  {idom_idom_gcd : 'a idom, comm_monoid_gcd_idom_gcd : 'a comm_monoid_gcd};
val idom_idom_gcd = #idom_idom_gcd : 'a idom_gcd -> 'a idom;
val comm_monoid_gcd_idom_gcd = #comm_monoid_gcd_idom_gcd :
  'a idom_gcd -> 'a comm_monoid_gcd;

type 'a semiring_gcd =
  {normalization_semidom_semiring_gcd : 'a normalization_semidom,
    comm_monoid_gcd_semiring_gcd : 'a comm_monoid_gcd};
val normalization_semidom_semiring_gcd = #normalization_semidom_semiring_gcd :
  'a semiring_gcd -> 'a normalization_semidom;
val comm_monoid_gcd_semiring_gcd = #comm_monoid_gcd_semiring_gcd :
  'a semiring_gcd -> 'a comm_monoid_gcd;

type 'a ring_gcd =
  {semiring_gcd_ring_gcd : 'a semiring_gcd, idom_gcd_ring_gcd : 'a idom_gcd};
val semiring_gcd_ring_gcd = #semiring_gcd_ring_gcd :
  'a ring_gcd -> 'a semiring_gcd;
val idom_gcd_ring_gcd = #idom_gcd_ring_gcd : 'a ring_gcd -> 'a idom_gcd;

val comm_monoid_gcd_int =
  {gcd_comm_monoid_gcd = gcd_inta,
    comm_semiring_1_comm_monoid_gcd = comm_semiring_1_int}
  : int comm_monoid_gcd;

val idom_gcd_int =
  {idom_idom_gcd = idom_int, comm_monoid_gcd_idom_gcd = comm_monoid_gcd_int} :
  int idom_gcd;

val divide_int = {divide = divide_inta} : int divide;

val semidom_divide_int =
  {divide_semidom_divide = divide_int, semidom_semidom_divide = semidom_int,
    semiring_no_zero_divisors_cancel_semidom_divide =
      semiring_no_zero_divisors_cancel_int}
  : int semidom_divide;

val unit_factor_int = {unit_factor = unit_factor_inta} : int unit_factor;

val semidom_divide_unit_factor_int =
  {semidom_divide_semidom_divide_unit_factor = semidom_divide_int,
    unit_factor_semidom_divide_unit_factor = unit_factor_int}
  : int semidom_divide_unit_factor;

val algebraic_semidom_int =
  {semidom_divide_algebraic_semidom = semidom_divide_int} :
  int algebraic_semidom;

val normalization_semidom_int =
  {algebraic_semidom_normalization_semidom = algebraic_semidom_int,
    semidom_divide_unit_factor_normalization_semidom =
      semidom_divide_unit_factor_int,
    normalizeb = normalize_int}
  : int normalization_semidom;

val semiring_gcd_int =
  {normalization_semidom_semiring_gcd = normalization_semidom_int,
    comm_monoid_gcd_semiring_gcd = comm_monoid_gcd_int}
  : int semiring_gcd;

val ring_gcd_int =
  {semiring_gcd_ring_gcd = semiring_gcd_int, idom_gcd_ring_gcd = idom_gcd_int} :
  int ring_gcd;

fun less_eq_int k l = IntInf.<= (integer_of_int k, integer_of_int l);

type 'a abs_if =
  {abs_abs_if : 'a abs, minus_abs_if : 'a minus, uminus_abs_if : 'a uminus,
    zero_abs_if : 'a zero, ord_abs_if : 'a ord};
val abs_abs_if = #abs_abs_if : 'a abs_if -> 'a abs;
val minus_abs_if = #minus_abs_if : 'a abs_if -> 'a minus;
val uminus_abs_if = #uminus_abs_if : 'a abs_if -> 'a uminus;
val zero_abs_if = #zero_abs_if : 'a abs_if -> 'a zero;
val ord_abs_if = #ord_abs_if : 'a abs_if -> 'a ord;

val ord_int = {less_eq = less_eq_int, less = less_int} : int ord;

val abs_if_int =
  {abs_abs_if = abs_int, minus_abs_if = minus_int, uminus_abs_if = uminus_int,
    zero_abs_if = zero_int, ord_abs_if = ord_int}
  : int abs_if;

fun modulo_inta k l =
  Int_of_integer (modulo_integer (integer_of_int k) (integer_of_int l));

type 'a modulo =
  {divide_modulo : 'a divide, dvd_modulo : 'a dvd, modulo : 'a -> 'a -> 'a};
val divide_modulo = #divide_modulo : 'a modulo -> 'a divide;
val dvd_modulo = #dvd_modulo : 'a modulo -> 'a dvd;
val modulo = #modulo : 'a modulo -> 'a -> 'a -> 'a;

val modulo_int =
  {divide_modulo = divide_int, dvd_modulo = dvd_int, modulo = modulo_inta} :
  int modulo;

type 'a semiring_char_0 = {semiring_1_semiring_char_0 : 'a semiring_1};
val semiring_1_semiring_char_0 = #semiring_1_semiring_char_0 :
  'a semiring_char_0 -> 'a semiring_1;

type 'a ring_char_0 =
  {semiring_char_0_ring_char_0 : 'a semiring_char_0,
    ring_1_ring_char_0 : 'a ring_1};
val semiring_char_0_ring_char_0 = #semiring_char_0_ring_char_0 :
  'a ring_char_0 -> 'a semiring_char_0;
val ring_1_ring_char_0 = #ring_1_ring_char_0 : 'a ring_char_0 -> 'a ring_1;

val semiring_char_0_int = {semiring_1_semiring_char_0 = semiring_1_int} :
  int semiring_char_0;

val ring_char_0_int =
  {semiring_char_0_ring_char_0 = semiring_char_0_int,
    ring_1_ring_char_0 = ring_1_int}
  : int ring_char_0;

type 'a quasi_order = {ord_quasi_order : 'a ord};
val ord_quasi_order = #ord_quasi_order : 'a quasi_order -> 'a ord;

type 'a weak_order = {quasi_order_weak_order : 'a quasi_order};
val quasi_order_weak_order = #quasi_order_weak_order :
  'a weak_order -> 'a quasi_order;

type 'a preorder = {ord_preorder : 'a ord};
val ord_preorder = #ord_preorder : 'a preorder -> 'a ord;

type 'a order =
  {preorder_order : 'a preorder, weak_order_order : 'a weak_order};
val preorder_order = #preorder_order : 'a order -> 'a preorder;
val weak_order_order = #weak_order_order : 'a order -> 'a weak_order;

val quasi_order_int = {ord_quasi_order = ord_int} : int quasi_order;

val weak_order_int = {quasi_order_weak_order = quasi_order_int} :
  int weak_order;

val preorder_int = {ord_preorder = ord_int} : int preorder;

val order_int =
  {preorder_order = preorder_int, weak_order_order = weak_order_int} :
  int order;

type 'a semiring_Gcd =
  {gcd_semiring_Gcd : 'a gcd, semiring_gcd_semiring_Gcd : 'a semiring_gcd};
val gcd_semiring_Gcd = #gcd_semiring_Gcd : 'a semiring_Gcd -> 'a gcd;
val semiring_gcd_semiring_Gcd = #semiring_gcd_semiring_Gcd :
  'a semiring_Gcd -> 'a semiring_gcd;

val semiring_Gcd_int =
  {gcd_semiring_Gcd = gcd_int, semiring_gcd_semiring_Gcd = semiring_gcd_int} :
  int semiring_Gcd;

val ceq_inta : (int -> int -> bool) option = SOME equal_inta;

val ceq_int = {ceq = ceq_inta} : int ceq;

type 'a idom_divide =
  {idom_idom_divide : 'a idom, semidom_divide_idom_divide : 'a semidom_divide};
val idom_idom_divide = #idom_idom_divide : 'a idom_divide -> 'a idom;
val semidom_divide_idom_divide = #semidom_divide_idom_divide :
  'a idom_divide -> 'a semidom_divide;

val idom_divide_int =
  {idom_idom_divide = idom_int, semidom_divide_idom_divide = semidom_divide_int}
  : int idom_divide;

datatype ('a, 'b) phantom = Phantom of 'b;

datatype set_impla = Set_Choose | Set_Collect | Set_DList | Set_RBT |
  Set_Monada;

val set_impl_inta : (int, set_impla) phantom = Phantom Set_RBT;

type 'a set_impl = {set_impl : ('a, set_impla) phantom};
val set_impl = #set_impl : 'a set_impl -> ('a, set_impla) phantom;

val set_impl_int = {set_impl = set_impl_inta} : int set_impl;

type 'a linorder = {order_linorder : 'a order};
val order_linorder = #order_linorder : 'a linorder -> 'a order;

val linorder_int = {order_linorder = order_int} : int linorder;

type 'a idom_abs_sgn =
  {abs_idom_abs_sgn : 'a abs, sgn_idom_abs_sgn : 'a sgn,
    idom_idom_abs_sgn : 'a idom};
val abs_idom_abs_sgn = #abs_idom_abs_sgn : 'a idom_abs_sgn -> 'a abs;
val sgn_idom_abs_sgn = #sgn_idom_abs_sgn : 'a idom_abs_sgn -> 'a sgn;
val idom_idom_abs_sgn = #idom_idom_abs_sgn : 'a idom_abs_sgn -> 'a idom;

val idom_abs_sgn_int =
  {abs_idom_abs_sgn = abs_int, sgn_idom_abs_sgn = sgn_int,
    idom_idom_abs_sgn = idom_int}
  : int idom_abs_sgn;

type 'a ordered_ab_semigroup_add =
  {ab_semigroup_add_ordered_ab_semigroup_add : 'a ab_semigroup_add,
    order_ordered_ab_semigroup_add : 'a order};
val ab_semigroup_add_ordered_ab_semigroup_add =
  #ab_semigroup_add_ordered_ab_semigroup_add :
  'a ordered_ab_semigroup_add -> 'a ab_semigroup_add;
val order_ordered_ab_semigroup_add = #order_ordered_ab_semigroup_add :
  'a ordered_ab_semigroup_add -> 'a order;

type 'a strict_ordered_ab_semigroup_add =
  {ordered_ab_semigroup_add_strict_ordered_ab_semigroup_add :
     'a ordered_ab_semigroup_add};
val ordered_ab_semigroup_add_strict_ordered_ab_semigroup_add =
  #ordered_ab_semigroup_add_strict_ordered_ab_semigroup_add :
  'a strict_ordered_ab_semigroup_add -> 'a ordered_ab_semigroup_add;

type 'a ordered_cancel_ab_semigroup_add =
  {cancel_ab_semigroup_add_ordered_cancel_ab_semigroup_add :
     'a cancel_ab_semigroup_add,
    strict_ordered_ab_semigroup_add_ordered_cancel_ab_semigroup_add :
      'a strict_ordered_ab_semigroup_add};
val cancel_ab_semigroup_add_ordered_cancel_ab_semigroup_add =
  #cancel_ab_semigroup_add_ordered_cancel_ab_semigroup_add :
  'a ordered_cancel_ab_semigroup_add -> 'a cancel_ab_semigroup_add;
val strict_ordered_ab_semigroup_add_ordered_cancel_ab_semigroup_add =
  #strict_ordered_ab_semigroup_add_ordered_cancel_ab_semigroup_add :
  'a ordered_cancel_ab_semigroup_add -> 'a strict_ordered_ab_semigroup_add;

type 'a ordered_semigroup_mult_zero =
  {semigroup_mult_ordered_semigroup_mult_zero : 'a semigroup_mult,
    order_ordered_semigroup_mult_zero : 'a order,
    mult_zero_ordered_semigroup_mult_zero : 'a mult_zero};
val semigroup_mult_ordered_semigroup_mult_zero =
  #semigroup_mult_ordered_semigroup_mult_zero :
  'a ordered_semigroup_mult_zero -> 'a semigroup_mult;
val order_ordered_semigroup_mult_zero = #order_ordered_semigroup_mult_zero :
  'a ordered_semigroup_mult_zero -> 'a order;
val mult_zero_ordered_semigroup_mult_zero =
  #mult_zero_ordered_semigroup_mult_zero :
  'a ordered_semigroup_mult_zero -> 'a mult_zero;

type 'a ordered_comm_monoid_add =
  {comm_monoid_add_ordered_comm_monoid_add : 'a comm_monoid_add,
    ordered_ab_semigroup_add_ordered_comm_monoid_add :
      'a ordered_ab_semigroup_add};
val comm_monoid_add_ordered_comm_monoid_add =
  #comm_monoid_add_ordered_comm_monoid_add :
  'a ordered_comm_monoid_add -> 'a comm_monoid_add;
val ordered_ab_semigroup_add_ordered_comm_monoid_add =
  #ordered_ab_semigroup_add_ordered_comm_monoid_add :
  'a ordered_comm_monoid_add -> 'a ordered_ab_semigroup_add;

type 'a ordered_semiring =
  {ordered_comm_monoid_add_ordered_semiring : 'a ordered_comm_monoid_add,
    semiring_ordered_semiring : 'a semiring};
val ordered_comm_monoid_add_ordered_semiring =
  #ordered_comm_monoid_add_ordered_semiring :
  'a ordered_semiring -> 'a ordered_comm_monoid_add;
val semiring_ordered_semiring = #semiring_ordered_semiring :
  'a ordered_semiring -> 'a semiring;

type 'a ordered_semiring_0 =
  {ordered_semigroup_mult_zero_ordered_semiring_0 :
     'a ordered_semigroup_mult_zero,
    ordered_semiring_ordered_semiring_0 : 'a ordered_semiring,
    semiring_0_ordered_semiring_0 : 'a semiring_0};
val ordered_semigroup_mult_zero_ordered_semiring_0 =
  #ordered_semigroup_mult_zero_ordered_semiring_0 :
  'a ordered_semiring_0 -> 'a ordered_semigroup_mult_zero;
val ordered_semiring_ordered_semiring_0 = #ordered_semiring_ordered_semiring_0 :
  'a ordered_semiring_0 -> 'a ordered_semiring;
val semiring_0_ordered_semiring_0 = #semiring_0_ordered_semiring_0 :
  'a ordered_semiring_0 -> 'a semiring_0;

type 'a ordered_cancel_semiring =
  {ordered_cancel_ab_semigroup_add_ordered_cancel_semiring :
     'a ordered_cancel_ab_semigroup_add,
    ordered_semiring_0_ordered_cancel_semiring : 'a ordered_semiring_0,
    semiring_0_cancel_ordered_cancel_semiring : 'a semiring_0_cancel};
val ordered_cancel_ab_semigroup_add_ordered_cancel_semiring =
  #ordered_cancel_ab_semigroup_add_ordered_cancel_semiring :
  'a ordered_cancel_semiring -> 'a ordered_cancel_ab_semigroup_add;
val ordered_semiring_0_ordered_cancel_semiring =
  #ordered_semiring_0_ordered_cancel_semiring :
  'a ordered_cancel_semiring -> 'a ordered_semiring_0;
val semiring_0_cancel_ordered_cancel_semiring =
  #semiring_0_cancel_ordered_cancel_semiring :
  'a ordered_cancel_semiring -> 'a semiring_0_cancel;

type 'a ordered_ab_semigroup_add_imp_le =
  {ordered_cancel_ab_semigroup_add_ordered_ab_semigroup_add_imp_le :
     'a ordered_cancel_ab_semigroup_add};
val ordered_cancel_ab_semigroup_add_ordered_ab_semigroup_add_imp_le =
  #ordered_cancel_ab_semigroup_add_ordered_ab_semigroup_add_imp_le :
  'a ordered_ab_semigroup_add_imp_le -> 'a ordered_cancel_ab_semigroup_add;

type 'a strict_ordered_comm_monoid_add =
  {comm_monoid_add_strict_ordered_comm_monoid_add : 'a comm_monoid_add,
    strict_ordered_ab_semigroup_add_strict_ordered_comm_monoid_add :
      'a strict_ordered_ab_semigroup_add};
val comm_monoid_add_strict_ordered_comm_monoid_add =
  #comm_monoid_add_strict_ordered_comm_monoid_add :
  'a strict_ordered_comm_monoid_add -> 'a comm_monoid_add;
val strict_ordered_ab_semigroup_add_strict_ordered_comm_monoid_add =
  #strict_ordered_ab_semigroup_add_strict_ordered_comm_monoid_add :
  'a strict_ordered_comm_monoid_add -> 'a strict_ordered_ab_semigroup_add;

type 'a ordered_cancel_comm_monoid_add =
  {ordered_cancel_ab_semigroup_add_ordered_cancel_comm_monoid_add :
     'a ordered_cancel_ab_semigroup_add,
    ordered_comm_monoid_add_ordered_cancel_comm_monoid_add :
      'a ordered_comm_monoid_add,
    strict_ordered_comm_monoid_add_ordered_cancel_comm_monoid_add :
      'a strict_ordered_comm_monoid_add};
val ordered_cancel_ab_semigroup_add_ordered_cancel_comm_monoid_add =
  #ordered_cancel_ab_semigroup_add_ordered_cancel_comm_monoid_add :
  'a ordered_cancel_comm_monoid_add -> 'a ordered_cancel_ab_semigroup_add;
val ordered_comm_monoid_add_ordered_cancel_comm_monoid_add =
  #ordered_comm_monoid_add_ordered_cancel_comm_monoid_add :
  'a ordered_cancel_comm_monoid_add -> 'a ordered_comm_monoid_add;
val strict_ordered_comm_monoid_add_ordered_cancel_comm_monoid_add =
  #strict_ordered_comm_monoid_add_ordered_cancel_comm_monoid_add :
  'a ordered_cancel_comm_monoid_add -> 'a strict_ordered_comm_monoid_add;

type 'a ordered_ab_semigroup_monoid_add_imp_le =
  {cancel_comm_monoid_add_ordered_ab_semigroup_monoid_add_imp_le :
     'a cancel_comm_monoid_add,
    ordered_ab_semigroup_add_imp_le_ordered_ab_semigroup_monoid_add_imp_le :
      'a ordered_ab_semigroup_add_imp_le,
    ordered_cancel_comm_monoid_add_ordered_ab_semigroup_monoid_add_imp_le :
      'a ordered_cancel_comm_monoid_add};
val cancel_comm_monoid_add_ordered_ab_semigroup_monoid_add_imp_le =
  #cancel_comm_monoid_add_ordered_ab_semigroup_monoid_add_imp_le :
  'a ordered_ab_semigroup_monoid_add_imp_le -> 'a cancel_comm_monoid_add;
val ordered_ab_semigroup_add_imp_le_ordered_ab_semigroup_monoid_add_imp_le =
  #ordered_ab_semigroup_add_imp_le_ordered_ab_semigroup_monoid_add_imp_le :
  'a ordered_ab_semigroup_monoid_add_imp_le ->
    'a ordered_ab_semigroup_add_imp_le;
val ordered_cancel_comm_monoid_add_ordered_ab_semigroup_monoid_add_imp_le =
  #ordered_cancel_comm_monoid_add_ordered_ab_semigroup_monoid_add_imp_le :
  'a ordered_ab_semigroup_monoid_add_imp_le ->
    'a ordered_cancel_comm_monoid_add;

type 'a ordered_ab_group_add =
  {ab_group_add_ordered_ab_group_add : 'a ab_group_add,
    ordered_ab_semigroup_monoid_add_imp_le_ordered_ab_group_add :
      'a ordered_ab_semigroup_monoid_add_imp_le};
val ab_group_add_ordered_ab_group_add = #ab_group_add_ordered_ab_group_add :
  'a ordered_ab_group_add -> 'a ab_group_add;
val ordered_ab_semigroup_monoid_add_imp_le_ordered_ab_group_add =
  #ordered_ab_semigroup_monoid_add_imp_le_ordered_ab_group_add :
  'a ordered_ab_group_add -> 'a ordered_ab_semigroup_monoid_add_imp_le;

type 'a ordered_ring =
  {ordered_ab_group_add_ordered_ring : 'a ordered_ab_group_add,
    ordered_cancel_semiring_ordered_ring : 'a ordered_cancel_semiring,
    ring_ordered_ring : 'a ring};
val ordered_ab_group_add_ordered_ring = #ordered_ab_group_add_ordered_ring :
  'a ordered_ring -> 'a ordered_ab_group_add;
val ordered_cancel_semiring_ordered_ring = #ordered_cancel_semiring_ordered_ring
  : 'a ordered_ring -> 'a ordered_cancel_semiring;
val ring_ordered_ring = #ring_ordered_ring : 'a ordered_ring -> 'a ring;

val ordered_ab_semigroup_add_int =
  {ab_semigroup_add_ordered_ab_semigroup_add = ab_semigroup_add_int,
    order_ordered_ab_semigroup_add = order_int}
  : int ordered_ab_semigroup_add;

val strict_ordered_ab_semigroup_add_int =
  {ordered_ab_semigroup_add_strict_ordered_ab_semigroup_add =
     ordered_ab_semigroup_add_int}
  : int strict_ordered_ab_semigroup_add;

val ordered_cancel_ab_semigroup_add_int =
  {cancel_ab_semigroup_add_ordered_cancel_ab_semigroup_add =
     cancel_ab_semigroup_add_int,
    strict_ordered_ab_semigroup_add_ordered_cancel_ab_semigroup_add =
      strict_ordered_ab_semigroup_add_int}
  : int ordered_cancel_ab_semigroup_add;

val ordered_semigroup_mult_zero_int =
  {semigroup_mult_ordered_semigroup_mult_zero = semigroup_mult_int,
    order_ordered_semigroup_mult_zero = order_int,
    mult_zero_ordered_semigroup_mult_zero = mult_zero_int}
  : int ordered_semigroup_mult_zero;

val ordered_comm_monoid_add_int =
  {comm_monoid_add_ordered_comm_monoid_add = comm_monoid_add_int,
    ordered_ab_semigroup_add_ordered_comm_monoid_add =
      ordered_ab_semigroup_add_int}
  : int ordered_comm_monoid_add;

val ordered_semiring_int =
  {ordered_comm_monoid_add_ordered_semiring = ordered_comm_monoid_add_int,
    semiring_ordered_semiring = semiring_int}
  : int ordered_semiring;

val ordered_semiring_0_int =
  {ordered_semigroup_mult_zero_ordered_semiring_0 =
     ordered_semigroup_mult_zero_int,
    ordered_semiring_ordered_semiring_0 = ordered_semiring_int,
    semiring_0_ordered_semiring_0 = semiring_0_int}
  : int ordered_semiring_0;

val ordered_cancel_semiring_int =
  {ordered_cancel_ab_semigroup_add_ordered_cancel_semiring =
     ordered_cancel_ab_semigroup_add_int,
    ordered_semiring_0_ordered_cancel_semiring = ordered_semiring_0_int,
    semiring_0_cancel_ordered_cancel_semiring = semiring_0_cancel_int}
  : int ordered_cancel_semiring;

val ordered_ab_semigroup_add_imp_le_int =
  {ordered_cancel_ab_semigroup_add_ordered_ab_semigroup_add_imp_le =
     ordered_cancel_ab_semigroup_add_int}
  : int ordered_ab_semigroup_add_imp_le;

val strict_ordered_comm_monoid_add_int =
  {comm_monoid_add_strict_ordered_comm_monoid_add = comm_monoid_add_int,
    strict_ordered_ab_semigroup_add_strict_ordered_comm_monoid_add =
      strict_ordered_ab_semigroup_add_int}
  : int strict_ordered_comm_monoid_add;

val ordered_cancel_comm_monoid_add_int =
  {ordered_cancel_ab_semigroup_add_ordered_cancel_comm_monoid_add =
     ordered_cancel_ab_semigroup_add_int,
    ordered_comm_monoid_add_ordered_cancel_comm_monoid_add =
      ordered_comm_monoid_add_int,
    strict_ordered_comm_monoid_add_ordered_cancel_comm_monoid_add =
      strict_ordered_comm_monoid_add_int}
  : int ordered_cancel_comm_monoid_add;

val ordered_ab_semigroup_monoid_add_imp_le_int =
  {cancel_comm_monoid_add_ordered_ab_semigroup_monoid_add_imp_le =
     cancel_comm_monoid_add_int,
    ordered_ab_semigroup_add_imp_le_ordered_ab_semigroup_monoid_add_imp_le =
      ordered_ab_semigroup_add_imp_le_int,
    ordered_cancel_comm_monoid_add_ordered_ab_semigroup_monoid_add_imp_le =
      ordered_cancel_comm_monoid_add_int}
  : int ordered_ab_semigroup_monoid_add_imp_le;

val ordered_ab_group_add_int =
  {ab_group_add_ordered_ab_group_add = ab_group_add_int,
    ordered_ab_semigroup_monoid_add_imp_le_ordered_ab_group_add =
      ordered_ab_semigroup_monoid_add_imp_le_int}
  : int ordered_ab_group_add;

val ordered_ring_int =
  {ordered_ab_group_add_ordered_ring = ordered_ab_group_add_int,
    ordered_cancel_semiring_ordered_ring = ordered_cancel_semiring_int,
    ring_ordered_ring = ring_int}
  : int ordered_ring;

type 'a zero_less_one =
  {order_zero_less_one : 'a order,
    zero_neq_one_zero_less_one : 'a zero_neq_one};
val order_zero_less_one = #order_zero_less_one : 'a zero_less_one -> 'a order;
val zero_neq_one_zero_less_one = #zero_neq_one_zero_less_one :
  'a zero_less_one -> 'a zero_neq_one;

val zero_less_one_int =
  {order_zero_less_one = order_int,
    zero_neq_one_zero_less_one = zero_neq_one_int}
  : int zero_less_one;

val cEnum_int :
  (int list * (((int -> bool) -> bool) * ((int -> bool) -> bool))) option
  = NONE;

type 'a cenum =
  {cEnum :
     ('a list * ((('a -> bool) -> bool) * (('a -> bool) -> bool))) option};
val cEnum = #cEnum :
  'a cenum ->
    ('a list * ((('a -> bool) -> bool) * (('a -> bool) -> bool))) option;

val cenum_int = {cEnum = cEnum_int} : int cenum;

type 'a linordered_ab_semigroup_add =
  {ordered_ab_semigroup_add_linordered_ab_semigroup_add :
     'a ordered_ab_semigroup_add,
    linorder_linordered_ab_semigroup_add : 'a linorder};
val ordered_ab_semigroup_add_linordered_ab_semigroup_add =
  #ordered_ab_semigroup_add_linordered_ab_semigroup_add :
  'a linordered_ab_semigroup_add -> 'a ordered_ab_semigroup_add;
val linorder_linordered_ab_semigroup_add = #linorder_linordered_ab_semigroup_add
  : 'a linordered_ab_semigroup_add -> 'a linorder;

type 'a linordered_cancel_ab_semigroup_add =
  {linordered_ab_semigroup_add_linordered_cancel_ab_semigroup_add :
     'a linordered_ab_semigroup_add,
    ordered_ab_semigroup_add_imp_le_linordered_cancel_ab_semigroup_add :
      'a ordered_ab_semigroup_add_imp_le};
val linordered_ab_semigroup_add_linordered_cancel_ab_semigroup_add =
  #linordered_ab_semigroup_add_linordered_cancel_ab_semigroup_add :
  'a linordered_cancel_ab_semigroup_add -> 'a linordered_ab_semigroup_add;
val ordered_ab_semigroup_add_imp_le_linordered_cancel_ab_semigroup_add =
  #ordered_ab_semigroup_add_imp_le_linordered_cancel_ab_semigroup_add :
  'a linordered_cancel_ab_semigroup_add -> 'a ordered_ab_semigroup_add_imp_le;

type 'a linordered_semiring =
  {linordered_cancel_ab_semigroup_add_linordered_semiring :
     'a linordered_cancel_ab_semigroup_add,
    ordered_ab_semigroup_monoid_add_imp_le_linordered_semiring :
      'a ordered_ab_semigroup_monoid_add_imp_le,
    ordered_cancel_semiring_linordered_semiring : 'a ordered_cancel_semiring};
val linordered_cancel_ab_semigroup_add_linordered_semiring =
  #linordered_cancel_ab_semigroup_add_linordered_semiring :
  'a linordered_semiring -> 'a linordered_cancel_ab_semigroup_add;
val ordered_ab_semigroup_monoid_add_imp_le_linordered_semiring =
  #ordered_ab_semigroup_monoid_add_imp_le_linordered_semiring :
  'a linordered_semiring -> 'a ordered_ab_semigroup_monoid_add_imp_le;
val ordered_cancel_semiring_linordered_semiring =
  #ordered_cancel_semiring_linordered_semiring :
  'a linordered_semiring -> 'a ordered_cancel_semiring;

type 'a linordered_semiring_strict =
  {linordered_semiring_linordered_semiring_strict : 'a linordered_semiring};
val linordered_semiring_linordered_semiring_strict =
  #linordered_semiring_linordered_semiring_strict :
  'a linordered_semiring_strict -> 'a linordered_semiring;

type 'a linordered_semiring_1 =
  {linordered_semiring_linordered_semiring_1 : 'a linordered_semiring,
    semiring_1_linordered_semiring_1 : 'a semiring_1};
val linordered_semiring_linordered_semiring_1 =
  #linordered_semiring_linordered_semiring_1 :
  'a linordered_semiring_1 -> 'a linordered_semiring;
val semiring_1_linordered_semiring_1 = #semiring_1_linordered_semiring_1 :
  'a linordered_semiring_1 -> 'a semiring_1;

type 'a linordered_semiring_1_strict =
  {linordered_semiring_1_linordered_semiring_1_strict :
     'a linordered_semiring_1,
    linordered_semiring_strict_linordered_semiring_1_strict :
      'a linordered_semiring_strict};
val linordered_semiring_1_linordered_semiring_1_strict =
  #linordered_semiring_1_linordered_semiring_1_strict :
  'a linordered_semiring_1_strict -> 'a linordered_semiring_1;
val linordered_semiring_strict_linordered_semiring_1_strict =
  #linordered_semiring_strict_linordered_semiring_1_strict :
  'a linordered_semiring_1_strict -> 'a linordered_semiring_strict;

type 'a ordered_ab_group_add_abs =
  {abs_ordered_ab_group_add_abs : 'a abs,
    ordered_ab_group_add_ordered_ab_group_add_abs : 'a ordered_ab_group_add};
val abs_ordered_ab_group_add_abs = #abs_ordered_ab_group_add_abs :
  'a ordered_ab_group_add_abs -> 'a abs;
val ordered_ab_group_add_ordered_ab_group_add_abs =
  #ordered_ab_group_add_ordered_ab_group_add_abs :
  'a ordered_ab_group_add_abs -> 'a ordered_ab_group_add;

type 'a linordered_ab_group_add =
  {linordered_cancel_ab_semigroup_add_linordered_ab_group_add :
     'a linordered_cancel_ab_semigroup_add,
    ordered_ab_group_add_linordered_ab_group_add : 'a ordered_ab_group_add};
val linordered_cancel_ab_semigroup_add_linordered_ab_group_add =
  #linordered_cancel_ab_semigroup_add_linordered_ab_group_add :
  'a linordered_ab_group_add -> 'a linordered_cancel_ab_semigroup_add;
val ordered_ab_group_add_linordered_ab_group_add =
  #ordered_ab_group_add_linordered_ab_group_add :
  'a linordered_ab_group_add -> 'a ordered_ab_group_add;

type 'a linordered_ring =
  {linordered_ab_group_add_linordered_ring : 'a linordered_ab_group_add,
    ordered_ab_group_add_abs_linordered_ring : 'a ordered_ab_group_add_abs,
    abs_if_linordered_ring : 'a abs_if,
    linordered_semiring_linordered_ring : 'a linordered_semiring,
    ordered_ring_linordered_ring : 'a ordered_ring};
val linordered_ab_group_add_linordered_ring =
  #linordered_ab_group_add_linordered_ring :
  'a linordered_ring -> 'a linordered_ab_group_add;
val ordered_ab_group_add_abs_linordered_ring =
  #ordered_ab_group_add_abs_linordered_ring :
  'a linordered_ring -> 'a ordered_ab_group_add_abs;
val abs_if_linordered_ring = #abs_if_linordered_ring :
  'a linordered_ring -> 'a abs_if;
val linordered_semiring_linordered_ring = #linordered_semiring_linordered_ring :
  'a linordered_ring -> 'a linordered_semiring;
val ordered_ring_linordered_ring = #ordered_ring_linordered_ring :
  'a linordered_ring -> 'a ordered_ring;

type 'a linordered_ring_strict =
  {linordered_ring_linordered_ring_strict : 'a linordered_ring,
    linordered_semiring_strict_linordered_ring_strict :
      'a linordered_semiring_strict,
    ring_no_zero_divisors_linordered_ring_strict : 'a ring_no_zero_divisors};
val linordered_ring_linordered_ring_strict =
  #linordered_ring_linordered_ring_strict :
  'a linordered_ring_strict -> 'a linordered_ring;
val linordered_semiring_strict_linordered_ring_strict =
  #linordered_semiring_strict_linordered_ring_strict :
  'a linordered_ring_strict -> 'a linordered_semiring_strict;
val ring_no_zero_divisors_linordered_ring_strict =
  #ring_no_zero_divisors_linordered_ring_strict :
  'a linordered_ring_strict -> 'a ring_no_zero_divisors;

type 'a ordered_comm_semiring =
  {comm_semiring_0_ordered_comm_semiring : 'a comm_semiring_0,
    ordered_semiring_ordered_comm_semiring : 'a ordered_semiring};
val comm_semiring_0_ordered_comm_semiring =
  #comm_semiring_0_ordered_comm_semiring :
  'a ordered_comm_semiring -> 'a comm_semiring_0;
val ordered_semiring_ordered_comm_semiring =
  #ordered_semiring_ordered_comm_semiring :
  'a ordered_comm_semiring -> 'a ordered_semiring;

type 'a ordered_cancel_comm_semiring =
  {comm_semiring_0_cancel_ordered_cancel_comm_semiring :
     'a comm_semiring_0_cancel,
    ordered_cancel_semiring_ordered_cancel_comm_semiring :
      'a ordered_cancel_semiring,
    ordered_comm_semiring_ordered_cancel_comm_semiring :
      'a ordered_comm_semiring};
val comm_semiring_0_cancel_ordered_cancel_comm_semiring =
  #comm_semiring_0_cancel_ordered_cancel_comm_semiring :
  'a ordered_cancel_comm_semiring -> 'a comm_semiring_0_cancel;
val ordered_cancel_semiring_ordered_cancel_comm_semiring =
  #ordered_cancel_semiring_ordered_cancel_comm_semiring :
  'a ordered_cancel_comm_semiring -> 'a ordered_cancel_semiring;
val ordered_comm_semiring_ordered_cancel_comm_semiring =
  #ordered_comm_semiring_ordered_cancel_comm_semiring :
  'a ordered_cancel_comm_semiring -> 'a ordered_comm_semiring;

type 'a linordered_comm_semiring_strict =
  {linordered_semiring_strict_linordered_comm_semiring_strict :
     'a linordered_semiring_strict,
    ordered_cancel_comm_semiring_linordered_comm_semiring_strict :
      'a ordered_cancel_comm_semiring};
val linordered_semiring_strict_linordered_comm_semiring_strict =
  #linordered_semiring_strict_linordered_comm_semiring_strict :
  'a linordered_comm_semiring_strict -> 'a linordered_semiring_strict;
val ordered_cancel_comm_semiring_linordered_comm_semiring_strict =
  #ordered_cancel_comm_semiring_linordered_comm_semiring_strict :
  'a linordered_comm_semiring_strict -> 'a ordered_cancel_comm_semiring;

type 'a linordered_nonzero_semiring =
  {linorder_linordered_nonzero_semiring : 'a linorder,
    comm_semiring_1_linordered_nonzero_semiring : 'a comm_semiring_1,
    ordered_comm_semiring_linordered_nonzero_semiring :
      'a ordered_comm_semiring,
    zero_less_one_linordered_nonzero_semiring : 'a zero_less_one};
val linorder_linordered_nonzero_semiring = #linorder_linordered_nonzero_semiring
  : 'a linordered_nonzero_semiring -> 'a linorder;
val comm_semiring_1_linordered_nonzero_semiring =
  #comm_semiring_1_linordered_nonzero_semiring :
  'a linordered_nonzero_semiring -> 'a comm_semiring_1;
val ordered_comm_semiring_linordered_nonzero_semiring =
  #ordered_comm_semiring_linordered_nonzero_semiring :
  'a linordered_nonzero_semiring -> 'a ordered_comm_semiring;
val zero_less_one_linordered_nonzero_semiring =
  #zero_less_one_linordered_nonzero_semiring :
  'a linordered_nonzero_semiring -> 'a zero_less_one;

type 'a linordered_semidom =
  {semiring_char_0_linordered_semidom : 'a semiring_char_0,
    linordered_comm_semiring_strict_linordered_semidom :
      'a linordered_comm_semiring_strict,
    linordered_nonzero_semiring_linordered_semidom :
      'a linordered_nonzero_semiring,
    semidom_linordered_semidom : 'a semidom};
val semiring_char_0_linordered_semidom = #semiring_char_0_linordered_semidom :
  'a linordered_semidom -> 'a semiring_char_0;
val linordered_comm_semiring_strict_linordered_semidom =
  #linordered_comm_semiring_strict_linordered_semidom :
  'a linordered_semidom -> 'a linordered_comm_semiring_strict;
val linordered_nonzero_semiring_linordered_semidom =
  #linordered_nonzero_semiring_linordered_semidom :
  'a linordered_semidom -> 'a linordered_nonzero_semiring;
val semidom_linordered_semidom = #semidom_linordered_semidom :
  'a linordered_semidom -> 'a semidom;

type 'a ordered_comm_ring =
  {comm_ring_ordered_comm_ring : 'a comm_ring,
    ordered_cancel_comm_semiring_ordered_comm_ring :
      'a ordered_cancel_comm_semiring,
    ordered_ring_ordered_comm_ring : 'a ordered_ring};
val comm_ring_ordered_comm_ring = #comm_ring_ordered_comm_ring :
  'a ordered_comm_ring -> 'a comm_ring;
val ordered_cancel_comm_semiring_ordered_comm_ring =
  #ordered_cancel_comm_semiring_ordered_comm_ring :
  'a ordered_comm_ring -> 'a ordered_cancel_comm_semiring;
val ordered_ring_ordered_comm_ring = #ordered_ring_ordered_comm_ring :
  'a ordered_comm_ring -> 'a ordered_ring;

type 'a ordered_ring_abs =
  {ordered_ab_group_add_abs_ordered_ring_abs : 'a ordered_ab_group_add_abs,
    ordered_ring_ordered_ring_abs : 'a ordered_ring};
val ordered_ab_group_add_abs_ordered_ring_abs =
  #ordered_ab_group_add_abs_ordered_ring_abs :
  'a ordered_ring_abs -> 'a ordered_ab_group_add_abs;
val ordered_ring_ordered_ring_abs = #ordered_ring_ordered_ring_abs :
  'a ordered_ring_abs -> 'a ordered_ring;

type 'a linordered_idom =
  {ring_char_0_linordered_idom : 'a ring_char_0,
    idom_abs_sgn_linordered_idom : 'a idom_abs_sgn,
    linordered_ring_strict_linordered_idom : 'a linordered_ring_strict,
    linordered_semidom_linordered_idom : 'a linordered_semidom,
    linordered_semiring_1_strict_linordered_idom :
      'a linordered_semiring_1_strict,
    ordered_comm_ring_linordered_idom : 'a ordered_comm_ring,
    ordered_ring_abs_linordered_idom : 'a ordered_ring_abs};
val ring_char_0_linordered_idom = #ring_char_0_linordered_idom :
  'a linordered_idom -> 'a ring_char_0;
val idom_abs_sgn_linordered_idom = #idom_abs_sgn_linordered_idom :
  'a linordered_idom -> 'a idom_abs_sgn;
val linordered_ring_strict_linordered_idom =
  #linordered_ring_strict_linordered_idom :
  'a linordered_idom -> 'a linordered_ring_strict;
val linordered_semidom_linordered_idom = #linordered_semidom_linordered_idom :
  'a linordered_idom -> 'a linordered_semidom;
val linordered_semiring_1_strict_linordered_idom =
  #linordered_semiring_1_strict_linordered_idom :
  'a linordered_idom -> 'a linordered_semiring_1_strict;
val ordered_comm_ring_linordered_idom = #ordered_comm_ring_linordered_idom :
  'a linordered_idom -> 'a ordered_comm_ring;
val ordered_ring_abs_linordered_idom = #ordered_ring_abs_linordered_idom :
  'a linordered_idom -> 'a ordered_ring_abs;

val linordered_ab_semigroup_add_int =
  {ordered_ab_semigroup_add_linordered_ab_semigroup_add =
     ordered_ab_semigroup_add_int,
    linorder_linordered_ab_semigroup_add = linorder_int}
  : int linordered_ab_semigroup_add;

val linordered_cancel_ab_semigroup_add_int =
  {linordered_ab_semigroup_add_linordered_cancel_ab_semigroup_add =
     linordered_ab_semigroup_add_int,
    ordered_ab_semigroup_add_imp_le_linordered_cancel_ab_semigroup_add =
      ordered_ab_semigroup_add_imp_le_int}
  : int linordered_cancel_ab_semigroup_add;

val linordered_semiring_int =
  {linordered_cancel_ab_semigroup_add_linordered_semiring =
     linordered_cancel_ab_semigroup_add_int,
    ordered_ab_semigroup_monoid_add_imp_le_linordered_semiring =
      ordered_ab_semigroup_monoid_add_imp_le_int,
    ordered_cancel_semiring_linordered_semiring = ordered_cancel_semiring_int}
  : int linordered_semiring;

val linordered_semiring_strict_int =
  {linordered_semiring_linordered_semiring_strict = linordered_semiring_int} :
  int linordered_semiring_strict;

val linordered_semiring_1_int =
  {linordered_semiring_linordered_semiring_1 = linordered_semiring_int,
    semiring_1_linordered_semiring_1 = semiring_1_int}
  : int linordered_semiring_1;

val linordered_semiring_1_strict_int =
  {linordered_semiring_1_linordered_semiring_1_strict =
     linordered_semiring_1_int,
    linordered_semiring_strict_linordered_semiring_1_strict =
      linordered_semiring_strict_int}
  : int linordered_semiring_1_strict;

val ordered_ab_group_add_abs_int =
  {abs_ordered_ab_group_add_abs = abs_int,
    ordered_ab_group_add_ordered_ab_group_add_abs = ordered_ab_group_add_int}
  : int ordered_ab_group_add_abs;

val linordered_ab_group_add_int =
  {linordered_cancel_ab_semigroup_add_linordered_ab_group_add =
     linordered_cancel_ab_semigroup_add_int,
    ordered_ab_group_add_linordered_ab_group_add = ordered_ab_group_add_int}
  : int linordered_ab_group_add;

val linordered_ring_int =
  {linordered_ab_group_add_linordered_ring = linordered_ab_group_add_int,
    ordered_ab_group_add_abs_linordered_ring = ordered_ab_group_add_abs_int,
    abs_if_linordered_ring = abs_if_int,
    linordered_semiring_linordered_ring = linordered_semiring_int,
    ordered_ring_linordered_ring = ordered_ring_int}
  : int linordered_ring;

val linordered_ring_strict_int =
  {linordered_ring_linordered_ring_strict = linordered_ring_int,
    linordered_semiring_strict_linordered_ring_strict =
      linordered_semiring_strict_int,
    ring_no_zero_divisors_linordered_ring_strict = ring_no_zero_divisors_int}
  : int linordered_ring_strict;

val ordered_comm_semiring_int =
  {comm_semiring_0_ordered_comm_semiring = comm_semiring_0_int,
    ordered_semiring_ordered_comm_semiring = ordered_semiring_int}
  : int ordered_comm_semiring;

val ordered_cancel_comm_semiring_int =
  {comm_semiring_0_cancel_ordered_cancel_comm_semiring =
     comm_semiring_0_cancel_int,
    ordered_cancel_semiring_ordered_cancel_comm_semiring =
      ordered_cancel_semiring_int,
    ordered_comm_semiring_ordered_cancel_comm_semiring =
      ordered_comm_semiring_int}
  : int ordered_cancel_comm_semiring;

val linordered_comm_semiring_strict_int =
  {linordered_semiring_strict_linordered_comm_semiring_strict =
     linordered_semiring_strict_int,
    ordered_cancel_comm_semiring_linordered_comm_semiring_strict =
      ordered_cancel_comm_semiring_int}
  : int linordered_comm_semiring_strict;

val linordered_nonzero_semiring_int =
  {linorder_linordered_nonzero_semiring = linorder_int,
    comm_semiring_1_linordered_nonzero_semiring = comm_semiring_1_int,
    ordered_comm_semiring_linordered_nonzero_semiring =
      ordered_comm_semiring_int,
    zero_less_one_linordered_nonzero_semiring = zero_less_one_int}
  : int linordered_nonzero_semiring;

val linordered_semidom_int =
  {semiring_char_0_linordered_semidom = semiring_char_0_int,
    linordered_comm_semiring_strict_linordered_semidom =
      linordered_comm_semiring_strict_int,
    linordered_nonzero_semiring_linordered_semidom =
      linordered_nonzero_semiring_int,
    semidom_linordered_semidom = semidom_int}
  : int linordered_semidom;

val ordered_comm_ring_int =
  {comm_ring_ordered_comm_ring = comm_ring_int,
    ordered_cancel_comm_semiring_ordered_comm_ring =
      ordered_cancel_comm_semiring_int,
    ordered_ring_ordered_comm_ring = ordered_ring_int}
  : int ordered_comm_ring;

val ordered_ring_abs_int =
  {ordered_ab_group_add_abs_ordered_ring_abs = ordered_ab_group_add_abs_int,
    ordered_ring_ordered_ring_abs = ordered_ring_int}
  : int ordered_ring_abs;

val linordered_idom_int =
  {ring_char_0_linordered_idom = ring_char_0_int,
    idom_abs_sgn_linordered_idom = idom_abs_sgn_int,
    linordered_ring_strict_linordered_idom = linordered_ring_strict_int,
    linordered_semidom_linordered_idom = linordered_semidom_int,
    linordered_semiring_1_strict_linordered_idom =
      linordered_semiring_1_strict_int,
    ordered_comm_ring_linordered_idom = ordered_comm_ring_int,
    ordered_ring_abs_linordered_idom = ordered_ring_abs_int}
  : int linordered_idom;

type 'a semiring_modulo =
  {comm_semiring_1_cancel_semiring_modulo : 'a comm_semiring_1_cancel,
    modulo_semiring_modulo : 'a modulo};
val comm_semiring_1_cancel_semiring_modulo =
  #comm_semiring_1_cancel_semiring_modulo :
  'a semiring_modulo -> 'a comm_semiring_1_cancel;
val modulo_semiring_modulo = #modulo_semiring_modulo :
  'a semiring_modulo -> 'a modulo;

val semiring_modulo_int =
  {comm_semiring_1_cancel_semiring_modulo = comm_semiring_1_cancel_int,
    modulo_semiring_modulo = modulo_int}
  : int semiring_modulo;

type 'a non_strict_order = {ord_non_strict_order : 'a ord};
val ord_non_strict_order = #ord_non_strict_order :
  'a non_strict_order -> 'a ord;

type 'a ordered_ab_semigroup =
  {ab_semigroup_add_ordered_ab_semigroup : 'a ab_semigroup_add,
    monoid_add_ordered_ab_semigroup : 'a monoid_add,
    non_strict_order_ordered_ab_semigroup : 'a non_strict_order};
val ab_semigroup_add_ordered_ab_semigroup =
  #ab_semigroup_add_ordered_ab_semigroup :
  'a ordered_ab_semigroup -> 'a ab_semigroup_add;
val monoid_add_ordered_ab_semigroup = #monoid_add_ordered_ab_semigroup :
  'a ordered_ab_semigroup -> 'a monoid_add;
val non_strict_order_ordered_ab_semigroup =
  #non_strict_order_ordered_ab_semigroup :
  'a ordered_ab_semigroup -> 'a non_strict_order;

type 'a ordered_semiring_0a =
  {semiring_0_ordered_semiring_0a : 'a semiring_0,
    ordered_ab_semigroup_ordered_semiring_0 : 'a ordered_ab_semigroup};
val semiring_0_ordered_semiring_0a = #semiring_0_ordered_semiring_0a :
  'a ordered_semiring_0a -> 'a semiring_0;
val ordered_ab_semigroup_ordered_semiring_0 =
  #ordered_ab_semigroup_ordered_semiring_0 :
  'a ordered_semiring_0a -> 'a ordered_ab_semigroup;

type 'a ordered_semiring_1 =
  {semiring_1_ordered_semiring_1 : 'a semiring_1,
    ordered_semiring_0_ordered_semiring_1 : 'a ordered_semiring_0a};
val semiring_1_ordered_semiring_1 = #semiring_1_ordered_semiring_1 :
  'a ordered_semiring_1 -> 'a semiring_1;
val ordered_semiring_0_ordered_semiring_1 =
  #ordered_semiring_0_ordered_semiring_1 :
  'a ordered_semiring_1 -> 'a ordered_semiring_0a;

type 'a poly_carrier =
  {comm_semiring_1_poly_carrier : 'a comm_semiring_1,
    ordered_semiring_1_poly_carrier : 'a ordered_semiring_1};
val comm_semiring_1_poly_carrier = #comm_semiring_1_poly_carrier :
  'a poly_carrier -> 'a comm_semiring_1;
val ordered_semiring_1_poly_carrier = #ordered_semiring_1_poly_carrier :
  'a poly_carrier -> 'a ordered_semiring_1;

val non_strict_order_int = {ord_non_strict_order = ord_int} :
  int non_strict_order;

val ordered_ab_semigroup_int =
  {ab_semigroup_add_ordered_ab_semigroup = ab_semigroup_add_int,
    monoid_add_ordered_ab_semigroup = monoid_add_int,
    non_strict_order_ordered_ab_semigroup = non_strict_order_int}
  : int ordered_ab_semigroup;

val ordered_semiring_0_inta =
  {semiring_0_ordered_semiring_0a = semiring_0_int,
    ordered_ab_semigroup_ordered_semiring_0 = ordered_ab_semigroup_int}
  : int ordered_semiring_0a;

val ordered_semiring_1_int =
  {semiring_1_ordered_semiring_1 = semiring_1_int,
    ordered_semiring_0_ordered_semiring_1 = ordered_semiring_0_inta}
  : int ordered_semiring_1;

val poly_carrier_int =
  {comm_semiring_1_poly_carrier = comm_semiring_1_int,
    ordered_semiring_1_poly_carrier = ordered_semiring_1_int}
  : int poly_carrier;

fun eq A_ a b = equal A_ a b;

fun comparator_of (A1_, A2_) x y =
  (if less ((ord_preorder o preorder_order o order_linorder) A2_) x y then Lt
    else (if eq A1_ x y then Eq else Gt));

fun compare_int x = comparator_of (equal_int, linorder_int) x;

val ccompare_inta : (int -> int -> ordera) option = SOME compare_int;

val ccompare_int = {ccompare = ccompare_inta} : int ccompare;

type 'a semidom_modulo =
  {algebraic_semidom_semidom_modulo : 'a algebraic_semidom,
    semiring_modulo_semidom_modulo : 'a semiring_modulo};
val algebraic_semidom_semidom_modulo = #algebraic_semidom_semidom_modulo :
  'a semidom_modulo -> 'a algebraic_semidom;
val semiring_modulo_semidom_modulo = #semiring_modulo_semidom_modulo :
  'a semidom_modulo -> 'a semiring_modulo;

type 'a idom_modulo =
  {semidom_modulo_idom_modulo : 'a semidom_modulo,
    idom_divide_idom_modulo : 'a idom_divide};
val semidom_modulo_idom_modulo = #semidom_modulo_idom_modulo :
  'a idom_modulo -> 'a semidom_modulo;
val idom_divide_idom_modulo = #idom_divide_idom_modulo :
  'a idom_modulo -> 'a idom_divide;

val semidom_modulo_int =
  {algebraic_semidom_semidom_modulo = algebraic_semidom_int,
    semiring_modulo_semidom_modulo = semiring_modulo_int}
  : int semidom_modulo;

val idom_modulo_int =
  {semidom_modulo_idom_modulo = semidom_modulo_int,
    idom_divide_idom_modulo = idom_divide_int}
  : int idom_modulo;

datatype 'a poly = Poly of 'a list;

datatype rat = Frct of (int * int);

datatype real_alg_2 = Rationala of rat |
  Irrational of nat * (int poly * (rat * rat));

datatype real_alg_3 = Real_Alg_Invariant of real_alg_2;

datatype real_alg = Real_Alg_Quotient of real_alg_3;

fun of_rat_3 xa = Real_Alg_Invariant (Rationala xa);

fun of_rat_real_alg x = Real_Alg_Quotient (of_rat_3 x);

datatype real = Real_of of real_alg;

fun ratreal x = (Real_of o of_rat_real_alg) x;

fun of_int a = Frct (a, one_inta);

fun real_of_int x = ratreal (of_int x);

type 'a real_embedding =
  {linordered_idom_real_embedding : 'a linordered_idom, real_of : 'a -> real};
val linordered_idom_real_embedding = #linordered_idom_real_embedding :
  'a real_embedding -> 'a linordered_idom;
val real_of = #real_of : 'a real_embedding -> 'a -> real;

val real_embedding_int =
  {linordered_idom_real_embedding = linordered_idom_int, real_of = real_of_int}
  : int real_embedding;

type 'a factorial_semiring =
  {normalization_semidom_factorial_semiring : 'a normalization_semidom};
val normalization_semidom_factorial_semiring =
  #normalization_semidom_factorial_semiring :
  'a factorial_semiring -> 'a normalization_semidom;

type 'a euclidean_semiring =
  {semidom_modulo_euclidean_semiring : 'a semidom_modulo,
    factorial_semiring_euclidean_semiring : 'a factorial_semiring,
    euclidean_size : 'a -> nat};
val semidom_modulo_euclidean_semiring = #semidom_modulo_euclidean_semiring :
  'a euclidean_semiring -> 'a semidom_modulo;
val factorial_semiring_euclidean_semiring =
  #factorial_semiring_euclidean_semiring :
  'a euclidean_semiring -> 'a factorial_semiring;
val euclidean_size = #euclidean_size : 'a euclidean_semiring -> 'a -> nat;

fun euclidean_size_int x = (nat o abs_inta) x;

type 'a euclidean_ring =
  {euclidean_semiring_euclidean_ring : 'a euclidean_semiring,
    idom_modulo_euclidean_ring : 'a idom_modulo};
val euclidean_semiring_euclidean_ring = #euclidean_semiring_euclidean_ring :
  'a euclidean_ring -> 'a euclidean_semiring;
val idom_modulo_euclidean_ring = #idom_modulo_euclidean_ring :
  'a euclidean_ring -> 'a idom_modulo;

val factorial_semiring_int =
  {normalization_semidom_factorial_semiring = normalization_semidom_int} :
  int factorial_semiring;

val euclidean_semiring_int =
  {semidom_modulo_euclidean_semiring = semidom_modulo_int,
    factorial_semiring_euclidean_semiring = factorial_semiring_int,
    euclidean_size = euclidean_size_int}
  : int euclidean_semiring;

val euclidean_ring_int =
  {euclidean_semiring_euclidean_ring = euclidean_semiring_int,
    idom_modulo_euclidean_ring = idom_modulo_int}
  : int euclidean_ring;

type 'a factorial_semiring_gcd =
  {factorial_semiring_factorial_semiring_gcd : 'a factorial_semiring,
    semiring_Gcd_factorial_semiring_gcd : 'a semiring_Gcd};
val factorial_semiring_factorial_semiring_gcd =
  #factorial_semiring_factorial_semiring_gcd :
  'a factorial_semiring_gcd -> 'a factorial_semiring;
val semiring_Gcd_factorial_semiring_gcd = #semiring_Gcd_factorial_semiring_gcd :
  'a factorial_semiring_gcd -> 'a semiring_Gcd;

type 'a factorial_ring_gcd =
  {factorial_semiring_gcd_factorial_ring_gcd : 'a factorial_semiring_gcd,
    ring_gcd_factorial_ring_gcd : 'a ring_gcd,
    idom_divide_factorial_ring_gcd : 'a idom_divide};
val factorial_semiring_gcd_factorial_ring_gcd =
  #factorial_semiring_gcd_factorial_ring_gcd :
  'a factorial_ring_gcd -> 'a factorial_semiring_gcd;
val ring_gcd_factorial_ring_gcd = #ring_gcd_factorial_ring_gcd :
  'a factorial_ring_gcd -> 'a ring_gcd;
val idom_divide_factorial_ring_gcd = #idom_divide_factorial_ring_gcd :
  'a factorial_ring_gcd -> 'a idom_divide;

val factorial_semiring_gcd_int =
  {factorial_semiring_factorial_semiring_gcd = factorial_semiring_int,
    semiring_Gcd_factorial_semiring_gcd = semiring_Gcd_int}
  : int factorial_semiring_gcd;

val factorial_ring_gcd_int =
  {factorial_semiring_gcd_factorial_ring_gcd = factorial_semiring_gcd_int,
    ring_gcd_factorial_ring_gcd = ring_gcd_int,
    idom_divide_factorial_ring_gcd = idom_divide_int}
  : int factorial_ring_gcd;

type 'a large_ordered_semiring_1 =
  {poly_carrier_large_ordered_semiring_1 : 'a poly_carrier};
val poly_carrier_large_ordered_semiring_1 =
  #poly_carrier_large_ordered_semiring_1 :
  'a large_ordered_semiring_1 -> 'a poly_carrier;

val large_ordered_semiring_1_int =
  {poly_carrier_large_ordered_semiring_1 = poly_carrier_int} :
  int large_ordered_semiring_1;

type 'a euclidean_semiring_gcd =
  {euclidean_semiring_euclidean_semiring_gcd : 'a euclidean_semiring,
    factorial_semiring_gcd_euclidean_semiring_gcd : 'a factorial_semiring_gcd};
val euclidean_semiring_euclidean_semiring_gcd =
  #euclidean_semiring_euclidean_semiring_gcd :
  'a euclidean_semiring_gcd -> 'a euclidean_semiring;
val factorial_semiring_gcd_euclidean_semiring_gcd =
  #factorial_semiring_gcd_euclidean_semiring_gcd :
  'a euclidean_semiring_gcd -> 'a factorial_semiring_gcd;

type 'a euclidean_ring_gcd =
  {euclidean_semiring_gcd_euclidean_ring_gcd : 'a euclidean_semiring_gcd,
    euclidean_ring_euclidean_ring_gcd : 'a euclidean_ring,
    factorial_ring_gcd_euclidean_ring_gcd : 'a factorial_ring_gcd};
val euclidean_semiring_gcd_euclidean_ring_gcd =
  #euclidean_semiring_gcd_euclidean_ring_gcd :
  'a euclidean_ring_gcd -> 'a euclidean_semiring_gcd;
val euclidean_ring_euclidean_ring_gcd = #euclidean_ring_euclidean_ring_gcd :
  'a euclidean_ring_gcd -> 'a euclidean_ring;
val factorial_ring_gcd_euclidean_ring_gcd =
  #factorial_ring_gcd_euclidean_ring_gcd :
  'a euclidean_ring_gcd -> 'a factorial_ring_gcd;

val euclidean_semiring_gcd_int =
  {euclidean_semiring_euclidean_semiring_gcd = euclidean_semiring_int,
    factorial_semiring_gcd_euclidean_semiring_gcd = factorial_semiring_gcd_int}
  : int euclidean_semiring_gcd;

val euclidean_ring_gcd_int =
  {euclidean_semiring_gcd_euclidean_ring_gcd = euclidean_semiring_gcd_int,
    euclidean_ring_euclidean_ring_gcd = euclidean_ring_int,
    factorial_ring_gcd_euclidean_ring_gcd = factorial_ring_gcd_int}
  : int euclidean_ring_gcd;

type 'a large_real_ordered_semiring_1 =
  {real_embedding_large_real_ordered_semiring_1 : 'a real_embedding,
    large_ordered_semiring_1_large_real_ordered_semiring_1 :
      'a large_ordered_semiring_1};
val real_embedding_large_real_ordered_semiring_1 =
  #real_embedding_large_real_ordered_semiring_1 :
  'a large_real_ordered_semiring_1 -> 'a real_embedding;
val large_ordered_semiring_1_large_real_ordered_semiring_1 =
  #large_ordered_semiring_1_large_real_ordered_semiring_1 :
  'a large_real_ordered_semiring_1 -> 'a large_ordered_semiring_1;

val large_real_ordered_semiring_1_int =
  {real_embedding_large_real_ordered_semiring_1 = real_embedding_int,
    large_ordered_semiring_1_large_real_ordered_semiring_1 =
      large_ordered_semiring_1_int}
  : int large_real_ordered_semiring_1;

val equal_nat = {equal = equal_nata} : nat equal;

fun times_nata m n = Nat (IntInf.* (integer_of_nat m, integer_of_nat n));

val times_nat = {times = times_nata} : nat times;

val dvd_nat = {times_dvd = times_nat} : nat dvd;

fun shows_prec_nat x = showsp_nat x;

fun shows_list_nat x = showsp_list shows_prec_nat zero_nata x;

val show_nat = {shows_prec = shows_prec_nat, shows_list = shows_list_nat} :
  nat show;

val one_nat = {onea = one_nata} : nat one;

fun plus_nata m n = Nat (IntInf.+ (integer_of_nat m, integer_of_nat n));

val plus_nat = {plus = plus_nata} : nat plus;

val zero_nat = {zerob = zero_nata} : nat zero;

val semigroup_add_nat = {plus_semigroup_add = plus_nat} : nat semigroup_add;

val numeral_nat =
  {one_numeral = one_nat, semigroup_add_numeral = semigroup_add_nat} :
  nat numeral;

val power_nat = {one_power = one_nat, times_power = times_nat} : nat power;

fun minus_nata m n =
  Nat (max ord_integer (0 : IntInf.int)
        (IntInf.- (integer_of_nat m, integer_of_nat n)));

val minus_nat = {minus = minus_nata} : nat minus;

fun min A_ a b = (if less_eq A_ a b then a else b);

fun less_eq_nat m n = IntInf.<= (integer_of_nat m, integer_of_nat n);

val ord_nat = {less_eq = less_eq_nat, less = less_nat} : nat ord;

fun inf_nata x = min ord_nat x;

type 'a inf = {inf : 'a -> 'a -> 'a};
val inf = #inf : 'a inf -> 'a -> 'a -> 'a;

val inf_nat = {inf = inf_nata} : nat inf;

fun sup_nata x = max ord_nat x;

type 'a sup = {sup : 'a -> 'a -> 'a};
val sup = #sup : 'a sup -> 'a -> 'a -> 'a;

val sup_nat = {sup = sup_nata} : nat sup;

val divide_nat = {divide = divide_nata} : nat divide;

val modulo_nat =
  {divide_modulo = divide_nat, dvd_modulo = dvd_nat, modulo = modulo_nata} :
  nat modulo;

val ab_semigroup_add_nat = {semigroup_add_ab_semigroup_add = semigroup_add_nat}
  : nat ab_semigroup_add;

val monoid_add_nat =
  {semigroup_add_monoid_add = semigroup_add_nat, zero_monoid_add = zero_nat} :
  nat monoid_add;

val comm_monoid_add_nat =
  {ab_semigroup_add_comm_monoid_add = ab_semigroup_add_nat,
    monoid_add_comm_monoid_add = monoid_add_nat}
  : nat comm_monoid_add;

val mult_zero_nat = {times_mult_zero = times_nat, zero_mult_zero = zero_nat} :
  nat mult_zero;

val semigroup_mult_nat = {times_semigroup_mult = times_nat} :
  nat semigroup_mult;

val semiring_nat =
  {ab_semigroup_add_semiring = ab_semigroup_add_nat,
    semigroup_mult_semiring = semigroup_mult_nat}
  : nat semiring;

val semiring_0_nat =
  {comm_monoid_add_semiring_0 = comm_monoid_add_nat,
    mult_zero_semiring_0 = mult_zero_nat, semiring_semiring_0 = semiring_nat}
  : nat semiring_0;

val semiring_no_zero_divisors_nat =
  {semiring_0_semiring_no_zero_divisors = semiring_0_nat} :
  nat semiring_no_zero_divisors;

val monoid_mult_nat =
  {semigroup_mult_monoid_mult = semigroup_mult_nat,
    power_monoid_mult = power_nat}
  : nat monoid_mult;

val semiring_numeral_nat =
  {monoid_mult_semiring_numeral = monoid_mult_nat,
    numeral_semiring_numeral = numeral_nat,
    semiring_semiring_numeral = semiring_nat}
  : nat semiring_numeral;

val zero_neq_one_nat =
  {one_zero_neq_one = one_nat, zero_zero_neq_one = zero_nat} : nat zero_neq_one;

val semiring_1_nat =
  {semiring_numeral_semiring_1 = semiring_numeral_nat,
    semiring_0_semiring_1 = semiring_0_nat,
    zero_neq_one_semiring_1 = zero_neq_one_nat}
  : nat semiring_1;

val semiring_1_no_zero_divisors_nat =
  {semiring_1_semiring_1_no_zero_divisors = semiring_1_nat,
    semiring_no_zero_divisors_semiring_1_no_zero_divisors =
      semiring_no_zero_divisors_nat}
  : nat semiring_1_no_zero_divisors;

val cancel_semigroup_add_nat =
  {semigroup_add_cancel_semigroup_add = semigroup_add_nat} :
  nat cancel_semigroup_add;

val cancel_ab_semigroup_add_nat =
  {ab_semigroup_add_cancel_ab_semigroup_add = ab_semigroup_add_nat,
    cancel_semigroup_add_cancel_ab_semigroup_add = cancel_semigroup_add_nat,
    minus_cancel_ab_semigroup_add = minus_nat}
  : nat cancel_ab_semigroup_add;

val cancel_comm_monoid_add_nat =
  {cancel_ab_semigroup_add_cancel_comm_monoid_add = cancel_ab_semigroup_add_nat,
    comm_monoid_add_cancel_comm_monoid_add = comm_monoid_add_nat}
  : nat cancel_comm_monoid_add;

val semiring_0_cancel_nat =
  {cancel_comm_monoid_add_semiring_0_cancel = cancel_comm_monoid_add_nat,
    semiring_0_semiring_0_cancel = semiring_0_nat}
  : nat semiring_0_cancel;

val ab_semigroup_mult_nat =
  {semigroup_mult_ab_semigroup_mult = semigroup_mult_nat} :
  nat ab_semigroup_mult;

val comm_semiring_nat =
  {ab_semigroup_mult_comm_semiring = ab_semigroup_mult_nat,
    semiring_comm_semiring = semiring_nat}
  : nat comm_semiring;

val comm_semiring_0_nat =
  {comm_semiring_comm_semiring_0 = comm_semiring_nat,
    semiring_0_comm_semiring_0 = semiring_0_nat}
  : nat comm_semiring_0;

val comm_semiring_0_cancel_nat =
  {comm_semiring_0_comm_semiring_0_cancel = comm_semiring_0_nat,
    semiring_0_cancel_comm_semiring_0_cancel = semiring_0_cancel_nat}
  : nat comm_semiring_0_cancel;

val semiring_1_cancel_nat =
  {semiring_0_cancel_semiring_1_cancel = semiring_0_cancel_nat,
    semiring_1_semiring_1_cancel = semiring_1_nat}
  : nat semiring_1_cancel;

val comm_monoid_mult_nat =
  {ab_semigroup_mult_comm_monoid_mult = ab_semigroup_mult_nat,
    monoid_mult_comm_monoid_mult = monoid_mult_nat,
    dvd_comm_monoid_mult = dvd_nat}
  : nat comm_monoid_mult;

val comm_semiring_1_nat =
  {comm_monoid_mult_comm_semiring_1 = comm_monoid_mult_nat,
    comm_semiring_0_comm_semiring_1 = comm_semiring_0_nat,
    semiring_1_comm_semiring_1 = semiring_1_nat}
  : nat comm_semiring_1;

val comm_semiring_1_cancel_nat =
  {comm_semiring_0_cancel_comm_semiring_1_cancel = comm_semiring_0_cancel_nat,
    comm_semiring_1_comm_semiring_1_cancel = comm_semiring_1_nat,
    semiring_1_cancel_comm_semiring_1_cancel = semiring_1_cancel_nat}
  : nat comm_semiring_1_cancel;

val semidom_nat =
  {comm_semiring_1_cancel_semidom = comm_semiring_1_cancel_nat,
    semiring_1_no_zero_divisors_semidom = semiring_1_no_zero_divisors_nat}
  : nat semidom;

val quasi_order_nat = {ord_quasi_order = ord_nat} : nat quasi_order;

val weak_order_nat = {quasi_order_weak_order = quasi_order_nat} :
  nat weak_order;

val preorder_nat = {ord_preorder = ord_nat} : nat preorder;

val order_nat =
  {preorder_order = preorder_nat, weak_order_order = weak_order_nat} :
  nat order;

val linorder_nat = {order_linorder = order_nat} : nat linorder;

fun compare_nata x = comparator_of (equal_nat, linorder_nat) x;

type 'a compare = {compare : 'a -> 'a -> ordera};
val compare = #compare : 'a compare -> 'a -> 'a -> ordera;

type 'a compare_order =
  {compare_compare_order : 'a compare, linorder_compare_order : 'a linorder};
val compare_compare_order = #compare_compare_order :
  'a compare_order -> 'a compare;
val linorder_compare_order = #linorder_compare_order :
  'a compare_order -> 'a linorder;

type 'a key = {compare_order_key : 'a compare_order};
val compare_order_key = #compare_order_key : 'a key -> 'a compare_order;

val compare_nat = {compare = compare_nata} : nat compare;

val compare_order_nat =
  {compare_compare_order = compare_nat, linorder_compare_order = linorder_nat} :
  nat compare_order;

val key_nat = {compare_order_key = compare_order_nat} : nat key;

type 'a quasi_order_sup =
  {sup_quasi_order_sup : 'a sup, quasi_order_quasi_order_sup : 'a quasi_order};
val sup_quasi_order_sup = #sup_quasi_order_sup : 'a quasi_order_sup -> 'a sup;
val quasi_order_quasi_order_sup = #quasi_order_quasi_order_sup :
  'a quasi_order_sup -> 'a quasi_order;

type 'a quasi_semilattice_sup =
  {quasi_order_sup_quasi_semilattice_sup : 'a quasi_order_sup};
val quasi_order_sup_quasi_semilattice_sup =
  #quasi_order_sup_quasi_semilattice_sup :
  'a quasi_semilattice_sup -> 'a quasi_order_sup;

type 'a semilattice_sup =
  {order_semilattice_sup : 'a order,
    quasi_semilattice_sup_semilattice_sup : 'a quasi_semilattice_sup};
val order_semilattice_sup = #order_semilattice_sup :
  'a semilattice_sup -> 'a order;
val quasi_semilattice_sup_semilattice_sup =
  #quasi_semilattice_sup_semilattice_sup :
  'a semilattice_sup -> 'a quasi_semilattice_sup;

type 'a semilattice_inf =
  {inf_semilattice_inf : 'a inf, order_semilattice_inf : 'a order};
val inf_semilattice_inf = #inf_semilattice_inf : 'a semilattice_inf -> 'a inf;
val order_semilattice_inf = #order_semilattice_inf :
  'a semilattice_inf -> 'a order;

type 'a lattice =
  {semilattice_inf_lattice : 'a semilattice_inf,
    semilattice_sup_lattice : 'a semilattice_sup};
val semilattice_inf_lattice = #semilattice_inf_lattice :
  'a lattice -> 'a semilattice_inf;
val semilattice_sup_lattice = #semilattice_sup_lattice :
  'a lattice -> 'a semilattice_sup;

val quasi_order_sup_nat =
  {sup_quasi_order_sup = sup_nat, quasi_order_quasi_order_sup = quasi_order_nat}
  : nat quasi_order_sup;

val quasi_semilattice_sup_nat =
  {quasi_order_sup_quasi_semilattice_sup = quasi_order_sup_nat} :
  nat quasi_semilattice_sup;

val semilattice_sup_nat =
  {order_semilattice_sup = order_nat,
    quasi_semilattice_sup_semilattice_sup = quasi_semilattice_sup_nat}
  : nat semilattice_sup;

val semilattice_inf_nat =
  {inf_semilattice_inf = inf_nat, order_semilattice_inf = order_nat} :
  nat semilattice_inf;

val lattice_nat =
  {semilattice_inf_lattice = semilattice_inf_nat,
    semilattice_sup_lattice = semilattice_sup_nat}
  : nat lattice;

val ceq_nata : (nat -> nat -> bool) option = SOME equal_nata;

val ceq_nat = {ceq = ceq_nata} : nat ceq;

val set_impl_nata : (nat, set_impla) phantom = Phantom Set_RBT;

val set_impl_nat = {set_impl = set_impl_nata} : nat set_impl;

val semiring_char_0_nat = {semiring_1_semiring_char_0 = semiring_1_nat} :
  nat semiring_char_0;

val semiring_no_zero_divisors_cancel_nat =
  {semiring_no_zero_divisors_semiring_no_zero_divisors_cancel =
     semiring_no_zero_divisors_nat}
  : nat semiring_no_zero_divisors_cancel;

val semidom_divide_nat =
  {divide_semidom_divide = divide_nat, semidom_semidom_divide = semidom_nat,
    semiring_no_zero_divisors_cancel_semidom_divide =
      semiring_no_zero_divisors_cancel_nat}
  : nat semidom_divide;

val finite_UNIV_nata : (nat, bool) phantom = Phantom false;

val card_UNIV_nata : (nat, nat) phantom = Phantom zero_nata;

type 'a finite_UNIV = {finite_UNIV : ('a, bool) phantom};
val finite_UNIV = #finite_UNIV : 'a finite_UNIV -> ('a, bool) phantom;

type 'a card_UNIV =
  {finite_UNIV_card_UNIV : 'a finite_UNIV, card_UNIVa : ('a, nat) phantom};
val finite_UNIV_card_UNIV = #finite_UNIV_card_UNIV :
  'a card_UNIV -> 'a finite_UNIV;
val card_UNIVa = #card_UNIVa : 'a card_UNIV -> ('a, nat) phantom;

val finite_UNIV_nat = {finite_UNIV = finite_UNIV_nata} : nat finite_UNIV;

val card_UNIV_nat =
  {finite_UNIV_card_UNIV = finite_UNIV_nat, card_UNIVa = card_UNIV_nata} :
  nat card_UNIV;

val cEnum_nat :
  (nat list * (((nat -> bool) -> bool) * ((nat -> bool) -> bool))) option
  = NONE;

val cenum_nat = {cEnum = cEnum_nat} : nat cenum;

val semiring_modulo_nat =
  {comm_semiring_1_cancel_semiring_modulo = comm_semiring_1_cancel_nat,
    modulo_semiring_modulo = modulo_nat}
  : nat semiring_modulo;

val algebraic_semidom_nat =
  {semidom_divide_algebraic_semidom = semidom_divide_nat} :
  nat algebraic_semidom;

val ccompare_nata : (nat -> nat -> ordera) option = SOME compare_nata;

val ccompare_nat = {ccompare = ccompare_nata} : nat ccompare;

datatype mapping_impla = Mapping_Choose | Mapping_Assoc_List | Mapping_RBT |
  Mapping_Mapping;

val mapping_impl_nata : (nat, mapping_impla) phantom = Phantom Mapping_RBT;

type 'a mapping_impl = {mapping_impl : ('a, mapping_impla) phantom};
val mapping_impl = #mapping_impl :
  'a mapping_impl -> ('a, mapping_impla) phantom;

val mapping_impl_nat = {mapping_impl = mapping_impl_nata} : nat mapping_impl;

fun proper_interval_nat no NONE = true
  | proper_interval_nat NONE (SOME x) = less_nat zero_nata x
  | proper_interval_nat (SOME x) (SOME y) = less_nat one_nata (minus_nata y x);

fun cproper_interval_nata x = proper_interval_nat x;

type 'a cproper_interval =
  {ccompare_cproper_interval : 'a ccompare,
    cproper_interval : 'a option -> 'a option -> bool};
val ccompare_cproper_interval = #ccompare_cproper_interval :
  'a cproper_interval -> 'a ccompare;
val cproper_interval = #cproper_interval :
  'a cproper_interval -> 'a option -> 'a option -> bool;

val cproper_interval_nat =
  {ccompare_cproper_interval = ccompare_nat,
    cproper_interval = cproper_interval_nata}
  : nat cproper_interval;

val semidom_modulo_nat =
  {algebraic_semidom_semidom_modulo = algebraic_semidom_nat,
    semiring_modulo_semidom_modulo = semiring_modulo_nat}
  : nat semidom_modulo;

fun equal_proda A_ B_ (x1, x2) (y1, y2) = eq A_ x1 y1 andalso eq B_ x2 y2;

fun quotient_of (Frct x) = x;

fun equal_rata a b =
  equal_proda equal_int equal_int (quotient_of a) (quotient_of b);

val equal_rat = {equal = equal_rata} : rat equal;

fun normalize p =
  (if less_int zero_inta (snd p)
    then let
           val a = gcd_intc (fst p) (snd p);
         in
           (divide_inta (fst p) a, divide_inta (snd p) a)
         end
    else (if equal_inta (snd p) zero_inta then (zero_inta, one_inta)
           else let
                  val a = uminus_inta (gcd_intc (fst p) (snd p));
                in
                  (divide_inta (fst p) a, divide_inta (snd p) a)
                end));

fun times_rata p q = Frct let
                            val a = quotient_of p;
                            val (aa, c) = a;
                            val b = quotient_of q;
                            val (ba, d) = b;
                          in
                            normalize (times_inta aa ba, times_inta c d)
                          end;

val times_rat = {times = times_rata} : rat times;

val dvd_rat = {times_dvd = times_rat} : rat dvd;

fun showsp_rat p x =
  let
    val (d, n) = quotient_of x;
  in
    (if equal_inta n one_inta then showsp_int p d
      else showsp_int p d o shows_string [#"/"] o showsp_int p n)
  end;

fun shows_prec_rat x = showsp_rat x;

fun shows_list_rat x = showsp_list shows_prec_rat zero_nata x;

val show_rat = {shows_prec = shows_prec_rat, shows_list = shows_list_rat} :
  rat show;

fun abs_rata p = Frct let
                        val a = quotient_of p;
                        val (aa, b) = a;
                      in
                        (abs_inta aa, b)
                      end;

val abs_rat = {abs = abs_rata} : rat abs;

val one_rata : rat = Frct (one_inta, one_inta);

val one_rat = {onea = one_rata} : rat one;

fun sgn_rata p = Frct (sgn_inta (fst (quotient_of p)), one_inta);

val sgn_rat = {sgn = sgn_rata} : rat sgn;

fun uminus_rata p = Frct let
                           val a = quotient_of p;
                           val (aa, b) = a;
                         in
                           (uminus_inta aa, b)
                         end;

fun minus_rata p q =
  Frct let
         val a = quotient_of p;
         val (aa, c) = a;
         val b = quotient_of q;
         val (ba, d) = b;
       in
         normalize
           (minus_inta (times_inta aa d) (times_inta ba c), times_inta c d)
       end;

val zero_rata : rat = Frct (zero_inta, one_inta);

fun plus_rata p q =
  Frct let
         val a = quotient_of p;
         val (aa, c) = a;
         val b = quotient_of q;
         val (ba, d) = b;
       in
         normalize
           (plus_inta (times_inta aa d) (times_inta ba c), times_inta c d)
       end;

val plus_rat = {plus = plus_rata} : rat plus;

val semigroup_add_rat = {plus_semigroup_add = plus_rat} : rat semigroup_add;

val cancel_semigroup_add_rat =
  {semigroup_add_cancel_semigroup_add = semigroup_add_rat} :
  rat cancel_semigroup_add;

val ab_semigroup_add_rat = {semigroup_add_ab_semigroup_add = semigroup_add_rat}
  : rat ab_semigroup_add;

val minus_rat = {minus = minus_rata} : rat minus;

val cancel_ab_semigroup_add_rat =
  {ab_semigroup_add_cancel_ab_semigroup_add = ab_semigroup_add_rat,
    cancel_semigroup_add_cancel_ab_semigroup_add = cancel_semigroup_add_rat,
    minus_cancel_ab_semigroup_add = minus_rat}
  : rat cancel_ab_semigroup_add;

val zero_rat = {zerob = zero_rata} : rat zero;

val monoid_add_rat =
  {semigroup_add_monoid_add = semigroup_add_rat, zero_monoid_add = zero_rat} :
  rat monoid_add;

val comm_monoid_add_rat =
  {ab_semigroup_add_comm_monoid_add = ab_semigroup_add_rat,
    monoid_add_comm_monoid_add = monoid_add_rat}
  : rat comm_monoid_add;

val cancel_comm_monoid_add_rat =
  {cancel_ab_semigroup_add_cancel_comm_monoid_add = cancel_ab_semigroup_add_rat,
    comm_monoid_add_cancel_comm_monoid_add = comm_monoid_add_rat}
  : rat cancel_comm_monoid_add;

val mult_zero_rat = {times_mult_zero = times_rat, zero_mult_zero = zero_rat} :
  rat mult_zero;

val semigroup_mult_rat = {times_semigroup_mult = times_rat} :
  rat semigroup_mult;

val semiring_rat =
  {ab_semigroup_add_semiring = ab_semigroup_add_rat,
    semigroup_mult_semiring = semigroup_mult_rat}
  : rat semiring;

val semiring_0_rat =
  {comm_monoid_add_semiring_0 = comm_monoid_add_rat,
    mult_zero_semiring_0 = mult_zero_rat, semiring_semiring_0 = semiring_rat}
  : rat semiring_0;

val semiring_0_cancel_rat =
  {cancel_comm_monoid_add_semiring_0_cancel = cancel_comm_monoid_add_rat,
    semiring_0_semiring_0_cancel = semiring_0_rat}
  : rat semiring_0_cancel;

val ab_semigroup_mult_rat =
  {semigroup_mult_ab_semigroup_mult = semigroup_mult_rat} :
  rat ab_semigroup_mult;

val comm_semiring_rat =
  {ab_semigroup_mult_comm_semiring = ab_semigroup_mult_rat,
    semiring_comm_semiring = semiring_rat}
  : rat comm_semiring;

val comm_semiring_0_rat =
  {comm_semiring_comm_semiring_0 = comm_semiring_rat,
    semiring_0_comm_semiring_0 = semiring_0_rat}
  : rat comm_semiring_0;

val comm_semiring_0_cancel_rat =
  {comm_semiring_0_comm_semiring_0_cancel = comm_semiring_0_rat,
    semiring_0_cancel_comm_semiring_0_cancel = semiring_0_cancel_rat}
  : rat comm_semiring_0_cancel;

val power_rat = {one_power = one_rat, times_power = times_rat} : rat power;

val monoid_mult_rat =
  {semigroup_mult_monoid_mult = semigroup_mult_rat,
    power_monoid_mult = power_rat}
  : rat monoid_mult;

val numeral_rat =
  {one_numeral = one_rat, semigroup_add_numeral = semigroup_add_rat} :
  rat numeral;

val semiring_numeral_rat =
  {monoid_mult_semiring_numeral = monoid_mult_rat,
    numeral_semiring_numeral = numeral_rat,
    semiring_semiring_numeral = semiring_rat}
  : rat semiring_numeral;

val zero_neq_one_rat =
  {one_zero_neq_one = one_rat, zero_zero_neq_one = zero_rat} : rat zero_neq_one;

val semiring_1_rat =
  {semiring_numeral_semiring_1 = semiring_numeral_rat,
    semiring_0_semiring_1 = semiring_0_rat,
    zero_neq_one_semiring_1 = zero_neq_one_rat}
  : rat semiring_1;

val semiring_1_cancel_rat =
  {semiring_0_cancel_semiring_1_cancel = semiring_0_cancel_rat,
    semiring_1_semiring_1_cancel = semiring_1_rat}
  : rat semiring_1_cancel;

val comm_monoid_mult_rat =
  {ab_semigroup_mult_comm_monoid_mult = ab_semigroup_mult_rat,
    monoid_mult_comm_monoid_mult = monoid_mult_rat,
    dvd_comm_monoid_mult = dvd_rat}
  : rat comm_monoid_mult;

val comm_semiring_1_rat =
  {comm_monoid_mult_comm_semiring_1 = comm_monoid_mult_rat,
    comm_semiring_0_comm_semiring_1 = comm_semiring_0_rat,
    semiring_1_comm_semiring_1 = semiring_1_rat}
  : rat comm_semiring_1;

val comm_semiring_1_cancel_rat =
  {comm_semiring_0_cancel_comm_semiring_1_cancel = comm_semiring_0_cancel_rat,
    comm_semiring_1_comm_semiring_1_cancel = comm_semiring_1_rat,
    semiring_1_cancel_comm_semiring_1_cancel = semiring_1_cancel_rat}
  : rat comm_semiring_1_cancel;

val comm_semiring_1_cancel_crossproduct_rat =
  {comm_semiring_1_cancel_comm_semiring_1_cancel_crossproduct =
     comm_semiring_1_cancel_rat}
  : rat comm_semiring_1_cancel_crossproduct;

val semiring_no_zero_divisors_rat =
  {semiring_0_semiring_no_zero_divisors = semiring_0_rat} :
  rat semiring_no_zero_divisors;

val semiring_1_no_zero_divisors_rat =
  {semiring_1_semiring_1_no_zero_divisors = semiring_1_rat,
    semiring_no_zero_divisors_semiring_1_no_zero_divisors =
      semiring_no_zero_divisors_rat}
  : rat semiring_1_no_zero_divisors;

val semiring_no_zero_divisors_cancel_rat =
  {semiring_no_zero_divisors_semiring_no_zero_divisors_cancel =
     semiring_no_zero_divisors_rat}
  : rat semiring_no_zero_divisors_cancel;

val uminus_rat = {uminus = uminus_rata} : rat uminus;

val group_add_rat =
  {cancel_semigroup_add_group_add = cancel_semigroup_add_rat,
    minus_group_add = minus_rat, monoid_add_group_add = monoid_add_rat,
    uminus_group_add = uminus_rat}
  : rat group_add;

val ab_group_add_rat =
  {cancel_comm_monoid_add_ab_group_add = cancel_comm_monoid_add_rat,
    group_add_ab_group_add = group_add_rat}
  : rat ab_group_add;

val ring_rat =
  {ab_group_add_ring = ab_group_add_rat,
    semiring_0_cancel_ring = semiring_0_cancel_rat}
  : rat ring;

val ring_no_zero_divisors_rat =
  {ring_ring_no_zero_divisors = ring_rat,
    semiring_no_zero_divisors_cancel_ring_no_zero_divisors =
      semiring_no_zero_divisors_cancel_rat}
  : rat ring_no_zero_divisors;

val neg_numeral_rat =
  {group_add_neg_numeral = group_add_rat, numeral_neg_numeral = numeral_rat} :
  rat neg_numeral;

val ring_1_rat =
  {neg_numeral_ring_1 = neg_numeral_rat, ring_ring_1 = ring_rat,
    semiring_1_cancel_ring_1 = semiring_1_cancel_rat}
  : rat ring_1;

val ring_1_no_zero_divisors_rat =
  {ring_1_ring_1_no_zero_divisors = ring_1_rat,
    ring_no_zero_divisors_ring_1_no_zero_divisors = ring_no_zero_divisors_rat,
    semiring_1_no_zero_divisors_ring_1_no_zero_divisors =
      semiring_1_no_zero_divisors_rat}
  : rat ring_1_no_zero_divisors;

val comm_ring_rat =
  {comm_semiring_0_cancel_comm_ring = comm_semiring_0_cancel_rat,
    ring_comm_ring = ring_rat}
  : rat comm_ring;

val comm_ring_1_rat =
  {comm_ring_comm_ring_1 = comm_ring_rat,
    comm_semiring_1_cancel_comm_ring_1 = comm_semiring_1_cancel_rat,
    ring_1_comm_ring_1 = ring_1_rat}
  : rat comm_ring_1;

val semidom_rat =
  {comm_semiring_1_cancel_semidom = comm_semiring_1_cancel_rat,
    semiring_1_no_zero_divisors_semidom = semiring_1_no_zero_divisors_rat}
  : rat semidom;

val idom_rat =
  {comm_ring_1_idom = comm_ring_1_rat,
    ring_1_no_zero_divisors_idom = ring_1_no_zero_divisors_rat,
    semidom_idom = semidom_rat,
    comm_semiring_1_cancel_crossproduct_idom =
      comm_semiring_1_cancel_crossproduct_rat}
  : rat idom;

fun inverse_rata p =
  Frct let
         val a = quotient_of p;
         val (aa, b) = a;
       in
         (if equal_inta aa zero_inta then (zero_inta, one_inta)
           else (times_inta (sgn_inta aa) b, abs_inta aa))
       end;

fun divide_rata p q = Frct let
                             val a = quotient_of p;
                             val (aa, c) = a;
                             val b = quotient_of q;
                             val (ba, d) = b;
                           in
                             normalize (times_inta aa d, times_inta c ba)
                           end;

type 'a inverse = {divide_inverse : 'a divide, inverse : 'a -> 'a};
val divide_inverse = #divide_inverse : 'a inverse -> 'a divide;
val inverse = #inverse : 'a inverse -> 'a -> 'a;

type 'a ufd = {idom_ufd : 'a idom};
val idom_ufd = #idom_ufd : 'a ufd -> 'a idom;

type 'a division_ring =
  {inverse_division_ring : 'a inverse,
    ring_1_no_zero_divisors_division_ring : 'a ring_1_no_zero_divisors};
val inverse_division_ring = #inverse_division_ring :
  'a division_ring -> 'a inverse;
val ring_1_no_zero_divisors_division_ring =
  #ring_1_no_zero_divisors_division_ring :
  'a division_ring -> 'a ring_1_no_zero_divisors;

type 'a field =
  {division_ring_field : 'a division_ring, idom_divide_field : 'a idom_divide,
    ufd_field : 'a ufd};
val division_ring_field = #division_ring_field : 'a field -> 'a division_ring;
val idom_divide_field = #idom_divide_field : 'a field -> 'a idom_divide;
val ufd_field = #ufd_field : 'a field -> 'a ufd;

val ufd_rat = {idom_ufd = idom_rat} : rat ufd;

val divide_rat = {divide = divide_rata} : rat divide;

val inverse_rat = {divide_inverse = divide_rat, inverse = inverse_rata} :
  rat inverse;

val division_ring_rat =
  {inverse_division_ring = inverse_rat,
    ring_1_no_zero_divisors_division_ring = ring_1_no_zero_divisors_rat}
  : rat division_ring;

val semidom_divide_rat =
  {divide_semidom_divide = divide_rat, semidom_semidom_divide = semidom_rat,
    semiring_no_zero_divisors_cancel_semidom_divide =
      semiring_no_zero_divisors_cancel_rat}
  : rat semidom_divide;

val idom_divide_rat =
  {idom_idom_divide = idom_rat, semidom_divide_idom_divide = semidom_divide_rat}
  : rat idom_divide;

val field_rat =
  {division_ring_field = division_ring_rat, idom_divide_field = idom_divide_rat,
    ufd_field = ufd_rat}
  : rat field;

fun less_eq_rat p q = let
                        val a = quotient_of p;
                        val (aa, c) = a;
                        val b = quotient_of q;
                        val (ba, d) = b;
                      in
                        less_eq_int (times_inta aa d) (times_inta c ba)
                      end;

fun less_rat p q = let
                     val a = quotient_of p;
                     val (aa, c) = a;
                     val b = quotient_of q;
                     val (ba, d) = b;
                   in
                     less_int (times_inta aa d) (times_inta c ba)
                   end;

val ord_rat = {less_eq = less_eq_rat, less = less_rat} : rat ord;

val abs_if_rat =
  {abs_abs_if = abs_rat, minus_abs_if = minus_rat, uminus_abs_if = uminus_rat,
    zero_abs_if = zero_rat, ord_abs_if = ord_rat}
  : rat abs_if;

val quasi_order_rat = {ord_quasi_order = ord_rat} : rat quasi_order;

val weak_order_rat = {quasi_order_weak_order = quasi_order_rat} :
  rat weak_order;

val preorder_rat = {ord_preorder = ord_rat} : rat preorder;

val order_rat =
  {preorder_order = preorder_rat, weak_order_order = weak_order_rat} :
  rat order;

val linorder_rat = {order_linorder = order_rat} : rat linorder;

fun compare_rata x = comparator_of (equal_rat, linorder_rat) x;

val compare_rat = {compare = compare_rata} : rat compare;

val semiring_char_0_rat = {semiring_1_semiring_char_0 = semiring_1_rat} :
  rat semiring_char_0;

val ring_char_0_rat =
  {semiring_char_0_ring_char_0 = semiring_char_0_rat,
    ring_1_ring_char_0 = ring_1_rat}
  : rat ring_char_0;

type 'a no_bot = {order_no_bot : 'a order};
val order_no_bot = #order_no_bot : 'a no_bot -> 'a order;

val no_bot_rat = {order_no_bot = order_rat} : rat no_bot;

type 'a no_top = {order_no_top : 'a order};
val order_no_top = #order_no_top : 'a no_top -> 'a order;

val no_top_rat = {order_no_top = order_rat} : rat no_top;

val ceq_rata : (rat -> rat -> bool) option = SOME equal_rata;

val ceq_rat = {ceq = ceq_rata} : rat ceq;

val set_impl_rata : (rat, set_impla) phantom = Phantom Set_RBT;

val set_impl_rat = {set_impl = set_impl_rata} : rat set_impl;

val idom_abs_sgn_rat =
  {abs_idom_abs_sgn = abs_rat, sgn_idom_abs_sgn = sgn_rat,
    idom_idom_abs_sgn = idom_rat}
  : rat idom_abs_sgn;

val ordered_ab_semigroup_add_rat =
  {ab_semigroup_add_ordered_ab_semigroup_add = ab_semigroup_add_rat,
    order_ordered_ab_semigroup_add = order_rat}
  : rat ordered_ab_semigroup_add;

val strict_ordered_ab_semigroup_add_rat =
  {ordered_ab_semigroup_add_strict_ordered_ab_semigroup_add =
     ordered_ab_semigroup_add_rat}
  : rat strict_ordered_ab_semigroup_add;

val ordered_cancel_ab_semigroup_add_rat =
  {cancel_ab_semigroup_add_ordered_cancel_ab_semigroup_add =
     cancel_ab_semigroup_add_rat,
    strict_ordered_ab_semigroup_add_ordered_cancel_ab_semigroup_add =
      strict_ordered_ab_semigroup_add_rat}
  : rat ordered_cancel_ab_semigroup_add;

val ordered_semigroup_mult_zero_rat =
  {semigroup_mult_ordered_semigroup_mult_zero = semigroup_mult_rat,
    order_ordered_semigroup_mult_zero = order_rat,
    mult_zero_ordered_semigroup_mult_zero = mult_zero_rat}
  : rat ordered_semigroup_mult_zero;

val ordered_comm_monoid_add_rat =
  {comm_monoid_add_ordered_comm_monoid_add = comm_monoid_add_rat,
    ordered_ab_semigroup_add_ordered_comm_monoid_add =
      ordered_ab_semigroup_add_rat}
  : rat ordered_comm_monoid_add;

val ordered_semiring_rat =
  {ordered_comm_monoid_add_ordered_semiring = ordered_comm_monoid_add_rat,
    semiring_ordered_semiring = semiring_rat}
  : rat ordered_semiring;

val ordered_semiring_0_rat =
  {ordered_semigroup_mult_zero_ordered_semiring_0 =
     ordered_semigroup_mult_zero_rat,
    ordered_semiring_ordered_semiring_0 = ordered_semiring_rat,
    semiring_0_ordered_semiring_0 = semiring_0_rat}
  : rat ordered_semiring_0;

val ordered_cancel_semiring_rat =
  {ordered_cancel_ab_semigroup_add_ordered_cancel_semiring =
     ordered_cancel_ab_semigroup_add_rat,
    ordered_semiring_0_ordered_cancel_semiring = ordered_semiring_0_rat,
    semiring_0_cancel_ordered_cancel_semiring = semiring_0_cancel_rat}
  : rat ordered_cancel_semiring;

val ordered_ab_semigroup_add_imp_le_rat =
  {ordered_cancel_ab_semigroup_add_ordered_ab_semigroup_add_imp_le =
     ordered_cancel_ab_semigroup_add_rat}
  : rat ordered_ab_semigroup_add_imp_le;

val strict_ordered_comm_monoid_add_rat =
  {comm_monoid_add_strict_ordered_comm_monoid_add = comm_monoid_add_rat,
    strict_ordered_ab_semigroup_add_strict_ordered_comm_monoid_add =
      strict_ordered_ab_semigroup_add_rat}
  : rat strict_ordered_comm_monoid_add;

val ordered_cancel_comm_monoid_add_rat =
  {ordered_cancel_ab_semigroup_add_ordered_cancel_comm_monoid_add =
     ordered_cancel_ab_semigroup_add_rat,
    ordered_comm_monoid_add_ordered_cancel_comm_monoid_add =
      ordered_comm_monoid_add_rat,
    strict_ordered_comm_monoid_add_ordered_cancel_comm_monoid_add =
      strict_ordered_comm_monoid_add_rat}
  : rat ordered_cancel_comm_monoid_add;

val ordered_ab_semigroup_monoid_add_imp_le_rat =
  {cancel_comm_monoid_add_ordered_ab_semigroup_monoid_add_imp_le =
     cancel_comm_monoid_add_rat,
    ordered_ab_semigroup_add_imp_le_ordered_ab_semigroup_monoid_add_imp_le =
      ordered_ab_semigroup_add_imp_le_rat,
    ordered_cancel_comm_monoid_add_ordered_ab_semigroup_monoid_add_imp_le =
      ordered_cancel_comm_monoid_add_rat}
  : rat ordered_ab_semigroup_monoid_add_imp_le;

val ordered_ab_group_add_rat =
  {ab_group_add_ordered_ab_group_add = ab_group_add_rat,
    ordered_ab_semigroup_monoid_add_imp_le_ordered_ab_group_add =
      ordered_ab_semigroup_monoid_add_imp_le_rat}
  : rat ordered_ab_group_add;

val ordered_ring_rat =
  {ordered_ab_group_add_ordered_ring = ordered_ab_group_add_rat,
    ordered_cancel_semiring_ordered_ring = ordered_cancel_semiring_rat,
    ring_ordered_ring = ring_rat}
  : rat ordered_ring;

type 'a field_char_0 =
  {field_field_char_0 : 'a field, ring_char_0_field_char_0 : 'a ring_char_0};
val field_field_char_0 = #field_field_char_0 : 'a field_char_0 -> 'a field;
val ring_char_0_field_char_0 = #ring_char_0_field_char_0 :
  'a field_char_0 -> 'a ring_char_0;

val field_char_0_rat =
  {field_field_char_0 = field_rat, ring_char_0_field_char_0 = ring_char_0_rat} :
  rat field_char_0;

val zero_less_one_rat =
  {order_zero_less_one = order_rat,
    zero_neq_one_zero_less_one = zero_neq_one_rat}
  : rat zero_less_one;

type 'a field_abs_sgn =
  {field_field_abs_sgn : 'a field,
    idom_abs_sgn_field_abs_sgn : 'a idom_abs_sgn};
val field_field_abs_sgn = #field_field_abs_sgn : 'a field_abs_sgn -> 'a field;
val idom_abs_sgn_field_abs_sgn = #idom_abs_sgn_field_abs_sgn :
  'a field_abs_sgn -> 'a idom_abs_sgn;

val field_abs_sgn_rat =
  {field_field_abs_sgn = field_rat,
    idom_abs_sgn_field_abs_sgn = idom_abs_sgn_rat}
  : rat field_abs_sgn;

val cEnum_rat :
  (rat list * (((rat -> bool) -> bool) * ((rat -> bool) -> bool))) option
  = NONE;

val cenum_rat = {cEnum = cEnum_rat} : rat cenum;

type 'a dense_order = {order_dense_order : 'a order};
val order_dense_order = #order_dense_order : 'a dense_order -> 'a order;

val dense_order_rat = {order_dense_order = order_rat} : rat dense_order;

val linordered_ab_semigroup_add_rat =
  {ordered_ab_semigroup_add_linordered_ab_semigroup_add =
     ordered_ab_semigroup_add_rat,
    linorder_linordered_ab_semigroup_add = linorder_rat}
  : rat linordered_ab_semigroup_add;

val linordered_cancel_ab_semigroup_add_rat =
  {linordered_ab_semigroup_add_linordered_cancel_ab_semigroup_add =
     linordered_ab_semigroup_add_rat,
    ordered_ab_semigroup_add_imp_le_linordered_cancel_ab_semigroup_add =
      ordered_ab_semigroup_add_imp_le_rat}
  : rat linordered_cancel_ab_semigroup_add;

val linordered_semiring_rat =
  {linordered_cancel_ab_semigroup_add_linordered_semiring =
     linordered_cancel_ab_semigroup_add_rat,
    ordered_ab_semigroup_monoid_add_imp_le_linordered_semiring =
      ordered_ab_semigroup_monoid_add_imp_le_rat,
    ordered_cancel_semiring_linordered_semiring = ordered_cancel_semiring_rat}
  : rat linordered_semiring;

val linordered_semiring_strict_rat =
  {linordered_semiring_linordered_semiring_strict = linordered_semiring_rat} :
  rat linordered_semiring_strict;

val linordered_semiring_1_rat =
  {linordered_semiring_linordered_semiring_1 = linordered_semiring_rat,
    semiring_1_linordered_semiring_1 = semiring_1_rat}
  : rat linordered_semiring_1;

val linordered_semiring_1_strict_rat =
  {linordered_semiring_1_linordered_semiring_1_strict =
     linordered_semiring_1_rat,
    linordered_semiring_strict_linordered_semiring_1_strict =
      linordered_semiring_strict_rat}
  : rat linordered_semiring_1_strict;

val ordered_ab_group_add_abs_rat =
  {abs_ordered_ab_group_add_abs = abs_rat,
    ordered_ab_group_add_ordered_ab_group_add_abs = ordered_ab_group_add_rat}
  : rat ordered_ab_group_add_abs;

val linordered_ab_group_add_rat =
  {linordered_cancel_ab_semigroup_add_linordered_ab_group_add =
     linordered_cancel_ab_semigroup_add_rat,
    ordered_ab_group_add_linordered_ab_group_add = ordered_ab_group_add_rat}
  : rat linordered_ab_group_add;

val linordered_ring_rat =
  {linordered_ab_group_add_linordered_ring = linordered_ab_group_add_rat,
    ordered_ab_group_add_abs_linordered_ring = ordered_ab_group_add_abs_rat,
    abs_if_linordered_ring = abs_if_rat,
    linordered_semiring_linordered_ring = linordered_semiring_rat,
    ordered_ring_linordered_ring = ordered_ring_rat}
  : rat linordered_ring;

val linordered_ring_strict_rat =
  {linordered_ring_linordered_ring_strict = linordered_ring_rat,
    linordered_semiring_strict_linordered_ring_strict =
      linordered_semiring_strict_rat,
    ring_no_zero_divisors_linordered_ring_strict = ring_no_zero_divisors_rat}
  : rat linordered_ring_strict;

val ordered_comm_semiring_rat =
  {comm_semiring_0_ordered_comm_semiring = comm_semiring_0_rat,
    ordered_semiring_ordered_comm_semiring = ordered_semiring_rat}
  : rat ordered_comm_semiring;

val ordered_cancel_comm_semiring_rat =
  {comm_semiring_0_cancel_ordered_cancel_comm_semiring =
     comm_semiring_0_cancel_rat,
    ordered_cancel_semiring_ordered_cancel_comm_semiring =
      ordered_cancel_semiring_rat,
    ordered_comm_semiring_ordered_cancel_comm_semiring =
      ordered_comm_semiring_rat}
  : rat ordered_cancel_comm_semiring;

val linordered_comm_semiring_strict_rat =
  {linordered_semiring_strict_linordered_comm_semiring_strict =
     linordered_semiring_strict_rat,
    ordered_cancel_comm_semiring_linordered_comm_semiring_strict =
      ordered_cancel_comm_semiring_rat}
  : rat linordered_comm_semiring_strict;

val linordered_nonzero_semiring_rat =
  {linorder_linordered_nonzero_semiring = linorder_rat,
    comm_semiring_1_linordered_nonzero_semiring = comm_semiring_1_rat,
    ordered_comm_semiring_linordered_nonzero_semiring =
      ordered_comm_semiring_rat,
    zero_less_one_linordered_nonzero_semiring = zero_less_one_rat}
  : rat linordered_nonzero_semiring;

val linordered_semidom_rat =
  {semiring_char_0_linordered_semidom = semiring_char_0_rat,
    linordered_comm_semiring_strict_linordered_semidom =
      linordered_comm_semiring_strict_rat,
    linordered_nonzero_semiring_linordered_semidom =
      linordered_nonzero_semiring_rat,
    semidom_linordered_semidom = semidom_rat}
  : rat linordered_semidom;

val ordered_comm_ring_rat =
  {comm_ring_ordered_comm_ring = comm_ring_rat,
    ordered_cancel_comm_semiring_ordered_comm_ring =
      ordered_cancel_comm_semiring_rat,
    ordered_ring_ordered_comm_ring = ordered_ring_rat}
  : rat ordered_comm_ring;

val ordered_ring_abs_rat =
  {ordered_ab_group_add_abs_ordered_ring_abs = ordered_ab_group_add_abs_rat,
    ordered_ring_ordered_ring_abs = ordered_ring_rat}
  : rat ordered_ring_abs;

val linordered_idom_rat =
  {ring_char_0_linordered_idom = ring_char_0_rat,
    idom_abs_sgn_linordered_idom = idom_abs_sgn_rat,
    linordered_ring_strict_linordered_idom = linordered_ring_strict_rat,
    linordered_semidom_linordered_idom = linordered_semidom_rat,
    linordered_semiring_1_strict_linordered_idom =
      linordered_semiring_1_strict_rat,
    ordered_comm_ring_linordered_idom = ordered_comm_ring_rat,
    ordered_ring_abs_linordered_idom = ordered_ring_abs_rat}
  : rat linordered_idom;

val non_strict_order_rat = {ord_non_strict_order = ord_rat} :
  rat non_strict_order;

val ordered_ab_semigroup_rat =
  {ab_semigroup_add_ordered_ab_semigroup = ab_semigroup_add_rat,
    monoid_add_ordered_ab_semigroup = monoid_add_rat,
    non_strict_order_ordered_ab_semigroup = non_strict_order_rat}
  : rat ordered_ab_semigroup;

val ordered_semiring_0_rata =
  {semiring_0_ordered_semiring_0a = semiring_0_rat,
    ordered_ab_semigroup_ordered_semiring_0 = ordered_ab_semigroup_rat}
  : rat ordered_semiring_0a;

val ordered_semiring_1_rat =
  {semiring_1_ordered_semiring_1 = semiring_1_rat,
    ordered_semiring_0_ordered_semiring_1 = ordered_semiring_0_rata}
  : rat ordered_semiring_1;

val poly_carrier_rat =
  {comm_semiring_1_poly_carrier = comm_semiring_1_rat,
    ordered_semiring_1_poly_carrier = ordered_semiring_1_rat}
  : rat poly_carrier;

type 'a dense_linorder =
  {dense_order_dense_linorder : 'a dense_order,
    linorder_dense_linorder : 'a linorder};
val dense_order_dense_linorder = #dense_order_dense_linorder :
  'a dense_linorder -> 'a dense_order;
val linorder_dense_linorder = #linorder_dense_linorder :
  'a dense_linorder -> 'a linorder;

type 'a unbounded_dense_linorder =
  {dense_linorder_unbounded_dense_linorder : 'a dense_linorder,
    no_bot_unbounded_dense_linorder : 'a no_bot,
    no_top_unbounded_dense_linorder : 'a no_top};
val dense_linorder_unbounded_dense_linorder =
  #dense_linorder_unbounded_dense_linorder :
  'a unbounded_dense_linorder -> 'a dense_linorder;
val no_bot_unbounded_dense_linorder = #no_bot_unbounded_dense_linorder :
  'a unbounded_dense_linorder -> 'a no_bot;
val no_top_unbounded_dense_linorder = #no_top_unbounded_dense_linorder :
  'a unbounded_dense_linorder -> 'a no_top;

type 'a linordered_field =
  {field_abs_sgn_linordered_field : 'a field_abs_sgn,
    field_char_0_linordered_field : 'a field_char_0,
    unbounded_dense_linorder_linordered_field : 'a unbounded_dense_linorder,
    linordered_idom_linordered_field : 'a linordered_idom};
val field_abs_sgn_linordered_field = #field_abs_sgn_linordered_field :
  'a linordered_field -> 'a field_abs_sgn;
val field_char_0_linordered_field = #field_char_0_linordered_field :
  'a linordered_field -> 'a field_char_0;
val unbounded_dense_linorder_linordered_field =
  #unbounded_dense_linorder_linordered_field :
  'a linordered_field -> 'a unbounded_dense_linorder;
val linordered_idom_linordered_field = #linordered_idom_linordered_field :
  'a linordered_field -> 'a linordered_idom;

val dense_linorder_rat =
  {dense_order_dense_linorder = dense_order_rat,
    linorder_dense_linorder = linorder_rat}
  : rat dense_linorder;

val unbounded_dense_linorder_rat =
  {dense_linorder_unbounded_dense_linorder = dense_linorder_rat,
    no_bot_unbounded_dense_linorder = no_bot_rat,
    no_top_unbounded_dense_linorder = no_top_rat}
  : rat unbounded_dense_linorder;

val linordered_field_rat =
  {field_abs_sgn_linordered_field = field_abs_sgn_rat,
    field_char_0_linordered_field = field_char_0_rat,
    unbounded_dense_linorder_linordered_field = unbounded_dense_linorder_rat,
    linordered_idom_linordered_field = linordered_idom_rat}
  : rat linordered_field;

val ccompare_rata : (rat -> rat -> ordera) option = SOME compare_rata;

val ccompare_rat = {ccompare = ccompare_rata} : rat ccompare;

fun real_of_rat x = ratreal x;

val real_embedding_rat =
  {linordered_idom_real_embedding = linordered_idom_rat, real_of = real_of_rat}
  : rat real_embedding;

type 'a archimedean_field =
  {linordered_field_archimedean_field : 'a linordered_field};
val linordered_field_archimedean_field = #linordered_field_archimedean_field :
  'a archimedean_field -> 'a linordered_field;

type 'a floor_ceiling =
  {archimedean_field_floor_ceiling : 'a archimedean_field,
    large_ordered_semiring_1_floor_ceiling : 'a large_ordered_semiring_1,
    floor : 'a -> int};
val archimedean_field_floor_ceiling = #archimedean_field_floor_ceiling :
  'a floor_ceiling -> 'a archimedean_field;
val large_ordered_semiring_1_floor_ceiling =
  #large_ordered_semiring_1_floor_ceiling :
  'a floor_ceiling -> 'a large_ordered_semiring_1;
val floor = #floor : 'a floor_ceiling -> 'a -> int;

fun floor_rat p = let
                    val a = quotient_of p;
                    val (aa, b) = a;
                  in
                    divide_inta aa b
                  end;

val archimedean_field_rat =
  {linordered_field_archimedean_field = linordered_field_rat} :
  rat archimedean_field;

val large_ordered_semiring_1_rat =
  {poly_carrier_large_ordered_semiring_1 = poly_carrier_rat} :
  rat large_ordered_semiring_1;

val floor_ceiling_rat =
  {archimedean_field_floor_ceiling = archimedean_field_rat,
    large_ordered_semiring_1_floor_ceiling = large_ordered_semiring_1_rat,
    floor = floor_rat}
  : rat floor_ceiling;

val large_real_ordered_semiring_1_rat =
  {real_embedding_large_real_ordered_semiring_1 = real_embedding_rat,
    large_ordered_semiring_1_large_real_ordered_semiring_1 =
      large_ordered_semiring_1_rat}
  : rat large_real_ordered_semiring_1;

fun equal_order Lt Gt = false
  | equal_order Gt Lt = false
  | equal_order Eq Gt = false
  | equal_order Gt Eq = false
  | equal_order Eq Lt = false
  | equal_order Lt Eq = false
  | equal_order Gt Gt = true
  | equal_order Lt Lt = true
  | equal_order Eq Eq = true;

datatype ('a, 'b) generator = Generator of (('b -> bool) * ('b -> 'a * 'b));

fun generator (Generator x) = x;

fun has_next g = fst (generator g);

fun next g = snd (generator g);

fun sorted_list_subset_fusion less eq g1 g2 s1 s2 =
  (if has_next g1 s1
    then let
           val (x, s1a) = next g1 s1;
         in
           has_next g2 s2 andalso
             let
               val (y, s2a) = next g2 s2;
             in
               (if eq x y then sorted_list_subset_fusion less eq g1 g2 s1a s2a
                 else less y x andalso
                        sorted_list_subset_fusion less eq g1 g2 s1 s2a)
             end
         end
    else true);

fun list_all_fusion g p s =
  (if has_next g s then let
                          val (x, sa) = next g s;
                        in
                          p x andalso list_all_fusion g p sa
                        end
    else true);

fun rbt_keys_next ((k, t) :: kts, Emptya) = (k, (kts, t))
  | rbt_keys_next (kts, Branch (c, l, k, v, r)) =
    rbt_keys_next ((k, r) :: kts, l);

fun rbt_has_next ([], Emptya) = false
  | rbt_has_next (vb :: vc, va) = true
  | rbt_has_next (v, Branch (vb, vc, vd, ve, vf)) = true;

val rbt_keys_generator :
  ('a, (('a * ('a, 'b) rbta) list * ('a, 'b) rbta)) generator
  = Generator (rbt_has_next, rbt_keys_next);

fun lt_of_comp acomp x y =
  (case acomp x y of Eq => false | Lt => true | Gt => false);

fun list_of_dlist A_ (Abs_dlist x) = x;

fun list_all p [] = true
  | list_all p (x :: xs) = p x andalso list_all p xs;

fun dlist_all A_ x xc = list_all x (list_of_dlist A_ xc);

fun impl_ofb B_ (Mapping_RBTa x) = x;

fun rbt_init x = ([], x);

fun init A_ xa = rbt_init (impl_ofb A_ xa);

fun filtera p [] = []
  | filtera p (x :: xs) = (if p x then x :: filtera p xs else filtera p xs);

fun collect A_ p =
  (case cEnum A_ of NONE => Collect_set p
    | SOME (enum, _) => Set_Monad (filtera p enum));

fun list_member equal (x :: xs) y = equal x y orelse list_member equal xs y
  | list_member equal [] y = false;

fun the (SOME x2) = x2;

fun memberc A_ xa = list_member (the (ceq A_)) (list_of_dlist A_ xa);

fun equal_optiona A_ NONE (SOME x2) = false
  | equal_optiona A_ (SOME x2) NONE = false
  | equal_optiona A_ (SOME x2) (SOME y2) = eq A_ x2 y2
  | equal_optiona A_ NONE NONE = true;

fun rbt_comp_lookup c Emptya k = NONE
  | rbt_comp_lookup c (Branch (uu, l, x, y, r)) k =
    (case c k x of Eq => SOME y | Lt => rbt_comp_lookup c l k
      | Gt => rbt_comp_lookup c r k);

fun lookupd A_ xa = rbt_comp_lookup (the (ccompare A_)) (impl_ofb A_ xa);

fun equal_unita u v = true;

val equal_unit = {equal = equal_unita} : unit equal;

fun memberb A_ t x = equal_optiona equal_unit (lookupd A_ t x) (SOME ());

fun member (A1_, A2_) x (Set_Monad xs) =
  (case ceq A1_
    of NONE =>
      (raise Fail "member Set_Monad: ceq = None")
        (fn _ => member (A1_, A2_) x (Set_Monad xs))
    | SOME eq => list_member eq xs x)
  | member (A1_, A2_) xa (Complement x) = not (member (A1_, A2_) xa x)
  | member (A1_, A2_) x (RBT_set rbt) = memberb A2_ rbt x
  | member (A1_, A2_) x (DList_set dxs) = memberc A1_ dxs x
  | member (A1_, A2_) x (Collect_set a) = a x;

fun subset_eq (A1_, A2_, A3_) (RBT_set rbt1) (RBT_set rbt2) =
  (case ccompare A3_
    of NONE =>
      (raise Fail "subset RBT_set RBT_set: ccompare = None")
        (fn _ => subset_eq (A1_, A2_, A3_) (RBT_set rbt1) (RBT_set rbt2))
    | SOME c =>
      (case ceq A2_
        of NONE =>
          sorted_list_subset_fusion (lt_of_comp c)
            (fn x => fn y => equal_order (c x y) Eq) rbt_keys_generator
            rbt_keys_generator (init A3_ rbt1) (init A3_ rbt2)
        | SOME eq =>
          sorted_list_subset_fusion (lt_of_comp c) eq rbt_keys_generator
            rbt_keys_generator (init A3_ rbt1) (init A3_ rbt2)))
  | subset_eq (A1_, A2_, A3_) (Complement a1) (Complement a2) =
    subset_eq (A1_, A2_, A3_) a2 a1
  | subset_eq (A1_, A2_, A3_) (Collect_set p) (Complement a) =
    subset_eq (A1_, A2_, A3_) a (collect A1_ (fn x => not (p x)))
  | subset_eq (A1_, A2_, A3_) (Set_Monad xs) c =
    list_all (fn x => member (A2_, A3_) x c) xs
  | subset_eq (A1_, A2_, A3_) (DList_set dxs) c =
    (case ceq A2_
      of NONE =>
        (raise Fail "subset DList_set1: ceq = None")
          (fn _ => subset_eq (A1_, A2_, A3_) (DList_set dxs) c)
      | SOME _ => dlist_all A2_ (fn x => member (A2_, A3_) x c) dxs)
  | subset_eq (A1_, A2_, A3_) (RBT_set rbt) b =
    (case ccompare A3_
      of NONE =>
        (raise Fail "subset RBT_set1: ccompare = None")
          (fn _ => subset_eq (A1_, A2_, A3_) (RBT_set rbt) b)
      | SOME _ =>
        list_all_fusion rbt_keys_generator (fn x => member (A2_, A3_) x b)
          (init A3_ rbt));

fun less_eq_set (A1_, A2_, A3_) = subset_eq (A1_, A2_, A3_);

fun equal_seta (A1_, A2_, A3_, A4_) a b =
  less_eq_set (A1_, A2_, A3_) a b andalso less_eq_set (A1_, A2_, A3_) b a;

fun equal_set (A1_, A2_, A3_, A4_) = {equal = equal_seta (A1_, A2_, A3_, A4_)} :
  'a set equal;

fun uminus_set (Complement b) = b
  | uminus_set (Collect_set p) = Collect_set (fn x => not (p x))
  | uminus_set a = Complement a;

fun balance (Branch (R, a, w, x, b)) s t (Branch (R, c, y, z, d)) =
  Branch (R, Branch (B, a, w, x, b), s, t, Branch (B, c, y, z, d))
  | balance (Branch (R, Branch (R, a, w, x, b), s, t, c)) y z Emptya =
    Branch (R, Branch (B, a, w, x, b), s, t, Branch (B, c, y, z, Emptya))
  | balance (Branch (R, Branch (R, a, w, x, b), s, t, c)) y z
    (Branch (B, va, vb, vc, vd)) =
    Branch
      (R, Branch (B, a, w, x, b), s, t,
        Branch (B, c, y, z, Branch (B, va, vb, vc, vd)))
  | balance (Branch (R, Emptya, w, x, Branch (R, b, s, t, c))) y z Emptya =
    Branch (R, Branch (B, Emptya, w, x, b), s, t, Branch (B, c, y, z, Emptya))
  | balance
    (Branch (R, Branch (B, va, vb, vc, vd), w, x, Branch (R, b, s, t, c))) y z
    Emptya =
    Branch
      (R, Branch (B, Branch (B, va, vb, vc, vd), w, x, b), s, t,
        Branch (B, c, y, z, Emptya))
  | balance (Branch (R, Emptya, w, x, Branch (R, b, s, t, c))) y z
    (Branch (B, va, vb, vc, vd)) =
    Branch
      (R, Branch (B, Emptya, w, x, b), s, t,
        Branch (B, c, y, z, Branch (B, va, vb, vc, vd)))
  | balance
    (Branch (R, Branch (B, ve, vf, vg, vh), w, x, Branch (R, b, s, t, c))) y z
    (Branch (B, va, vb, vc, vd)) =
    Branch
      (R, Branch (B, Branch (B, ve, vf, vg, vh), w, x, b), s, t,
        Branch (B, c, y, z, Branch (B, va, vb, vc, vd)))
  | balance Emptya w x (Branch (R, b, s, t, Branch (R, c, y, z, d))) =
    Branch (R, Branch (B, Emptya, w, x, b), s, t, Branch (B, c, y, z, d))
  | balance (Branch (B, va, vb, vc, vd)) w x
    (Branch (R, b, s, t, Branch (R, c, y, z, d))) =
    Branch
      (R, Branch (B, Branch (B, va, vb, vc, vd), w, x, b), s, t,
        Branch (B, c, y, z, d))
  | balance Emptya w x (Branch (R, Branch (R, b, s, t, c), y, z, Emptya)) =
    Branch (R, Branch (B, Emptya, w, x, b), s, t, Branch (B, c, y, z, Emptya))
  | balance Emptya w x
    (Branch (R, Branch (R, b, s, t, c), y, z, Branch (B, va, vb, vc, vd))) =
    Branch
      (R, Branch (B, Emptya, w, x, b), s, t,
        Branch (B, c, y, z, Branch (B, va, vb, vc, vd)))
  | balance (Branch (B, va, vb, vc, vd)) w x
    (Branch (R, Branch (R, b, s, t, c), y, z, Emptya)) =
    Branch
      (R, Branch (B, Branch (B, va, vb, vc, vd), w, x, b), s, t,
        Branch (B, c, y, z, Emptya))
  | balance (Branch (B, va, vb, vc, vd)) w x
    (Branch (R, Branch (R, b, s, t, c), y, z, Branch (B, ve, vf, vg, vh))) =
    Branch
      (R, Branch (B, Branch (B, va, vb, vc, vd), w, x, b), s, t,
        Branch (B, c, y, z, Branch (B, ve, vf, vg, vh)))
  | balance Emptya s t Emptya = Branch (B, Emptya, s, t, Emptya)
  | balance Emptya s t (Branch (B, va, vb, vc, vd)) =
    Branch (B, Emptya, s, t, Branch (B, va, vb, vc, vd))
  | balance Emptya s t (Branch (v, Emptya, vb, vc, Emptya)) =
    Branch (B, Emptya, s, t, Branch (v, Emptya, vb, vc, Emptya))
  | balance Emptya s t (Branch (v, Branch (B, ve, vf, vg, vh), vb, vc, Emptya))
    = Branch
        (B, Emptya, s, t,
          Branch (v, Branch (B, ve, vf, vg, vh), vb, vc, Emptya))
  | balance Emptya s t (Branch (v, Emptya, vb, vc, Branch (B, vf, vg, vh, vi)))
    = Branch
        (B, Emptya, s, t,
          Branch (v, Emptya, vb, vc, Branch (B, vf, vg, vh, vi)))
  | balance Emptya s t
    (Branch (v, Branch (B, ve, vj, vk, vl), vb, vc, Branch (B, vf, vg, vh, vi)))
    = Branch
        (B, Emptya, s, t,
          Branch
            (v, Branch (B, ve, vj, vk, vl), vb, vc, Branch (B, vf, vg, vh, vi)))
  | balance (Branch (B, va, vb, vc, vd)) s t Emptya =
    Branch (B, Branch (B, va, vb, vc, vd), s, t, Emptya)
  | balance (Branch (B, va, vb, vc, vd)) s t (Branch (B, ve, vf, vg, vh)) =
    Branch (B, Branch (B, va, vb, vc, vd), s, t, Branch (B, ve, vf, vg, vh))
  | balance (Branch (B, va, vb, vc, vd)) s t
    (Branch (v, Emptya, vf, vg, Emptya)) =
    Branch
      (B, Branch (B, va, vb, vc, vd), s, t, Branch (v, Emptya, vf, vg, Emptya))
  | balance (Branch (B, va, vb, vc, vd)) s t
    (Branch (v, Branch (B, vi, vj, vk, vl), vf, vg, Emptya)) =
    Branch
      (B, Branch (B, va, vb, vc, vd), s, t,
        Branch (v, Branch (B, vi, vj, vk, vl), vf, vg, Emptya))
  | balance (Branch (B, va, vb, vc, vd)) s t
    (Branch (v, Emptya, vf, vg, Branch (B, vj, vk, vl, vm))) =
    Branch
      (B, Branch (B, va, vb, vc, vd), s, t,
        Branch (v, Emptya, vf, vg, Branch (B, vj, vk, vl, vm)))
  | balance (Branch (B, va, vb, vc, vd)) s t
    (Branch (v, Branch (B, vi, vn, vo, vp), vf, vg, Branch (B, vj, vk, vl, vm)))
    = Branch
        (B, Branch (B, va, vb, vc, vd), s, t,
          Branch
            (v, Branch (B, vi, vn, vo, vp), vf, vg, Branch (B, vj, vk, vl, vm)))
  | balance (Branch (v, Emptya, vb, vc, Emptya)) s t Emptya =
    Branch (B, Branch (v, Emptya, vb, vc, Emptya), s, t, Emptya)
  | balance (Branch (v, Emptya, vb, vc, Branch (B, ve, vf, vg, vh))) s t Emptya
    = Branch
        (B, Branch (v, Emptya, vb, vc, Branch (B, ve, vf, vg, vh)), s, t,
          Emptya)
  | balance (Branch (v, Branch (B, vf, vg, vh, vi), vb, vc, Emptya)) s t Emptya
    = Branch
        (B, Branch (v, Branch (B, vf, vg, vh, vi), vb, vc, Emptya), s, t,
          Emptya)
  | balance
    (Branch (v, Branch (B, vf, vg, vh, vi), vb, vc, Branch (B, ve, vj, vk, vl)))
    s t Emptya =
    Branch
      (B, Branch
            (v, Branch (B, vf, vg, vh, vi), vb, vc, Branch (B, ve, vj, vk, vl)),
        s, t, Emptya)
  | balance (Branch (v, Emptya, vf, vg, Emptya)) s t
    (Branch (B, va, vb, vc, vd)) =
    Branch
      (B, Branch (v, Emptya, vf, vg, Emptya), s, t, Branch (B, va, vb, vc, vd))
  | balance (Branch (v, Emptya, vf, vg, Branch (B, vi, vj, vk, vl))) s t
    (Branch (B, va, vb, vc, vd)) =
    Branch
      (B, Branch (v, Emptya, vf, vg, Branch (B, vi, vj, vk, vl)), s, t,
        Branch (B, va, vb, vc, vd))
  | balance (Branch (v, Branch (B, vj, vk, vl, vm), vf, vg, Emptya)) s t
    (Branch (B, va, vb, vc, vd)) =
    Branch
      (B, Branch (v, Branch (B, vj, vk, vl, vm), vf, vg, Emptya), s, t,
        Branch (B, va, vb, vc, vd))
  | balance
    (Branch (v, Branch (B, vj, vk, vl, vm), vf, vg, Branch (B, vi, vn, vo, vp)))
    s t (Branch (B, va, vb, vc, vd)) =
    Branch
      (B, Branch
            (v, Branch (B, vj, vk, vl, vm), vf, vg, Branch (B, vi, vn, vo, vp)),
        s, t, Branch (B, va, vb, vc, vd));

fun rbt_comp_ins c f k v Emptya = Branch (R, Emptya, k, v, Emptya)
  | rbt_comp_ins c f k v (Branch (B, l, x, y, r)) =
    (case c k x of Eq => Branch (B, l, x, f k y v, r)
      | Lt => balance (rbt_comp_ins c f k v l) x y r
      | Gt => balance l x y (rbt_comp_ins c f k v r))
  | rbt_comp_ins c f k v (Branch (R, l, x, y, r)) =
    (case c k x of Eq => Branch (R, l, x, f k y v, r)
      | Lt => Branch (R, rbt_comp_ins c f k v l, x, y, r)
      | Gt => Branch (R, l, x, y, rbt_comp_ins c f k v r));

fun paint c Emptya = Emptya
  | paint c (Branch (uu, l, k, v, r)) = Branch (c, l, k, v, r);

fun rbt_comp_insert_with_key c f k v t = paint B (rbt_comp_ins c f k v t);

fun rbt_comp_insert c =
  rbt_comp_insert_with_key c (fn _ => fn _ => fn nv => nv);

fun inserte A_ xc xd xe =
  Mapping_RBTa (rbt_comp_insert (the (ccompare A_)) xc xd (impl_ofb A_ xe));

fun comp_sunion_with c f ((ka, va) :: asa) ((k, v) :: bs) =
  (case c k ka of Eq => (ka, f ka va v) :: comp_sunion_with c f asa bs
    | Lt => (k, v) :: comp_sunion_with c f ((ka, va) :: asa) bs
    | Gt => (ka, va) :: comp_sunion_with c f asa ((k, v) :: bs))
  | comp_sunion_with c f [] bs = bs
  | comp_sunion_with c f asa [] = asa;

datatype comparea = LT | GT | EQ;

fun skip_red (Branch (R, l, k, v, r)) = l
  | skip_red Emptya = Emptya
  | skip_red (Branch (B, va, vb, vc, vd)) = Branch (B, va, vb, vc, vd);

fun skip_black t =
  let
    val ta = skip_red t;
  in
    (case ta of Emptya => ta | Branch (R, _, _, _, _) => ta
      | Branch (B, l, _, _, _) => l)
  end;

fun compare_height sx s t tx =
  (case (skip_red sx, (skip_red s, (skip_red t, skip_red tx)))
    of (Emptya, (Emptya, (_, Emptya))) => EQ
    | (Emptya, (Emptya, (_, Branch (_, _, _, _, _)))) => LT
    | (Emptya, (Branch (_, _, _, _, _), (Emptya, _))) => EQ
    | (Emptya, (Branch (_, _, _, _, _), (Branch (_, _, _, _, _), Emptya))) => EQ
    | (Emptya,
        (Branch (_, sa, _, _, _),
          (Branch (_, ta, _, _, _), Branch (_, txa, _, _, _))))
      => compare_height Emptya sa ta (skip_black txa)
    | (Branch (_, _, _, _, _), (Emptya, (Emptya, Emptya))) => GT
    | (Branch (_, _, _, _, _), (Emptya, (Emptya, Branch (_, _, _, _, _)))) => LT
    | (Branch (_, _, _, _, _), (Emptya, (Branch (_, _, _, _, _), Emptya))) => EQ
    | (Branch (_, _, _, _, _),
        (Emptya, (Branch (_, _, _, _, _), Branch (_, _, _, _, _))))
      => LT
    | (Branch (_, _, _, _, _), (Branch (_, _, _, _, _), (Emptya, _))) => GT
    | (Branch (_, sxa, _, _, _),
        (Branch (_, sa, _, _, _), (Branch (_, ta, _, _, _), Emptya)))
      => compare_height (skip_black sxa) sa ta Emptya
    | (Branch (_, sxa, _, _, _),
        (Branch (_, sa, _, _, _),
          (Branch (_, ta, _, _, _), Branch (_, txa, _, _, _))))
      => compare_height (skip_black sxa) sa ta (skip_black txa));

fun suc n = plus_nata n one_nata;

fun gen_length n (x :: xs) = gen_length (suc n) xs
  | gen_length n [] = n;

fun size_list x = gen_length zero_nata x;

fun apfst f (x, y) = (f x, y);

fun map_prod f g (a, b) = (f a, g b);

fun divmod_nat m n =
  let
    val k = integer_of_nat m;
    val l = integer_of_nat n;
  in
    map_prod nat_of_integer nat_of_integer
      (if ((k : IntInf.int) = (0 : IntInf.int))
        then ((0 : IntInf.int), (0 : IntInf.int))
        else (if ((l : IntInf.int) = (0 : IntInf.int))
               then ((0 : IntInf.int), k) else IntInf.divMod ( k, l )))
  end;

fun rbtreeify_g n kvs =
  (if equal_nata n zero_nata orelse equal_nata n one_nata then (Emptya, kvs)
    else let
           val (na, r) = divmod_nat n (nat_of_integer (2 : IntInf.int));
         in
           (if equal_nata r zero_nata
             then let
                    val (t1, (k, v) :: kvsa) = rbtreeify_g na kvs;
                  in
                    apfst (fn a => Branch (B, t1, k, v, a))
                      (rbtreeify_g na kvsa)
                  end
             else let
                    val (t1, (k, v) :: kvsa) = rbtreeify_f na kvs;
                  in
                    apfst (fn a => Branch (B, t1, k, v, a))
                      (rbtreeify_g na kvsa)
                  end)
         end)
and rbtreeify_f n kvs =
  (if equal_nata n zero_nata then (Emptya, kvs)
    else (if equal_nata n one_nata
           then let
                  val (k, v) :: kvsa = kvs;
                in
                  (Branch (R, Emptya, k, v, Emptya), kvsa)
                end
           else let
                  val (na, r) = divmod_nat n (nat_of_integer (2 : IntInf.int));
                in
                  (if equal_nata r zero_nata
                    then let
                           val (t1, (k, v) :: kvsa) = rbtreeify_f na kvs;
                         in
                           apfst (fn a => Branch (B, t1, k, v, a))
                             (rbtreeify_g na kvsa)
                         end
                    else let
                           val (t1, (k, v) :: kvsa) = rbtreeify_f na kvs;
                         in
                           apfst (fn a => Branch (B, t1, k, v, a))
                             (rbtreeify_f na kvsa)
                         end)
                end));

fun rbtreeify kvs = fst (rbtreeify_g (suc (size_list kvs)) kvs);

fun gen_entries kvts (Branch (c, l, k, v, r)) =
  gen_entries (((k, v), r) :: kvts) l
  | gen_entries ((kv, t) :: kvts) Emptya = kv :: gen_entries kvts t
  | gen_entries [] Emptya = [];

fun entries x = gen_entries [] x;

fun folda f (Branch (c, lt, k, v, rt)) x = folda f rt (f k v (folda f lt x))
  | folda f Emptya x = x;

fun rbt_comp_union_with_key c f t1 t2 =
  (case compare_height t1 t1 t2 t2
    of LT =>
      folda (rbt_comp_insert_with_key c (fn k => fn v => fn w => f k w v)) t1 t2
    | GT => folda (rbt_comp_insert_with_key c f) t2 t1
    | EQ => rbtreeify (comp_sunion_with c f (entries t1) (entries t2)));

fun join A_ xc xd xe =
  Mapping_RBTa
    (rbt_comp_union_with_key (the (ccompare A_)) xc (impl_ofb A_ xd)
      (impl_ofb A_ xe));

fun list_insert equal x xs = (if list_member equal xs x then xs else x :: xs);

fun insertc A_ xb xc =
  Abs_dlist (list_insert (the (ceq A_)) xb (list_of_dlist A_ xc));

fun fold f (x :: xs) s = fold f xs (f x s)
  | fold f [] s = s;

fun foldc A_ x xc = fold x (list_of_dlist A_ xc);

fun uniona A_ = foldc A_ (insertc A_);

fun id x = (fn xa => xa) x;

fun is_none (SOME x) = false
  | is_none NONE = true;

fun inter_list A_ xb xc =
  Mapping_RBTa
    (fold (fn k => rbt_comp_insert (the (ccompare A_)) k ())
      (filtera
        (fn x =>
          not (is_none
                (rbt_comp_lookup (the (ccompare A_)) (impl_ofb A_ xb) x)))
        xc)
      Emptya);

fun filterc A_ xb xc =
  Mapping_RBTa (rbtreeify (filtera xb (entries (impl_ofb A_ xc))));

fun comp_sinter_with c f ((ka, va) :: asa) ((k, v) :: bs) =
  (case c k ka of Eq => (ka, f ka va v) :: comp_sinter_with c f asa bs
    | Lt => comp_sinter_with c f ((ka, va) :: asa) bs
    | Gt => comp_sinter_with c f asa ((k, v) :: bs))
  | comp_sinter_with c f [] uu = []
  | comp_sinter_with c f uv [] = [];

fun map_option f NONE = NONE
  | map_option f (SOME x2) = SOME (f x2);

fun map_filter f [] = []
  | map_filter f (x :: xs) =
    (case f x of NONE => map_filter f xs | SOME y => y :: map_filter f xs);

fun rbt_comp_inter_with_key c f t1 t2 =
  (case compare_height t1 t1 t2 t2
    of LT =>
      rbtreeify
        (map_filter
          (fn (k, v) =>
            map_option (fn w => (k, f k v w)) (rbt_comp_lookup c t2 k))
          (entries t1))
    | GT =>
      rbtreeify
        (map_filter
          (fn (k, v) =>
            map_option (fn w => (k, f k w v)) (rbt_comp_lookup c t1 k))
          (entries t2))
    | EQ => rbtreeify (comp_sinter_with c f (entries t1) (entries t2)));

fun meet A_ xc xd xe =
  Mapping_RBTa
    (rbt_comp_inter_with_key (the (ccompare A_)) xc (impl_ofb A_ xd)
      (impl_ofb A_ xe));

fun filterb A_ xb xc = Abs_dlist (filtera xb (list_of_dlist A_ xc));

fun inf_seta (A1_, A2_) (RBT_set rbt1) (Set_Monad xs) =
  (case ccompare A2_
    of NONE =>
      (raise Fail "inter RBT_set Set_Monad: ccompare = None")
        (fn _ => inf_seta (A1_, A2_) (RBT_set rbt1) (Set_Monad xs))
    | SOME _ => RBT_set (inter_list A2_ rbt1 xs))
  | inf_seta (A1_, A2_) (RBT_set rbt) (DList_set dxs) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "inter RBT_set DList_set: ccompare = None")
          (fn _ => inf_seta (A1_, A2_) (RBT_set rbt) (DList_set dxs))
      | SOME _ =>
        (case ceq A1_
          of NONE =>
            (raise Fail "inter RBT_set DList_set: ceq = None")
              (fn _ => inf_seta (A1_, A2_) (RBT_set rbt) (DList_set dxs))
          | SOME _ => RBT_set (inter_list A2_ rbt (list_of_dlist A1_ dxs))))
  | inf_seta (A1_, A2_) (RBT_set rbt1) (RBT_set rbt2) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "inter RBT_set RBT_set: ccompare = None")
          (fn _ => inf_seta (A1_, A2_) (RBT_set rbt1) (RBT_set rbt2))
      | SOME _ => RBT_set (meet A2_ (fn _ => fn _ => id) rbt1 rbt2))
  | inf_seta (A1_, A2_) (DList_set dxs1) (Set_Monad xs) =
    (case ceq A1_
      of NONE =>
        (raise Fail "inter DList_set Set_Monad: ceq = None")
          (fn _ => inf_seta (A1_, A2_) (DList_set dxs1) (Set_Monad xs))
      | SOME eq => DList_set (filterb A1_ (list_member eq xs) dxs1))
  | inf_seta (A1_, A2_) (DList_set dxs1) (DList_set dxs2) =
    (case ceq A1_
      of NONE =>
        (raise Fail "inter DList_set DList_set: ceq = None")
          (fn _ => inf_seta (A1_, A2_) (DList_set dxs1) (DList_set dxs2))
      | SOME _ => DList_set (filterb A1_ (memberc A1_ dxs2) dxs1))
  | inf_seta (A1_, A2_) (DList_set dxs) (RBT_set rbt) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "inter DList_set RBT_set: ccompare = None")
          (fn _ => inf_seta (A1_, A2_) (DList_set dxs) (RBT_set rbt))
      | SOME _ =>
        (case ceq A1_
          of NONE =>
            (raise Fail "inter DList_set RBT_set: ceq = None")
              (fn _ => inf_seta (A1_, A2_) (DList_set dxs) (RBT_set rbt))
          | SOME _ => RBT_set (inter_list A2_ rbt (list_of_dlist A1_ dxs))))
  | inf_seta (A1_, A2_) (Set_Monad xs1) (Set_Monad xs2) =
    (case ceq A1_
      of NONE =>
        (raise Fail "inter Set_Monad Set_Monad: ceq = None")
          (fn _ => inf_seta (A1_, A2_) (Set_Monad xs1) (Set_Monad xs2))
      | SOME eq => Set_Monad (filtera (list_member eq xs2) xs1))
  | inf_seta (A1_, A2_) (Set_Monad xs) (DList_set dxs2) =
    (case ceq A1_
      of NONE =>
        (raise Fail "inter Set_Monad DList_set: ceq = None")
          (fn _ => inf_seta (A1_, A2_) (Set_Monad xs) (DList_set dxs2))
      | SOME eq => DList_set (filterb A1_ (list_member eq xs) dxs2))
  | inf_seta (A1_, A2_) (Set_Monad xs) (RBT_set rbt1) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "inter Set_Monad RBT_set: ccompare = None")
          (fn _ => inf_seta (A1_, A2_) (RBT_set rbt1) (Set_Monad xs))
      | SOME _ => RBT_set (inter_list A2_ rbt1 xs))
  | inf_seta (A1_, A2_) (Complement ba) (Complement b) =
    Complement (sup_seta (A1_, A2_) ba b)
  | inf_seta (A1_, A2_) g (RBT_set rbt2) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "inter RBT_set2: ccompare = None")
          (fn _ => inf_seta (A1_, A2_) g (RBT_set rbt2))
      | SOME _ =>
        RBT_set (filterc A2_ ((fn x => member (A1_, A2_) x g) o fst) rbt2))
  | inf_seta (A1_, A2_) (RBT_set rbt1) g =
    (case ccompare A2_
      of NONE =>
        (raise Fail "inter RBT_set1: ccompare = None")
          (fn _ => inf_seta (A1_, A2_) (RBT_set rbt1) g)
      | SOME _ =>
        RBT_set (filterc A2_ ((fn x => member (A1_, A2_) x g) o fst) rbt1))
  | inf_seta (A1_, A2_) h (DList_set dxs2) =
    (case ceq A1_
      of NONE =>
        (raise Fail "inter DList_set2: ceq = None")
          (fn _ => inf_seta (A1_, A2_) h (DList_set dxs2))
      | SOME _ => DList_set (filterb A1_ (fn x => member (A1_, A2_) x h) dxs2))
  | inf_seta (A1_, A2_) (DList_set dxs1) h =
    (case ceq A1_
      of NONE =>
        (raise Fail "inter DList_set1: ceq = None")
          (fn _ => inf_seta (A1_, A2_) (DList_set dxs1) h)
      | SOME _ => DList_set (filterb A1_ (fn x => member (A1_, A2_) x h) dxs1))
  | inf_seta (A1_, A2_) i (Set_Monad xs) =
    Set_Monad (filtera (fn x => member (A1_, A2_) x i) xs)
  | inf_seta (A1_, A2_) (Set_Monad xs) i =
    Set_Monad (filtera (fn x => member (A1_, A2_) x i) xs)
  | inf_seta (A1_, A2_) j (Collect_set a) =
    Collect_set (fn x => a x andalso member (A1_, A2_) x j)
  | inf_seta (A1_, A2_) (Collect_set a) j =
    Collect_set (fn x => a x andalso member (A1_, A2_) x j)
and sup_seta (A1_, A2_) ba (Complement b) =
  Complement (inf_seta (A1_, A2_) (uminus_set ba) b)
  | sup_seta (A1_, A2_) (Complement ba) b =
    Complement (inf_seta (A1_, A2_) ba (uminus_set b))
  | sup_seta (A1_, A2_) b (Collect_set a) =
    Collect_set (fn x => a x orelse member (A1_, A2_) x b)
  | sup_seta (A1_, A2_) (Collect_set a) b =
    Collect_set (fn x => a x orelse member (A1_, A2_) x b)
  | sup_seta (A1_, A2_) (Set_Monad xs) (Set_Monad ys) = Set_Monad (xs @ ys)
  | sup_seta (A1_, A2_) (DList_set dxs1) (Set_Monad ws) =
    (case ceq A1_
      of NONE =>
        (raise Fail "union DList_set Set_Monad: ceq = None")
          (fn _ => sup_seta (A1_, A2_) (DList_set dxs1) (Set_Monad ws))
      | SOME _ => DList_set (fold (insertc A1_) ws dxs1))
  | sup_seta (A1_, A2_) (Set_Monad ws) (DList_set dxs2) =
    (case ceq A1_
      of NONE =>
        (raise Fail "union Set_Monad DList_set: ceq = None")
          (fn _ => sup_seta (A1_, A2_) (Set_Monad ws) (DList_set dxs2))
      | SOME _ => DList_set (fold (insertc A1_) ws dxs2))
  | sup_seta (A1_, A2_) (RBT_set rbt1) (Set_Monad zs) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "union RBT_set Set_Monad: ccompare = None")
          (fn _ => sup_seta (A1_, A2_) (RBT_set rbt1) (Set_Monad zs))
      | SOME _ => RBT_set (fold (fn k => inserte A2_ k ()) zs rbt1))
  | sup_seta (A1_, A2_) (Set_Monad zs) (RBT_set rbt2) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "union Set_Monad RBT_set: ccompare = None")
          (fn _ => sup_seta (A1_, A2_) (Set_Monad zs) (RBT_set rbt2))
      | SOME _ => RBT_set (fold (fn k => inserte A2_ k ()) zs rbt2))
  | sup_seta (A1_, A2_) (DList_set dxs1) (DList_set dxs2) =
    (case ceq A1_
      of NONE =>
        (raise Fail "union DList_set DList_set: ceq = None")
          (fn _ => sup_seta (A1_, A2_) (DList_set dxs1) (DList_set dxs2))
      | SOME _ => DList_set (uniona A1_ dxs1 dxs2))
  | sup_seta (A1_, A2_) (DList_set dxs) (RBT_set rbt) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "union DList_set RBT_set: ccompare = None")
          (fn _ => sup_seta (A1_, A2_) (RBT_set rbt) (DList_set dxs))
      | SOME _ =>
        (case ceq A1_
          of NONE =>
            (raise Fail "union DList_set RBT_set: ceq = None")
              (fn _ => sup_seta (A1_, A2_) (RBT_set rbt) (DList_set dxs))
          | SOME _ => RBT_set (foldc A1_ (fn k => inserte A2_ k ()) dxs rbt)))
  | sup_seta (A1_, A2_) (RBT_set rbt) (DList_set dxs) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "union RBT_set DList_set: ccompare = None")
          (fn _ => sup_seta (A1_, A2_) (RBT_set rbt) (DList_set dxs))
      | SOME _ =>
        (case ceq A1_
          of NONE =>
            (raise Fail "union RBT_set DList_set: ceq = None")
              (fn _ => sup_seta (A1_, A2_) (RBT_set rbt) (DList_set dxs))
          | SOME _ => RBT_set (foldc A1_ (fn k => inserte A2_ k ()) dxs rbt)))
  | sup_seta (A1_, A2_) (RBT_set rbt1) (RBT_set rbt2) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "union RBT_set RBT_set: ccompare = None")
          (fn _ => sup_seta (A1_, A2_) (RBT_set rbt1) (RBT_set rbt2))
      | SOME _ => RBT_set (join A2_ (fn _ => fn _ => id) rbt1 rbt2));

fun inf_set (A1_, A2_) = {inf = inf_seta (A1_, A2_)} : 'a set inf;

fun sup_set (A1_, A2_) = {sup = sup_seta (A1_, A2_)} : 'a set sup;

fun less_set (A1_, A2_, A3_) a b =
  less_eq_set (A1_, A2_, A3_) a b andalso not (less_eq_set (A1_, A2_, A3_) b a);

fun ord_set (A1_, A2_, A3_) =
  {less_eq = less_eq_set (A1_, A2_, A3_), less = less_set (A1_, A2_, A3_)} :
  'a set ord;

fun quasi_order_set (A1_, A2_, A3_) =
  {ord_quasi_order = ord_set (A1_, A2_, A3_)} : 'a set quasi_order;

fun weak_order_set (A1_, A2_, A3_) =
  {quasi_order_weak_order = quasi_order_set (A1_, A2_, A3_)} :
  'a set weak_order;

fun preorder_set (A1_, A2_, A3_) = {ord_preorder = ord_set (A1_, A2_, A3_)} :
  'a set preorder;

fun order_set (A1_, A2_, A3_) =
  {preorder_order = preorder_set (A1_, A2_, A3_),
    weak_order_order = weak_order_set (A1_, A2_, A3_)}
  : 'a set order;

fun quasi_order_sup_set (A1_, A2_, A3_) =
  {sup_quasi_order_sup = sup_set (A2_, A3_),
    quasi_order_quasi_order_sup = quasi_order_set (A1_, A2_, A3_)}
  : 'a set quasi_order_sup;

fun quasi_semilattice_sup_set (A1_, A2_, A3_) =
  {quasi_order_sup_quasi_semilattice_sup = quasi_order_sup_set (A1_, A2_, A3_)}
  : 'a set quasi_semilattice_sup;

fun semilattice_sup_set (A1_, A2_, A3_) =
  {order_semilattice_sup = order_set (A1_, A2_, A3_),
    quasi_semilattice_sup_semilattice_sup =
      quasi_semilattice_sup_set (A1_, A2_, A3_)}
  : 'a set semilattice_sup;

fun semilattice_inf_set (A1_, A2_, A3_) =
  {inf_semilattice_inf = inf_set (A2_, A3_),
    order_semilattice_inf = order_set (A1_, A2_, A3_)}
  : 'a set semilattice_inf;

fun lattice_set (A1_, A2_, A3_) =
  {semilattice_inf_lattice = semilattice_inf_set (A1_, A2_, A3_),
    semilattice_sup_lattice = semilattice_sup_set (A1_, A2_, A3_)}
  : 'a set lattice;

fun list_all2_fusion p g1 g2 s1 s2 =
  (if has_next g1 s1
    then has_next g2 s2 andalso let
                                  val (x, s1a) = next g1 s1;
                                  val (y, s2a) = next g2 s2;
                                in
                                  p x y andalso list_all2_fusion p g1 g2 s1a s2a
                                end
    else not (has_next g2 s2));

fun set_eq (A1_, A2_, A3_) (RBT_set rbt1) (RBT_set rbt2) =
  (case ccompare A3_
    of NONE =>
      (raise Fail "set_eq RBT_set RBT_set: ccompare = None")
        (fn _ => set_eq (A1_, A2_, A3_) (RBT_set rbt1) (RBT_set rbt2))
    | SOME c =>
      (case ceq A2_
        of NONE =>
          list_all2_fusion (fn x => fn y => equal_order (c x y) Eq)
            rbt_keys_generator rbt_keys_generator (init A3_ rbt1)
            (init A3_ rbt2)
        | SOME eq =>
          list_all2_fusion eq rbt_keys_generator rbt_keys_generator
            (init A3_ rbt1) (init A3_ rbt2)))
  | set_eq (A1_, A2_, A3_) (Complement a) (Complement b) =
    set_eq (A1_, A2_, A3_) a b
  | set_eq (A1_, A2_, A3_) a b =
    less_eq_set (A1_, A2_, A3_) a b andalso less_eq_set (A1_, A2_, A3_) b a;

fun ceq_seta (A1_, A2_, A3_) =
  (case ceq A2_ of NONE => NONE | SOME _ => SOME (set_eq (A1_, A2_, A3_)));

fun ceq_set (A1_, A2_, A3_) = {ceq = ceq_seta (A1_, A2_, A3_)} : 'a set ceq;

val set_impl_seta : ('a set, set_impla) phantom = Phantom Set_Choose;

val set_impl_set = {set_impl = set_impl_seta} : 'a set set_impl;

fun of_phantom (Phantom x) = x;

fun emptye A_ = Mapping_RBTa Emptya;

fun emptyc A_ = Abs_dlist [];

fun set_empty_choose (A1_, A2_) =
  (case ccompare A2_
    of NONE =>
      (case ceq A1_ of NONE => Set_Monad [] | SOME _ => DList_set (emptyc A1_))
    | SOME _ => RBT_set (emptye A2_));

fun set_empty (A1_, A2_) Set_Choose = set_empty_choose (A1_, A2_)
  | set_empty (A1_, A2_) Set_Monada = Set_Monad []
  | set_empty (A1_, A2_) Set_RBT = RBT_set (emptye A2_)
  | set_empty (A1_, A2_) Set_DList = DList_set (emptyc A1_)
  | set_empty (A1_, A2_) Set_Collect = Collect_set (fn _ => false);

fun fun_upda equal f aa b a = (if equal aa a then b else f a);

fun balance_right a k x (Branch (R, b, s, y, c)) =
  Branch (R, a, k, x, Branch (B, b, s, y, c))
  | balance_right (Branch (B, a, k, x, b)) s y Emptya =
    balance (Branch (R, a, k, x, b)) s y Emptya
  | balance_right (Branch (B, a, k, x, b)) s y (Branch (B, va, vb, vc, vd)) =
    balance (Branch (R, a, k, x, b)) s y (Branch (B, va, vb, vc, vd))
  | balance_right (Branch (R, a, k, x, Branch (B, b, s, y, c))) t z Emptya =
    Branch (R, balance (paint R a) k x b, s, y, Branch (B, c, t, z, Emptya))
  | balance_right (Branch (R, a, k, x, Branch (B, b, s, y, c))) t z
    (Branch (B, va, vb, vc, vd)) =
    Branch
      (R, balance (paint R a) k x b, s, y,
        Branch (B, c, t, z, Branch (B, va, vb, vc, vd)))
  | balance_right Emptya k x Emptya = Emptya
  | balance_right (Branch (R, va, vb, vc, Emptya)) k x Emptya = Emptya
  | balance_right (Branch (R, va, vb, vc, Branch (R, ve, vf, vg, vh))) k x
    Emptya = Emptya
  | balance_right Emptya k x (Branch (B, va, vb, vc, vd)) = Emptya
  | balance_right (Branch (R, ve, vf, vg, Emptya)) k x
    (Branch (B, va, vb, vc, vd)) = Emptya
  | balance_right (Branch (R, ve, vf, vg, Branch (R, vi, vj, vk, vl))) k x
    (Branch (B, va, vb, vc, vd)) = Emptya;

fun balance_left (Branch (R, a, k, x, b)) s y c =
  Branch (R, Branch (B, a, k, x, b), s, y, c)
  | balance_left Emptya k x (Branch (B, a, s, y, b)) =
    balance Emptya k x (Branch (R, a, s, y, b))
  | balance_left (Branch (B, va, vb, vc, vd)) k x (Branch (B, a, s, y, b)) =
    balance (Branch (B, va, vb, vc, vd)) k x (Branch (R, a, s, y, b))
  | balance_left Emptya k x (Branch (R, Branch (B, a, s, y, b), t, z, c)) =
    Branch (R, Branch (B, Emptya, k, x, a), s, y, balance b t z (paint R c))
  | balance_left (Branch (B, va, vb, vc, vd)) k x
    (Branch (R, Branch (B, a, s, y, b), t, z, c)) =
    Branch
      (R, Branch (B, Branch (B, va, vb, vc, vd), k, x, a), s, y,
        balance b t z (paint R c))
  | balance_left Emptya k x Emptya = Emptya
  | balance_left Emptya k x (Branch (R, Emptya, vb, vc, vd)) = Emptya
  | balance_left Emptya k x (Branch (R, Branch (R, ve, vf, vg, vh), vb, vc, vd))
    = Emptya
  | balance_left (Branch (B, va, vb, vc, vd)) k x Emptya = Emptya
  | balance_left (Branch (B, va, vb, vc, vd)) k x
    (Branch (R, Emptya, vf, vg, vh)) = Emptya
  | balance_left (Branch (B, va, vb, vc, vd)) k x
    (Branch (R, Branch (R, vi, vj, vk, vl), vf, vg, vh)) = Emptya;

fun combine Emptya x = x
  | combine (Branch (v, va, vb, vc, vd)) Emptya = Branch (v, va, vb, vc, vd)
  | combine (Branch (R, a, k, x, b)) (Branch (R, c, s, y, d)) =
    (case combine b c
      of Emptya => Branch (R, a, k, x, Branch (R, Emptya, s, y, d))
      | Branch (R, b2, t, z, c2) =>
        Branch (R, Branch (R, a, k, x, b2), t, z, Branch (R, c2, s, y, d))
      | Branch (B, b2, t, z, c2) =>
        Branch (R, a, k, x, Branch (R, Branch (B, b2, t, z, c2), s, y, d)))
  | combine (Branch (B, a, k, x, b)) (Branch (B, c, s, y, d)) =
    (case combine b c
      of Emptya => balance_left a k x (Branch (B, Emptya, s, y, d))
      | Branch (R, b2, t, z, c2) =>
        Branch (R, Branch (B, a, k, x, b2), t, z, Branch (B, c2, s, y, d))
      | Branch (B, b2, t, z, c2) =>
        balance_left a k x (Branch (B, Branch (B, b2, t, z, c2), s, y, d)))
  | combine (Branch (B, va, vb, vc, vd)) (Branch (R, b, k, x, c)) =
    Branch (R, combine (Branch (B, va, vb, vc, vd)) b, k, x, c)
  | combine (Branch (R, a, k, x, b)) (Branch (B, va, vb, vc, vd)) =
    Branch (R, a, k, x, combine b (Branch (B, va, vb, vc, vd)));

fun rbt_comp_del c x Emptya = Emptya
  | rbt_comp_del c x (Branch (uu, a, y, s, b)) =
    (case c x y of Eq => combine a b | Lt => rbt_comp_del_from_left c x a y s b
      | Gt => rbt_comp_del_from_right c x a y s b)
and rbt_comp_del_from_left c x (Branch (B, lt, z, v, rt)) y s b =
  balance_left (rbt_comp_del c x (Branch (B, lt, z, v, rt))) y s b
  | rbt_comp_del_from_left c x Emptya y s b =
    Branch (R, rbt_comp_del c x Emptya, y, s, b)
  | rbt_comp_del_from_left c x (Branch (R, va, vb, vc, vd)) y s b =
    Branch (R, rbt_comp_del c x (Branch (R, va, vb, vc, vd)), y, s, b)
and rbt_comp_del_from_right c x a y s (Branch (B, lt, z, v, rt)) =
  balance_right a y s (rbt_comp_del c x (Branch (B, lt, z, v, rt)))
  | rbt_comp_del_from_right c x a y s Emptya =
    Branch (R, a, y, s, rbt_comp_del c x Emptya)
  | rbt_comp_del_from_right c x a y s (Branch (R, va, vb, vc, vd)) =
    Branch (R, a, y, s, rbt_comp_del c x (Branch (R, va, vb, vc, vd)));

fun rbt_comp_delete c k t = paint B (rbt_comp_del c k t);

fun deletea A_ xb xc =
  Mapping_RBTa (rbt_comp_delete (the (ccompare A_)) xb (impl_ofb A_ xc));

fun list_remove1 equal x (y :: xs) =
  (if equal x y then xs else y :: list_remove1 equal x xs)
  | list_remove1 equal x [] = [];

fun removea A_ xb xc =
  Abs_dlist (list_remove1 (the (ceq A_)) xb (list_of_dlist A_ xc));

fun inserta (A1_, A2_) xa (Complement x) = Complement (remove (A1_, A2_) xa x)
  | inserta (A1_, A2_) x (RBT_set rbt) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "insert RBT_set: ccompare = None")
          (fn _ => inserta (A1_, A2_) x (RBT_set rbt))
      | SOME _ => RBT_set (inserte A2_ x () rbt))
  | inserta (A1_, A2_) x (DList_set dxs) =
    (case ceq A1_
      of NONE =>
        (raise Fail "insert DList_set: ceq = None")
          (fn _ => inserta (A1_, A2_) x (DList_set dxs))
      | SOME _ => DList_set (insertc A1_ x dxs))
  | inserta (A1_, A2_) x (Set_Monad xs) = Set_Monad (x :: xs)
  | inserta (A1_, A2_) x (Collect_set a) =
    (case ceq A1_
      of NONE =>
        (raise Fail "insert Collect_set: ceq = None")
          (fn _ => inserta (A1_, A2_) x (Collect_set a))
      | SOME eq => Collect_set (fun_upda eq a x true))
and remove (A1_, A2_) x (Complement a) = Complement (inserta (A1_, A2_) x a)
  | remove (A1_, A2_) x (RBT_set rbt) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "remove RBT_set: ccompare = None")
          (fn _ => remove (A1_, A2_) x (RBT_set rbt))
      | SOME _ => RBT_set (deletea A2_ x rbt))
  | remove (A1_, A2_) x (DList_set dxs) =
    (case ceq A1_
      of NONE =>
        (raise Fail "remove DList_set: ceq = None")
          (fn _ => remove (A1_, A2_) x (DList_set dxs))
      | SOME _ => DList_set (removea A1_ x dxs))
  | remove (A1_, A2_) x (Collect_set a) =
    (case ceq A1_
      of NONE =>
        (raise Fail "remove Collect: ceq = None")
          (fn _ => remove (A1_, A2_) x (Collect_set a))
      | SOME eq => Collect_set (fun_upda eq a x false));

fun foldl f a [] = a
  | foldl f a (x :: xs) = foldl f (f a x) xs;

fun set_aux (A1_, A2_) Set_Monada = Set_Monad
  | set_aux (A1_, A2_) Set_Choose =
    (case ccompare A2_
      of NONE =>
        (case ceq A1_ of NONE => Set_Monad
          | SOME _ =>
            foldl (fn s => fn x => inserta (A1_, A2_) x s)
              (DList_set (emptyc A1_)))
      | SOME _ =>
        foldl (fn s => fn x => inserta (A1_, A2_) x s) (RBT_set (emptye A2_)))
  | set_aux (A1_, A2_) impl =
    foldl (fn s => fn x => inserta (A1_, A2_) x s) (set_empty (A1_, A2_) impl);

fun set (A1_, A2_, A3_) xs = set_aux (A1_, A2_) (of_phantom (set_impl A3_)) xs;

fun map f [] = []
  | map f (x21 :: x22) = f x21 :: map f x22;

fun subseqs [] = [[]]
  | subseqs (x :: xs) = let
                          val xss = subseqs xs;
                        in
                          map (fn a => x :: a) xss @ xss
                        end;

fun list_ex p [] = false
  | list_ex p (x :: xs) = p x orelse list_ex p xs;

fun cEnum_set (A1_, A2_, A3_, A4_) =
  (case cEnum A1_ of NONE => NONE
    | SOME (enum_a, (_, _)) =>
      SOME (map (set (A2_, A3_, A4_)) (subseqs enum_a),
             ((fn p => list_all p (map (set (A2_, A3_, A4_)) (subseqs enum_a))),
               (fn p =>
                 list_ex p (map (set (A2_, A3_, A4_)) (subseqs enum_a))))));

fun cenum_set (A1_, A2_, A3_, A4_) = {cEnum = cEnum_set (A1_, A2_, A3_, A4_)} :
  'a set cenum;

fun finite_UNIV_seta A_ = Phantom (of_phantom (finite_UNIV A_));

fun finite_UNIV_set A_ = {finite_UNIV = finite_UNIV_seta A_} :
  'a set finite_UNIV;

fun set_less_eq_aux_Compl_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then (if has_next g2 s2
           then let
                  val (x, s1a) = next g1 s1;
                  val (y, s2a) = next g2 s2;
                in
                  (if less x y
                    then proper_interval ao (SOME x) orelse
                           set_less_eq_aux_Compl_fusion less proper_interval g1
                             g2 (SOME x) s1a s2
                    else (if less y x
                           then proper_interval ao (SOME y) orelse
                                  set_less_eq_aux_Compl_fusion less
                                    proper_interval g1 g2 (SOME y) s1 s2a
                           else proper_interval ao (SOME y)))
                end
           else true)
    else true);

fun compl_set_less_eq_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then let
           val (x, s1a) = next g1 s1;
         in
           (if has_next g2 s2
             then let
                    val (y, s2a) = next g2 s2;
                  in
                    (if less x y
                      then not (proper_interval ao (SOME x)) andalso
                             compl_set_less_eq_aux_fusion less proper_interval
                               g1 g2 (SOME x) s1a s2
                      else (if less y x
                             then not (proper_interval ao (SOME y)) andalso
                                    compl_set_less_eq_aux_fusion less
                                      proper_interval g1 g2 (SOME y) s1 s2a
                             else not (proper_interval ao (SOME y))))
                  end
             else not (proper_interval ao (SOME x)) andalso
                    compl_set_less_eq_aux_fusion less proper_interval g1 g2
                      (SOME x) s1a s2)
         end
    else (if has_next g2 s2
           then let
                  val (y, s2a) = next g2 s2;
                in
                  not (proper_interval ao (SOME y)) andalso
                    compl_set_less_eq_aux_fusion less proper_interval g1 g2
                      (SOME y) s1 s2a
                end
           else not (proper_interval ao NONE)));

fun set_less_eq_aux_Compl less proper_interval ao (x :: xs) (y :: ys) =
  (if less x y
    then proper_interval ao (SOME x) orelse
           set_less_eq_aux_Compl less proper_interval (SOME x) xs (y :: ys)
    else (if less y x
           then proper_interval ao (SOME y) orelse
                  set_less_eq_aux_Compl less proper_interval (SOME y) (x :: xs)
                    ys
           else proper_interval ao (SOME y)))
  | set_less_eq_aux_Compl less proper_interval ao xs [] = true
  | set_less_eq_aux_Compl less proper_interval ao [] ys = true;

fun compl_set_less_eq_aux less proper_interval ao (x :: xs) (y :: ys) =
  (if less x y
    then not (proper_interval ao (SOME x)) andalso
           compl_set_less_eq_aux less proper_interval (SOME x) xs (y :: ys)
    else (if less y x
           then not (proper_interval ao (SOME y)) andalso
                  compl_set_less_eq_aux less proper_interval (SOME y) (x :: xs)
                    ys
           else not (proper_interval ao (SOME y))))
  | compl_set_less_eq_aux less proper_interval ao (x :: xs) [] =
    not (proper_interval ao (SOME x)) andalso
      compl_set_less_eq_aux less proper_interval (SOME x) xs []
  | compl_set_less_eq_aux less proper_interval ao [] (y :: ys) =
    not (proper_interval ao (SOME y)) andalso
      compl_set_less_eq_aux less proper_interval (SOME y) [] ys
  | compl_set_less_eq_aux less proper_interval ao [] [] =
    not (proper_interval ao NONE);

fun lexord_eq_fusion less g1 g2 s1 s2 =
  (if has_next g1 s1
    then has_next g2 s2 andalso
           let
             val (x, s1a) = next g1 s1;
             val (y, s2a) = next g2 s2;
           in
             less x y orelse
               not (less y x) andalso lexord_eq_fusion less g1 g2 s1a s2a
           end
    else true);

fun remdups_sorted less (x :: y :: xs) =
  (if less x y then x :: remdups_sorted less (y :: xs)
    else remdups_sorted less (y :: xs))
  | remdups_sorted less [x] = [x]
  | remdups_sorted less [] = [];

fun quicksort_acc less ac (x :: v :: va) =
  quicksort_part less ac x [] [] [] (v :: va)
  | quicksort_acc less ac [x] = x :: ac
  | quicksort_acc less ac [] = ac
and quicksort_part less ac x lts eqs gts (z :: zs) =
  (if less x z then quicksort_part less ac x lts eqs (z :: gts) zs
    else (if less z x then quicksort_part less ac x (z :: lts) eqs gts zs
           else quicksort_part less ac x lts (z :: eqs) gts zs))
  | quicksort_part less ac x lts eqs gts [] =
    quicksort_acc less (eqs @ x :: quicksort_acc less ac gts) lts;

fun quicksort less = quicksort_acc less [];

fun gen_keys kts (Branch (c, l, k, v, r)) = gen_keys ((k, r) :: kts) l
  | gen_keys ((k, t) :: kts) Emptya = k :: gen_keys kts t
  | gen_keys [] Emptya = [];

fun keys x = gen_keys [] x;

fun keysa A_ xa = keys (impl_ofb A_ xa);

fun csorted_list_of_set (A1_, A2_) (Set_Monad xs) =
  (case ccompare A2_
    of NONE =>
      (raise Fail "csorted_list_of_set Set_Monad: ccompare = None")
        (fn _ => csorted_list_of_set (A1_, A2_) (Set_Monad xs))
    | SOME c => remdups_sorted (lt_of_comp c) (quicksort (lt_of_comp c) xs))
  | csorted_list_of_set (A1_, A2_) (DList_set dxs) =
    (case ceq A1_
      of NONE =>
        (raise Fail "csorted_list_of_set DList_set: ceq = None")
          (fn _ => csorted_list_of_set (A1_, A2_) (DList_set dxs))
      | SOME _ =>
        (case ccompare A2_
          of NONE =>
            (raise Fail "csorted_list_of_set DList_set: ccompare = None")
              (fn _ => csorted_list_of_set (A1_, A2_) (DList_set dxs))
          | SOME c => quicksort (lt_of_comp c) (list_of_dlist A1_ dxs)))
  | csorted_list_of_set (A1_, A2_) (RBT_set rbt) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "csorted_list_of_set RBT_set: ccompare = None")
          (fn _ => csorted_list_of_set (A1_, A2_) (RBT_set rbt))
      | SOME _ => keysa A2_ rbt);

fun bot_set (A1_, A2_, A3_) = set_empty (A1_, A2_) (of_phantom (set_impl A3_));

fun top_set (A1_, A2_, A3_) = uminus_set (bot_set (A1_, A2_, A3_));

fun le_of_comp acomp x y =
  (case acomp x y of Eq => true | Lt => true | Gt => false);

fun lexordp_eq less (x :: xs) (y :: ys) =
  less x y orelse not (less y x) andalso lexordp_eq less xs ys
  | lexordp_eq less (x :: xs) [] = false
  | lexordp_eq less xs [] = null xs
  | lexordp_eq less [] ys = true;

fun finitea A_ = finitea A_;

fun finite (A1_, A2_, A3_) (Collect_set p) =
  of_phantom (finite_UNIV A1_) orelse
    (raise Fail "finite Collect_set") (fn _ => finitea A1_ (Collect_set p))
  | finite (A1_, A2_, A3_) (Set_Monad xs) = true
  | finite (A1_, A2_, A3_) (Complement a) =
    (if of_phantom (finite_UNIV A1_) then true
      else (if finitea A1_ a then false
             else (raise Fail "finite Complement: infinite set")
                    (fn _ => finitea A1_ (Complement a))))
  | finite (A1_, A2_, A3_) (RBT_set rbt) =
    (case ccompare A3_
      of NONE =>
        (raise Fail "finite RBT_set: ccompare = None")
          (fn _ => finite (A1_, A2_, A3_) (RBT_set rbt))
      | SOME _ => true)
  | finite (A1_, A2_, A3_) (DList_set dxs) =
    (case ceq A2_
      of NONE =>
        (raise Fail "finite DList_set: ceq = None")
          (fn _ => finite (A1_, A2_, A3_) (DList_set dxs))
      | SOME _ => true);

fun set_less_aux_Compl_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then let
           val (x, s1a) = next g1 s1;
         in
           (if has_next g2 s2
             then let
                    val (y, s2a) = next g2 s2;
                  in
                    (if less x y
                      then proper_interval ao (SOME x) orelse
                             set_less_aux_Compl_fusion less proper_interval g1
                               g2 (SOME x) s1a s2
                      else (if less y x
                             then proper_interval ao (SOME y) orelse
                                    set_less_aux_Compl_fusion less
                                      proper_interval g1 g2 (SOME y) s1 s2a
                             else proper_interval ao (SOME y)))
                  end
             else proper_interval ao (SOME x) orelse
                    set_less_aux_Compl_fusion less proper_interval g1 g2
                      (SOME x) s1a s2)
         end
    else (if has_next g2 s2
           then let
                  val (y, s2a) = next g2 s2;
                in
                  proper_interval ao (SOME y) orelse
                    set_less_aux_Compl_fusion less proper_interval g1 g2
                      (SOME y) s1 s2a
                end
           else proper_interval ao NONE));

fun compl_set_less_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  has_next g1 s1 andalso
    (has_next g2 s2 andalso
      let
        val (x, s1a) = next g1 s1;
        val (y, s2a) = next g2 s2;
      in
        (if less x y
          then not (proper_interval ao (SOME x)) andalso
                 compl_set_less_aux_fusion less proper_interval g1 g2 (SOME x)
                   s1a s2
          else (if less y x
                 then not (proper_interval ao (SOME y)) andalso
                        compl_set_less_aux_fusion less proper_interval g1 g2
                          (SOME y) s1 s2a
                 else not (proper_interval ao (SOME y))))
      end);

fun set_less_aux_Compl less proper_interval ao (x :: xs) (y :: ys) =
  (if less x y
    then proper_interval ao (SOME x) orelse
           set_less_aux_Compl less proper_interval (SOME x) xs (y :: ys)
    else (if less y x
           then proper_interval ao (SOME y) orelse
                  set_less_aux_Compl less proper_interval (SOME y) (x :: xs) ys
           else proper_interval ao (SOME y)))
  | set_less_aux_Compl less proper_interval ao (x :: xs) [] =
    proper_interval ao (SOME x) orelse
      set_less_aux_Compl less proper_interval (SOME x) xs []
  | set_less_aux_Compl less proper_interval ao [] (y :: ys) =
    proper_interval ao (SOME y) orelse
      set_less_aux_Compl less proper_interval (SOME y) [] ys
  | set_less_aux_Compl less proper_interval ao [] [] = proper_interval ao NONE;

fun compl_set_less_aux less proper_interval ao (x :: xs) (y :: ys) =
  (if less x y
    then not (proper_interval ao (SOME x)) andalso
           compl_set_less_aux less proper_interval (SOME x) xs (y :: ys)
    else (if less y x
           then not (proper_interval ao (SOME y)) andalso
                  compl_set_less_aux less proper_interval (SOME y) (x :: xs) ys
           else not (proper_interval ao (SOME y))))
  | compl_set_less_aux less proper_interval ao xs [] = false
  | compl_set_less_aux less proper_interval ao [] ys = false;

fun lexord_fusion less g1 g2 s1 s2 =
  (if has_next g1 s1
    then (if has_next g2 s2
           then let
                  val (x, s1a) = next g1 s1;
                  val (y, s2a) = next g2 s2;
                in
                  less x y orelse
                    not (less y x) andalso lexord_fusion less g1 g2 s1a s2a
                end
           else false)
    else has_next g2 s2);

fun lexordp less (x :: xs) (y :: ys) =
  less x y orelse not (less y x) andalso lexordp less xs ys
  | lexordp less xs [] = false
  | lexordp less [] ys = not (null ys);

fun comp_of_ords le lt x y =
  (if lt x y then Lt else (if le x y then Eq else Gt));

fun ccompare_seta (A1_, A2_, A3_, A4_) =
  (case ccompare (ccompare_cproper_interval A3_) of NONE => NONE
    | SOME _ =>
      SOME (comp_of_ords (cless_eq_set (A1_, A2_, A3_, A4_))
             (cless_set (A1_, A2_, A3_, A4_))))
and cless_set (A1_, A2_, A3_, A4_) (Complement (RBT_set rbt1)) (RBT_set rbt2) =
  (case ccompare (ccompare_cproper_interval A3_)
    of NONE =>
      (raise Fail "cless_set (Complement RBT_set) RBT_set: ccompare = None")
        (fn _ =>
          cless_set (A1_, A2_, A3_, A4_) (Complement (RBT_set rbt1))
            (RBT_set rbt2))
    | SOME c =>
      finite (A1_, A2_, ccompare_cproper_interval A3_)
        (top_set (A2_, ccompare_cproper_interval A3_, A4_)) andalso
        compl_set_less_aux_fusion (lt_of_comp c) (cproper_interval A3_)
          rbt_keys_generator rbt_keys_generator NONE
          (init (ccompare_cproper_interval A3_) rbt1)
          (init (ccompare_cproper_interval A3_) rbt2))
  | cless_set (A1_, A2_, A3_, A4_) (RBT_set rbt1) (Complement (RBT_set rbt2)) =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cless_set RBT_set (Complement RBT_set): ccompare = None")
          (fn _ =>
            cless_set (A1_, A2_, A3_, A4_) (RBT_set rbt1)
              (Complement (RBT_set rbt2)))
      | SOME c =>
        (if finite (A1_, A2_, ccompare_cproper_interval A3_)
              (top_set (A2_, ccompare_cproper_interval A3_, A4_))
          then set_less_aux_Compl_fusion (lt_of_comp c) (cproper_interval A3_)
                 rbt_keys_generator rbt_keys_generator NONE
                 (init (ccompare_cproper_interval A3_) rbt1)
                 (init (ccompare_cproper_interval A3_) rbt2)
          else true))
  | cless_set (A1_, A2_, A3_, A4_) (RBT_set rbta) (RBT_set rbt) =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cless_set RBT_set RBT_set: ccompare = None")
          (fn _ => cless_set (A1_, A2_, A3_, A4_) (RBT_set rbta) (RBT_set rbt))
      | SOME c =>
        lexord_fusion (fn x => fn y => lt_of_comp c y x) rbt_keys_generator
          rbt_keys_generator (init (ccompare_cproper_interval A3_) rbta)
          (init (ccompare_cproper_interval A3_) rbt))
  | cless_set (A1_, A2_, A3_, A4_) (Complement a) (Complement b) =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cless_set Complement Complement: ccompare = None")
          (fn _ => cless_set (A1_, A2_, A3_, A4_) (Complement a) (Complement b))
      | SOME _ => lt_of_comp (the (ccompare_seta (A1_, A2_, A3_, A4_))) b a)
  | cless_set (A1_, A2_, A3_, A4_) (Complement a) b =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cless_set Complement1: ccompare = None")
          (fn _ => cless_set (A1_, A2_, A3_, A4_) (Complement a) b)
      | SOME c =>
        (if finite (A1_, A2_, ccompare_cproper_interval A3_) a andalso
              finite (A1_, A2_, ccompare_cproper_interval A3_) b
          then finite (A1_, A2_, ccompare_cproper_interval A3_)
                 (top_set (A2_, ccompare_cproper_interval A3_, A4_)) andalso
                 compl_set_less_aux (lt_of_comp c) (cproper_interval A3_) NONE
                   (csorted_list_of_set (A2_, ccompare_cproper_interval A3_) a)
                   (csorted_list_of_set (A2_, ccompare_cproper_interval A3_) b)
          else (raise Fail "cless_set Complement1: infinite set")
                 (fn _ => cless_set (A1_, A2_, A3_, A4_) (Complement a) b)))
  | cless_set (A1_, A2_, A3_, A4_) a (Complement b) =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cless_set Complement2: ccompare = None")
          (fn _ => cless_set (A1_, A2_, A3_, A4_) a (Complement b))
      | SOME c =>
        (if finite (A1_, A2_, ccompare_cproper_interval A3_) a andalso
              finite (A1_, A2_, ccompare_cproper_interval A3_) b
          then (if finite (A1_, A2_, ccompare_cproper_interval A3_)
                     (top_set (A2_, ccompare_cproper_interval A3_, A4_))
                 then set_less_aux_Compl (lt_of_comp c) (cproper_interval A3_)
                        NONE
                        (csorted_list_of_set
                          (A2_, ccompare_cproper_interval A3_) a)
                        (csorted_list_of_set
                          (A2_, ccompare_cproper_interval A3_) b)
                 else true)
          else (raise Fail "cless_set Complement2: infinite set")
                 (fn _ => cless_set (A1_, A2_, A3_, A4_) a (Complement b))))
  | cless_set (A1_, A2_, A3_, A4_) a b =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cless_set: ccompare = None")
          (fn _ => cless_set (A1_, A2_, A3_, A4_) a b)
      | SOME c =>
        (if finite (A1_, A2_, ccompare_cproper_interval A3_) a andalso
              finite (A1_, A2_, ccompare_cproper_interval A3_) b
          then lexordp (fn x => fn y => lt_of_comp c y x)
                 (csorted_list_of_set (A2_, ccompare_cproper_interval A3_) a)
                 (csorted_list_of_set (A2_, ccompare_cproper_interval A3_) b)
          else (raise Fail "cless_set: infinite set")
                 (fn _ => cless_set (A1_, A2_, A3_, A4_) a b)))
and cless_eq_set (A1_, A2_, A3_, A4_) (Complement (RBT_set rbt1)) (RBT_set rbt2)
  = (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail
          "cless_eq_set (Complement RBT_set) RBT_set: ccompare = None")
          (fn _ =>
            cless_eq_set (A1_, A2_, A3_, A4_) (Complement (RBT_set rbt1))
              (RBT_set rbt2))
      | SOME c =>
        finite (A1_, A2_, ccompare_cproper_interval A3_)
          (top_set (A2_, ccompare_cproper_interval A3_, A4_)) andalso
          compl_set_less_eq_aux_fusion (lt_of_comp c) (cproper_interval A3_)
            rbt_keys_generator rbt_keys_generator NONE
            (init (ccompare_cproper_interval A3_) rbt1)
            (init (ccompare_cproper_interval A3_) rbt2))
  | cless_eq_set (A1_, A2_, A3_, A4_) (RBT_set rbt1) (Complement (RBT_set rbt2))
    = (case ccompare (ccompare_cproper_interval A3_)
        of NONE =>
          (raise Fail
            "cless_eq_set RBT_set (Complement RBT_set): ccompare = None")
            (fn _ =>
              cless_eq_set (A1_, A2_, A3_, A4_) (RBT_set rbt1)
                (Complement (RBT_set rbt2)))
        | SOME c =>
          (if finite (A1_, A2_, ccompare_cproper_interval A3_)
                (top_set (A2_, ccompare_cproper_interval A3_, A4_))
            then set_less_eq_aux_Compl_fusion (lt_of_comp c)
                   (cproper_interval A3_) rbt_keys_generator rbt_keys_generator
                   NONE (init (ccompare_cproper_interval A3_) rbt1)
                   (init (ccompare_cproper_interval A3_) rbt2)
            else true))
  | cless_eq_set (A1_, A2_, A3_, A4_) (RBT_set rbta) (RBT_set rbt) =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cless_eq_set RBT_set RBT_set: ccompare = None")
          (fn _ =>
            cless_eq_set (A1_, A2_, A3_, A4_) (RBT_set rbta) (RBT_set rbt))
      | SOME c =>
        lexord_eq_fusion (fn x => fn y => lt_of_comp c y x) rbt_keys_generator
          rbt_keys_generator (init (ccompare_cproper_interval A3_) rbta)
          (init (ccompare_cproper_interval A3_) rbt))
  | cless_eq_set (A1_, A2_, A3_, A4_) (Complement a) (Complement b) =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cless_eq_set Complement Complement: ccompare = None")
          (fn _ =>
            le_of_comp (the (ccompare_seta (A1_, A2_, A3_, A4_))) (Complement a)
              (Complement b))
      | SOME _ => cless_eq_set (A1_, A2_, A3_, A4_) b a)
  | cless_eq_set (A1_, A2_, A3_, A4_) (Complement a) b =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cless_eq_set Complement1: ccompare = None")
          (fn _ => cless_eq_set (A1_, A2_, A3_, A4_) (Complement a) b)
      | SOME c =>
        (if finite (A1_, A2_, ccompare_cproper_interval A3_) a andalso
              finite (A1_, A2_, ccompare_cproper_interval A3_) b
          then finite (A1_, A2_, ccompare_cproper_interval A3_)
                 (top_set (A2_, ccompare_cproper_interval A3_, A4_)) andalso
                 compl_set_less_eq_aux (lt_of_comp c) (cproper_interval A3_)
                   NONE
                   (csorted_list_of_set (A2_, ccompare_cproper_interval A3_) a)
                   (csorted_list_of_set (A2_, ccompare_cproper_interval A3_) b)
          else (raise Fail "cless_eq_set Complement1: infinite set")
                 (fn _ => cless_eq_set (A1_, A2_, A3_, A4_) (Complement a) b)))
  | cless_eq_set (A1_, A2_, A3_, A4_) a (Complement b) =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cless_eq_set Complement2: ccompare = None")
          (fn _ => cless_eq_set (A1_, A2_, A3_, A4_) a (Complement b))
      | SOME c =>
        (if finite (A1_, A2_, ccompare_cproper_interval A3_) a andalso
              finite (A1_, A2_, ccompare_cproper_interval A3_) b
          then (if finite (A1_, A2_, ccompare_cproper_interval A3_)
                     (top_set (A2_, ccompare_cproper_interval A3_, A4_))
                 then set_less_eq_aux_Compl (lt_of_comp c)
                        (cproper_interval A3_) NONE
                        (csorted_list_of_set
                          (A2_, ccompare_cproper_interval A3_) a)
                        (csorted_list_of_set
                          (A2_, ccompare_cproper_interval A3_) b)
                 else true)
          else (raise Fail "cless_eq_set Complement2: infinite set")
                 (fn _ => cless_eq_set (A1_, A2_, A3_, A4_) a (Complement b))))
  | cless_eq_set (A1_, A2_, A3_, A4_) a b =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cless_eq_set: ccompare = None")
          (fn _ => cless_eq_set (A1_, A2_, A3_, A4_) a b)
      | SOME c =>
        (if finite (A1_, A2_, ccompare_cproper_interval A3_) a andalso
              finite (A1_, A2_, ccompare_cproper_interval A3_) b
          then lexordp_eq (fn x => fn y => lt_of_comp c y x)
                 (csorted_list_of_set (A2_, ccompare_cproper_interval A3_) a)
                 (csorted_list_of_set (A2_, ccompare_cproper_interval A3_) b)
          else (raise Fail "cless_eq_set: infinite set")
                 (fn _ => cless_eq_set (A1_, A2_, A3_, A4_) a b)));

fun ccompare_set (A1_, A2_, A3_, A4_) =
  {ccompare = ccompare_seta (A1_, A2_, A3_, A4_)} : 'a set ccompare;

fun fold_fusion g f s b =
  (if has_next g s then let
                          val (x, sa) = next g s;
                        in
                          fold_fusion g f sa (f x b)
                        end
    else b);

fun length_last_fusion g s =
  (if has_next g s
    then let
           val (x, sa) = next g s;
         in
           fold_fusion g (fn xa => fn (n, _) => (plus_nata n one_nata, xa)) sa
             (one_nata, x)
         end
    else (zero_nata, (raise Fail "undefined")));

fun gen_length_fusion g n s =
  (if has_next g s then gen_length_fusion g (suc n) (snd (next g s)) else n);

fun length_fusion g = gen_length_fusion g zero_nata;

fun card_UNIV A_ = card_UNIVa A_;

fun proper_interval_set_Compl_aux_fusion A_ less proper_interval g1 g2 ao n s1
  s2 =
  (if has_next g1 s1
    then let
           val (x, s1a) = next g1 s1;
         in
           (if has_next g2 s2
             then let
                    val (y, s2a) = next g2 s2;
                  in
                    (if less x y
                      then proper_interval ao (SOME x) orelse
                             proper_interval_set_Compl_aux_fusion A_ less
                               proper_interval g1 g2 (SOME x)
                               (plus_nata n one_nata) s1a s2
                      else (if less y x
                             then proper_interval ao (SOME y) orelse
                                    proper_interval_set_Compl_aux_fusion A_ less
                                      proper_interval g1 g2 (SOME y)
                                      (plus_nata n one_nata) s1 s2a
                             else proper_interval ao (SOME x) andalso
                                    let
                                      val m =
minus_nata (of_phantom (card_UNIV A_)) n;
                                    in
                                      not
(equal_nata (minus_nata m (length_fusion g2 s2a))
  (nat_of_integer (2 : IntInf.int))) orelse
not (equal_nata (minus_nata m (length_fusion g1 s1a))
      (nat_of_integer (2 : IntInf.int)))
                                    end))
                  end
             else let
                    val m = minus_nata (of_phantom (card_UNIV A_)) n;
                    val (len_x, xa) = length_last_fusion g1 s1;
                  in
                    not (equal_nata m len_x) andalso
                      (if equal_nata m (plus_nata len_x one_nata)
                        then not (proper_interval (SOME xa) NONE) else true)
                  end)
         end
    else (if has_next g2 s2
           then let
                  val (_, _) = next g2 s2;
                  val m = minus_nata (of_phantom (card_UNIV A_)) n;
                  val (len_y, y) = length_last_fusion g2 s2;
                in
                  not (equal_nata m len_y) andalso
                    (if equal_nata m (plus_nata len_y one_nata)
                      then not (proper_interval (SOME y) NONE) else true)
                end
           else less_nat (plus_nata n one_nata) (of_phantom (card_UNIV A_))));

fun proper_interval_Compl_set_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  has_next g1 s1 andalso
    (has_next g2 s2 andalso
      let
        val (x, s1a) = next g1 s1;
        val (y, s2a) = next g2 s2;
      in
        (if less x y
          then not (proper_interval ao (SOME x)) andalso
                 proper_interval_Compl_set_aux_fusion less proper_interval g1 g2
                   (SOME x) s1a s2
          else (if less y x
                 then not (proper_interval ao (SOME y)) andalso
                        proper_interval_Compl_set_aux_fusion less
                          proper_interval g1 g2 (SOME y) s1 s2a
                 else not (proper_interval ao (SOME x)) andalso
                        (has_next g2 s2a orelse has_next g1 s1a)))
      end);

fun exhaustive_above_fusion proper_interval g y s =
  (if has_next g s
    then let
           val (x, sa) = next g s;
         in
           not (proper_interval (SOME y) (SOME x)) andalso
             exhaustive_above_fusion proper_interval g x sa
         end
    else not (proper_interval (SOME y) NONE));

fun proper_interval_set_aux_fusion less proper_interval g1 g2 s1 s2 =
  has_next g2 s2 andalso
    let
      val (y, s2a) = next g2 s2;
    in
      (if has_next g1 s1
        then let
               val (x, s1a) = next g1 s1;
             in
               (if less x y then false
                 else (if less y x
                        then proper_interval (SOME y) (SOME x) orelse
                               (has_next g2 s2a orelse
                                 not (exhaustive_above_fusion proper_interval g1
                                       x s1a))
                        else proper_interval_set_aux_fusion less proper_interval
                               g1 g2 s1a s2a))
             end
        else has_next g2 s2a orelse proper_interval (SOME y) NONE)
    end;

fun length_last (x :: xs) =
  fold (fn xa => fn (n, _) => (plus_nata n one_nata, xa)) xs (one_nata, x)
  | length_last [] = (zero_nata, (raise Fail "undefined"));

fun proper_interval_set_Compl_aux A_ less proper_interval ao n (x :: xs)
  (y :: ys) =
  (if less x y
    then proper_interval ao (SOME x) orelse
           proper_interval_set_Compl_aux A_ less proper_interval (SOME x)
             (plus_nata n one_nata) xs (y :: ys)
    else (if less y x
           then proper_interval ao (SOME y) orelse
                  proper_interval_set_Compl_aux A_ less proper_interval (SOME y)
                    (plus_nata n one_nata) (x :: xs) ys
           else proper_interval ao (SOME x) andalso
                  let
                    val m = minus_nata (of_phantom (card_UNIV A_)) n;
                  in
                    not (equal_nata (minus_nata m (size_list ys))
                          (nat_of_integer (2 : IntInf.int))) orelse
                      not (equal_nata (minus_nata m (size_list xs))
                            (nat_of_integer (2 : IntInf.int)))
                  end))
  | proper_interval_set_Compl_aux A_ less proper_interval ao n (x :: xs) [] =
    let
      val m = minus_nata (of_phantom (card_UNIV A_)) n;
      val (len_x, xa) = length_last (x :: xs);
    in
      not (equal_nata m len_x) andalso
        (if equal_nata m (plus_nata len_x one_nata)
          then not (proper_interval (SOME xa) NONE) else true)
    end
  | proper_interval_set_Compl_aux A_ less proper_interval ao n [] (y :: ys) =
    let
      val m = minus_nata (of_phantom (card_UNIV A_)) n;
      val (len_y, ya) = length_last (y :: ys);
    in
      not (equal_nata m len_y) andalso
        (if equal_nata m (plus_nata len_y one_nata)
          then not (proper_interval (SOME ya) NONE) else true)
    end
  | proper_interval_set_Compl_aux A_ less proper_interval ao n [] [] =
    less_nat (plus_nata n one_nata) (of_phantom (card_UNIV A_));

fun proper_interval_Compl_set_aux less proper_interval ao uu [] = false
  | proper_interval_Compl_set_aux less proper_interval ao [] uv = false
  | proper_interval_Compl_set_aux less proper_interval ao (x :: xs) (y :: ys) =
    (if less x y
      then not (proper_interval ao (SOME x)) andalso
             proper_interval_Compl_set_aux less proper_interval (SOME x) xs
               (y :: ys)
      else (if less y x
             then not (proper_interval ao (SOME y)) andalso
                    proper_interval_Compl_set_aux less proper_interval (SOME y)
                      (x :: xs) ys
             else not (proper_interval ao (SOME x)) andalso
                    (if null ys then not (null xs) else true)));

fun exhaustive_above proper_interval x (y :: ys) =
  not (proper_interval (SOME x) (SOME y)) andalso
    exhaustive_above proper_interval y ys
  | exhaustive_above proper_interval x [] = not (proper_interval (SOME x) NONE);

fun proper_interval_set_aux less proper_interval (x :: xs) (y :: ys) =
  (if less x y then false
    else (if less y x
           then proper_interval (SOME y) (SOME x) orelse
                  (not (null ys) orelse
                    not (exhaustive_above proper_interval x xs))
           else proper_interval_set_aux less proper_interval xs ys))
  | proper_interval_set_aux less proper_interval [] (y :: ys) =
    not (null ys) orelse proper_interval (SOME y) NONE
  | proper_interval_set_aux less proper_interval xs [] = false;

fun exhaustive_fusion proper_interval g s =
  has_next g s andalso
    let
      val (x, sa) = next g s;
    in
      not (proper_interval NONE (SOME x)) andalso
        exhaustive_above_fusion proper_interval g x sa
    end;

fun carda A_ = carda A_;

fun is_UNIV (A1_, A2_, A3_, A4_) (RBT_set rbt) =
  (case ccompare (ccompare_cproper_interval A3_)
    of NONE =>
      (raise Fail "is_UNIV RBT_set: ccompare = None")
        (fn _ => is_UNIV (A1_, A2_, A3_, A4_) (RBT_set rbt))
    | SOME _ =>
      of_phantom (finite_UNIV (finite_UNIV_card_UNIV A1_)) andalso
        exhaustive_fusion (cproper_interval A3_) rbt_keys_generator
          (init (ccompare_cproper_interval A3_) rbt))
  | is_UNIV (A1_, A2_, A3_, A4_) a =
    let
      val aa = carda A1_ (top_set (A2_, ccompare_cproper_interval A3_, A4_));
      val b = carda A1_ a;
    in
      (if less_nat zero_nata aa then equal_nata aa b
        else (if less_nat zero_nata b then false
               else (raise Fail "is_UNIV called on infinite type and set")
                      (fn _ => is_UNIV (A1_, A2_, A3_, A4_) a)))
    end;

fun is_emptya A_ xa =
  (case impl_ofb A_ xa of Emptya => true | Branch (_, _, _, _, _) => false);

fun nulla A_ xa = null (list_of_dlist A_ xa);

fun is_empty (A1_, A2_, A3_, A4_) (Complement a) =
  is_UNIV (A1_, A2_, A3_, A4_) a
  | is_empty (A1_, A2_, A3_, A4_) (RBT_set rbt) =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "is_empty RBT_set: ccompare = None")
          (fn _ => is_empty (A1_, A2_, A3_, A4_) (RBT_set rbt))
      | SOME _ => is_emptya (ccompare_cproper_interval A3_) rbt)
  | is_empty (A1_, A2_, A3_, A4_) (DList_set dxs) =
    (case ceq A2_
      of NONE =>
        (raise Fail "is_empty DList_set: ceq = None")
          (fn _ => is_empty (A1_, A2_, A3_, A4_) (DList_set dxs))
      | SOME _ => nulla A2_ dxs)
  | is_empty (A1_, A2_, A3_, A4_) (Set_Monad xs) = null xs;

fun cproper_interval_seta (A1_, A2_, A3_, A4_)
  (SOME (Complement (RBT_set rbt1))) (SOME (RBT_set rbt2)) =
  (case ccompare (ccompare_cproper_interval A3_)
    of NONE =>
      (raise Fail
        "cproper_interval (Complement RBT_set) RBT_set: ccompare = None")
        (fn _ =>
          cproper_interval_seta (A1_, A2_, A3_, A4_)
            (SOME (Complement (RBT_set rbt1))) (SOME (RBT_set rbt2)))
    | SOME c =>
      finite (finite_UNIV_card_UNIV A1_, A2_, ccompare_cproper_interval A3_)
        (top_set (A2_, ccompare_cproper_interval A3_, A4_)) andalso
        proper_interval_Compl_set_aux_fusion (lt_of_comp c)
          (cproper_interval A3_) rbt_keys_generator rbt_keys_generator NONE
          (init (ccompare_cproper_interval A3_) rbt1)
          (init (ccompare_cproper_interval A3_) rbt2))
  | cproper_interval_seta (A1_, A2_, A3_, A4_) (SOME (RBT_set rbt1))
    (SOME (Complement (RBT_set rbt2))) =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail
          "cproper_interval RBT_set (Complement RBT_set): ccompare = None")
          (fn _ =>
            cproper_interval_seta (A1_, A2_, A3_, A4_) (SOME (RBT_set rbt1))
              (SOME (Complement (RBT_set rbt2))))
      | SOME c =>
        finite (finite_UNIV_card_UNIV A1_, A2_, ccompare_cproper_interval A3_)
          (top_set (A2_, ccompare_cproper_interval A3_, A4_)) andalso
          proper_interval_set_Compl_aux_fusion A1_ (lt_of_comp c)
            (cproper_interval A3_) rbt_keys_generator rbt_keys_generator NONE
            zero_nata (init (ccompare_cproper_interval A3_) rbt1)
            (init (ccompare_cproper_interval A3_) rbt2))
  | cproper_interval_seta (A1_, A2_, A3_, A4_) (SOME (RBT_set rbt1))
    (SOME (RBT_set rbt2)) =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cproper_interval RBT_set RBT_set: ccompare = None")
          (fn _ =>
            cproper_interval_seta (A1_, A2_, A3_, A4_) (SOME (RBT_set rbt1))
              (SOME (RBT_set rbt2)))
      | SOME c =>
        finite (finite_UNIV_card_UNIV A1_, A2_, ccompare_cproper_interval A3_)
          (top_set (A2_, ccompare_cproper_interval A3_, A4_)) andalso
          proper_interval_set_aux_fusion (lt_of_comp c) (cproper_interval A3_)
            rbt_keys_generator rbt_keys_generator
            (init (ccompare_cproper_interval A3_) rbt1)
            (init (ccompare_cproper_interval A3_) rbt2))
  | cproper_interval_seta (A1_, A2_, A3_, A4_) (SOME (Complement a))
    (SOME (Complement b)) =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cproper_interval Complement Complement: ccompare = None")
          (fn _ =>
            cproper_interval_seta (A1_, A2_, A3_, A4_) (SOME (Complement a))
              (SOME (Complement b)))
      | SOME _ => cproper_interval_seta (A1_, A2_, A3_, A4_) (SOME b) (SOME a))
  | cproper_interval_seta (A1_, A2_, A3_, A4_) (SOME (Complement a)) (SOME b) =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cproper_interval Complement1: ccompare = None")
          (fn _ =>
            cproper_interval_seta (A1_, A2_, A3_, A4_) (SOME (Complement a))
              (SOME b))
      | SOME c =>
        finite (finite_UNIV_card_UNIV A1_, A2_, ccompare_cproper_interval A3_)
          (top_set (A2_, ccompare_cproper_interval A3_, A4_)) andalso
          proper_interval_Compl_set_aux (lt_of_comp c) (cproper_interval A3_)
            NONE (csorted_list_of_set (A2_, ccompare_cproper_interval A3_) a)
            (csorted_list_of_set (A2_, ccompare_cproper_interval A3_) b))
  | cproper_interval_seta (A1_, A2_, A3_, A4_) (SOME a) (SOME (Complement b)) =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cproper_interval Complement2: ccompare = None")
          (fn _ =>
            cproper_interval_seta (A1_, A2_, A3_, A4_) (SOME a)
              (SOME (Complement b)))
      | SOME c =>
        finite (finite_UNIV_card_UNIV A1_, A2_, ccompare_cproper_interval A3_)
          (top_set (A2_, ccompare_cproper_interval A3_, A4_)) andalso
          proper_interval_set_Compl_aux A1_ (lt_of_comp c)
            (cproper_interval A3_) NONE zero_nata
            (csorted_list_of_set (A2_, ccompare_cproper_interval A3_) a)
            (csorted_list_of_set (A2_, ccompare_cproper_interval A3_) b))
  | cproper_interval_seta (A1_, A2_, A3_, A4_) (SOME a) (SOME b) =
    (case ccompare (ccompare_cproper_interval A3_)
      of NONE =>
        (raise Fail "cproper_interval: ccompare = None")
          (fn _ => cproper_interval_seta (A1_, A2_, A3_, A4_) (SOME a) (SOME b))
      | SOME c =>
        finite (finite_UNIV_card_UNIV A1_, A2_, ccompare_cproper_interval A3_)
          (top_set (A2_, ccompare_cproper_interval A3_, A4_)) andalso
          proper_interval_set_aux (lt_of_comp c) (cproper_interval A3_)
            (csorted_list_of_set (A2_, ccompare_cproper_interval A3_) a)
            (csorted_list_of_set (A2_, ccompare_cproper_interval A3_) b))
  | cproper_interval_seta (A1_, A2_, A3_, A4_) (SOME a) NONE =
    not (is_UNIV (A1_, A2_, A3_, A4_) a)
  | cproper_interval_seta (A1_, A2_, A3_, A4_) NONE (SOME b) =
    not (is_empty (A1_, A2_, A3_, A4_) b)
  | cproper_interval_seta (A1_, A2_, A3_, A4_) NONE NONE = true;

fun cproper_interval_set (A1_, A2_, A3_, A4_) =
  {ccompare_cproper_interval =
     ccompare_set (finite_UNIV_card_UNIV A1_, A2_, A3_, A4_),
    cproper_interval = cproper_interval_seta (A1_, A2_, A3_, A4_)}
  : 'a set cproper_interval;

fun equal_boola p true = p
  | equal_boola p false = not p
  | equal_boola true p = p
  | equal_boola false p = not p;

val equal_bool = {equal = equal_boola} : bool equal;

fun equal_lista A_ [] (x21 :: x22) = false
  | equal_lista A_ (x21 :: x22) [] = false
  | equal_lista A_ (x21 :: x22) (y21 :: y22) =
    eq A_ x21 y21 andalso equal_lista A_ x22 y22
  | equal_lista A_ [] [] = true;

fun equal_list A_ = {equal = equal_lista A_} : ('a list) equal;

fun shows_prec_list A_ p xs = shows_list A_ xs;

fun shows_list_list A_ xss = showsp_list (shows_prec_list A_) zero_nata xss;

fun show_list A_ =
  {shows_prec = shows_prec_list A_, shows_list = shows_list_list A_} :
  ('a list) show;

val default_lista : 'a list = [];

type 'a default = {default : 'a};
val default = #default : 'a default -> 'a;

val default_list = {default = default_lista} : ('a list) default;

fun less_eq_list (A1_, A2_) (x :: xs) (y :: ys) =
  less ((ord_preorder o preorder_order) A2_) x y orelse
    eq A1_ x y andalso less_eq_list (A1_, A2_) xs ys
  | less_eq_list (A1_, A2_) [] xs = true
  | less_eq_list (A1_, A2_) (x :: xs) [] = false;

fun less_list (A1_, A2_) (x :: xs) (y :: ys) =
  less ((ord_preorder o preorder_order) A2_) x y orelse
    eq A1_ x y andalso less_list (A1_, A2_) xs ys
  | less_list (A1_, A2_) [] (x :: xs) = true
  | less_list (A1_, A2_) xs [] = false;

fun ord_list (A1_, A2_) =
  {less_eq = less_eq_list (A1_, A2_), less = less_list (A1_, A2_)} :
  ('a list) ord;

fun comparator_list comp_a (x :: xa) (y :: ya) =
  (case comp_a x y of Eq => comparator_list comp_a xa ya | Lt => Lt | Gt => Gt)
  | comparator_list comp_a (x :: xa) [] = Gt
  | comparator_list comp_a [] (y :: ya) = Lt
  | comparator_list comp_a [] [] = Eq;

fun compare_lista A_ = comparator_list (compare A_);

fun quasi_order_list (A1_, A2_) = {ord_quasi_order = ord_list (A1_, A2_)} :
  ('a list) quasi_order;

fun weak_order_list (A1_, A2_) =
  {quasi_order_weak_order = quasi_order_list (A1_, A2_)} : ('a list) weak_order;

fun preorder_list (A1_, A2_) = {ord_preorder = ord_list (A1_, A2_)} :
  ('a list) preorder;

fun order_list (A1_, A2_) =
  {preorder_order = preorder_list (A1_, A2_),
    weak_order_order = weak_order_list (A1_, A2_)}
  : ('a list) order;

fun linorder_list (A1_, A2_) =
  {order_linorder = order_list (A1_, order_linorder A2_)} : ('a list) linorder;

fun compare_list A_ = {compare = compare_lista A_} : ('a list) compare;

fun compare_order_list (A1_, A2_) =
  {compare_compare_order = compare_list (compare_compare_order A1_),
    linorder_compare_order = linorder_list (A2_, linorder_compare_order A1_)}
  : ('a list) compare_order;

fun key_list (A1_, A2_) =
  {compare_order_key = compare_order_list (compare_order_key A2_, A1_)} :
  ('a list) key;

fun equality_list eq_a (x :: xa) (y :: ya) =
  eq_a x y andalso equality_list eq_a xa ya
  | equality_list eq_a (x :: xa) [] = false
  | equality_list eq_a [] (y :: ya) = false
  | equality_list eq_a [] [] = true;

fun ceq_lista A_ =
  (case ceq A_ of NONE => NONE | SOME eq_a => SOME (equality_list eq_a));

fun ceq_list A_ = {ceq = ceq_lista A_} : ('a list) ceq;

type 'a infinite = {};

val infinite_list = {} : ('a list) infinite;

val set_impl_lista : (('a list), set_impla) phantom = Phantom Set_Choose;

val set_impl_list = {set_impl = set_impl_lista} : ('a list) set_impl;

type 'a countable = {};

fun countable_list A_ = {} : ('a list) countable;

val finite_UNIV_lista : (('a list), bool) phantom = Phantom false;

val card_UNIV_lista : (('a list), nat) phantom = Phantom zero_nata;

val finite_UNIV_list = {finite_UNIV = finite_UNIV_lista} :
  ('a list) finite_UNIV;

val card_UNIV_list =
  {finite_UNIV_card_UNIV = finite_UNIV_list, card_UNIVa = card_UNIV_lista} :
  ('a list) card_UNIV;

val cEnum_list :
  (('a list) list *
    ((('a list -> bool) -> bool) * (('a list -> bool) -> bool))) option
  = NONE;

val cenum_list = {cEnum = cEnum_list} : ('a list) cenum;

fun ccompare_lista A_ =
  (case ccompare A_ of NONE => NONE
    | SOME comp_a => SOME (comparator_list comp_a));

fun ccompare_list A_ = {ccompare = ccompare_lista A_} : ('a list) ccompare;

val mapping_impl_lista : (('a list), mapping_impla) phantom =
  Phantom Mapping_Choose;

val mapping_impl_list = {mapping_impl = mapping_impl_lista} :
  ('a list) mapping_impl;

fun cproper_interval_lista A_ xso yso = (raise Fail "undefined");

fun cproper_interval_list A_ =
  {ccompare_cproper_interval = ccompare_list A_,
    cproper_interval = cproper_interval_lista A_}
  : ('a list) cproper_interval;

fun gcdc (A1_, A2_) a b =
  (if eq A2_ b
        (zerob
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_comm_semiring_1 o
             comm_semiring_1_comm_semiring_1_cancel o
             comm_semiring_1_cancel_semidom o semidom_semidom_divide o
             semidom_divide_algebraic_semidom o
             algebraic_semidom_normalization_semidom o
             normalization_semidom_factorial_semiring o
             factorial_semiring_euclidean_semiring)
            A1_))
    then normalizeb
           ((normalization_semidom_factorial_semiring o
              factorial_semiring_euclidean_semiring)
             A1_)
           a
    else gcdc (A1_, A2_) b
           (modulo
             ((modulo_semiring_modulo o semiring_modulo_semidom_modulo o
                semidom_modulo_euclidean_semiring)
               A1_)
             a b));

fun lcmc (A1_, A2_) a b =
  divide
    ((divide_modulo o modulo_semiring_modulo o semiring_modulo_semidom_modulo o
       semidom_modulo_euclidean_semiring)
      A1_)
    (normalizeb
      ((normalization_semidom_factorial_semiring o
         factorial_semiring_euclidean_semiring)
        A1_)
      (times
        ((times_dvd o dvd_modulo o modulo_semiring_modulo o
           semiring_modulo_semidom_modulo o semidom_modulo_euclidean_semiring)
          A1_)
        a b))
    (gcdc (A1_, A2_) a b);

fun euclidean_size_field (A1_, A2_) x =
  (if eq A2_ x
        (zerob
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_comm_semiring_1 o
             comm_semiring_1_comm_semiring_1_cancel o
             comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
             idom_divide_field)
            A1_))
    then zero_nata else one_nata);

fun rep_real_alg_3 (Real_Alg_Invariant x) = x;

fun coeffs A_ (Poly x) = x;

fun uminus_polya A_ p =
  Poly (map (uminus ((uminus_group_add o group_add_ab_group_add) A_))
         (coeffs
           ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add)
             A_)
           p));

fun nth (x :: xs) n =
  (if equal_nata n zero_nata then x else nth xs (minus_nata n one_nata));

fun nth_default dflt xs n =
  (if less_nat n (size_list xs) then nth xs n else dflt);

fun coeff A_ p = nth_default (zerob A_) (coeffs A_ p);

fun degreea A_ p = minus_nata (size_list (coeffs A_ p)) one_nata;

fun abs_int_poly p =
  (if less_int (coeff zero_int p (degreea zero_int p)) zero_inta
    then uminus_polya ab_group_add_int p else p);

fun foldr f [] = id
  | foldr f (x :: xs) = f x o foldr f xs;

fun fold_coeffs A_ f p = foldr f (coeffs A_ p);

fun tighten_poly_bounds p l r sr =
  let
    val m =
      divide_rata (plus_rata l r) (of_int (Int_of_integer (2 : IntInf.int)));
    val sm =
      sgn_rata
        (fold_coeffs zero_int
          (fn a => fn b => plus_rata (of_int a) (times_rata m b)) p zero_rata);
  in
    (if equal_rata sm sr then (l, (m, sm)) else (m, (r, sr)))
  end;

fun tighten_poly_bounds_epsilon p x l r sr =
  (if less_eq_rat (minus_rata r l) x then (l, (r, sr))
    else let
           val (la, a) = tighten_poly_bounds p l r sr;
           val (aa, b) = a;
         in
           tighten_poly_bounds_epsilon p x la aa b
         end);

fun tighten_poly_bounds_for_x p x l r sr =
  (if less_rat x l orelse less_rat r x then (l, (r, sr))
    else let
           val (la, a) = tighten_poly_bounds p l r sr;
           val (aa, b) = a;
         in
           tighten_poly_bounds_for_x p x la aa b
         end);

fun normalize_bounds_1_main eps rai =
  let
    val (p, (l, r)) = rai;
    val (la, (ra, sr)) =
      tighten_poly_bounds_epsilon p eps l r
        (sgn_rata
          (fold_coeffs zero_int
            (fn a => fn b => plus_rata (of_int a) (times_rata r b)) p
            zero_rata));
    val fr = of_int (floor_rat ra);
    val (lb, (rb, _)) = tighten_poly_bounds_for_x p fr la ra sr;
  in
    (p, (lb, rb))
  end;

fun fract a b = Frct (normalize (a, b));

val real_alg_precision : rat = fract one_inta (Int_of_integer (2 : IntInf.int));

fun normalize_bounds_1 x = normalize_bounds_1_main real_alg_precision x;

fun poly_real_alg_1 (p, (uu, uv)) = p;

datatype root_info = Root_Info of (rat -> rat -> nat) * (rat -> nat);

fun number_root (Root_Info (x1, x2)) = x2;

fun dvd (A1_, A2_) a b =
  eq A2_
    (modulo ((modulo_semiring_modulo o semiring_modulo_semidom_modulo) A1_) b a)
    (zerob
      ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
         semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
         comm_semiring_1_cancel_semidom o semidom_semidom_divide o
         semidom_divide_algebraic_semidom o algebraic_semidom_semidom_modulo)
        A1_));

fun poly_neg_number_rootat p =
  (if dvd (semidom_modulo_nat, equal_nat) (nat_of_integer (2 : IntInf.int))
        (degreea zero_rat p)
    then sgn_rata (coeff zero_rat p (degreea zero_rat p))
    else uminus_rata (sgn_rata (coeff zero_rat p (degreea zero_rat p))));

fun remdups_adj A_ [] = []
  | remdups_adj A_ [x] = [x]
  | remdups_adj A_ (x :: y :: xs) =
    (if eq A_ x y then remdups_adj A_ (x :: xs)
      else x :: remdups_adj A_ (y :: xs));

fun sign_changes_neg_number_rootat ps =
  minus_nata
    (size_list
      (remdups_adj equal_rat
        (filtera (fn x => not (equal_rata x zero_rata))
          (map poly_neg_number_rootat ps))))
    one_nata;

fun polya A_ p =
  fold_coeffs
    ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_comm_semiring_0) A_)
    (fn a => fn f => fn x =>
      plus ((plus_semigroup_add o semigroup_add_monoid_add o
              monoid_add_comm_monoid_add o comm_monoid_add_semiring_0 o
              semiring_0_comm_semiring_0)
             A_)
        a (times
            ((times_mult_zero o mult_zero_semiring_0 o
               semiring_0_comm_semiring_0)
              A_)
            x (f x)))
    p (fn _ =>
        zerob ((zero_mult_zero o mult_zero_semiring_0 o
                 semiring_0_comm_semiring_0)
                A_));

fun sign_changes_rat ps x =
  minus_nata
    (size_list
      (remdups_adj equal_rat
        (filtera (fn xa => not (equal_rata xa zero_rata))
          (map (fn p => sgn_rata (polya comm_semiring_0_rat p x)) ps))))
    one_nata;

fun minus_poly_rev_list A_ (x :: xs) (y :: ys) =
  minus (minus_group_add A_) x y :: minus_poly_rev_list A_ xs ys
  | minus_poly_rev_list A_ xs [] = xs
  | minus_poly_rev_list A_ [] (y :: ys) = [];

fun tla [] = []
  | tla (x21 :: x22) = x22;

fun hda (x21 :: x22) = x21;

fun mod_poly_one_main_list (A1_, A2_) r d n =
  (if equal_nata n zero_nata then r
    else let
           val a = hda r;
           val rr =
             tla (if eq A1_ a
                       (zerob
                         ((zero_mult_zero o mult_zero_semiring_0 o
                            semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                            comm_semiring_1_comm_semiring_1_cancel o
                            comm_semiring_1_cancel_comm_ring_1)
                           A2_))
                   then r
                   else minus_poly_rev_list
                          ((group_add_neg_numeral o neg_numeral_ring_1 o
                             ring_1_comm_ring_1)
                            A2_)
                          r (map (times
                                   ((times_dvd o dvd_comm_monoid_mult o
                                      comm_monoid_mult_comm_semiring_1 o
                                      comm_semiring_1_comm_semiring_1_cancel o
                                      comm_semiring_1_cancel_comm_ring_1)
                                     A2_)
                                   a)
                              d));
         in
           mod_poly_one_main_list (A1_, A2_) rr d (minus_nata n one_nata)
         end);

fun dropWhile p [] = []
  | dropWhile p (x :: xs) = (if p x then dropWhile p xs else x :: xs);

fun rev xs = fold (fn a => fn b => a :: b) xs [];

fun strip_while p = rev o dropWhile p o rev;

fun poly_of_list (A1_, A2_) asa =
  Poly (strip_while
         (eq A2_ (zerob ((zero_monoid_add o monoid_add_comm_monoid_add) A1_)))
         asa);

fun last (x :: xs) = (if null xs then x else last xs);

fun modulo_polya (A1_, A2_) f g =
  let
    val cg =
      coeffs
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
           idom_divide_field)
          A1_)
        g;
  in
    (if null cg then f
      else let
             val cf =
               coeffs
                 ((zero_mult_zero o mult_zero_semiring_0 o
                    semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                    comm_semiring_1_comm_semiring_1_cancel o
                    comm_semiring_1_cancel_semidom o semidom_idom o
                    idom_idom_divide o idom_divide_field)
                   A1_)
                 f;
             val ilc =
               inverse ((inverse_division_ring o division_ring_field) A1_)
                 (last cg);
             val ch =
               map (times
                     ((times_dvd o dvd_comm_monoid_mult o
                        comm_monoid_mult_comm_semiring_1 o
                        comm_semiring_1_comm_semiring_1_cancel o
                        comm_semiring_1_cancel_semidom o semidom_idom o
                        idom_idom_divide o idom_divide_field)
                       A1_)
                     ilc)
                 cg;
             val r =
               mod_poly_one_main_list
                 (A2_, (comm_ring_1_idom o idom_idom_divide o idom_divide_field)
                         A1_)
                 (rev cf) (rev ch)
                 (minus_nata (plus_nata one_nata (size_list cf))
                   (size_list cg));
           in
             poly_of_list
               ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
                  semiring_1_comm_semiring_1 o
                  comm_semiring_1_comm_semiring_1_cancel o
                  comm_semiring_1_cancel_semidom o semidom_idom o
                  idom_idom_divide o idom_divide_field)
                  A1_,
                 A2_)
               (rev r)
           end)
  end;

fun sturm_aux_rat p q =
  (if equal_nata (degreea zero_rat q) zero_nata then [p, q]
    else p :: sturm_aux_rat q
                (uminus_polya ab_group_add_rat
                  (modulo_polya (field_rat, equal_rat) p q)));

fun cCons (A1_, A2_) x xs =
  (if null xs andalso eq A2_ x (zerob A1_) then [] else x :: xs);

fun pderiv_coeffs_code (A1_, A2_, A3_) f (x :: xs) =
  cCons ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1)
           A2_,
          A1_)
    (times
      ((times_dvd o dvd_comm_monoid_mult o comm_monoid_mult_comm_semiring_1)
        A2_)
      f x)
    (pderiv_coeffs_code (A1_, A2_, A3_)
      (plus ((plus_semigroup_add o semigroup_add_numeral o
               numeral_semiring_numeral o semiring_numeral_semiring_1 o
               semiring_1_comm_semiring_1)
              A2_)
        f (onea ((one_numeral o numeral_semiring_numeral o
                   semiring_numeral_semiring_1 o semiring_1_comm_semiring_1)
                  A2_)))
      xs)
  | pderiv_coeffs_code (A1_, A2_, A3_) f [] = [];

fun pderiv_coeffs (A1_, A2_, A3_) xs =
  pderiv_coeffs_code (A1_, A2_, A3_)
    (onea ((one_numeral o numeral_semiring_numeral o
             semiring_numeral_semiring_1 o semiring_1_comm_semiring_1)
            A2_))
    (tla xs);

fun pderiv (A1_, A2_, A3_) p =
  Poly (pderiv_coeffs (A1_, A2_, A3_)
         (coeffs
           ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
              semiring_1_comm_semiring_1)
             A2_)
           p));

fun sturm_rat p =
  sturm_aux_rat p
    (pderiv (equal_rat, comm_semiring_1_rat, semiring_no_zero_divisors_rat) p);

fun map_poly B_ (A1_, A2_) f p =
  Poly (strip_while (eq A2_ (zerob A1_)) (map f (coeffs B_ p)));

fun root_info p =
  (if equal_nata (degreea zero_int p) one_nata
    then let
           val x =
             fract (uminus_inta
                     (case coeffs zero_int p of [] => zero_inta | x :: _ => x))
               (coeff zero_int p one_nata);
         in
           Root_Info
             ((fn l => fn r =>
                (if less_eq_rat l x andalso less_eq_rat x r then one_nata
                  else zero_nata)),
               (fn b => (if less_eq_rat x b then one_nata else zero_nata)))
         end
    else let
           val rp = map_poly zero_int (zero_rat, equal_rat) of_int p;
           val ps = sturm_rat rp;
         in
           Root_Info
             ((fn a => fn b =>
                minus_nata (sign_changes_rat ps a) (sign_changes_rat ps b)),
               (fn a =>
                 minus_nata (sign_changes_neg_number_rootat ps)
                   (sign_changes_rat ps a)))
         end);

fun real_alg_2 rai =
  let
    val p = poly_real_alg_1 rai;
  in
    (if equal_nata (degreea zero_int p) one_nata
      then Rationala
             (fract
               (uminus_inta
                 (case coeffs zero_int p of [] => zero_inta | x :: _ => x))
               (coeff zero_int p one_nata))
      else let
             val (pa, (l, r)) = normalize_bounds_1 rai;
           in
             Irrational (number_root (root_info p) r, (pa, (l, r)))
           end)
  end;

fun reflect_poly (A1_, A2_) p =
  Poly (rev (dropWhile (eq A2_ (zerob A1_)) (coeffs A1_ p)));

fun inverse_1 (p, (l, r)) =
  real_alg_2
    (abs_int_poly (reflect_poly (zero_int, equal_int) p),
      (inverse_rata r, inverse_rata l));

fun inverse_2 (Rationala r) = Rationala (inverse_rata r)
  | inverse_2 (Irrational (n, x)) = inverse_1 x;

fun inverse_3 xa = Real_Alg_Invariant (inverse_2 (rep_real_alg_3 xa));

fun inverse_real_alg (Real_Alg_Quotient x) = Real_Alg_Quotient (inverse_3 x);

fun inverse_reala (Real_of x) = Real_of (inverse_real_alg x);

fun zero_polyb A_ = Poly [];

fun pCons (A1_, A2_) a p = Poly (cCons (A1_, A2_) a (coeffs A1_ p));

fun poly_uminus_inner (A1_, A2_) [] =
  zero_polyb
    ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
       semiring_1_semiring_1_cancel o semiring_1_cancel_ring_1)
      A2_)
  | poly_uminus_inner (A1_, A2_) [a] =
    pCons ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_semiring_1_cancel o semiring_1_cancel_ring_1)
             A2_,
            A1_)
      a (zero_polyb
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_semiring_1_cancel o semiring_1_cancel_ring_1)
            A2_))
  | poly_uminus_inner (A1_, A2_) (a :: b :: cs) =
    pCons ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_semiring_1_cancel o semiring_1_cancel_ring_1)
             A2_,
            A1_)
      a (pCons
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_semiring_1_cancel o semiring_1_cancel_ring_1)
             A2_,
            A1_)
          (uminus
            ((uminus_group_add o group_add_neg_numeral o neg_numeral_ring_1)
              A2_)
            b)
          (poly_uminus_inner (A1_, A2_) cs));

fun poly_uminus (A1_, A2_) p =
  poly_uminus_inner (A1_, A2_)
    (coeffs
      ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
         semiring_1_semiring_1_cancel o semiring_1_cancel_ring_1)
        A2_)
      p);

fun uminus_1 (p, (l, r)) =
  (abs_int_poly (poly_uminus (equal_int, ring_1_int) p),
    (uminus_rata r, uminus_rata l));

fun uminus_2 (Rationala r) = Rationala (uminus_rata r)
  | uminus_2 (Irrational (n, x)) = real_alg_2 (uminus_1 x);

fun uminus_3 xa = Real_Alg_Invariant (uminus_2 (rep_real_alg_3 xa));

fun uminus_real_alg (Real_Alg_Quotient x) = Real_Alg_Quotient (uminus_3 x);

fun uminus_reala (Real_of x) = Real_of (uminus_real_alg x);

fun binary_power A_ x n =
  (if equal_nata n zero_nata then onea ((one_power o power_monoid_mult) A_)
    else let
           val (d, r) = divmod_nat n (nat_of_integer (2 : IntInf.int));
           val reca =
             binary_power A_ (times ((times_power o power_monoid_mult) A_) x x)
               d;
         in
           (if equal_nata r zero_nata then reca
             else times ((times_power o power_monoid_mult) A_) reca x)
         end);

fun zip (x :: xs) (y :: ys) = (x, y) :: zip xs ys
  | zip xs [] = []
  | zip [] ys = [];

fun upt i j = (if less_nat i j then i :: upt (suc i) j else []);

fun poly_mult_rat_main (A1_, A2_) n d f =
  let
    val fs =
      coeffs
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_semidom o semidom_idom)
          A2_)
        f;
    val k = size_list fs;
  in
    poly_of_list
      ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
         semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
         comm_semiring_1_cancel_semidom o semidom_idom)
         A2_,
        A1_)
      (map (fn (fi, i) =>
             times ((times_dvd o dvd_comm_monoid_mult o
                      comm_monoid_mult_comm_semiring_1 o
                      comm_semiring_1_comm_semiring_1_cancel o
                      comm_semiring_1_cancel_semidom o semidom_idom)
                     A2_)
               (times
                 ((times_dvd o dvd_comm_monoid_mult o
                    comm_monoid_mult_comm_semiring_1 o
                    comm_semiring_1_comm_semiring_1_cancel o
                    comm_semiring_1_cancel_semidom o semidom_idom)
                   A2_)
                 fi (binary_power
                      ((monoid_mult_semiring_numeral o
                         semiring_numeral_semiring_1 o
                         semiring_1_comm_semiring_1 o
                         comm_semiring_1_comm_semiring_1_cancel o
                         comm_semiring_1_cancel_semidom o semidom_idom)
                        A2_)
                      d i))
               (binary_power
                 ((monoid_mult_semiring_numeral o semiring_numeral_semiring_1 o
                    semiring_1_comm_semiring_1 o
                    comm_semiring_1_comm_semiring_1_cancel o
                    comm_semiring_1_cancel_semidom o semidom_idom)
                   A2_)
                 n (minus_nata k (suc i))))
        (zip fs (upt zero_nata k)))
  end;

fun poly_mult_rat r p = let
                          val (n, d) = quotient_of r;
                        in
                          poly_mult_rat_main (equal_int, idom_int) n d p
                        end;

fun sdiv_poly (A1_, A2_) p a =
  map_poly
    ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
       semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
       comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
      A2_)
    ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
       semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
       comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
       A2_,
      A1_)
    (fn c =>
      divide ((divide_semidom_divide o semidom_divide_idom_divide) A2_) c a)
    p;

fun content A_ p =
  fold_coeffs
    ((zero_gcd o gcd_comm_monoid_gcd o comm_monoid_gcd_semiring_gcd) A_)
    (gcda ((gcd_comm_monoid_gcd o comm_monoid_gcd_semiring_gcd) A_)) p
    (zerob
      ((zero_gcd o gcd_comm_monoid_gcd o comm_monoid_gcd_semiring_gcd) A_));

fun cf_pos_poly f =
  let
    val c = content semiring_gcd_int f;
    val a = times_inta (sgn_inta (coeff zero_int f (degreea zero_int f))) c;
  in
    sdiv_poly (equal_int, idom_divide_int) f a
  end;

fun mult_rat_1_pos r1 (p2, (l2, r2)) =
  real_alg_2
    (cf_pos_poly (poly_mult_rat r1 p2), (times_rata l2 r1, times_rata r2 r1));

fun mult_rat_1 x y =
  (if less_rat x zero_rata then uminus_2 (mult_rat_1_pos (uminus_rata x) y)
    else (if equal_rata x zero_rata then Rationala zero_rata
           else mult_rat_1_pos x y));

fun l_r (Root_Info (x1, x2)) = x1;

fun select_correct_factor_main bnd_update bnd_get bnd todo old l r n =
  (case todo
    of [] =>
      (if equal_nata n one_nata then (hda old, (l, r))
        else let
               val bnda = bnd_update bnd;
               val (la, ra) = bnd_get bnda;
             in
               select_correct_factor_main bnd_update bnd_get bnda old [] la ra
                 zero_nata
             end)
    | (p, ri) :: todoa =>
      let
        val m = l_r ri l r;
      in
        (if equal_nata m zero_nata
          then select_correct_factor_main bnd_update bnd_get bnd todoa old l r n
          else select_correct_factor_main bnd_update bnd_get bnd todoa
                 ((p, ri) :: old) l r (plus_nata n m))
      end);

fun select_correct_factor bnd_update bnd_get init polys =
  let
    val (l, r) = bnd_get init;
  in
    select_correct_factor_main bnd_update bnd_get init polys [] l r zero_nata
  end;

fun divide_poly_main_list (A1_, A2_) lc q r d n =
  (if equal_nata n zero_nata then q
    else let
           val cr = hda r;
         in
           (if eq A1_ cr
                 (zerob
                   ((zero_mult_zero o mult_zero_semiring_0 o
                      semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                      comm_semiring_1_comm_semiring_1_cancel o
                      comm_semiring_1_cancel_semidom o semidom_idom o
                      idom_idom_divide)
                     A2_))
             then divide_poly_main_list (A1_, A2_) lc
                    (cCons
                      ((zero_mult_zero o mult_zero_semiring_0 o
                         semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                         comm_semiring_1_comm_semiring_1_cancel o
                         comm_semiring_1_cancel_semidom o semidom_idom o
                         idom_idom_divide)
                         A2_,
                        A1_)
                      cr q)
                    (tla r) d (minus_nata n one_nata)
             else let
                    val a =
                      divide
                        ((divide_semidom_divide o semidom_divide_idom_divide)
                          A2_)
                        cr lc;
                    val qq =
                      cCons ((zero_mult_zero o mult_zero_semiring_0 o
                               semiring_0_semiring_1 o
                               semiring_1_comm_semiring_1 o
                               comm_semiring_1_comm_semiring_1_cancel o
                               comm_semiring_1_cancel_semidom o semidom_idom o
                               idom_idom_divide)
                               A2_,
                              A1_)
                        a q;
                    val rr =
                      minus_poly_rev_list
                        ((group_add_neg_numeral o neg_numeral_ring_1 o
                           ring_1_comm_ring_1 o comm_ring_1_idom o
                           idom_idom_divide)
                          A2_)
                        r (map (times
                                 ((times_dvd o dvd_comm_monoid_mult o
                                    comm_monoid_mult_comm_semiring_1 o
                                    comm_semiring_1_comm_semiring_1_cancel o
                                    comm_semiring_1_cancel_semidom o
                                    semidom_idom o idom_idom_divide)
                                   A2_)
                                 a)
                            d);
                  in
                    (if eq A1_ (hda rr)
                          (zerob
                            ((zero_mult_zero o mult_zero_semiring_0 o
                               semiring_0_semiring_1 o
                               semiring_1_comm_semiring_1 o
                               comm_semiring_1_comm_semiring_1_cancel o
                               comm_semiring_1_cancel_semidom o semidom_idom o
                               idom_idom_divide)
                              A2_))
                      then divide_poly_main_list (A1_, A2_) lc qq (tla rr) d
                             (minus_nata n one_nata)
                      else [])
                  end)
         end);

fun divide_poly_list (A1_, A2_) f g =
  let
    val cg =
      coeffs
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
          A2_)
        g;
  in
    (if null cg then g
      else let
             val cf =
               coeffs
                 ((zero_mult_zero o mult_zero_semiring_0 o
                    semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                    comm_semiring_1_comm_semiring_1_cancel o
                    comm_semiring_1_cancel_semidom o semidom_idom o
                    idom_idom_divide)
                   A2_)
                 f;
             val cgr = rev cg;
           in
             poly_of_list
               ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
                  semiring_1_comm_semiring_1 o
                  comm_semiring_1_comm_semiring_1_cancel o
                  comm_semiring_1_cancel_semidom o semidom_idom o
                  idom_idom_divide)
                  A2_,
                 A1_)
               (divide_poly_main_list (A1_, A2_) (hda cgr) [] (rev cf) cgr
                 (minus_nata (plus_nata one_nata (size_list cf))
                   (size_list cg)))
           end)
  end;

fun divide_polya (A1_, A2_) f g = divide_poly_list (A1_, A2_) f g;

fun plus_coeffs (A1_, A2_) xs [] = xs
  | plus_coeffs (A1_, A2_) [] (v :: va) = v :: va
  | plus_coeffs (A1_, A2_) (x :: xs) (y :: ys) =
    cCons ((zero_monoid_add o monoid_add_comm_monoid_add) A1_, A2_)
      (plus ((plus_semigroup_add o semigroup_add_monoid_add o
               monoid_add_comm_monoid_add)
              A1_)
        x y)
      (plus_coeffs (A1_, A2_) xs ys);

fun plus_polya (A1_, A2_) p q =
  Poly (plus_coeffs (A1_, A2_)
         (coeffs ((zero_monoid_add o monoid_add_comm_monoid_add) A1_) p)
         (coeffs ((zero_monoid_add o monoid_add_comm_monoid_add) A1_) q));

fun minus_polya (A1_, A2_) p q =
  plus_polya
    ((comm_monoid_add_cancel_comm_monoid_add o
       cancel_comm_monoid_add_ab_group_add)
       A1_,
      A2_)
    p (uminus_polya A1_ q);

fun one_polyb A_ =
  Poly [onea ((one_numeral o numeral_semiring_numeral o
                semiring_numeral_semiring_1 o semiring_1_comm_semiring_1)
               A_)];

fun equal_polya (A1_, A2_) p q = equal_lista A2_ (coeffs A1_ p) (coeffs A1_ q);

fun equal_poly (A1_, A2_) = {equal = equal_polya (A1_, A2_)} : 'a poly equal;

fun yun_factorization_main (A1_, A2_) gcd bn cn i sqr =
  (if eq (equal_poly
           ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
              semiring_Gcd_factorial_semiring_gcd o
              factorial_semiring_gcd_factorial_ring_gcd)
              A1_,
             A2_))
        bn (one_polyb
             ((comm_semiring_1_comm_semiring_1_cancel o
                comm_semiring_1_cancel_semidom o semidom_idom o
                idom_idom_divide o idom_divide_factorial_ring_gcd)
               A1_))
    then sqr
    else let
           val dn =
             minus_polya
               ((ab_group_add_ring o ring_ring_1 o ring_1_comm_ring_1 o
                  comm_ring_1_idom o idom_idom_divide o
                  idom_divide_factorial_ring_gcd)
                  A1_,
                 A2_)
               cn (pderiv
                    (A2_, (comm_semiring_1_comm_semiring_1_cancel o
                            comm_semiring_1_cancel_semidom o semidom_idom o
                            idom_idom_divide o idom_divide_factorial_ring_gcd)
                            A1_,
                      (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
                        semiring_1_no_zero_divisors_semidom o semidom_idom o
                        idom_idom_divide o idom_divide_factorial_ring_gcd)
                        A1_)
                    bn);
           val an = gcd bn dn;
         in
           yun_factorization_main (A1_, A2_) gcd
             (divide_polya (A2_, idom_divide_factorial_ring_gcd A1_) bn an)
             (divide_polya (A2_, idom_divide_factorial_ring_gcd A1_) dn an)
             (suc i) ((an, i) :: sqr)
         end);

fun yun_monic_factorization (A1_, A2_) gcd p =
  let
    val pp =
      pderiv
        (A2_, (comm_semiring_1_comm_semiring_1_cancel o
                comm_semiring_1_cancel_semidom o semidom_idom o
                idom_idom_divide o idom_divide_factorial_ring_gcd)
                A1_,
          (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
            semiring_1_no_zero_divisors_semidom o semidom_idom o
            idom_idom_divide o idom_divide_factorial_ring_gcd)
            A1_)
        p;
    val u = gcd p pp;
    val b0 = divide_polya (A2_, idom_divide_factorial_ring_gcd A1_) p u;
    val c0 = divide_polya (A2_, idom_divide_factorial_ring_gcd A1_) pp u;
  in
    filtera
      (fn (a, _) =>
        not (eq (equal_poly
                  ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
                     semiring_Gcd_factorial_semiring_gcd o
                     factorial_semiring_gcd_factorial_ring_gcd)
                     A1_,
                    A2_))
              a (one_polyb
                  ((comm_semiring_1_comm_semiring_1_cancel o
                     comm_semiring_1_cancel_semidom o semidom_idom o
                     idom_idom_divide o idom_divide_factorial_ring_gcd)
                    A1_))))
      (yun_factorization_main (A1_, A2_) gcd b0 c0 zero_nata [])
  end;

fun normalize_poly (A1_, A2_, A3_) p =
  divide_polya (A1_, A2_) p
    (pCons
      ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
         semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
         comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
         A2_,
        A1_)
      (unit_factor (unit_factor_semidom_divide_unit_factor A3_)
        (coeff
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_comm_semiring_1 o
             comm_semiring_1_comm_semiring_1_cancel o
             comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
            A2_)
          p (degreea
              ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
                 semiring_1_comm_semiring_1 o
                 comm_semiring_1_comm_semiring_1_cancel o
                 comm_semiring_1_cancel_semidom o semidom_idom o
                 idom_idom_divide)
                A2_)
              p)))
      (zero_polyb
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
          A2_)));

fun primitive_part (A1_, A2_) p =
  map_poly ((zero_gcd o gcd_comm_monoid_gcd o comm_monoid_gcd_semiring_gcd) A1_)
    ((zero_gcd o gcd_comm_monoid_gcd o comm_monoid_gcd_semiring_gcd) A1_, A2_)
    (fn x =>
      divide
        ((divide_semidom_divide o semidom_divide_algebraic_semidom o
           algebraic_semidom_normalization_semidom o
           normalization_semidom_semiring_gcd)
          A1_)
        x (content A1_ p))
    p;

fun pseudo_mod_main_list (A1_, A2_) lc r d n =
  (if equal_nata n zero_nata then r
    else let
           val rr =
             map (times
                   ((times_dvd o dvd_comm_monoid_mult o
                      comm_monoid_mult_comm_semiring_1 o
                      comm_semiring_1_comm_semiring_1_cancel o
                      comm_semiring_1_cancel_comm_ring_1)
                     A2_)
                   lc)
               r;
           val a = hda r;
           val rrr =
             tla (if eq A1_ a
                       (zerob
                         ((zero_mult_zero o mult_zero_semiring_0 o
                            semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                            comm_semiring_1_comm_semiring_1_cancel o
                            comm_semiring_1_cancel_comm_ring_1)
                           A2_))
                   then rr
                   else minus_poly_rev_list
                          ((group_add_neg_numeral o neg_numeral_ring_1 o
                             ring_1_comm_ring_1)
                            A2_)
                          rr (map (times
                                    ((times_dvd o dvd_comm_monoid_mult o
                                       comm_monoid_mult_comm_semiring_1 o
                                       comm_semiring_1_comm_semiring_1_cancel o
                                       comm_semiring_1_cancel_comm_ring_1)
                                      A2_)
                                    a)
                               d));
         in
           pseudo_mod_main_list (A1_, A2_) lc rrr d (minus_nata n one_nata)
         end);

fun pseudo_mod_list (A1_, A2_) p q =
  (if null q then p
    else let
           val rq = rev q;
           val a =
             pseudo_mod_main_list (A1_, A2_) (hda rq) (rev p) rq
               (minus_nata (plus_nata one_nata (size_list p)) (size_list q));
         in
           rev a
         end);

fun pseudo_mod (A1_, A2_, A3_) f g =
  poly_of_list
    ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
       semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
       comm_semiring_1_cancel_comm_ring_1)
       A2_,
      A1_)
    (pseudo_mod_list (A1_, A2_)
      (coeffs
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_comm_ring_1)
          A2_)
        f)
      (coeffs
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_comm_ring_1)
          A2_)
        g));

fun is_zero A_ p = null (coeffs A_ p);

fun gcd_poly_code_aux (A1_, A2_) p q =
  (if is_zero
        ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
           semiring_Gcd_factorial_semiring_gcd o
           factorial_semiring_gcd_factorial_ring_gcd)
          A1_)
        q
    then normalize_poly
           (A2_, idom_divide_factorial_ring_gcd A1_,
             (semidom_divide_unit_factor_normalization_semidom o
               normalization_semidom_semiring_gcd o semiring_gcd_ring_gcd o
               ring_gcd_factorial_ring_gcd)
               A1_)
           p
    else gcd_poly_code_aux (A1_, A2_) q
           (primitive_part
             ((semiring_gcd_ring_gcd o ring_gcd_factorial_ring_gcd) A1_, A2_)
             (pseudo_mod
               (A2_, (comm_ring_1_idom o idom_idom_divide o
                       idom_divide_factorial_ring_gcd)
                       A1_,
                 (semiring_1_no_zero_divisors_semidom o semidom_idom o
                   idom_idom_divide o idom_divide_factorial_ring_gcd)
                   A1_)
               p q)));

fun smult (A1_, A2_, A3_) a p =
  Poly (if eq A1_ a
             (zerob
               ((zero_mult_zero o mult_zero_semiring_0 o
                  semiring_0_comm_semiring_0)
                 A2_))
         then []
         else map (times
                    ((times_mult_zero o mult_zero_semiring_0 o
                       semiring_0_comm_semiring_0)
                      A2_)
                    a)
                (coeffs
                  ((zero_mult_zero o mult_zero_semiring_0 o
                     semiring_0_comm_semiring_0)
                    A2_)
                  p));

fun gcd_poly_code (A1_, A2_) p q =
  (if is_zero
        ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
           semiring_Gcd_factorial_semiring_gcd o
           factorial_semiring_gcd_factorial_ring_gcd)
          A1_)
        p
    then normalize_poly
           (A2_, idom_divide_factorial_ring_gcd A1_,
             (semidom_divide_unit_factor_normalization_semidom o
               normalization_semidom_semiring_gcd o semiring_gcd_ring_gcd o
               ring_gcd_factorial_ring_gcd)
               A1_)
           q
    else (if is_zero
               ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
                  semiring_Gcd_factorial_semiring_gcd o
                  factorial_semiring_gcd_factorial_ring_gcd)
                 A1_)
               q
           then normalize_poly
                  (A2_, idom_divide_factorial_ring_gcd A1_,
                    (semidom_divide_unit_factor_normalization_semidom o
                      normalization_semidom_semiring_gcd o
                      semiring_gcd_ring_gcd o ring_gcd_factorial_ring_gcd)
                      A1_)
                  p
           else let
                  val c1 =
                    content
                      ((semiring_gcd_ring_gcd o ring_gcd_factorial_ring_gcd)
                        A1_)
                      p;
                  val c2 =
                    content
                      ((semiring_gcd_ring_gcd o ring_gcd_factorial_ring_gcd)
                        A1_)
                      q;
                  val pa =
                    map_poly
                      ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
                         semiring_Gcd_factorial_semiring_gcd o
                         factorial_semiring_gcd_factorial_ring_gcd)
                        A1_)
                      ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
                         semiring_Gcd_factorial_semiring_gcd o
                         factorial_semiring_gcd_factorial_ring_gcd)
                         A1_,
                        A2_)
                      (fn x =>
                        divide
                          ((divide_semidom_divide o semidom_divide_idom_divide o
                             idom_divide_factorial_ring_gcd)
                            A1_)
                          x c1)
                      p;
                  val qa =
                    map_poly
                      ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
                         semiring_Gcd_factorial_semiring_gcd o
                         factorial_semiring_gcd_factorial_ring_gcd)
                        A1_)
                      ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
                         semiring_Gcd_factorial_semiring_gcd o
                         factorial_semiring_gcd_factorial_ring_gcd)
                         A1_,
                        A2_)
                      (fn x =>
                        divide
                          ((divide_semidom_divide o semidom_divide_idom_divide o
                             idom_divide_factorial_ring_gcd)
                            A1_)
                          x c2)
                      q;
                in
                  smult (A2_, (comm_semiring_0_comm_semiring_1 o
                                comm_semiring_1_comm_semiring_1_cancel o
                                comm_semiring_1_cancel_semidom o semidom_idom o
                                idom_idom_divide o
                                idom_divide_factorial_ring_gcd)
                                A1_,
                          (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
                            semiring_1_no_zero_divisors_semidom o semidom_idom o
                            idom_idom_divide o idom_divide_factorial_ring_gcd)
                            A1_)
                    (gcda ((gcd_Gcd o gcd_semiring_Gcd o
                             semiring_Gcd_factorial_semiring_gcd o
                             factorial_semiring_gcd_factorial_ring_gcd)
                            A1_)
                      c1 c2)
                    (gcd_poly_code_aux (A1_, A2_) pa qa)
                end));

fun gcd_polyc (A1_, A2_) p q = gcd_poly_code (A1_, A2_) p q;

fun coprime (A1_, A2_) =
  (fn x => fn y =>
    eq A2_ (gcda ((gcd_comm_monoid_gcd o comm_monoid_gcd_semiring_gcd) A1_) x y)
      (onea ((one_gcd o gcd_comm_monoid_gcd o comm_monoid_gcd_semiring_gcd)
              A1_)));

datatype 'a arith_ops_record =
  Arith_Ops_Record of
    'a * 'a * ('a -> 'a -> 'a) * ('a -> 'a -> 'a) * ('a -> 'a -> 'a) *
      ('a -> 'a) * ('a -> 'a -> 'a) * ('a -> 'a) * ('a -> 'a -> 'a) *
      ('a -> 'a) * ('a -> 'a) * (int -> 'a) * ('a -> int) * ('a -> bool);

fun mult_p_integer p x y = modulo_integer (IntInf.* (x, y)) p;

fun power_p_integer p x n =
  (if IntInf.<= (n, (0 : IntInf.int)) then (1 : IntInf.int)
    else let
           val reca =
             power_p_integer p (mult_p_integer p x x)
               (Bits_Integer.shiftr n (1 : IntInf.int));
         in
           (if (((IntInf.andb (n,
                   (1 : IntInf.int))) : IntInf.int) = (0 : IntInf.int))
             then reca else mult_p_integer p reca x)
         end);

fun inverse_p_integer p x =
  (if ((x : IntInf.int) = (0 : IntInf.int)) then (0 : IntInf.int)
    else power_p_integer p x (IntInf.- (p, (2 : IntInf.int))));

fun uminus_p_integer p x =
  (if ((x : IntInf.int) = (0 : IntInf.int)) then (0 : IntInf.int)
    else IntInf.- (p, x));

fun divide_p_integer p x y = mult_p_integer p x (inverse_p_integer p y);

fun minus_p_integer p x y =
  (if IntInf.<= (y, x) then IntInf.- (x, y) else IntInf.- (IntInf.+ (x, p), y));

fun plus_p_integer p x y = let
                             val z = IntInf.+ (x, y);
                           in
                             (if IntInf.<= (p, z) then IntInf.- (z, p) else z)
                           end;

fun finite_field_ops_integer p =
  Arith_Ops_Record
    ((0 : IntInf.int), (1 : IntInf.int), plus_p_integer p, mult_p_integer p,
      minus_p_integer p, uminus_p_integer p, divide_p_integer p,
      inverse_p_integer p,
      (fn x => fn y =>
        (if ((y : IntInf.int) = (0 : IntInf.int)) then x
          else (0 : IntInf.int))),
      (fn x =>
        (if ((x : IntInf.int) = (0 : IntInf.int)) then (0 : IntInf.int)
          else (1 : IntInf.int))),
      (fn x => x), integer_of_int, Int_of_integer,
      (fn x => IntInf.<= ((0 : IntInf.int), x) andalso IntInf.< (x, p)));

fun modulo_uint64 x y =
  (if ((y : Uint64.uint64) = Uint64.zero) then x else Uint64.modulus x y);

fun mult_p64 p x y = modulo_uint64 (Uint64.times x y) p;

fun power_p64 p x n =
  (if ((n : Uint64.uint64) = Uint64.zero) then Uint64.one
    else let
           val reca =
             power_p64 p (mult_p64 p x x) (Uint64.shiftr n (1 : IntInf.int));
         in
           (if (((Uint64.andb n Uint64.one) : Uint64.uint64) = Uint64.zero)
             then reca else mult_p64 p reca x)
         end);

fun inverse_p64 p x =
  (if ((x : Uint64.uint64) = Uint64.zero) then Uint64.zero
    else power_p64 p x (Uint64.minus p (Uint64.fromInt (2 : IntInf.int))));

fun uminus_p64 p x =
  (if ((x : Uint64.uint64) = Uint64.zero) then Uint64.zero
    else Uint64.minus p x);

fun divide_p64 p x y = mult_p64 p x (inverse_p64 p y);

fun minus_p64 p x y =
  (if Uint64.less_eq y x then Uint64.minus x y
    else Uint64.minus (Uint64.plus x p) y);

fun plus_p64 p x y = let
                       val z = Uint64.plus x y;
                     in
                       (if Uint64.less_eq p z then Uint64.minus z p else z)
                     end;

fun uint64_of_int i = Uint64.fromInt (integer_of_int i);

fun int_of_uint64 x = Int_of_integer (Uint64.toInt x);

fun finite_field_ops64 p =
  Arith_Ops_Record
    (Uint64.zero, Uint64.one, plus_p64 p, mult_p64 p, minus_p64 p, uminus_p64 p,
      divide_p64 p, inverse_p64 p,
      (fn x => fn y =>
        (if ((y : Uint64.uint64) = Uint64.zero) then x else Uint64.zero)),
      (fn x =>
        (if ((x : Uint64.uint64) = Uint64.zero) then Uint64.zero
          else Uint64.one)),
      (fn x => x), uint64_of_int, int_of_uint64,
      (fn x => Uint64.less_eq Uint64.zero x andalso Uint64.less x p));

fun modulo_uint32 x y =
  (if ((y : Word32.word) = (Word32.fromInt 0)) then x else Word32.mod (x, y));

fun mult_p32 p x y = modulo_uint32 (Word32.* (x, y)) p;

fun power_p32 p x n =
  (if ((n : Word32.word) = (Word32.fromInt 0)) then (Word32.fromInt 1)
    else let
           val reca =
             power_p32 p (mult_p32 p x x) (Uint32.shiftr n (1 : IntInf.int));
         in
           (if (((Word32.andb (n,
                   (Word32.fromInt 1))) : Word32.word) = (Word32.fromInt 0))
             then reca else mult_p32 p reca x)
         end);

fun inverse_p32 p x =
  (if ((x : Word32.word) = (Word32.fromInt 0)) then (Word32.fromInt 0)
    else power_p32 p x
           (Word32.- (p, Word32.fromLargeInt (IntInf.toLarge (2 : IntInf.int)))));

fun uminus_p32 p x =
  (if ((x : Word32.word) = (Word32.fromInt 0)) then (Word32.fromInt 0)
    else Word32.- (p, x));

fun divide_p32 p x y = mult_p32 p x (inverse_p32 p y);

fun minus_p32 p x y =
  (if Word32.<= (y, x) then Word32.- (x, y) else Word32.- (Word32.+ (x, p), y));

fun plus_p32 p x y = let
                       val z = Word32.+ (x, y);
                     in
                       (if Word32.<= (p, z) then Word32.- (z, p) else z)
                     end;

fun uint32_of_int i = Word32.fromLargeInt (IntInf.toLarge (integer_of_int i));

fun int_of_uint32 x =
  Int_of_integer (IntInf.fromLarge (Word32.toLargeInt x) : IntInf.int);

fun finite_field_ops32 p =
  Arith_Ops_Record
    ((Word32.fromInt 0), (Word32.fromInt 1), plus_p32 p, mult_p32 p,
      minus_p32 p, uminus_p32 p, divide_p32 p, inverse_p32 p,
      (fn x => fn y =>
        (if ((y : Word32.word) = (Word32.fromInt 0)) then x
          else (Word32.fromInt 0))),
      (fn x =>
        (if ((x : Word32.word) = (Word32.fromInt 0)) then (Word32.fromInt 0)
          else (Word32.fromInt 1))),
      (fn x => x), uint32_of_int, int_of_uint32,
      (fn x => Word32.<= ((Word32.fromInt 0), x) andalso Word32.< (x, p)));

fun oneb
  (Arith_Ops_Record
    (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14))
  = x2;

fun normalizec
  (Arith_Ops_Record
    (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14))
  = x10;

fun moduloa
  (Arith_Ops_Record
    (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14))
  = x9;

fun zeroc
  (Arith_Ops_Record
    (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14))
  = x1;

fun gcd_eucl_i A_ ops a b =
  (if eq A_ b (zeroc ops) then normalizec ops a
    else gcd_eucl_i A_ ops b (moduloa ops a b));

fun uminusa
  (Arith_Ops_Record
    (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14))
  = x6;

fun of_intb
  (Arith_Ops_Record
    (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14))
  = x12;

fun unit_factora
  (Arith_Ops_Record
    (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14))
  = x11;

fun lead_coeff_i ops pp = (case pp of [] => zeroc ops | _ :: _ => last pp);

fun cCons_i A_ ops x xs =
  (if null xs andalso eq A_ x (zeroc ops) then [] else x :: xs);

fun unit_factor_poly_i A_ ops xs =
  cCons_i A_ ops (unit_factora ops (lead_coeff_i ops xs)) [];

fun inversea
  (Arith_Ops_Record
    (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14))
  = x8;

fun timesa
  (Arith_Ops_Record
    (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14))
  = x4;

fun smult_i A_ ops a pp =
  (if eq A_ a (zeroc ops) then []
    else strip_while (eq A_ (zeroc ops)) (map (timesa ops a) pp));

fun normalize_poly_i A_ ops xs =
  smult_i A_ ops (inversea ops (unit_factora ops (lead_coeff_i ops xs))) xs;

fun minusa
  (Arith_Ops_Record
    (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14))
  = x5;

fun minus_poly_rev_list_i ops (x :: xs) (y :: ys) =
  minusa ops x y :: minus_poly_rev_list_i ops xs ys
  | minus_poly_rev_list_i ops xs [] = xs
  | minus_poly_rev_list_i ops [] (y :: ys) = [];

fun mod_poly_one_main_i A_ ops r d n =
  (if equal_nata n zero_nata then r
    else let
           val a = hda r;
           val rr =
             tla (if eq A_ a (zeroc ops) then r
                   else minus_poly_rev_list_i ops r (map (timesa ops a) d));
         in
           mod_poly_one_main_i A_ ops rr d (minus_nata n one_nata)
         end);

fun poly_of_list_i A_ ops = strip_while (eq A_ (zeroc ops));

fun mod_field_poly_i A_ ops cf cg =
  (if null cg then cf
    else let
           val ilc = inversea ops (last cg);
           val ch = map (timesa ops ilc) cg;
           val r =
             mod_poly_one_main_i A_ ops (rev cf) (rev ch)
               (minus_nata (plus_nata one_nata (size_list cf)) (size_list cg));
         in
           poly_of_list_i A_ ops (rev r)
         end);

fun divmod_poly_one_main_i A_ ops q r d n =
  (if equal_nata n zero_nata then (q, r)
    else let
           val a = hda r;
           val qqq = cCons_i A_ ops a q;
           val rr =
             tla (if eq A_ a (zeroc ops) then r
                   else minus_poly_rev_list_i ops r (map (timesa ops a) d));
         in
           divmod_poly_one_main_i A_ ops qqq rr d (minus_nata n one_nata)
         end);

fun div_field_poly_i A_ ops cf cg =
  (if null cg then []
    else let
           val ilc = inversea ops (last cg);
           val ch = map (timesa ops ilc) cg;
           val q =
             fst (divmod_poly_one_main_i A_ ops [] (rev cf) (rev ch)
                   (minus_nata (plus_nata one_nata (size_list cf))
                     (size_list cg)));
         in
           poly_of_list_i A_ ops (map (timesa ops ilc) q)
         end);

val karatsuba_lower_bound : nat = nat_of_integer (7 : IntInf.int);

fun coeffs_minus_i ops (x :: xs) (y :: ys) =
  minusa ops x y :: coeffs_minus_i ops xs ys
  | coeffs_minus_i ops xs [] = xs
  | coeffs_minus_i ops [] (v :: va) = map (uminusa ops) (v :: va);

fun replicate n x =
  (if equal_nata n zero_nata then []
    else x :: replicate (minus_nata n one_nata) x);

fun monom_mult_i ops n xs =
  (if null xs then xs else replicate n (zeroc ops) @ xs);

fun minus_poly_i A_ ops (x :: xs) (y :: ys) =
  cCons_i A_ ops (minusa ops x y) (minus_poly_i A_ ops xs ys)
  | minus_poly_i A_ ops xs [] = xs
  | minus_poly_i A_ ops [] (v :: va) = map (uminusa ops) (v :: va);

fun plusa
  (Arith_Ops_Record
    (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14))
  = x3;

fun plus_poly_i A_ ops (x :: xs) (y :: ys) =
  cCons_i A_ ops (plusa ops x y) (plus_poly_i A_ ops xs ys)
  | plus_poly_i A_ ops xs [] = xs
  | plus_poly_i A_ ops [] (v :: va) = v :: va;

fun split_at n (x :: xs) =
  (if equal_nata n zero_nata then ([], x :: xs)
    else let
           val (bef, a) = split_at (minus_nata n one_nata) xs;
         in
           (x :: bef, a)
         end)
  | split_at n [] = ([], []);

fun karatsuba_main_i A_ ops f n g m =
  (if less_eq_nat n karatsuba_lower_bound orelse
        less_eq_nat m karatsuba_lower_bound
    then let
           val ff = poly_of_list_i A_ ops f;
         in
           foldr (fn a => fn p =>
                   plus_poly_i A_ ops (smult_i A_ ops a ff)
                     (cCons_i A_ ops (zeroc ops) p))
             g []
         end
    else let
           val n2 = divide_nata n (nat_of_integer (2 : IntInf.int));
         in
           (if less_nat n2 m
             then let
                    val (f0, f1) = split_at n2 f;
                    val (g0, g1) = split_at n2 g;
                    val p1 =
                      karatsuba_main_i A_ ops f1 (minus_nata n n2) g1
                        (minus_nata m n2);
                    val p2 =
                      karatsuba_main_i A_ ops (coeffs_minus_i ops f1 f0) n2
                        (coeffs_minus_i ops g1 g0) n2;
                    val p3 = karatsuba_main_i A_ ops f0 n2 g0 n2;
                  in
                    plus_poly_i A_ ops (monom_mult_i ops (plus_nata n2 n2) p1)
                      (plus_poly_i A_ ops
                        (monom_mult_i ops n2
                          (plus_poly_i A_ ops (minus_poly_i A_ ops p1 p2) p3))
                        p3)
                  end
             else let
                    val (f0, f1) = split_at n2 f;
                    val p1 = karatsuba_main_i A_ ops f1 (minus_nata n n2) g m;
                    val a = karatsuba_main_i A_ ops f0 n2 g m;
                  in
                    plus_poly_i A_ ops (monom_mult_i ops n2 p1) a
                  end)
         end);

fun times_poly_i A_ ops f g =
  let
    val n = size_list f;
    val m = size_list g;
  in
    (if less_eq_nat n karatsuba_lower_bound orelse
          less_eq_nat m karatsuba_lower_bound
      then (if less_eq_nat n m
             then foldr (fn a => fn p =>
                          plus_poly_i A_ ops (smult_i A_ ops a g)
                            (cCons_i A_ ops (zeroc ops) p))
                    f []
             else foldr (fn a => fn p =>
                          plus_poly_i A_ ops (smult_i A_ ops a f)
                            (cCons_i A_ ops (zeroc ops) p))
                    g [])
      else (if less_eq_nat n m then karatsuba_main_i A_ ops g m f n
             else karatsuba_main_i A_ ops f n g m))
  end;

fun dp
  (Arith_Ops_Record
    (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14))
  = x14;

fun no_leading p xs = (if not (null xs) then not (p (hda xs)) else true);

fun is_poly A_ ops xs =
  list_all (dp ops) xs andalso no_leading (eq A_ (zeroc ops)) (rev xs);

fun poly_ops A_ ops =
  Arith_Ops_Record
    ([], [oneb ops], plus_poly_i A_ ops, times_poly_i A_ ops,
      minus_poly_i A_ ops, map (uminusa ops), div_field_poly_i A_ ops,
      (fn _ => []), mod_field_poly_i A_ ops, normalize_poly_i A_ ops,
      unit_factor_poly_i A_ ops,
      (fn i => (if equal_inta i zero_inta then [] else [of_intb ops i])),
      (fn _ => zero_inta), is_poly A_ ops);

fun gcd_poly_i A_ ops = gcd_eucl_i (equal_list A_) (poly_ops A_ ops);

fun pderiv_main_i A_ ops f (x :: xs) =
  cCons_i A_ ops (timesa ops f x)
    (pderiv_main_i A_ ops (plusa ops f (oneb ops)) xs)
  | pderiv_main_i A_ ops f [] = [];

fun pderiv_i A_ ops xs = pderiv_main_i A_ ops (oneb ops) (tla xs);

fun square_free_i A_ ops xs =
  equal_lista A_ (gcd_poly_i A_ ops xs (pderiv_i A_ ops xs)) [oneb ops];

fun of_int_poly_i ops f = map (of_intb ops) (coeffs zero_int f);

fun m m x = modulo_inta x m;

fun mp ma = map_poly zero_int (zero_int, equal_int) (m ma);

fun square_free_impl_main A_ p ff_ops f =
  square_free_i A_ ff_ops (of_int_poly_i ff_ops (mp p f));

val equal_integer = {equal = (fn a => fn b => ((a : IntInf.int) = b))} :
  IntInf.int equal;

val equal_uint64 = {equal = (fn a => fn b => ((a : Uint64.uint64) = b))} :
  Uint64.uint64 equal;

val equal_uint32 = {equal = (fn a => fn b => ((a : Word32.word) = b))} :
  Word32.word equal;

fun square_free_impl p =
  (if less_eq_int p (Int_of_integer (65535 : IntInf.int))
    then square_free_impl_main equal_uint32 p
           (finite_field_ops32 (uint32_of_int p))
    else (if less_eq_int p (Int_of_integer (4294967295 : IntInf.int))
           then square_free_impl_main equal_uint64 p
                  (finite_field_ops64 (uint64_of_int p))
           else square_free_impl_main equal_integer p
                  (finite_field_ops_integer (integer_of_int p))));

fun find uu [] = NONE
  | find p (x :: xs) = (if p x then SOME x else find p xs);

fun square_free_heuristic f =
  let
    val lc = coeff zero_int f (degreea zero_int f);
  in
    find (fn p =>
           coprime (semiring_gcd_int, equal_int) lc p andalso
             square_free_impl p f)
      [Int_of_integer (2 : IntInf.int), Int_of_integer (3 : IntInf.int),
        Int_of_integer (5 : IntInf.int), Int_of_integer (7 : IntInf.int),
        Int_of_integer (11 : IntInf.int), Int_of_integer (13 : IntInf.int),
        Int_of_integer (17 : IntInf.int), Int_of_integer (19 : IntInf.int),
        Int_of_integer (23 : IntInf.int)]
  end;

fun square_free_factorization_int_main f =
  (case square_free_heuristic f
    of NONE =>
      yun_monic_factorization (factorial_ring_gcd_int, equal_int)
        (gcd_polyc (factorial_ring_gcd_int, equal_int)) f
    | SOME _ => [(f, zero_nata)]);

fun square_free_factorization_inta f =
  (if equal_nata (degreea zero_int f) zero_nata
    then (coeff zero_int f (degreea zero_int f), [])
    else let
           val c = content semiring_gcd_int f;
           val d =
             times_inta (sgn_inta (coeff zero_int f (degreea zero_int f))) c;
           val g = sdiv_poly (equal_int, idom_divide_int) f d;
         in
           (d, square_free_factorization_int_main g)
         end);

fun takeWhile p [] = []
  | takeWhile p (x :: xs) = (if p x then x :: takeWhile p xs else []);

fun x_split (A1_, A2_) f =
  let
    val fs = coeffs ((zero_mult_zero o mult_zero_semiring_0) A2_) f;
    val zs =
      takeWhile (eq A1_ (zerob ((zero_mult_zero o mult_zero_semiring_0) A2_)))
        fs;
  in
    (case zs of [] => (zero_nata, f)
      | _ :: _ =>
        (size_list zs,
          poly_of_list (comm_monoid_add_semiring_0 A2_, A1_)
            (dropWhile
              (eq A1_ (zerob ((zero_mult_zero o mult_zero_semiring_0) A2_)))
              fs)))
  end;

fun monom (A1_, A2_) a n =
  Poly (if eq A2_ a (zerob A1_) then [] else replicate n (zerob A1_) @ [a]);

fun square_free_factorization_int f =
  let
    val (n, g) = x_split (equal_int, semiring_0_int) f;
    val (d, fs) = square_free_factorization_inta g;
  in
    (if equal_nata n zero_nata then (d, fs)
      else (d, (monom (zero_int, equal_int) one_inta one_nata,
                 minus_nata n one_nata) ::
                 fs))
  end;

fun power_poly_f_mod_i A_ ff_ops modulus a n =
  (if equal_nata n zero_nata then modulus [oneb ff_ops]
    else let
           val (d, r) = divmod_nat n (nat_of_integer (2 : IntInf.int));
           val reca =
             power_poly_f_mod_i A_ ff_ops modulus
               (modulus (times_poly_i A_ ff_ops a a)) d;
         in
           (if equal_nata r zero_nata then reca
             else modulus (times_poly_i A_ ff_ops reca a))
         end);

fun degree_i pp = minus_nata (size_list pp) one_nata;

fun dist_degree_factorize_main_i A_ p ff_ops ze on dv v w d res =
  (if equal_lista A_ v [on] then res
    else (if less_nat dv (plus_nata d d) then (dv, v) :: res
           else let
                  val wa =
                    power_poly_f_mod_i A_ ff_ops
                      (fn f => mod_field_poly_i A_ ff_ops f v) w (nat p);
                  val da = suc d;
                  val gd =
                    gcd_poly_i A_ ff_ops (minus_poly_i A_ ff_ops wa [ze, on]) v;
                in
                  (if equal_lista A_ gd [on]
                    then dist_degree_factorize_main_i A_ p ff_ops ze on dv v wa
                           da res
                    else let
                           val va = div_field_poly_i A_ ff_ops v gd;
                         in
                           dist_degree_factorize_main_i A_ p ff_ops ze on
                             (degree_i va) va (mod_field_poly_i A_ ff_ops wa va)
                             da ((da, gd) :: res)
                         end)
                end));

fun distinct_degree_factorization_i A_ p ff_ops f =
  let
    val ze = zeroc ff_ops;
    val on = oneb ff_ops;
  in
    (if equal_nata (degree_i f) one_nata then [(one_nata, f)]
      else dist_degree_factorize_main_i A_ p ff_ops ze on (degree_i f) f
             [ze, on] zero_nata [])
  end;

fun int_of_nat n = Int_of_integer (integer_of_nat n);

fun partition p [] = ([], [])
  | partition p (x :: xs) = let
                              val (yes, no) = partition p xs;
                            in
                              (if p x then (x :: yes, no) else (yes, x :: no))
                            end;

fun maps f [] = []
  | maps f (x :: xs) = f x @ maps f xs;

fun berlekamp_factorization_main_i A_ p ff_ops ze on d divs (v :: vs) n =
  (if equal_lista A_ v [on]
    then berlekamp_factorization_main_i A_ p ff_ops ze on d divs vs n
    else (if equal_nata (size_list divs) n then divs
           else let
                  val of_int = of_intb ff_ops;
                  val facts =
                    filtera (fn w => not (equal_lista A_ w [on]))
                      (maps (fn u =>
                              map (fn s =>
                                    gcd_poly_i A_ ff_ops u
                                      (minus_poly_i A_ ff_ops v
(if equal_nata s zero_nata then [] else [of_int (int_of_nat s)])))
                                (upt zero_nata (nat p)))
                        divs);
                  val (lin, nonlin) =
                    partition (fn q => equal_nata (degree_i q) d) facts;
                in
                  lin @ berlekamp_factorization_main_i A_ p ff_ops ze on d
                          nonlin vs (minus_nata n (size_list lin))
                end))
  | berlekamp_factorization_main_i A_ p ff_ops ze on d divs [] n = divs;

fun power_polys_i A_ ff_ops mul_p u curr_p i =
  (if equal_nata i zero_nata then []
    else curr_p ::
           power_polys_i A_ ff_ops mul_p u
             (mod_field_poly_i A_ ff_ops (times_poly_i A_ ff_ops curr_p mul_p)
               u)
             (minus_nata i one_nata));

datatype 'a x_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option =
  Abs_x_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option of
    (nat * (nat * ('a Vector.vector) Vector.vector)) option;

fun rep_x_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option
  (Abs_x_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option x) =
  x;

datatype 'a mat_impl =
  Abs_mat_impl of (nat * (nat * ('a Vector.vector) Vector.vector));

fun rep_mat_impl (Abs_mat_impl x) = x;

fun sel21a xa =
  Abs_mat_impl
    (case rep_x_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option
            xa
      of NONE => rep_mat_impl (raise Fail "undefined") | SOME x2 => x2);

fun dis1a xa =
  (case rep_x_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option
          xa
    of NONE => true | SOME _ => false);

fun rep_isoma x = (if dis1a x then NONE else SOME (sel21a x));

fun mat_of_rows_list_impl_aux xb xc =
  Abs_x_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option
    (if list_all (fn r => equal_nata (size_list r) xb) xc
      then SOME (size_list xc, (xb, Vector.fromList (map Vector.fromList xc)))
      else NONE);

fun mat_of_rows_list_impl x1 x2 = rep_isoma (mat_of_rows_list_impl_aux x1 x2);

datatype 'a mat = Mat_impl of 'a mat_impl;

datatype 'a vec_impl = Abs_vec_impl of (nat * 'a Vector.vector);

fun rep_vec_impl (Abs_vec_impl x) = x;

fun sub asa n = Vector.sub (asa, integer_of_nat n);

fun vec_index_impl xa = let
                          val (_, a) = rep_vec_impl xa;
                        in
                          sub a
                        end;

datatype 'a vec = Vec_impl of 'a vec_impl;

fun vec_index (Vec_impl v) i = vec_index_impl v i;

fun of_fun f n = Vector.tabulate (integer_of_nat n, f o nat_of_integer);

fun mat_of_fun xc xd xe =
  Abs_mat_impl (xc, (xd, of_fun (fn i => of_fun (fn j => xe (i, j)) xd) xc));

fun mat nr nc f = Mat_impl (mat_of_fun nr nc f);

fun mat_of_rows n rs =
  mat (size_list rs) n (fn (i, a) => vec_index (nth rs i) a);

fun vec_of_fun xb xc = Abs_vec_impl (xb, of_fun xc xb);

fun vec n f = Vec_impl (vec_of_fun n f);

fun mat_of_rows_list nc vs =
  (case mat_of_rows_list_impl nc vs
    of NONE => mat_of_rows nc (map (fn v => vec nc (nth v)) vs)
    | SOME a => Mat_impl a);

fun berlekamp_mat_i A_ p ff_ops u =
  let
    val n = degree_i u;
    val ze = zeroc ff_ops;
    val on = oneb ff_ops;
    val mul_p =
      power_poly_f_mod_i A_ ff_ops (fn v => mod_field_poly_i A_ ff_ops v u)
        [ze, on] (nat p);
    val xks = power_polys_i A_ ff_ops mul_p u [on] n;
  in
    mat_of_rows_list n
      (map (fn cs => cs @ replicate (minus_nata n (size_list cs)) ze) xks)
  end;

fun tabulatea f n = Vector.tabulate (n, f);

fun suba a i = Vector.sub (a, i);

fun eliminate_entries_i2 A_ xc xe xg xh xi xj =
  Abs_mat_impl
    (let
       val (nr, a) = rep_mat_impl xi;
       val (nc, aa) = a;
     in
       (fn i =>
         (nr, (nc, let
                     val ai = suba aa i;
                   in
                     tabulatea
                       (fn ia =>
                         let
                           val aia = suba aa ia;
                         in
                           (if ((ia : IntInf.int) = i) then aia
                             else let
                                    val vi_j = xh ia;
                                  in
                                    (if eq A_ vi_j xc then aia
                                      else tabulatea
     (fn j => xe (suba aia j) (xg vi_j (suba ai j))) (integer_of_nat nc))
                                  end)
                         end)
                       (integer_of_nat nr)
                   end)))
     end
      xj);

fun dim_row_impl xa = fst (rep_mat_impl xa);

fun eliminate_entries_gen_zero A_ mm tt z v (Mat_impl m) i j =
  (if less_nat i (dim_row_impl m)
    then Mat_impl (eliminate_entries_i2 A_ z mm tt v m (integer_of_nat i))
    else (raise Fail "index out of range in eliminate_entries")
           (fn _ => eliminate_entries_gen_zero A_ mm tt z v (Mat_impl m) i j));

fun eliminate_entries_i A_ ops =
  eliminate_entries_gen_zero A_ (minusa ops) (timesa ops) (zeroc ops);

fun list_update [] i y = []
  | list_update (x :: xs) i y =
    (if equal_nata i zero_nata then y :: xs
      else x :: list_update xs (minus_nata i one_nata) y);

fun length asa = nat_of_integer (Vector.length asa);

fun list_of asa = map (sub asa) (upt zero_nata (length asa));

fun mat_swaprows_impl xc xd xe =
  Abs_mat_impl
    let
      val (nr, a) = rep_mat_impl xe;
      val (nc, aa) = a;
    in
      (if less_nat xc nr andalso less_nat xd nr
        then let
               val ai = sub aa xc;
               val aj = sub aa xd;
               val arows = list_of aa;
               val ab =
                 Vector.fromList (list_update (list_update arows xc aj) xd ai);
             in
               (nr, (nc, ab))
             end
        else (nr, (nc, aa)))
    end;

fun mat_swaprows k l (Mat_impl a) =
  let
    val nr = dim_row_impl a;
  in
    (if less_nat l nr andalso less_nat k nr
      then Mat_impl (mat_swaprows_impl k l a)
      else (raise Fail "index out of bounds in mat_swaprows")
             (fn _ => mat_swaprows k l (Mat_impl a)))
  end;

fun mat_multrow_gen_impl xc xd xe xf =
  Abs_mat_impl let
                 val (nr, a) = rep_mat_impl xf;
                 val (nc, aa) = a;
                 val ak = sub aa xd;
                 val arows = list_of aa;
                 val aka = Vector.fromList (map (xc xe) (list_of ak));
                 val ab = Vector.fromList (list_update arows xd aka);
               in
                 (nr, (nc, ab))
               end;

fun mat_multrow_gen mul k aa (Mat_impl a) =
  Mat_impl (mat_multrow_gen_impl mul k aa a);

fun multrow_i ops = mat_multrow_gen (timesa ops);

fun index_mat_impl xa =
  let
    val (nr, (_, m)) = rep_mat_impl xa;
  in
    (fn (i, j) =>
      (if less_nat i nr then sub (sub m i) j
        else sub (Vector.fromList (nth [] (minus_nata i nr))) j))
  end;

fun index_mat (Mat_impl m) ij = index_mat_impl m ij;

fun gauss_jordan_main_i A_ ops nr nc a i j =
  (if less_nat i nr andalso less_nat j nc
    then let
           val aij = index_mat a (i, j);
         in
           (if eq A_ aij (zeroc ops)
             then (case maps (fn ia =>
                               (if not (eq A_ (index_mat a (ia, j)) (zeroc ops))
                                 then [ia] else []))
                          (upt (suc i) nr)
                    of [] => gauss_jordan_main_i A_ ops nr nc a i (suc j)
                    | ia :: _ =>
                      gauss_jordan_main_i A_ ops nr nc (mat_swaprows i ia a) i
                        j)
             else (if eq A_ aij (oneb ops)
                    then let
                           val v =
                             (fn ia => index_mat a (nat_of_integer ia, j));
                         in
                           gauss_jordan_main_i A_ ops nr nc
                             (eliminate_entries_i A_ ops v a i j) (suc i)
                             (suc j)
                         end
                    else let
                           val iaij = inversea ops aij;
                           val aa = multrow_i ops i iaij a;
                           val v =
                             (fn ia => index_mat aa (nat_of_integer ia, j));
                         in
                           gauss_jordan_main_i A_ ops nr nc
                             (eliminate_entries_i A_ ops v aa i j) (suc i)
                             (suc j)
                         end))
         end
    else a);

fun dim_row (Mat_impl m) = dim_row_impl m;

fun dim_col_impl xa = fst (snd (rep_mat_impl xa));

fun dim_col (Mat_impl m) = dim_col_impl m;

fun gauss_jordan_single_i A_ ops a =
  gauss_jordan_main_i A_ ops (dim_row a) (dim_col a) a zero_nata zero_nata;

fun transpose_mat a =
  mat (dim_col a) (dim_row a) (fn (i, j) => index_mat a (j, i));

fun berlekamp_resulting_mat_i A_ p ff_ops u =
  let
    val q = berlekamp_mat_i A_ p ff_ops u;
    val n = dim_row q;
    val qi =
      mat n n
        (fn (i, j) =>
          (if equal_nata i j
            then minusa ff_ops (index_mat q (i, j)) (oneb ff_ops)
            else index_mat q (i, j)));
  in
    gauss_jordan_single_i A_ ff_ops (transpose_mat qi)
  end;

fun pivot_positions_main_gen A_ zero a nr nc i j =
  (if less_nat i nr
    then (if less_nat j nc
           then (if eq A_ (index_mat a (i, j)) zero
                  then pivot_positions_main_gen A_ zero a nr nc i (suc j)
                  else (i, j) ::
                         pivot_positions_main_gen A_ zero a nr nc (suc i)
                           (suc j))
           else [])
    else []);

fun pivot_positions_gen A_ zer a =
  pivot_positions_main_gen A_ zer a (dim_row a) (dim_col a) zero_nata zero_nata;

fun swap p = (snd p, fst p);

fun map_of A_ ((l, v) :: ps) k = (if eq A_ l k then SOME v else map_of A_ ps k)
  | map_of A_ [] k = NONE;

fun non_pivot_base_gen uminus zero one a pivots =
  let
    val _ = dim_row a;
    val nc = dim_col a;
    val invers = map_of equal_nat (map swap pivots);
  in
    (fn qj =>
      vec nc
        (fn i =>
          (if equal_nata i qj then one
            else (case invers i of NONE => zero
                   | SOME j => uminus (index_mat a (j, qj))))))
  end;

fun membera A_ [] y = false
  | membera A_ (x :: xs) y = eq A_ x y orelse membera A_ xs y;

fun find_base_vectors_gen A_ uminus zero one a =
  let
    val pp = pivot_positions_gen A_ zero a;
    val b =
      filtera (fn j => not (membera equal_nat (map snd pp) j))
        (upt zero_nata (dim_col a));
  in
    map (non_pivot_base_gen uminus zero one a pp) b
  end;

fun find_base_vectors_i A_ ops a =
  find_base_vectors_gen A_ (uminusa ops) (zeroc ops) (oneb ops) a;

fun list_of_vec_impl xa = let
                            val (_, a) = rep_vec_impl xa;
                          in
                            list_of a
                          end;

fun list_of_vec (Vec_impl v) = list_of_vec_impl v;

fun berlekamp_basis_i A_ p ff_ops u =
  map (poly_of_list_i A_ ff_ops o list_of_vec)
    (find_base_vectors_i A_ ff_ops (berlekamp_resulting_mat_i A_ p ff_ops u));

fun berlekamp_monic_factorization_i A_ p ff_ops d f =
  let
    val vs = berlekamp_basis_i A_ p ff_ops f;
  in
    berlekamp_factorization_main_i A_ p ff_ops (zeroc ff_ops) (oneb ff_ops) d
      [f] vs (size_list vs)
  end;

fun finite_field_factorization_i A_ p ff_ops f =
  (if equal_nata (degree_i f) zero_nata then (lead_coeff_i ff_ops f, [])
    else let
           val a = lead_coeff_i ff_ops f;
           val u = smult_i A_ ff_ops (inversea ff_ops a) f;
           val gs =
             (if false then distinct_degree_factorization_i A_ p ff_ops u
               else [(one_nata, u)]);
           val (irr, hs) =
             partition (fn (i, fa) => equal_nata (degree_i fa) i) gs;
         in
           (a, map snd irr @
                 maps (fn (aa, b) =>
                        berlekamp_monic_factorization_i A_ p ff_ops aa b)
                   hs)
         end);

fun to_int
  (Arith_Ops_Record
    (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14))
  = x13;

fun to_int_poly_i ops f =
  poly_of_list (comm_monoid_add_int, equal_int) (map (to_int ops) f);

fun finite_field_factorization_main A_ p f_ops f =
  let
    val (c, fs) =
      finite_field_factorization_i A_ p f_ops (of_int_poly_i f_ops (mp p f));
  in
    (to_int f_ops c, map (to_int_poly_i f_ops) fs)
  end;

fun finite_field_factorization_int p =
  (if less_eq_int p (Int_of_integer (65535 : IntInf.int))
    then finite_field_factorization_main equal_uint32 p
           (finite_field_ops32 (uint32_of_int p))
    else (if less_eq_int p (Int_of_integer (4294967295 : IntInf.int))
           then finite_field_factorization_main equal_uint64 p
                  (finite_field_ops64 (uint64_of_int p))
           else finite_field_factorization_main equal_integer p
                  (finite_field_ops_integer (integer_of_int p))));

datatype ('a, 'b, 'c) subseqs_foldr_impl =
  Sublists_Foldr_Impl of
    ('b -> 'a list -> nat -> 'b list * 'c) * ('c -> 'b list * 'c);

fun subseqs_foldr (Sublists_Foldr_Impl (x1, x2)) = x1;

fun next_subseqs_foldr (Sublists_Foldr_Impl (x1, x2)) = x2;

fun coeffs_minus A_ (x :: xs) (y :: ys) =
  minus ((minus_group_add o group_add_ab_group_add) A_) x y ::
    coeffs_minus A_ xs ys
  | coeffs_minus A_ xs [] = xs
  | coeffs_minus A_ [] (v :: va) =
    map (uminus ((uminus_group_add o group_add_ab_group_add) A_)) (v :: va);

fun monom_mult A_ n f =
  Poly let
         val xs =
           coeffs
             ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
                semiring_1_comm_semiring_1)
               A_)
             f;
       in
         (if null xs then xs
           else replicate n
                  (zerob
                    ((zero_mult_zero o mult_zero_semiring_0 o
                       semiring_0_semiring_1 o semiring_1_comm_semiring_1)
                      A_)) @
                  xs)
       end;

fun karatsuba_main (A1_, A2_, A3_) f n g m =
  (if less_eq_nat n karatsuba_lower_bound orelse
        less_eq_nat m karatsuba_lower_bound
    then let
           val ff =
             poly_of_list
               ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
                  semiring_1_comm_semiring_1 o
                  comm_semiring_1_comm_semiring_1_cancel o
                  comm_semiring_1_cancel_comm_ring_1)
                  A2_,
                 A1_)
               f;
         in
           foldr (fn a => fn p =>
                   plus_polya
                     ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
                        semiring_1_comm_semiring_1 o
                        comm_semiring_1_comm_semiring_1_cancel o
                        comm_semiring_1_cancel_comm_ring_1)
                        A2_,
                       A1_)
                     (smult
                       (A1_, (comm_semiring_0_comm_semiring_1 o
                               comm_semiring_1_comm_semiring_1_cancel o
                               comm_semiring_1_cancel_comm_ring_1)
                               A2_,
                         A3_)
                       a ff)
                     (pCons
                       ((zero_mult_zero o mult_zero_semiring_0 o
                          semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                          comm_semiring_1_comm_semiring_1_cancel o
                          comm_semiring_1_cancel_comm_ring_1)
                          A2_,
                         A1_)
                       (zerob
                         ((zero_mult_zero o mult_zero_semiring_0 o
                            semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                            comm_semiring_1_comm_semiring_1_cancel o
                            comm_semiring_1_cancel_comm_ring_1)
                           A2_))
                       p))
             g (zero_polyb
                 ((zero_mult_zero o mult_zero_semiring_0 o
                    semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                    comm_semiring_1_comm_semiring_1_cancel o
                    comm_semiring_1_cancel_comm_ring_1)
                   A2_))
         end
    else let
           val n2 = divide_nata n (nat_of_integer (2 : IntInf.int));
         in
           (if less_nat n2 m
             then let
                    val (f0, f1) = split_at n2 f;
                    val (g0, g1) = split_at n2 g;
                    val p1 =
                      karatsuba_main (A1_, A2_, A3_) f1 (minus_nata n n2) g1
                        (minus_nata m n2);
                    val p2 =
                      karatsuba_main (A1_, A2_, A3_)
                        (coeffs_minus
                          ((ab_group_add_ring o ring_ring_1 o
                             ring_1_comm_ring_1)
                            A2_)
                          f1 f0)
                        n2 (coeffs_minus
                             ((ab_group_add_ring o ring_ring_1 o
                                ring_1_comm_ring_1)
                               A2_)
                             g1 g0)
                        n2;
                    val p3 = karatsuba_main (A1_, A2_, A3_) f0 n2 g0 n2;
                  in
                    plus_polya
                      ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
                         semiring_1_comm_semiring_1 o
                         comm_semiring_1_comm_semiring_1_cancel o
                         comm_semiring_1_cancel_comm_ring_1)
                         A2_,
                        A1_)
                      (monom_mult
                        ((comm_semiring_1_comm_semiring_1_cancel o
                           comm_semiring_1_cancel_comm_ring_1)
                          A2_)
                        (plus_nata n2 n2) p1)
                      (plus_polya
                        ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
                           semiring_1_comm_semiring_1 o
                           comm_semiring_1_comm_semiring_1_cancel o
                           comm_semiring_1_cancel_comm_ring_1)
                           A2_,
                          A1_)
                        (monom_mult
                          ((comm_semiring_1_comm_semiring_1_cancel o
                             comm_semiring_1_cancel_comm_ring_1)
                            A2_)
                          n2 (plus_polya
                               ((comm_monoid_add_semiring_0 o
                                  semiring_0_semiring_1 o
                                  semiring_1_comm_semiring_1 o
                                  comm_semiring_1_comm_semiring_1_cancel o
                                  comm_semiring_1_cancel_comm_ring_1)
                                  A2_,
                                 A1_)
                               (minus_polya
                                 ((ab_group_add_ring o ring_ring_1 o
                                    ring_1_comm_ring_1)
                                    A2_,
                                   A1_)
                                 p1 p2)
                               p3))
                        p3)
                  end
             else let
                    val (f0, f1) = split_at n2 f;
                    val p1 =
                      karatsuba_main (A1_, A2_, A3_) f1 (minus_nata n n2) g m;
                    val a = karatsuba_main (A1_, A2_, A3_) f0 n2 g m;
                  in
                    plus_polya
                      ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
                         semiring_1_comm_semiring_1 o
                         comm_semiring_1_comm_semiring_1_cancel o
                         comm_semiring_1_cancel_comm_ring_1)
                         A2_,
                        A1_)
                      (monom_mult
                        ((comm_semiring_1_comm_semiring_1_cancel o
                           comm_semiring_1_cancel_comm_ring_1)
                          A2_)
                        n2 p1)
                      a
                  end)
         end);

fun karatsuba_mult_poly (A1_, A2_, A3_) f g =
  let
    val ff =
      coeffs
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_comm_ring_1)
          A2_)
        f;
    val gg =
      coeffs
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_comm_ring_1)
          A2_)
        g;
    val n = size_list ff;
    val m = size_list gg;
  in
    (if less_eq_nat n karatsuba_lower_bound orelse
          less_eq_nat m karatsuba_lower_bound
      then (if less_eq_nat n m
             then foldr (fn a => fn p =>
                          plus_polya
                            ((comm_monoid_add_semiring_0 o
                               semiring_0_semiring_1 o
                               semiring_1_comm_semiring_1 o
                               comm_semiring_1_comm_semiring_1_cancel o
                               comm_semiring_1_cancel_comm_ring_1)
                               A2_,
                              A1_)
                            (smult
                              (A1_, (comm_semiring_0_comm_semiring_1 o
                                      comm_semiring_1_comm_semiring_1_cancel o
                                      comm_semiring_1_cancel_comm_ring_1)
                                      A2_,
                                A3_)
                              a g)
                            (pCons
                              ((zero_mult_zero o mult_zero_semiring_0 o
                                 semiring_0_semiring_1 o
                                 semiring_1_comm_semiring_1 o
                                 comm_semiring_1_comm_semiring_1_cancel o
                                 comm_semiring_1_cancel_comm_ring_1)
                                 A2_,
                                A1_)
                              (zerob
                                ((zero_mult_zero o mult_zero_semiring_0 o
                                   semiring_0_semiring_1 o
                                   semiring_1_comm_semiring_1 o
                                   comm_semiring_1_comm_semiring_1_cancel o
                                   comm_semiring_1_cancel_comm_ring_1)
                                  A2_))
                              p))
                    ff (zero_polyb
                         ((zero_mult_zero o mult_zero_semiring_0 o
                            semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                            comm_semiring_1_comm_semiring_1_cancel o
                            comm_semiring_1_cancel_comm_ring_1)
                           A2_))
             else foldr (fn a => fn p =>
                          plus_polya
                            ((comm_monoid_add_semiring_0 o
                               semiring_0_semiring_1 o
                               semiring_1_comm_semiring_1 o
                               comm_semiring_1_comm_semiring_1_cancel o
                               comm_semiring_1_cancel_comm_ring_1)
                               A2_,
                              A1_)
                            (smult
                              (A1_, (comm_semiring_0_comm_semiring_1 o
                                      comm_semiring_1_comm_semiring_1_cancel o
                                      comm_semiring_1_cancel_comm_ring_1)
                                      A2_,
                                A3_)
                              a f)
                            (pCons
                              ((zero_mult_zero o mult_zero_semiring_0 o
                                 semiring_0_semiring_1 o
                                 semiring_1_comm_semiring_1 o
                                 comm_semiring_1_comm_semiring_1_cancel o
                                 comm_semiring_1_cancel_comm_ring_1)
                                 A2_,
                                A1_)
                              (zerob
                                ((zero_mult_zero o mult_zero_semiring_0 o
                                   semiring_0_semiring_1 o
                                   semiring_1_comm_semiring_1 o
                                   comm_semiring_1_comm_semiring_1_cancel o
                                   comm_semiring_1_cancel_comm_ring_1)
                                  A2_))
                              p))
                    gg (zero_polyb
                         ((zero_mult_zero o mult_zero_semiring_0 o
                            semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                            comm_semiring_1_comm_semiring_1_cancel o
                            comm_semiring_1_cancel_comm_ring_1)
                           A2_)))
      else (if less_eq_nat n m then karatsuba_main (A1_, A2_, A3_) gg m ff n
             else karatsuba_main (A1_, A2_, A3_) ff n gg m))
  end;

fun prod_list_m m [] = one_polyb comm_semiring_1_int
  | prod_list_m m (f :: fs) =
    mp m (karatsuba_mult_poly
           (equal_int, comm_ring_1_int, semiring_no_zero_divisors_int) f
           (prod_list_m m fs));

fun inv_M2 m m2 = (fn x => (if less_eq_int x m2 then x else minus_inta x m));

fun divmod_int m n =
  map_prod Int_of_integer Int_of_integer
    (divmod_integer (integer_of_int m) (integer_of_int n));

fun div_mod_int_poly p q =
  (if equal_polya (zero_int, equal_int) q (zero_polyb zero_int) then NONE
    else let
           val n = degreea zero_int q;
           val _ = coeff zero_int q n;
         in
           fold_coeffs zero_int
             (fn a => fn b =>
               (case b of NONE => NONE
                 | SOME (s, r) =>
                   let
                     val ar = pCons (zero_int, equal_int) a r;
                     val (ba, m) =
                       divmod_int (coeff zero_int ar (degreea zero_int q))
                         (coeff zero_int q (degreea zero_int q));
                   in
                     (if equal_inta m zero_inta
                       then SOME (pCons (zero_int, equal_int) ba s,
                                   minus_polya (ab_group_add_int, equal_int) ar
                                     (smult
                                       (equal_int, comm_semiring_0_int,
 semiring_no_zero_divisors_int)
                                       ba q))
                       else NONE)
                   end))
             p (SOME (zero_polyb zero_int, zero_polyb zero_int))
         end);

fun div_int_poly p q =
  (case div_mod_int_poly p q of NONE => NONE
    | SOME (d, m) =>
      (if equal_polya (zero_int, equal_int) m (zero_polyb zero_int) then SOME d
        else NONE));

fun dvd_int_poly q p =
  (if equal_polya (zero_int, equal_int) q (zero_polyb zero_int)
    then equal_polya (zero_int, equal_int) p (zero_polyb zero_int)
    else not (is_none (div_int_poly p q)));

fun remove1 A_ x [] = []
  | remove1 A_ x (y :: xs) = (if eq A_ x y then xs else y :: remove1 A_ x xs);

fun reconstruction m sl_impl m2 state u luu lu d r vs res cands =
  (case cands
    of [] =>
      let
        val da = suc d;
      in
        (if less_nat r (plus_nata da da) then u :: res
          else let
                 val (candsa, statea) = next_subseqs_foldr sl_impl state;
               in
                 reconstruction m sl_impl m2 statea u luu lu da r vs res candsa
               end)
      end
    | (lv, ws) :: candsa =>
      let
        val lva = inv_M2 m m2 lv;
      in
        (if dvd (semidom_modulo_int, equal_int) lva
              (case coeffs zero_int luu of [] => zero_inta | x :: _ => x)
          then let
                 val vb =
                   map_poly zero_int (zero_int, equal_int) (inv_M2 m m2)
                     (mp m (smult
                             (equal_int, comm_semiring_0_int,
                               semiring_no_zero_divisors_int)
                             lu (prod_list_m m ws)));
               in
                 (if dvd_int_poly vb luu
                   then let
                          val pp_vb =
                            primitive_part (semiring_gcd_int, equal_int) vb;
                          val ua =
                            divide_polya (equal_int, idom_divide_int) u pp_vb;
                          val ra = minus_nata r (size_list ws);
                          val resa = pp_vb :: res;
                        in
                          (if less_nat ra (plus_nata d d) then ua :: resa
                            else let
                                   val lua =
                                     coeff zero_int ua (degreea zero_int ua);
                                   val vsa =
                                     fold (remove1
    (equal_poly (zero_int, equal_int)))
                                       ws vs;
                                   val (candsb, statea) =
                                     subseqs_foldr sl_impl (lua, []) vsa d;
                                 in
                                   reconstruction m sl_impl m2 statea ua
                                     (smult
                                       (equal_int, comm_semiring_0_int,
 semiring_no_zero_divisors_int)
                                       lua ua)
                                     lua d ra vsa resa candsb
                                 end)
                        end
                   else reconstruction m sl_impl m2 state u luu lu d r vs res
                          candsa)
               end
          else reconstruction m sl_impl m2 state u luu lu d r vs res candsa)
      end);

fun zassenhaus_reconstruction_generic sl_impl vs p n f =
  let
    val lf = coeff zero_int f (degreea zero_int f);
    val pn = binary_power monoid_mult_int p n;
    val (_, state) = subseqs_foldr sl_impl (lf, []) vs zero_nata;
  in
    reconstruction pn sl_impl (divide_inta pn (Int_of_integer (2 : IntInf.int)))
      state f
      (smult (equal_int, comm_semiring_0_int, semiring_no_zero_divisors_int) lf
        f)
      lf zero_nata (size_list vs) vs [] []
  end;

fun next_subseqs1 f head tail ret0 ret1 ((i, v) :: prevs) =
  next_subseqs2 f head tail (f head v :: ret0) ret1 prevs v (upt zero_nata i)
  | next_subseqs1 f head tail ret0 ret1 [] = (ret0, (head, (tail, ret1)))
and next_subseqs2 f head tail ret0 ret1 prevs v (j :: js) =
  let
    val va = f (sub tail j) v;
  in
    next_subseqs2 f head tail (va :: ret0) ((j, va) :: ret1) prevs v js
  end
  | next_subseqs2 f head tail ret0 ret1 prevs v [] =
    next_subseqs1 f head tail ret0 ret1 prevs;

fun next_subseqs f (head, (tail, prevs)) =
  next_subseqs1 f head tail [] [] prevs;

fun create_subseqs f base elements n =
  (if equal_nata n zero_nata
    then (if null elements
           then ([base], ((raise Fail "undefined"), (Vector.fromList [], [])))
           else let
                  val head = hda elements;
                  val tail = Vector.fromList (tla elements);
                in
                  ([base], (head, (tail, [(length tail, base)])))
                end)
    else next_subseqs f
           (snd (create_subseqs f base elements (minus_nata n one_nata))));

fun impl f = Sublists_Foldr_Impl (create_subseqs f, next_subseqs f);

fun mul_const m p c =
  modulo_inta
    (times_inta (case coeffs zero_int p of [] => zero_inta | x :: _ => x) c) m;

fun zassenhaus_reconstruction vs p n f =
  let
    val mul = mul_const (binary_power monoid_mult_int p n);
    val sl_impl = impl (fn x => map_prod (mul x) (fn a => x :: a));
  in
    zassenhaus_reconstruction_generic sl_impl vs p n f
  end;

fun find_exponent_main p pm m bnd =
  (if less_int bnd pm then m
    else find_exponent_main p (times_inta pm p) (suc m) bnd);

fun find_exponent p bnd = find_exponent_main p p one_nata bnd;

val primes_1000 : nat list =
  [nat_of_integer (2 : IntInf.int), nat_of_integer (3 : IntInf.int),
    nat_of_integer (5 : IntInf.int), nat_of_integer (7 : IntInf.int),
    nat_of_integer (11 : IntInf.int), nat_of_integer (13 : IntInf.int),
    nat_of_integer (17 : IntInf.int), nat_of_integer (19 : IntInf.int),
    nat_of_integer (23 : IntInf.int), nat_of_integer (29 : IntInf.int),
    nat_of_integer (31 : IntInf.int), nat_of_integer (37 : IntInf.int),
    nat_of_integer (41 : IntInf.int), nat_of_integer (43 : IntInf.int),
    nat_of_integer (47 : IntInf.int), nat_of_integer (53 : IntInf.int),
    nat_of_integer (59 : IntInf.int), nat_of_integer (61 : IntInf.int),
    nat_of_integer (67 : IntInf.int), nat_of_integer (71 : IntInf.int),
    nat_of_integer (73 : IntInf.int), nat_of_integer (79 : IntInf.int),
    nat_of_integer (83 : IntInf.int), nat_of_integer (89 : IntInf.int),
    nat_of_integer (97 : IntInf.int), nat_of_integer (101 : IntInf.int),
    nat_of_integer (103 : IntInf.int), nat_of_integer (107 : IntInf.int),
    nat_of_integer (109 : IntInf.int), nat_of_integer (113 : IntInf.int),
    nat_of_integer (127 : IntInf.int), nat_of_integer (131 : IntInf.int),
    nat_of_integer (137 : IntInf.int), nat_of_integer (139 : IntInf.int),
    nat_of_integer (149 : IntInf.int), nat_of_integer (151 : IntInf.int),
    nat_of_integer (157 : IntInf.int), nat_of_integer (163 : IntInf.int),
    nat_of_integer (167 : IntInf.int), nat_of_integer (173 : IntInf.int),
    nat_of_integer (179 : IntInf.int), nat_of_integer (181 : IntInf.int),
    nat_of_integer (191 : IntInf.int), nat_of_integer (193 : IntInf.int),
    nat_of_integer (197 : IntInf.int), nat_of_integer (199 : IntInf.int),
    nat_of_integer (211 : IntInf.int), nat_of_integer (223 : IntInf.int),
    nat_of_integer (227 : IntInf.int), nat_of_integer (229 : IntInf.int),
    nat_of_integer (233 : IntInf.int), nat_of_integer (239 : IntInf.int),
    nat_of_integer (241 : IntInf.int), nat_of_integer (251 : IntInf.int),
    nat_of_integer (257 : IntInf.int), nat_of_integer (263 : IntInf.int),
    nat_of_integer (269 : IntInf.int), nat_of_integer (271 : IntInf.int),
    nat_of_integer (277 : IntInf.int), nat_of_integer (281 : IntInf.int),
    nat_of_integer (283 : IntInf.int), nat_of_integer (293 : IntInf.int),
    nat_of_integer (307 : IntInf.int), nat_of_integer (311 : IntInf.int),
    nat_of_integer (313 : IntInf.int), nat_of_integer (317 : IntInf.int),
    nat_of_integer (331 : IntInf.int), nat_of_integer (337 : IntInf.int),
    nat_of_integer (347 : IntInf.int), nat_of_integer (349 : IntInf.int),
    nat_of_integer (353 : IntInf.int), nat_of_integer (359 : IntInf.int),
    nat_of_integer (367 : IntInf.int), nat_of_integer (373 : IntInf.int),
    nat_of_integer (379 : IntInf.int), nat_of_integer (383 : IntInf.int),
    nat_of_integer (389 : IntInf.int), nat_of_integer (397 : IntInf.int),
    nat_of_integer (401 : IntInf.int), nat_of_integer (409 : IntInf.int),
    nat_of_integer (419 : IntInf.int), nat_of_integer (421 : IntInf.int),
    nat_of_integer (431 : IntInf.int), nat_of_integer (433 : IntInf.int),
    nat_of_integer (439 : IntInf.int), nat_of_integer (443 : IntInf.int),
    nat_of_integer (449 : IntInf.int), nat_of_integer (457 : IntInf.int),
    nat_of_integer (461 : IntInf.int), nat_of_integer (463 : IntInf.int),
    nat_of_integer (467 : IntInf.int), nat_of_integer (479 : IntInf.int),
    nat_of_integer (487 : IntInf.int), nat_of_integer (491 : IntInf.int),
    nat_of_integer (499 : IntInf.int), nat_of_integer (503 : IntInf.int),
    nat_of_integer (509 : IntInf.int), nat_of_integer (521 : IntInf.int),
    nat_of_integer (523 : IntInf.int), nat_of_integer (541 : IntInf.int),
    nat_of_integer (547 : IntInf.int), nat_of_integer (557 : IntInf.int),
    nat_of_integer (563 : IntInf.int), nat_of_integer (569 : IntInf.int),
    nat_of_integer (571 : IntInf.int), nat_of_integer (577 : IntInf.int),
    nat_of_integer (587 : IntInf.int), nat_of_integer (593 : IntInf.int),
    nat_of_integer (599 : IntInf.int), nat_of_integer (601 : IntInf.int),
    nat_of_integer (607 : IntInf.int), nat_of_integer (613 : IntInf.int),
    nat_of_integer (617 : IntInf.int), nat_of_integer (619 : IntInf.int),
    nat_of_integer (631 : IntInf.int), nat_of_integer (641 : IntInf.int),
    nat_of_integer (643 : IntInf.int), nat_of_integer (647 : IntInf.int),
    nat_of_integer (653 : IntInf.int), nat_of_integer (659 : IntInf.int),
    nat_of_integer (661 : IntInf.int), nat_of_integer (673 : IntInf.int),
    nat_of_integer (677 : IntInf.int), nat_of_integer (683 : IntInf.int),
    nat_of_integer (691 : IntInf.int), nat_of_integer (701 : IntInf.int),
    nat_of_integer (709 : IntInf.int), nat_of_integer (719 : IntInf.int),
    nat_of_integer (727 : IntInf.int), nat_of_integer (733 : IntInf.int),
    nat_of_integer (739 : IntInf.int), nat_of_integer (743 : IntInf.int),
    nat_of_integer (751 : IntInf.int), nat_of_integer (757 : IntInf.int),
    nat_of_integer (761 : IntInf.int), nat_of_integer (769 : IntInf.int),
    nat_of_integer (773 : IntInf.int), nat_of_integer (787 : IntInf.int),
    nat_of_integer (797 : IntInf.int), nat_of_integer (809 : IntInf.int),
    nat_of_integer (811 : IntInf.int), nat_of_integer (821 : IntInf.int),
    nat_of_integer (823 : IntInf.int), nat_of_integer (827 : IntInf.int),
    nat_of_integer (829 : IntInf.int), nat_of_integer (839 : IntInf.int),
    nat_of_integer (853 : IntInf.int), nat_of_integer (857 : IntInf.int),
    nat_of_integer (859 : IntInf.int), nat_of_integer (863 : IntInf.int),
    nat_of_integer (877 : IntInf.int), nat_of_integer (881 : IntInf.int),
    nat_of_integer (883 : IntInf.int), nat_of_integer (887 : IntInf.int),
    nat_of_integer (907 : IntInf.int), nat_of_integer (911 : IntInf.int),
    nat_of_integer (919 : IntInf.int), nat_of_integer (929 : IntInf.int),
    nat_of_integer (937 : IntInf.int), nat_of_integer (941 : IntInf.int),
    nat_of_integer (947 : IntInf.int), nat_of_integer (953 : IntInf.int),
    nat_of_integer (967 : IntInf.int), nat_of_integer (971 : IntInf.int),
    nat_of_integer (977 : IntInf.int), nat_of_integer (983 : IntInf.int),
    nat_of_integer (991 : IntInf.int), nat_of_integer (997 : IntInf.int)];

fun next_candidates n =
  (if equal_nata n zero_nata
    then (nat_of_integer (1001 : IntInf.int), primes_1000)
    else (plus_nata n (nat_of_integer (30 : IntInf.int)),
           [n, plus_nata n (nat_of_integer (2 : IntInf.int)),
             plus_nata n (nat_of_integer (6 : IntInf.int)),
             plus_nata n (nat_of_integer (8 : IntInf.int)),
             plus_nata n (nat_of_integer (12 : IntInf.int)),
             plus_nata n (nat_of_integer (18 : IntInf.int)),
             plus_nata n (nat_of_integer (20 : IntInf.int)),
             plus_nata n (nat_of_integer (26 : IntInf.int))]));

fun all_interval_nat p i j =
  less_eq_nat j i orelse p i andalso all_interval_nat p (suc i) j;

fun prime_nat p =
  less_nat one_nata p andalso
    all_interval_nat (fn n => not (dvd (semidom_modulo_nat, equal_nat) n p))
      (suc one_nata) p;

fun next_primes n =
  (if equal_nata n zero_nata then next_candidates zero_nata
    else let
           val (m, ps) = next_candidates n;
         in
           (m, filtera prime_nat ps)
         end);

fun find_prime_main f np ps =
  (case ps of [] => let
                      val a = next_primes np;
                      val (aa, b) = a;
                    in
                      find_prime_main f aa b
                    end
    | p :: psa => (if f p then p else find_prime_main f np psa));

fun find_prime f = find_prime_main f zero_nata [];

fun suitable_prime_bz f =
  let
    val lc = coeff zero_int f (degreea zero_int f);
  in
    int_of_nat
      (find_prime
        (fn n =>
          let
            val p = int_of_nat n;
          in
            coprime (semiring_gcd_int, equal_int) lc p andalso
              square_free_impl p f
          end))
  end;

datatype 'a factor_tree = Factor_Leaf of 'a * int poly |
  Factor_Node of 'a * 'a factor_tree * 'a factor_tree;

fun factor_node_info (Factor_Leaf (i, x)) = i
  | factor_node_info (Factor_Node (i, l, r)) = i;

fun product_factor_tree p (Factor_Leaf (i, x)) = Factor_Leaf (x, x)
  | product_factor_tree p (Factor_Node (i, l, r)) =
    let
      val la = product_factor_tree p l;
      val ra = product_factor_tree p r;
      val f = factor_node_info la;
      val g = factor_node_info ra;
      val fg =
        mp p (karatsuba_mult_poly
               (equal_int, comm_ring_1_int, semiring_no_zero_divisors_int) f g);
    in
      Factor_Node (fg, la, ra)
    end;

fun dividea
  (Arith_Ops_Record
    (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14))
  = x7;

fun euclid_ext_aux_i A_ ops sa s ta t ra r =
  (if eq A_ r (zeroc ops)
    then let
           val c = dividea ops (oneb ops) (unit_factora ops ra);
         in
           ((timesa ops sa c, timesa ops ta c), normalizec ops ra)
         end
    else let
           val q = dividea ops ra r;
         in
           euclid_ext_aux_i A_ ops s (minusa ops sa (timesa ops q s)) t
             (minusa ops ta (timesa ops q t)) r (moduloa ops ra r)
         end);

fun euclid_ext_poly_i A_ ops =
  euclid_ext_aux_i (equal_list A_) (poly_ops A_ ops) (oneb (poly_ops A_ ops))
    (zeroc (poly_ops A_ ops)) (zeroc (poly_ops A_ ops))
    (oneb (poly_ops A_ ops));

fun bezout_coefficients_i A_ ff_ops f g = fst (euclid_ext_poly_i A_ ff_ops f g);

fun euclid_ext_poly_mod_main A_ p ff_ops f g =
  let
    val (a, b) =
      bezout_coefficients_i A_ ff_ops (of_int_poly_i ff_ops f)
        (of_int_poly_i ff_ops g);
  in
    (to_int_poly_i ff_ops a, to_int_poly_i ff_ops b)
  end;

fun euclid_ext_poly_dynamic p =
  (if less_eq_int p (Int_of_integer (65535 : IntInf.int))
    then euclid_ext_poly_mod_main equal_uint32 p
           (finite_field_ops32 (uint32_of_int p))
    else (if less_eq_int p (Int_of_integer (4294967295 : IntInf.int))
           then euclid_ext_poly_mod_main equal_uint64 p
                  (finite_field_ops64 (uint64_of_int p))
           else euclid_ext_poly_mod_main equal_integer p
                  (finite_field_ops_integer (integer_of_int p))));

fun pdivmod_monic_i A_ ops cf cg =
  let
    val (q, r) =
      divmod_poly_one_main_i A_ ops [] (rev cf) (rev cg)
        (minus_nata (plus_nata one_nata (size_list cf)) (size_list cg));
  in
    (poly_of_list_i A_ ops q, poly_of_list_i A_ ops (rev r))
  end;

fun dupe_monic_i A_ ops d h s t u =
  let
    val (q, a) = pdivmod_monic_i A_ ops (times_poly_i A_ ops t u) d;
  in
    (plus_poly_i A_ ops (times_poly_i A_ ops s u) (times_poly_i A_ ops h q), a)
  end;

fun dupe_monic_i_int A_ ops d h s t =
  let
    val da = of_int_poly_i ops d;
    val ha = of_int_poly_i ops h;
    val sa = of_int_poly_i ops s;
    val ta = of_int_poly_i ops t;
  in
    (fn u =>
      let
        val (db, hb) = dupe_monic_i A_ ops da ha sa ta (of_int_poly_i ops u);
      in
        (to_int_poly_i ops db, to_int_poly_i ops hb)
      end)
  end;

fun dupe_monic_dynamic p =
  (if less_eq_int p (Int_of_integer (65535 : IntInf.int))
    then dupe_monic_i_int equal_uint32 (finite_field_ops32 (uint32_of_int p))
    else (if less_eq_int p (Int_of_integer (4294967295 : IntInf.int))
           then dupe_monic_i_int equal_uint64
                  (finite_field_ops64 (uint64_of_int p))
           else dupe_monic_i_int equal_integer
                  (finite_field_ops_integer (integer_of_int p))));

fun simple_quadratic_hensel_step c q s t d h =
  let
    val u =
      mp q (sdiv_poly (equal_int, idom_divide_int)
             (minus_polya (ab_group_add_int, equal_int) c
               (karatsuba_mult_poly
                 (equal_int, comm_ring_1_int, semiring_no_zero_divisors_int) d
                 h))
             q);
    val a = dupe_monic_dynamic q d h s t u;
    val (aa, b) = a;
    val da =
      plus_polya (comm_monoid_add_int, equal_int) d
        (smult (equal_int, comm_semiring_0_int, semiring_no_zero_divisors_int) q
          b);
    val ab =
      plus_polya (comm_monoid_add_int, equal_int) h
        (smult (equal_int, comm_semiring_0_int, semiring_no_zero_divisors_int) q
          aa);
  in
    (da, ab)
  end;

fun quadratic_hensel_step c q s t d h =
  let
    val dupe = dupe_monic_dynamic q d h s t;
    val u =
      mp q (sdiv_poly (equal_int, idom_divide_int)
             (minus_polya (ab_group_add_int, equal_int) c
               (karatsuba_mult_poly
                 (equal_int, comm_ring_1_int, semiring_no_zero_divisors_int) d
                 h))
             q);
    val a = dupe u;
    val (aa, b) = a;
    val da =
      plus_polya (comm_monoid_add_int, equal_int) d
        (smult (equal_int, comm_semiring_0_int, semiring_no_zero_divisors_int) q
          b);
    val ha =
      plus_polya (comm_monoid_add_int, equal_int) h
        (smult (equal_int, comm_semiring_0_int, semiring_no_zero_divisors_int) q
          aa);
    val ua =
      mp q (sdiv_poly (equal_int, idom_divide_int)
             (minus_polya (ab_group_add_int, equal_int)
               (plus_polya (comm_monoid_add_int, equal_int)
                 (karatsuba_mult_poly
                   (equal_int, comm_ring_1_int, semiring_no_zero_divisors_int) s
                   da)
                 (karatsuba_mult_poly
                   (equal_int, comm_ring_1_int, semiring_no_zero_divisors_int) t
                   ha))
               (one_polyb comm_semiring_1_int))
             q);
    val ab = dupe ua;
    val (ac, ba) = ab;
    val qa = times_inta q q;
    val sa =
      mp qa (minus_polya (ab_group_add_int, equal_int) s
              (smult
                (equal_int, comm_semiring_0_int, semiring_no_zero_divisors_int)
                q ac));
    val ta =
      mp qa (minus_polya (ab_group_add_int, equal_int) t
              (smult
                (equal_int, comm_semiring_0_int, semiring_no_zero_divisors_int)
                q ba));
  in
    (sa, (ta, (da, ha)))
  end;

fun quadratic_hensel_loop c p s1 t1 d1 h1 j =
  (if less_eq_nat j one_nata then (p, (s1, (t1, (d1, h1))))
    else (if dvd (semidom_modulo_nat, equal_nat)
               (nat_of_integer (2 : IntInf.int)) j
           then let
                  val (q, (s, (t, (d, h)))) =
                    quadratic_hensel_loop c p s1 t1 d1 h1
                      (divide_nata j (nat_of_integer (2 : IntInf.int)));
                  val qq = times_inta q q;
                  val (sa, (ta, (da, ha))) = quadratic_hensel_step c q s t d h;
                in
                  (qq, (sa, (ta, (da, ha))))
                end
           else let
                  val (q, (s, (t, (d, h)))) =
                    quadratic_hensel_loop c p s1 t1 d1 h1
                      (plus_nata
                        (divide_nata j (nat_of_integer (2 : IntInf.int)))
                        one_nata);
                  val (sa, (ta, (da, ha))) = quadratic_hensel_step c q s t d h;
                  val qq = times_inta q q;
                  val pj = divide_inta qq p;
                  val down = mp pj;
                in
                  (pj, (down sa, (down ta, (down da, down ha))))
                end));

fun quadratic_hensel_main c p s1 t1 d1 h1 j =
  (if less_eq_nat j one_nata then (d1, h1)
    else (if dvd (semidom_modulo_nat, equal_nat)
               (nat_of_integer (2 : IntInf.int)) j
           then let
                  val (q, a) =
                    quadratic_hensel_loop c p s1 t1 d1 h1
                      (divide_nata j (nat_of_integer (2 : IntInf.int)));
                  val (s, aa) = a;
                  val (t, ab) = aa;
                  val (ac, b) = ab;
                in
                  simple_quadratic_hensel_step c q s t ac b
                end
           else let
                  val (q, (s, (t, (d, h)))) =
                    quadratic_hensel_loop c p s1 t1 d1 h1
                      (plus_nata
                        (divide_nata j (nat_of_integer (2 : IntInf.int)))
                        one_nata);
                  val (da, ha) = simple_quadratic_hensel_step c q s t d h;
                  val down = mp (divide_inta (times_inta q q) p);
                in
                  (down da, down ha)
                end));

fun quadratic_hensel_binary p n c d h =
  let
    val (s, t) = euclid_ext_poly_dynamic p d h;
  in
    quadratic_hensel_main c p s t d h n
  end;

fun hensel_lifting_main p n u (Factor_Leaf (uu, uv)) = [u]
  | hensel_lifting_main p n u (Factor_Node (uw, l, r)) =
    let
      val v = factor_node_info l;
      val w = factor_node_info r;
      val (va, wa) = quadratic_hensel_binary p n u v w;
    in
      hensel_lifting_main p n va l @ hensel_lifting_main p n wa r
    end;

fun partition_factors_main s [] = ([], [])
  | partition_factors_main s ((f, d) :: xs) =
    (if less_eq_nat d s
      then let
             val (l, a) = partition_factors_main (minus_nata s d) xs;
           in
             ((f, d) :: l, a)
           end
      else let
             val (l, r) = partition_factors_main d xs;
           in
             (l, (f, d) :: r)
           end);

fun sum_list A_ xs =
  foldr (plus ((plus_semigroup_add o semigroup_add_monoid_add) A_)) xs
    (zerob (zero_monoid_add A_));

fun partition_factors xs =
  let
    val n =
      divide_nata (sum_list monoid_add_nat (map snd xs))
        (nat_of_integer (2 : IntInf.int));
  in
    (case partition_factors_main n xs of ([], []) => ([], [])
      | ([], [x]) => ([], [x]) | ([], x :: y :: ys) => ([x], y :: ys)
      | ([x], b) => ([x], b) | (x :: y :: ys, []) => ([x], y :: ys)
      | (x :: y :: ys, ad :: listb) => (x :: y :: ys, ad :: listb))
  end;

fun create_factor_tree_balanced xs =
  (if less_eq_nat (size_list xs) one_nata then Factor_Leaf ((), fst (hda xs))
    else let
           val (l, r) = partition_factors xs;
         in
           Factor_Node
             ((), create_factor_tree_balanced l, create_factor_tree_balanced r)
         end);

fun sequences B_ key (a :: b :: xs) =
  (if less ((ord_preorder o preorder_order o order_linorder) B_) (key b) (key a)
    then desca B_ key b [a] xs else asc B_ key b (fn ba => a :: ba) xs)
  | sequences B_ key [] = [[]]
  | sequences B_ key [v] = [[v]]
and asc B_ key a f (b :: bs) =
  (if not (less ((ord_preorder o preorder_order o order_linorder) B_) (key b)
            (key a))
    then asc B_ key b (f o (fn ba => a :: ba)) bs
    else f [a] :: sequences B_ key (b :: bs))
  | asc B_ key a f [] = f [a] :: sequences B_ key []
and desca B_ key a asa (b :: bs) =
  (if less ((ord_preorder o preorder_order o order_linorder) B_) (key b) (key a)
    then desca B_ key b (a :: asa) bs
    else (a :: asa) :: sequences B_ key (b :: bs))
  | desca B_ key a asa [] = (a :: asa) :: sequences B_ key [];

fun mergec B_ key (a :: asa) (b :: bs) =
  (if less ((ord_preorder o preorder_order o order_linorder) B_) (key b) (key a)
    then b :: mergec B_ key (a :: asa) bs else a :: mergec B_ key asa (b :: bs))
  | mergec B_ key [] bs = bs
  | mergec B_ key (v :: va) [] = v :: va;

fun merge_pairs B_ key (a :: b :: xs) =
  mergec B_ key a b :: merge_pairs B_ key xs
  | merge_pairs B_ key [] = []
  | merge_pairs B_ key [v] = [v];

fun merge_alla B_ key [] = []
  | merge_alla B_ key [x] = x
  | merge_alla B_ key (v :: vb :: vc) =
    merge_alla B_ key (merge_pairs B_ key (v :: vb :: vc));

fun sort_key B_ key = merge_alla B_ key o sequences B_ key;

fun create_factor_tree xs =
  let
    val ys = map (fn f => (f, degreea zero_int f)) xs;
    val a = rev (sort_key linorder_nat snd ys);
  in
    create_factor_tree_balanced a
  end;

fun hensel_lifting_monic p n u vs =
  (if null vs then []
    else let
           val pn = binary_power monoid_mult_int p n;
           val c = mp pn u;
           val a = product_factor_tree p (create_factor_tree vs);
         in
           hensel_lifting_main p n c a
         end);

fun euclid_ext_aux (A1_, A2_) sa s ta t ra r =
  (if eq A2_ r
        (zerob
          ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
             semiring_Gcd_factorial_semiring_gcd o
             factorial_semiring_gcd_factorial_ring_gcd o
             factorial_ring_gcd_euclidean_ring_gcd)
            A1_))
    then let
           val c =
             divide
               ((divide_modulo o modulo_semiring_modulo o
                  semiring_modulo_semidom_modulo o semidom_modulo_idom_modulo o
                  idom_modulo_euclidean_ring o
                  euclidean_ring_euclidean_ring_gcd)
                 A1_)
               (onea ((one_gcd o gcd_Gcd o gcd_semiring_Gcd o
                        semiring_Gcd_factorial_semiring_gcd o
                        factorial_semiring_gcd_factorial_ring_gcd o
                        factorial_ring_gcd_euclidean_ring_gcd)
                       A1_))
               (unit_factor
                 ((unit_factor_semidom_divide_unit_factor o
                    semidom_divide_unit_factor_normalization_semidom o
                    normalization_semidom_semiring_gcd o semiring_gcd_ring_gcd o
                    ring_gcd_factorial_ring_gcd o
                    factorial_ring_gcd_euclidean_ring_gcd)
                   A1_)
                 ra);
         in
           ((times ((times_dvd o dvd_gcd o gcd_Gcd o gcd_semiring_Gcd o
                      semiring_Gcd_factorial_semiring_gcd o
                      factorial_semiring_gcd_factorial_ring_gcd o
                      factorial_ring_gcd_euclidean_ring_gcd)
                     A1_)
               sa c,
              times ((times_dvd o dvd_gcd o gcd_Gcd o gcd_semiring_Gcd o
                       semiring_Gcd_factorial_semiring_gcd o
                       factorial_semiring_gcd_factorial_ring_gcd o
                       factorial_ring_gcd_euclidean_ring_gcd)
                      A1_)
                ta c),
             normalizeb
               ((normalization_semidom_semiring_gcd o semiring_gcd_ring_gcd o
                  ring_gcd_factorial_ring_gcd o
                  factorial_ring_gcd_euclidean_ring_gcd)
                 A1_)
               ra)
         end
    else let
           val q =
             divide
               ((divide_modulo o modulo_semiring_modulo o
                  semiring_modulo_semidom_modulo o semidom_modulo_idom_modulo o
                  idom_modulo_euclidean_ring o
                  euclidean_ring_euclidean_ring_gcd)
                 A1_)
               ra r;
         in
           euclid_ext_aux (A1_, A2_) s
             (minus
               ((minus_group_add o group_add_neg_numeral o neg_numeral_ring_1 o
                  ring_1_comm_ring_1 o comm_ring_1_idom o idom_idom_divide o
                  idom_divide_idom_modulo o idom_modulo_euclidean_ring o
                  euclidean_ring_euclidean_ring_gcd)
                 A1_)
               sa (times
                    ((times_dvd o dvd_gcd o gcd_Gcd o gcd_semiring_Gcd o
                       semiring_Gcd_factorial_semiring_gcd o
                       factorial_semiring_gcd_factorial_ring_gcd o
                       factorial_ring_gcd_euclidean_ring_gcd)
                      A1_)
                    q s))
             t (minus
                 ((minus_group_add o group_add_neg_numeral o
                    neg_numeral_ring_1 o ring_1_comm_ring_1 o comm_ring_1_idom o
                    idom_idom_divide o idom_divide_idom_modulo o
                    idom_modulo_euclidean_ring o
                    euclidean_ring_euclidean_ring_gcd)
                   A1_)
                 ta (times
                      ((times_dvd o dvd_gcd o gcd_Gcd o gcd_semiring_Gcd o
                         semiring_Gcd_factorial_semiring_gcd o
                         factorial_semiring_gcd_factorial_ring_gcd o
                         factorial_ring_gcd_euclidean_ring_gcd)
                        A1_)
                      q t))
             r (modulo
                 ((modulo_semiring_modulo o semiring_modulo_semidom_modulo o
                    semidom_modulo_idom_modulo o idom_modulo_euclidean_ring o
                    euclidean_ring_euclidean_ring_gcd)
                   A1_)
                 ra r)
         end);

fun bezout_coefficients (A1_, A2_) a b =
  fst (euclid_ext_aux (A1_, A2_)
        (onea ((one_gcd o gcd_Gcd o gcd_semiring_Gcd o
                 semiring_Gcd_factorial_semiring_gcd o
                 factorial_semiring_gcd_factorial_ring_gcd o
                 factorial_ring_gcd_euclidean_ring_gcd)
                A1_))
        (zerob
          ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
             semiring_Gcd_factorial_semiring_gcd o
             factorial_semiring_gcd_factorial_ring_gcd o
             factorial_ring_gcd_euclidean_ring_gcd)
            A1_))
        (zerob
          ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
             semiring_Gcd_factorial_semiring_gcd o
             factorial_semiring_gcd_factorial_ring_gcd o
             factorial_ring_gcd_euclidean_ring_gcd)
            A1_))
        (onea ((one_gcd o gcd_Gcd o gcd_semiring_Gcd o
                 semiring_Gcd_factorial_semiring_gcd o
                 factorial_semiring_gcd_factorial_ring_gcd o
                 factorial_ring_gcd_euclidean_ring_gcd)
                A1_))
        a b);

fun inverse_mod x m =
  fst (bezout_coefficients (euclidean_ring_gcd_int, equal_int) x m);

fun hensel_lifting p n f gs =
  let
    val lc = coeff zero_int f (degreea zero_int f);
    val ilc = inverse_mod lc (binary_power monoid_mult_int p n);
    val g =
      smult (equal_int, comm_semiring_0_int, semiring_no_zero_divisors_int) ilc
        f;
  in
    hensel_lifting_monic p n g gs
  end;

fun root_int_maina pm ipm ip x n =
  let
    val xpm = binary_power monoid_mult_int x pm;
    val xp = times_inta xpm x;
  in
    (if less_eq_int xp n then (x, equal_inta xp n)
      else root_int_maina pm ipm ip
             (divide_inta (plus_inta (divide_inta n xpm) (times_inta x ipm)) ip)
             n)
  end;

fun numeral A_ (Bit1 n) =
  let
    val m = numeral A_ n;
  in
    plus ((plus_semigroup_add o semigroup_add_numeral) A_)
      (plus ((plus_semigroup_add o semigroup_add_numeral) A_) m m)
      (onea (one_numeral A_))
  end
  | numeral A_ (Bit0 n) =
    let
      val m = numeral A_ n;
    in
      plus ((plus_semigroup_add o semigroup_add_numeral) A_) m m
    end
  | numeral A_ One = onea (one_numeral A_);

fun of_nat A_ n =
  (if equal_nata n zero_nata
    then zerob ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1)
                 A_)
    else let
           val (m, q) = divmod_nat n (nat_of_integer (2 : IntInf.int));
           val ma =
             times ((times_power o power_monoid_mult o
                      monoid_mult_semiring_numeral o
                      semiring_numeral_semiring_1)
                     A_)
               (numeral
                 ((numeral_semiring_numeral o semiring_numeral_semiring_1) A_)
                 (Bit0 One))
               (of_nat A_ m);
         in
           (if equal_nata q zero_nata then ma
             else plus ((plus_semigroup_add o semigroup_add_numeral o
                          numeral_semiring_numeral o
                          semiring_numeral_semiring_1)
                         A_)
                    ma (onea ((one_numeral o numeral_semiring_numeral o
                                semiring_numeral_semiring_1)
                               A_)))
         end);

fun ceiling A_ x =
  uminus_inta
    (floor A_
      (uminus
        ((uminus_abs_if o abs_if_linordered_ring o
           linordered_ring_linordered_ring_strict o
           linordered_ring_strict_linordered_idom o
           linordered_idom_linordered_field o
           linordered_field_archimedean_field o archimedean_field_floor_ceiling)
          A_)
        x));

datatype proper_base = Abs_proper_base of int;

fun into_base xa =
  Abs_proper_base
    (if less_eq_int (Int_of_integer (2 : IntInf.int)) xa then xa
      else Int_of_integer (2 : IntInf.int));

fun rep_proper_base (Abs_proper_base x) = x;

fun square_base xa =
  Abs_proper_base (times_inta (rep_proper_base xa) (rep_proper_base xa));

fun get_base x = rep_proper_base x;

fun log_main b x =
  (if less_int x (get_base b) then (zero_nata, one_inta)
    else let
           val (z, bz) = log_main (square_base b) x;
           val l = times_nata (nat_of_integer (2 : IntInf.int)) z;
           val bz1 = times_inta bz (get_base b);
         in
           (if less_int x bz1 then (l, bz) else (suc l, bz1))
         end);

fun log_ceiling b x = let
                        val (y, by) = log_main (into_base b) x;
                      in
                        (if equal_inta x by then y else suc y)
                      end;

fun start_value n p =
  binary_power monoid_mult_int (Int_of_integer (2 : IntInf.int))
    (nat (ceiling floor_ceiling_rat
           (divide_rata
             (of_nat semiring_1_rat
               (log_ceiling (Int_of_integer (2 : IntInf.int)) n))
             (of_nat semiring_1_rat p))));

fun root_int_main p n =
  (if equal_nata p zero_nata then (one_inta, equal_inta n one_inta)
    else let
           val pm = minus_nata p one_nata;
         in
           root_int_maina pm (int_of_nat pm) (int_of_nat p) (start_value n p) n
         end);

fun root_int_ceiling_pos p x =
  (if equal_nata p zero_nata then zero_inta
    else (case root_int_main p x of (y, true) => y
           | (y, false) => plus_inta y one_inta));

fun root_int_floor_pos p x =
  (if equal_nata p zero_nata then zero_inta else fst (root_int_main p x));

fun root_int_floor p x =
  (if less_eq_int zero_inta x then root_int_floor_pos p x
    else uminus_inta (root_int_ceiling_pos p (uminus_inta x)));

fun mahler_landau_graeffe_approximation kk dd f =
  let
    val no =
      sum_list monoid_add_int
        (map (fn a => times_inta a a) (coeffs zero_int f));
  in
    root_int_floor kk (times_inta (int_of_nat dd) no)
  end;

fun alternate (x :: y :: ys) = let
                                 val (evn, od) = alternate ys;
                               in
                                 (x :: evn, y :: od)
                               end
  | alternate [] = ([], [])
  | alternate [v] = ([v], []);

fun poly_even_odd (A1_, A2_) f =
  let
    val (evn, od) =
      alternate
        (coeffs
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_comm_semiring_1 o
             comm_semiring_1_comm_semiring_1_cancel o
             comm_semiring_1_cancel_comm_ring_1)
            A2_)
          f);
  in
    (poly_of_list
       ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
          semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
          comm_semiring_1_cancel_comm_ring_1)
          A2_,
         A1_)
       evn,
      poly_of_list
        ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_comm_ring_1)
           A2_,
          A1_)
        od)
  end;

fun graeffe_one_step (A1_, A2_) c f =
  let
    val (g, h) = poly_even_odd (A1_, comm_ring_1_idom A2_) f;
  in
    smult (A1_, (comm_semiring_0_comm_semiring_1 o
                  comm_semiring_1_comm_semiring_1_cancel o
                  comm_semiring_1_cancel_semidom o semidom_idom)
                  A2_,
            (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
              semiring_1_no_zero_divisors_semidom o semidom_idom)
              A2_)
      c (minus_polya
          ((ab_group_add_ring o ring_ring_1 o ring_1_comm_ring_1 o
             comm_ring_1_idom)
             A2_,
            A1_)
          (karatsuba_mult_poly
            (A1_, comm_ring_1_idom A2_,
              (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
                semiring_1_no_zero_divisors_semidom o semidom_idom)
                A2_)
            g g)
          (karatsuba_mult_poly
            (A1_, comm_ring_1_idom A2_,
              (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
                semiring_1_no_zero_divisors_semidom o semidom_idom)
                A2_)
            (monom_mult
              ((comm_semiring_1_comm_semiring_1_cancel o
                 comm_semiring_1_cancel_semidom o semidom_idom)
                A2_)
              one_nata h)
            h))
  end;

fun mahler_approximation_main bnd dd c g mm k kk =
  let
    val mmm = mahler_landau_graeffe_approximation kk dd g;
    val new_mm = (if equal_nata k zero_nata then mmm else min ord_int mm mmm);
  in
    (if less_eq_nat bnd k then new_mm
      else mahler_approximation_main bnd (times_nata dd dd) c
             (graeffe_one_step (equal_int, idom_int) c g) new_mm (suc k)
             (times_nata (nat_of_integer (2 : IntInf.int)) kk))
  end;

fun mahler_approximation bnd d f =
  mahler_approximation_main bnd (times_nata d d)
    (binary_power monoid_mult_int (uminus_inta one_inta) (degreea zero_int f)) f
    (uminus_inta one_inta) zero_nata (nat_of_integer (2 : IntInf.int));

fun fold_atLeastAtMost_nat f a b acc =
  (if less_nat b a then acc
    else fold_atLeastAtMost_nat f (plus_nata a one_nata) b (f a acc));

fun fact A_ n =
  of_nat (semiring_1_semiring_char_0 A_)
    (fold_atLeastAtMost_nat times_nata (nat_of_integer (2 : IntInf.int)) n
      one_nata);

fun binomial n k =
  (if less_eq_nat k n
    then divide_nata (fact semiring_char_0_nat n)
           (times_nata (fact semiring_char_0_nat k)
             (fact semiring_char_0_nat (minus_nata n k)))
    else zero_nata);

fun mignotte_bound f d =
  let
    val da = minus_nata d one_nata;
    val d2 = divide_nata da (nat_of_integer (2 : IntInf.int));
    val binom = binomial da d2;
  in
    plus_inta (mahler_approximation (nat_of_integer (2 : IntInf.int)) binom f)
      (times_inta (int_of_nat binom)
        (abs_inta (coeff zero_int f (degreea zero_int f))))
  end;

fun factor_bound x = mignotte_bound x;

fun drop n [] = []
  | drop n (x :: xs) =
    (if equal_nata n zero_nata then x :: xs
      else drop (minus_nata n one_nata) xs);

fun max_factor_degree degs =
  let
    val ds = sort_key linorder_nat (fn x => x) degs;
  in
    sum_list monoid_add_nat
      (drop (divide_nata (size_list ds) (nat_of_integer (2 : IntInf.int))) ds)
  end;

fun degree_bound A_ vs = max_factor_degree (map (degreea A_) vs);

fun berlekamp_zassenhaus_factorization f =
  let
    val p = suitable_prime_bz f;
    val (_, fs) = finite_field_factorization_int p f;
    val max_deg = degree_bound zero_int fs;
    val bnd =
      times_inta
        (times_inta (Int_of_integer (2 : IntInf.int))
          (abs_inta (coeff zero_int f (degreea zero_int f))))
        (factor_bound f max_deg);
    val k = find_exponent p bnd;
    val vs = hensel_lifting p k f fs;
  in
    zassenhaus_reconstruction vs p k f
  end;

fun internal_int_poly_factorization f =
  let
    val (a, gis) = square_free_factorization_int f;
  in
    (a, maps (fn (g, i) =>
               map (fn fa => (fa, i)) (berlekamp_zassenhaus_factorization g))
          gis)
  end;

fun reflect_factorization cfs =
  let
    val (c, fs) = cfs;
  in
    (c, map (fn (f, a) => (reflect_poly (zero_int, equal_int) f, a)) fs)
  end;

fun factorize_int_last_nz_poly f =
  let
    val df = degreea zero_int f;
  in
    (if equal_nata df zero_nata
      then ((case coeffs zero_int f of [] => zero_inta | x :: _ => x), [])
      else (if equal_nata df one_nata
             then (content semiring_gcd_int f,
                    [(primitive_part (semiring_gcd_int, equal_int) f,
                       zero_nata)])
             else (if less_int
                        (abs_inta
                          (case coeffs zero_int f of [] => zero_inta
                            | x :: _ => x))
                        (abs_inta (coeff zero_int f df))
                    then reflect_factorization
                           (internal_int_poly_factorization
                             (reflect_poly (zero_int, equal_int) f))
                    else internal_int_poly_factorization f)))
  end;

fun factorize_int_poly f =
  let
    val (n, g) = x_split (equal_int, semiring_0_int) f;
  in
    (if equal_polya (zero_int, equal_int) g (zero_polyb zero_int)
      then (zero_inta, [])
      else let
             val (a, fs) = factorize_int_last_nz_poly g;
           in
             (if equal_nata n zero_nata then (a, fs)
               else (a, (monom (zero_int, equal_int) one_inta one_nata,
                          minus_nata n one_nata) ::
                          fs))
           end)
  end;

fun factors_of_int_poly p =
  map (abs_int_poly o fst) (snd (factorize_int_poly p));

fun real_alg_2a ri p l r =
  (if equal_nata (degreea zero_int p) one_nata
    then Rationala
           (fract
             (uminus_inta
               (case coeffs zero_int p of [] => zero_inta | x :: _ => x))
             (coeff zero_int p one_nata))
    else let
           val (pa, (la, ra)) =
             normalize_bounds_1
               let
                 val (la, (ra, _)) =
                   tighten_poly_bounds_for_x p zero_rata l r
                     (sgn_rata
                       (fold_coeffs zero_int
                         (fn a => fn b => plus_rata (of_int a) (times_rata r b))
                         p zero_rata));
               in
                 (p, (la, ra))
               end;
         in
           Irrational (number_root ri ra, (pa, (la, ra)))
         end);

fun select_correct_factor_int_poly bnd_update bnd_get init p =
  let
    val qs = factors_of_int_poly p;
    val polys = map (fn q => (q, root_info q)) qs;
    val a = select_correct_factor bnd_update bnd_get init polys;
    val (aa, b) = a;
  in
    let
      val (q, ri) = aa;
    in
      (fn (ab, ba) => real_alg_2a ri q ab ba)
    end
      b
  end;

fun tighten_poly_bounds_binary cr1 cr2 ((l1, (r1, sr1)), (l2, (r2, sr2))) =
  (tighten_poly_bounds cr1 l1 r1 sr1, tighten_poly_bounds cr2 l2 r2 sr2);

fun zero_poly A_ = {zerob = zero_polyb A_} : 'a poly zero;

fun poly_lift (A1_, A2_) =
  map_poly A1_ (zero_poly A1_, equal_poly (A1_, A2_))
    (fn a => pCons (A1_, A2_) a (zero_polyb A1_));

fun plus_poly (A1_, A2_) = {plus = plus_polya (A1_, A2_)} : 'a poly plus;

fun semigroup_add_poly (A1_, A2_) = {plus_semigroup_add = plus_poly (A1_, A2_)}
  : 'a poly semigroup_add;

fun ab_semigroup_add_poly (A1_, A2_) =
  {semigroup_add_ab_semigroup_add = semigroup_add_poly (A1_, A2_)} :
  'a poly ab_semigroup_add;

fun monoid_add_poly (A1_, A2_) =
  {semigroup_add_monoid_add = semigroup_add_poly (A1_, A2_),
    zero_monoid_add =
      zero_poly ((zero_monoid_add o monoid_add_comm_monoid_add) A1_)}
  : 'a poly monoid_add;

fun comm_monoid_add_poly (A1_, A2_) =
  {ab_semigroup_add_comm_monoid_add = ab_semigroup_add_poly (A1_, A2_),
    monoid_add_comm_monoid_add = monoid_add_poly (A1_, A2_)}
  : 'a poly comm_monoid_add;

fun poly_x_mult_y (A1_, A2_) p =
  let
    val cs = coeffs ((zero_monoid_add o monoid_add_comm_monoid_add) A1_) p;
  in
    poly_of_list
      (comm_monoid_add_poly (A1_, A2_),
        equal_poly ((zero_monoid_add o monoid_add_comm_monoid_add) A1_, A2_))
      (map (fn (i, ai) =>
             monom ((zero_monoid_add o monoid_add_comm_monoid_add) A1_, A2_) ai
               i)
        (zip (upt zero_nata (size_list cs)) cs))
  end;

fun dichotomous_Lazard A_ x y n =
  (if less_eq_nat n one_nata
    then (if equal_nata n one_nata then x
           else onea ((one_numeral o numeral_neg_numeral o neg_numeral_ring_1 o
                        ring_1_comm_ring_1 o comm_ring_1_idom o
                        idom_idom_divide)
                       A_))
    else let
           val (d, r) = divmod_nat n (nat_of_integer (2 : IntInf.int));
           val reca = dichotomous_Lazard A_ x y d;
           val recsq =
             divide ((divide_semidom_divide o semidom_divide_idom_divide) A_)
               (times
                 ((times_dvd o dvd_comm_monoid_mult o
                    comm_monoid_mult_comm_semiring_1 o
                    comm_semiring_1_comm_semiring_1_cancel o
                    comm_semiring_1_cancel_semidom o semidom_idom o
                    idom_idom_divide)
                   A_)
                 reca reca)
               y;
         in
           (if equal_nata r zero_nata then recsq
             else divide
                    ((divide_semidom_divide o semidom_divide_idom_divide) A_)
                    (times
                      ((times_dvd o dvd_comm_monoid_mult o
                         comm_monoid_mult_comm_semiring_1 o
                         comm_semiring_1_comm_semiring_1_cancel o
                         comm_semiring_1_cancel_semidom o semidom_idom o
                         idom_idom_divide)
                        A_)
                      recsq x)
                    y)
         end);

fun resultant_impl_rec (A1_, A2_) gi_1 gi ni_1 d1_1 hi_2 =
  let
    val ni =
      degreea
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
          A2_)
        gi;
    val pmod =
      pseudo_mod
        (A1_, (comm_ring_1_idom o idom_idom_divide) A2_,
          (semiring_1_no_zero_divisors_semidom o semidom_idom o
            idom_idom_divide)
            A2_)
        gi_1 gi;
  in
    (if is_zero
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_comm_semiring_1 o
             comm_semiring_1_comm_semiring_1_cancel o
             comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
            A2_)
          pmod
      then (if equal_nata ni zero_nata
             then let
                    val d1 = minus_nata ni_1 ni;
                    val gia =
                      coeff ((zero_mult_zero o mult_zero_semiring_0 o
                               semiring_0_semiring_1 o
                               semiring_1_comm_semiring_1 o
                               comm_semiring_1_comm_semiring_1_cancel o
                               comm_semiring_1_cancel_semidom o semidom_idom o
                               idom_idom_divide)
                              A2_)
                        gi (degreea
                             ((zero_mult_zero o mult_zero_semiring_0 o
                                semiring_0_semiring_1 o
                                semiring_1_comm_semiring_1 o
                                comm_semiring_1_comm_semiring_1_cancel o
                                comm_semiring_1_cancel_semidom o semidom_idom o
                                idom_idom_divide)
                               A2_)
                             gi);
                  in
                    (if equal_nata d1 one_nata then gia
                      else let
                             val gi_1a =
                               coeff ((zero_mult_zero o mult_zero_semiring_0 o
semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
comm_semiring_1_comm_semiring_1_cancel o comm_semiring_1_cancel_semidom o
semidom_idom o idom_idom_divide)
                                       A2_)
                                 gi_1
                                 (degreea
                                   ((zero_mult_zero o mult_zero_semiring_0 o
                                      semiring_0_semiring_1 o
                                      semiring_1_comm_semiring_1 o
                                      comm_semiring_1_comm_semiring_1_cancel o
                                      comm_semiring_1_cancel_semidom o
                                      semidom_idom o idom_idom_divide)
                                     A2_)
                                   gi_1);
                             val hi_1 =
                               (if equal_nata d1_1 one_nata then gi_1a
                                 else dichotomous_Lazard A2_ gi_1a hi_2 d1_1);
                           in
                             dichotomous_Lazard A2_ gia hi_1 d1
                           end)
                  end
             else zerob ((zero_mult_zero o mult_zero_semiring_0 o
                           semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                           comm_semiring_1_comm_semiring_1_cancel o
                           comm_semiring_1_cancel_semidom o semidom_idom o
                           idom_idom_divide)
                          A2_))
      else let
             val d1 = minus_nata ni_1 ni;
             val gi_1a =
               coeff ((zero_mult_zero o mult_zero_semiring_0 o
                        semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                        comm_semiring_1_comm_semiring_1_cancel o
                        comm_semiring_1_cancel_semidom o semidom_idom o
                        idom_idom_divide)
                       A2_)
                 gi_1
                 (degreea
                   ((zero_mult_zero o mult_zero_semiring_0 o
                      semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                      comm_semiring_1_comm_semiring_1_cancel o
                      comm_semiring_1_cancel_semidom o semidom_idom o
                      idom_idom_divide)
                     A2_)
                   gi_1);
             val hi_1 =
               (if equal_nata d1_1 one_nata then gi_1a
                 else dichotomous_Lazard A2_ gi_1a hi_2 d1_1);
             val divisor =
               (if equal_nata d1 one_nata
                 then times ((times_dvd o dvd_comm_monoid_mult o
                               comm_monoid_mult_comm_semiring_1 o
                               comm_semiring_1_comm_semiring_1_cancel o
                               comm_semiring_1_cancel_semidom o semidom_idom o
                               idom_idom_divide)
                              A2_)
                        gi_1a hi_1
                 else (if dvd (semidom_modulo_nat, equal_nat)
                            (nat_of_integer (2 : IntInf.int)) d1
                        then times ((times_dvd o dvd_comm_monoid_mult o
                                      comm_monoid_mult_comm_semiring_1 o
                                      comm_semiring_1_comm_semiring_1_cancel o
                                      comm_semiring_1_cancel_semidom o
                                      semidom_idom o idom_idom_divide)
                                     A2_)
                               (uminus
                                 ((uminus_group_add o group_add_neg_numeral o
                                    neg_numeral_ring_1 o ring_1_comm_ring_1 o
                                    comm_ring_1_idom o idom_idom_divide)
                                   A2_)
                                 gi_1a)
                               (binary_power
                                 ((monoid_mult_semiring_numeral o
                                    semiring_numeral_semiring_1 o
                                    semiring_1_comm_semiring_1 o
                                    comm_semiring_1_comm_semiring_1_cancel o
                                    comm_semiring_1_cancel_semidom o
                                    semidom_idom o idom_idom_divide)
                                   A2_)
                                 hi_1 d1)
                        else times ((times_dvd o dvd_comm_monoid_mult o
                                      comm_monoid_mult_comm_semiring_1 o
                                      comm_semiring_1_comm_semiring_1_cancel o
                                      comm_semiring_1_cancel_semidom o
                                      semidom_idom o idom_idom_divide)
                                     A2_)
                               gi_1a
                               (binary_power
                                 ((monoid_mult_semiring_numeral o
                                    semiring_numeral_semiring_1 o
                                    semiring_1_comm_semiring_1 o
                                    comm_semiring_1_comm_semiring_1_cancel o
                                    comm_semiring_1_cancel_semidom o
                                    semidom_idom o idom_idom_divide)
                                   A2_)
                                 hi_1 d1)));
             val gi_p1 = sdiv_poly (A1_, A2_) pmod divisor;
           in
             resultant_impl_rec (A1_, A2_) gi gi_p1 ni d1 hi_1
           end)
  end;

fun resultant_impl_start (A1_, A2_) g1 g2 =
  let
    val pmod =
      pseudo_mod
        (A1_, (comm_ring_1_idom o idom_idom_divide) A2_,
          (semiring_1_no_zero_divisors_semidom o semidom_idom o
            idom_idom_divide)
            A2_)
        g1 g2;
    val n2 =
      degreea
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
          A2_)
        g2;
    val n1 =
      degreea
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
          A2_)
        g1;
    val g2a =
      coeff ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
               semiring_1_comm_semiring_1 o
               comm_semiring_1_comm_semiring_1_cancel o
               comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
              A2_)
        g2 (degreea
             ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
                semiring_1_comm_semiring_1 o
                comm_semiring_1_comm_semiring_1_cancel o
                comm_semiring_1_cancel_semidom o semidom_idom o
                idom_idom_divide)
               A2_)
             g2);
    val d1 = minus_nata n1 n2;
  in
    (if is_zero
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_comm_semiring_1 o
             comm_semiring_1_comm_semiring_1_cancel o
             comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
            A2_)
          pmod
      then (if equal_nata n2 zero_nata
             then (if equal_nata d1 zero_nata
                    then onea ((one_numeral o numeral_neg_numeral o
                                 neg_numeral_ring_1 o ring_1_comm_ring_1 o
                                 comm_ring_1_idom o idom_idom_divide)
                                A2_)
                    else (if equal_nata d1 one_nata then g2a
                           else binary_power
                                  ((monoid_mult_semiring_numeral o
                                     semiring_numeral_semiring_1 o
                                     semiring_1_comm_semiring_1 o
                                     comm_semiring_1_comm_semiring_1_cancel o
                                     comm_semiring_1_cancel_semidom o
                                     semidom_idom o idom_idom_divide)
                                    A2_)
                                  g2a d1))
             else zerob ((zero_mult_zero o mult_zero_semiring_0 o
                           semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                           comm_semiring_1_comm_semiring_1_cancel o
                           comm_semiring_1_cancel_semidom o semidom_idom o
                           idom_idom_divide)
                          A2_))
      else let
             val g3 =
               (if dvd (semidom_modulo_nat, equal_nat)
                     (nat_of_integer (2 : IntInf.int)) d1
                 then uminus_polya
                        ((ab_group_add_ring o ring_ring_1 o ring_1_comm_ring_1 o
                           comm_ring_1_idom o idom_idom_divide)
                          A2_)
                        pmod
                 else pmod);
             val n3 =
               degreea
                 ((zero_mult_zero o mult_zero_semiring_0 o
                    semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                    comm_semiring_1_comm_semiring_1_cancel o
                    comm_semiring_1_cancel_semidom o semidom_idom o
                    idom_idom_divide)
                   A2_)
                 g3;
             val pmoda =
               pseudo_mod
                 (A1_, (comm_ring_1_idom o idom_idom_divide) A2_,
                   (semiring_1_no_zero_divisors_semidom o semidom_idom o
                     idom_idom_divide)
                     A2_)
                 g2 g3;
           in
             (if is_zero
                   ((zero_mult_zero o mult_zero_semiring_0 o
                      semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                      comm_semiring_1_comm_semiring_1_cancel o
                      comm_semiring_1_cancel_semidom o semidom_idom o
                      idom_idom_divide)
                     A2_)
                   pmoda
               then (if equal_nata n3 zero_nata
                      then let
                             val d2 = minus_nata n2 n3;
                             val g3a =
                               coeff ((zero_mult_zero o mult_zero_semiring_0 o
semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
comm_semiring_1_comm_semiring_1_cancel o comm_semiring_1_cancel_semidom o
semidom_idom o idom_idom_divide)
                                       A2_)
                                 g3 (degreea
                                      ((zero_mult_zero o mult_zero_semiring_0 o
 semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
 comm_semiring_1_comm_semiring_1_cancel o comm_semiring_1_cancel_semidom o
 semidom_idom o idom_idom_divide)
A2_)
                                      g3);
                           in
                             (if equal_nata d2 one_nata then g3a
                               else dichotomous_Lazard A2_ g3a
                                      (if equal_nata d1 one_nata then g2a
else binary_power
       ((monoid_mult_semiring_numeral o semiring_numeral_semiring_1 o
          semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
          comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
         A2_)
       g2a d1)
                                      d2)
                           end
                      else zerob ((zero_mult_zero o mult_zero_semiring_0 o
                                    semiring_0_semiring_1 o
                                    semiring_1_comm_semiring_1 o
                                    comm_semiring_1_comm_semiring_1_cancel o
                                    comm_semiring_1_cancel_semidom o
                                    semidom_idom o idom_idom_divide)
                                   A2_))
               else let
                      val h2 =
                        (if equal_nata d1 one_nata then g2a
                          else binary_power
                                 ((monoid_mult_semiring_numeral o
                                    semiring_numeral_semiring_1 o
                                    semiring_1_comm_semiring_1 o
                                    comm_semiring_1_comm_semiring_1_cancel o
                                    comm_semiring_1_cancel_semidom o
                                    semidom_idom o idom_idom_divide)
                                   A2_)
                                 g2a d1);
                      val d2 = minus_nata n2 n3;
                      val divisor =
                        (if equal_nata d2 one_nata
                          then times ((times_dvd o dvd_comm_monoid_mult o
comm_monoid_mult_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
                                       A2_)
                                 g2a h2
                          else (if dvd (semidom_modulo_nat, equal_nat)
                                     (nat_of_integer (2 : IntInf.int)) d2
                                 then times
((times_dvd o dvd_comm_monoid_mult o comm_monoid_mult_comm_semiring_1 o
   comm_semiring_1_comm_semiring_1_cancel o comm_semiring_1_cancel_semidom o
   semidom_idom o idom_idom_divide)
  A2_)
(uminus
  ((uminus_group_add o group_add_neg_numeral o neg_numeral_ring_1 o
     ring_1_comm_ring_1 o comm_ring_1_idom o idom_idom_divide)
    A2_)
  g2a)
(binary_power
  ((monoid_mult_semiring_numeral o semiring_numeral_semiring_1 o
     semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
     comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
    A2_)
  h2 d2)
                                 else times
((times_dvd o dvd_comm_monoid_mult o comm_monoid_mult_comm_semiring_1 o
   comm_semiring_1_comm_semiring_1_cancel o comm_semiring_1_cancel_semidom o
   semidom_idom o idom_idom_divide)
  A2_)
g2a (binary_power
      ((monoid_mult_semiring_numeral o semiring_numeral_semiring_1 o
         semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
         comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
        A2_)
      h2 d2)));
                      val g4 = sdiv_poly (A1_, A2_) pmoda divisor;
                    in
                      resultant_impl_rec (A1_, A2_) g3 g4 n3 d2 h2
                    end)
           end)
  end;

fun resultant_impl_Lazard (A1_, A2_) g1 g2 =
  (if is_zero
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
          A2_)
        g2
    then (if equal_nata
               (degreea
                 ((zero_mult_zero o mult_zero_semiring_0 o
                    semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                    comm_semiring_1_comm_semiring_1_cancel o
                    comm_semiring_1_cancel_semidom o semidom_idom o
                    idom_idom_divide)
                   A2_)
                 g1)
               zero_nata
           then onea ((one_numeral o numeral_neg_numeral o neg_numeral_ring_1 o
                        ring_1_comm_ring_1 o comm_ring_1_idom o
                        idom_idom_divide)
                       A2_)
           else zerob ((zero_mult_zero o mult_zero_semiring_0 o
                         semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                         comm_semiring_1_comm_semiring_1_cancel o
                         comm_semiring_1_cancel_semidom o semidom_idom o
                         idom_idom_divide)
                        A2_))
    else resultant_impl_start (A1_, A2_) g1 g2);

fun resultant_impl (A1_, A2_) f g =
  (if less_eq_nat
        (size_list
          (coeffs
            ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
               semiring_Gcd_factorial_semiring_gcd o
               factorial_semiring_gcd_factorial_ring_gcd)
              A1_)
            g))
        (size_list
          (coeffs
            ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
               semiring_Gcd_factorial_semiring_gcd o
               factorial_semiring_gcd_factorial_ring_gcd)
              A1_)
            f))
    then resultant_impl_Lazard (A2_, idom_divide_factorial_ring_gcd A1_) f g
    else let
           val res =
             resultant_impl_Lazard (A2_, idom_divide_factorial_ring_gcd A1_) g
               f;
         in
           (if dvd (semidom_modulo_nat, equal_nat)
                 (nat_of_integer (2 : IntInf.int))
                 (degreea
                   ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
                      semiring_Gcd_factorial_semiring_gcd o
                      factorial_semiring_gcd_factorial_ring_gcd)
                     A1_)
                   f) orelse
                 dvd (semidom_modulo_nat, equal_nat)
                   (nat_of_integer (2 : IntInf.int))
                   (degreea
                     ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
                        semiring_Gcd_factorial_semiring_gcd o
                        factorial_semiring_gcd_factorial_ring_gcd)
                       A1_)
                     g)
             then res
             else uminus
                    ((uminus_group_add o group_add_neg_numeral o
                       neg_numeral_ring_1 o ring_1_comm_ring_1 o
                       comm_ring_1_idom o idom_idom_divide o
                       idom_divide_factorial_ring_gcd)
                      A1_)
                    res)
         end);

fun resultant (A1_, A2_) f g = resultant_impl (A1_, A2_) f g;

fun unit_factor_polya (A1_, A2_, A3_) p =
  pCons ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
           A2_,
          A1_)
    (unit_factor (unit_factor_semidom_divide_unit_factor A3_)
      (coeff
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
          A2_)
        p (degreea
            ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
               semiring_1_comm_semiring_1 o
               comm_semiring_1_comm_semiring_1_cancel o
               comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
              A2_)
            p)))
    (zero_polyb
      ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
         semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
         comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
        A2_));

fun lcm_polya (A1_, A2_) p q =
  divide_polya (A2_, idom_divide_factorial_ring_gcd A1_)
    (normalize_poly
      (A2_, idom_divide_factorial_ring_gcd A1_,
        (semidom_divide_unit_factor_normalization_semidom o
          normalization_semidom_semiring_gcd o semiring_gcd_ring_gcd o
          ring_gcd_factorial_ring_gcd)
          A1_)
      (karatsuba_mult_poly
        (A2_, (comm_ring_1_idom o idom_idom_divide o
                idom_divide_factorial_ring_gcd)
                A1_,
          (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
            semiring_1_no_zero_divisors_semidom o semidom_idom o
            idom_idom_divide o idom_divide_factorial_ring_gcd)
            A1_)
        p q))
    (gcd_polyc (A1_, A2_) p q);

fun gcd_polyb A_ x = dummy_Gcd x;

fun times_polya (A1_, A2_, A3_) p q =
  fold_coeffs
    ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_comm_semiring_0) A2_)
    (fn a => fn pa =>
      plus_polya
        ((comm_monoid_add_semiring_0 o semiring_0_comm_semiring_0) A2_, A1_)
        (smult (A1_, A2_, A3_) a q)
        (pCons
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_comm_semiring_0)
             A2_,
            A1_)
          (zerob
            ((zero_mult_zero o mult_zero_semiring_0 o
               semiring_0_comm_semiring_0)
              A2_))
          pa))
    p (zero_polyb
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_comm_semiring_0)
          A2_));

fun one_poly A_ = {onea = one_polyb A_} : 'a poly one;

fun times_poly (A1_, A2_, A3_) = {times = times_polya (A1_, A2_, A3_)} :
  'a poly times;

fun dvd_poly (A1_, A2_, A3_) =
  {times_dvd = times_poly (A1_, comm_semiring_0_comm_semiring_1 A2_, A3_)} :
  'a poly dvd;

fun gcd_polya (A1_, A2_) =
  {one_gcd =
     one_poly
       ((comm_semiring_1_comm_semiring_1_cancel o
          comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
          idom_divide_factorial_ring_gcd)
         A1_),
    zero_gcd =
      zero_poly
        ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
           semiring_Gcd_factorial_semiring_gcd o
           factorial_semiring_gcd_factorial_ring_gcd)
          A1_),
    dvd_gcd =
      dvd_poly
        (A2_, (comm_semiring_1_comm_semiring_1_cancel o
                comm_semiring_1_cancel_semidom o semidom_idom o
                idom_idom_divide o idom_divide_factorial_ring_gcd)
                A1_,
          (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
            semiring_1_no_zero_divisors_semidom o semidom_idom o
            idom_idom_divide o idom_divide_factorial_ring_gcd)
            A1_),
    gcda = gcd_polyc (A1_, A2_), lcma = lcm_polya (A1_, A2_)}
  : 'a poly gcda;

fun lcm_poly (A1_, A2_) x = dummy_Lcm (gcd_poly (A1_, A2_)) x
and gcd_poly (A1_, A2_) =
  {gcd_Gcd = gcd_polya (A1_, A2_), gcd = gcd_polyb A1_,
    lcm = lcm_poly (A1_, A2_)}
  : 'a poly gcd;

fun mult_zero_poly (A1_, A2_, A3_) =
  {times_mult_zero = times_poly (A1_, A2_, A3_),
    zero_mult_zero =
      zero_poly
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_comm_semiring_0)
          A2_)}
  : 'a poly mult_zero;

fun semigroup_mult_poly (A1_, A2_, A3_) =
  {times_semigroup_mult = times_poly (A1_, A2_, A3_)} : 'a poly semigroup_mult;

fun semiring_poly (A1_, A2_, A3_) =
  {ab_semigroup_add_semiring =
     ab_semigroup_add_poly
       ((comm_monoid_add_semiring_0 o semiring_0_comm_semiring_0) A2_, A1_),
    semigroup_mult_semiring = semigroup_mult_poly (A1_, A2_, A3_)}
  : 'a poly semiring;

fun semiring_0_poly (A1_, A2_, A3_) =
  {comm_monoid_add_semiring_0 =
     comm_monoid_add_poly
       ((comm_monoid_add_semiring_0 o semiring_0_comm_semiring_0) A2_, A1_),
    mult_zero_semiring_0 = mult_zero_poly (A1_, A2_, A3_),
    semiring_semiring_0 = semiring_poly (A1_, A2_, A3_)}
  : 'a poly semiring_0;

fun semiring_no_zero_divisors_poly (A1_, A2_, A3_) =
  {semiring_0_semiring_no_zero_divisors = semiring_0_poly (A1_, A2_, A3_)} :
  'a poly semiring_no_zero_divisors;

fun semiring_no_zero_divisors_cancel_poly (A1_, A2_) =
  {semiring_no_zero_divisors_semiring_no_zero_divisors_cancel =
     semiring_no_zero_divisors_poly
       (A1_, (comm_semiring_0_comm_semiring_1 o
               comm_semiring_1_comm_semiring_1_cancel o
               comm_semiring_1_cancel_semidom o semidom_idom)
               A2_,
         (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
           semiring_1_no_zero_divisors_semidom o semidom_idom)
           A2_)}
  : 'a poly semiring_no_zero_divisors_cancel;

fun power_poly (A1_, A2_, A3_) =
  {one_power = one_poly A2_,
    times_power = times_poly (A1_, comm_semiring_0_comm_semiring_1 A2_, A3_)}
  : 'a poly power;

fun monoid_mult_poly (A1_, A2_, A3_) =
  {semigroup_mult_monoid_mult =
     semigroup_mult_poly (A1_, comm_semiring_0_comm_semiring_1 A2_, A3_),
    power_monoid_mult = power_poly (A1_, A2_, A3_)}
  : 'a poly monoid_mult;

fun numeral_poly (A1_, A2_) =
  {one_numeral = one_poly A2_,
    semigroup_add_numeral =
      semigroup_add_poly
        ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1)
           A2_,
          A1_)}
  : 'a poly numeral;

fun semiring_numeral_poly (A1_, A2_, A3_) =
  {monoid_mult_semiring_numeral = monoid_mult_poly (A1_, A2_, A3_),
    numeral_semiring_numeral = numeral_poly (A1_, A2_),
    semiring_semiring_numeral =
      semiring_poly (A1_, comm_semiring_0_comm_semiring_1 A2_, A3_)}
  : 'a poly semiring_numeral;

fun zero_neq_one_poly A_ =
  {one_zero_neq_one = one_poly A_,
    zero_zero_neq_one =
      zero_poly
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1)
          A_)}
  : 'a poly zero_neq_one;

fun semiring_1_poly (A1_, A2_, A3_) =
  {semiring_numeral_semiring_1 = semiring_numeral_poly (A1_, A2_, A3_),
    semiring_0_semiring_1 =
      semiring_0_poly (A1_, comm_semiring_0_comm_semiring_1 A2_, A3_),
    zero_neq_one_semiring_1 = zero_neq_one_poly A2_}
  : 'a poly semiring_1;

fun semiring_1_no_zero_divisors_poly (A1_, A2_, A3_) =
  {semiring_1_semiring_1_no_zero_divisors =
     semiring_1_poly
       (A1_, A2_, semiring_no_zero_divisors_semiring_1_no_zero_divisors A3_),
    semiring_no_zero_divisors_semiring_1_no_zero_divisors =
      semiring_no_zero_divisors_poly
        (A1_, comm_semiring_0_comm_semiring_1 A2_,
          semiring_no_zero_divisors_semiring_1_no_zero_divisors A3_)}
  : 'a poly semiring_1_no_zero_divisors;

fun cancel_semigroup_add_poly (A1_, A2_) =
  {semigroup_add_cancel_semigroup_add =
     semigroup_add_poly (comm_monoid_add_cancel_comm_monoid_add A1_, A2_)}
  : 'a poly cancel_semigroup_add;

fun minus_poly (A1_, A2_) = {minus = minus_polya (A1_, A2_)} : 'a poly minus;

fun cancel_ab_semigroup_add_poly (A1_, A2_) =
  {ab_semigroup_add_cancel_ab_semigroup_add =
     ab_semigroup_add_poly
       ((comm_monoid_add_cancel_comm_monoid_add o
          cancel_comm_monoid_add_ab_group_add)
          A1_,
         A2_),
    cancel_semigroup_add_cancel_ab_semigroup_add =
      cancel_semigroup_add_poly (cancel_comm_monoid_add_ab_group_add A1_, A2_),
    minus_cancel_ab_semigroup_add = minus_poly (A1_, A2_)}
  : 'a poly cancel_ab_semigroup_add;

fun cancel_comm_monoid_add_poly (A1_, A2_) =
  {cancel_ab_semigroup_add_cancel_comm_monoid_add =
     cancel_ab_semigroup_add_poly (A1_, A2_),
    comm_monoid_add_cancel_comm_monoid_add =
      comm_monoid_add_poly
        ((comm_monoid_add_cancel_comm_monoid_add o
           cancel_comm_monoid_add_ab_group_add)
           A1_,
          A2_)}
  : 'a poly cancel_comm_monoid_add;

fun semiring_0_cancel_poly (A1_, A2_, A3_, A4_) =
  {cancel_comm_monoid_add_semiring_0_cancel =
     cancel_comm_monoid_add_poly (A1_, A2_),
    semiring_0_semiring_0_cancel =
      semiring_0_poly (A2_, comm_semiring_0_comm_semiring_0_cancel A3_, A4_)}
  : 'a poly semiring_0_cancel;

fun ab_semigroup_mult_poly (A1_, A2_, A3_) =
  {semigroup_mult_ab_semigroup_mult = semigroup_mult_poly (A1_, A2_, A3_)} :
  'a poly ab_semigroup_mult;

fun comm_semiring_poly (A1_, A2_, A3_) =
  {ab_semigroup_mult_comm_semiring = ab_semigroup_mult_poly (A1_, A2_, A3_),
    semiring_comm_semiring = semiring_poly (A1_, A2_, A3_)}
  : 'a poly comm_semiring;

fun comm_semiring_0_poly (A1_, A2_, A3_) =
  {comm_semiring_comm_semiring_0 = comm_semiring_poly (A1_, A2_, A3_),
    semiring_0_comm_semiring_0 = semiring_0_poly (A1_, A2_, A3_)}
  : 'a poly comm_semiring_0;

fun comm_semiring_0_cancel_poly (A1_, A2_, A3_, A4_) =
  {comm_semiring_0_comm_semiring_0_cancel =
     comm_semiring_0_poly
       (A2_, comm_semiring_0_comm_semiring_0_cancel A3_, A4_),
    semiring_0_cancel_comm_semiring_0_cancel =
      semiring_0_cancel_poly (A1_, A2_, A3_, A4_)}
  : 'a poly comm_semiring_0_cancel;

fun semiring_1_cancel_poly (A1_, A2_, A3_) =
  {semiring_0_cancel_semiring_1_cancel =
     semiring_0_cancel_poly
       ((ab_group_add_ring o ring_ring_1 o ring_1_comm_ring_1) A2_, A1_,
         (comm_semiring_0_cancel_comm_ring o comm_ring_comm_ring_1) A2_, A3_),
    semiring_1_semiring_1_cancel =
      semiring_1_poly
        (A1_, (comm_semiring_1_comm_semiring_1_cancel o
                comm_semiring_1_cancel_comm_ring_1)
                A2_,
          A3_)}
  : 'a poly semiring_1_cancel;

fun comm_monoid_mult_poly (A1_, A2_, A3_) =
  {ab_semigroup_mult_comm_monoid_mult =
     ab_semigroup_mult_poly (A1_, comm_semiring_0_comm_semiring_1 A2_, A3_),
    monoid_mult_comm_monoid_mult = monoid_mult_poly (A1_, A2_, A3_),
    dvd_comm_monoid_mult = dvd_poly (A1_, A2_, A3_)}
  : 'a poly comm_monoid_mult;

fun comm_semiring_1_poly (A1_, A2_, A3_) =
  {comm_monoid_mult_comm_semiring_1 = comm_monoid_mult_poly (A1_, A2_, A3_),
    comm_semiring_0_comm_semiring_1 =
      comm_semiring_0_poly (A1_, comm_semiring_0_comm_semiring_1 A2_, A3_),
    semiring_1_comm_semiring_1 = semiring_1_poly (A1_, A2_, A3_)}
  : 'a poly comm_semiring_1;

fun comm_semiring_1_cancel_poly (A1_, A2_, A3_) =
  {comm_semiring_0_cancel_comm_semiring_1_cancel =
     comm_semiring_0_cancel_poly
       ((ab_group_add_ring o ring_ring_1 o ring_1_comm_ring_1) A2_, A1_,
         (comm_semiring_0_cancel_comm_ring o comm_ring_comm_ring_1) A2_, A3_),
    comm_semiring_1_comm_semiring_1_cancel =
      comm_semiring_1_poly
        (A1_, (comm_semiring_1_comm_semiring_1_cancel o
                comm_semiring_1_cancel_comm_ring_1)
                A2_,
          A3_),
    semiring_1_cancel_comm_semiring_1_cancel =
      semiring_1_cancel_poly (A1_, A2_, A3_)}
  : 'a poly comm_semiring_1_cancel;

fun semidom_poly (A1_, A2_) =
  {comm_semiring_1_cancel_semidom =
     comm_semiring_1_cancel_poly
       (A1_, comm_ring_1_idom A2_,
         (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
           semiring_1_no_zero_divisors_semidom o semidom_idom)
           A2_),
    semiring_1_no_zero_divisors_semidom =
      semiring_1_no_zero_divisors_poly
        (A1_, (comm_semiring_1_comm_semiring_1_cancel o
                comm_semiring_1_cancel_semidom o semidom_idom)
                A2_,
          (semiring_1_no_zero_divisors_semidom o semidom_idom) A2_)}
  : 'a poly semidom;

fun divide_poly (A1_, A2_) = {divide = divide_polya (A1_, A2_)} :
  'a poly divide;

fun semidom_divide_poly (A1_, A2_) =
  {divide_semidom_divide = divide_poly (A1_, A2_),
    semidom_semidom_divide = semidom_poly (A1_, idom_idom_divide A2_),
    semiring_no_zero_divisors_cancel_semidom_divide =
      semiring_no_zero_divisors_cancel_poly (A1_, idom_idom_divide A2_)}
  : 'a poly semidom_divide;

fun unit_factor_poly (A1_, A2_, A3_) =
  {unit_factor = unit_factor_polya (A1_, A2_, A3_)} : 'a poly unit_factor;

fun semidom_divide_unit_factor_poly (A1_, A2_, A3_) =
  {semidom_divide_semidom_divide_unit_factor = semidom_divide_poly (A1_, A2_),
    unit_factor_semidom_divide_unit_factor = unit_factor_poly (A1_, A2_, A3_)}
  : 'a poly semidom_divide_unit_factor;

fun algebraic_semidom_poly (A1_, A2_) =
  {semidom_divide_algebraic_semidom = semidom_divide_poly (A1_, A2_)} :
  'a poly algebraic_semidom;

fun normalization_semidom_poly (A1_, A2_, A3_) =
  {algebraic_semidom_normalization_semidom = algebraic_semidom_poly (A1_, A2_),
    semidom_divide_unit_factor_normalization_semidom =
      semidom_divide_unit_factor_poly (A1_, A2_, A3_),
    normalizeb = normalize_poly (A1_, A2_, A3_)}
  : 'a poly normalization_semidom;

fun factorial_semiring_poly (A1_, A2_) =
  {normalization_semidom_factorial_semiring =
     normalization_semidom_poly
       (A2_, idom_divide_factorial_ring_gcd A1_,
         (semidom_divide_unit_factor_normalization_semidom o
           normalization_semidom_semiring_gcd o semiring_gcd_ring_gcd o
           ring_gcd_factorial_ring_gcd)
           A1_)}
  : 'a poly factorial_semiring;

fun comm_monoid_gcd_poly (A1_, A2_) =
  {gcd_comm_monoid_gcd = gcd_polya (A1_, A2_),
    comm_semiring_1_comm_monoid_gcd =
      comm_semiring_1_poly
        (A2_, (comm_semiring_1_comm_semiring_1_cancel o
                comm_semiring_1_cancel_semidom o semidom_idom o
                idom_idom_divide o idom_divide_factorial_ring_gcd)
                A1_,
          (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
            semiring_1_no_zero_divisors_semidom o semidom_idom o
            idom_idom_divide o idom_divide_factorial_ring_gcd)
            A1_)}
  : 'a poly comm_monoid_gcd;

fun semiring_gcd_poly (A1_, A2_) =
  {normalization_semidom_semiring_gcd =
     normalization_semidom_poly
       (A2_, idom_divide_factorial_ring_gcd A1_,
         (semidom_divide_unit_factor_normalization_semidom o
           normalization_semidom_semiring_gcd o semiring_gcd_ring_gcd o
           ring_gcd_factorial_ring_gcd)
           A1_),
    comm_monoid_gcd_semiring_gcd = comm_monoid_gcd_poly (A1_, A2_)}
  : 'a poly semiring_gcd;

fun semiring_Gcd_poly (A1_, A2_) =
  {gcd_semiring_Gcd = gcd_poly (A1_, A2_),
    semiring_gcd_semiring_Gcd = semiring_gcd_poly (A1_, A2_)}
  : 'a poly semiring_Gcd;

fun factorial_semiring_gcd_poly (A1_, A2_) =
  {factorial_semiring_factorial_semiring_gcd =
     factorial_semiring_poly (A1_, A2_),
    semiring_Gcd_factorial_semiring_gcd = semiring_Gcd_poly (A1_, A2_)}
  : 'a poly factorial_semiring_gcd;

fun comm_semiring_1_cancel_crossproduct_poly (A1_, A2_) =
  {comm_semiring_1_cancel_comm_semiring_1_cancel_crossproduct =
     comm_semiring_1_cancel_poly
       (A1_, comm_ring_1_idom A2_,
         (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
           semiring_1_no_zero_divisors_semidom o semidom_idom)
           A2_)}
  : 'a poly comm_semiring_1_cancel_crossproduct;

fun uminus_poly A_ = {uminus = uminus_polya A_} : 'a poly uminus;

fun group_add_poly (A1_, A2_) =
  {cancel_semigroup_add_group_add =
     cancel_semigroup_add_poly (cancel_comm_monoid_add_ab_group_add A1_, A2_),
    minus_group_add = minus_poly (A1_, A2_),
    monoid_add_group_add =
      monoid_add_poly
        ((comm_monoid_add_cancel_comm_monoid_add o
           cancel_comm_monoid_add_ab_group_add)
           A1_,
          A2_),
    uminus_group_add = uminus_poly A1_}
  : 'a poly group_add;

fun ab_group_add_poly (A1_, A2_) =
  {cancel_comm_monoid_add_ab_group_add = cancel_comm_monoid_add_poly (A1_, A2_),
    group_add_ab_group_add = group_add_poly (A1_, A2_)}
  : 'a poly ab_group_add;

fun ring_poly (A1_, A2_, A3_) =
  {ab_group_add_ring =
     ab_group_add_poly ((ab_group_add_ring o ring_comm_ring) A2_, A1_),
    semiring_0_cancel_ring =
      semiring_0_cancel_poly
        ((ab_group_add_ring o ring_comm_ring) A2_, A1_,
          comm_semiring_0_cancel_comm_ring A2_, A3_)}
  : 'a poly ring;

fun ring_no_zero_divisors_poly (A1_, A2_) =
  {ring_ring_no_zero_divisors =
     ring_poly
       (A1_, (comm_ring_comm_ring_1 o comm_ring_1_idom) A2_,
         (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
           semiring_1_no_zero_divisors_semidom o semidom_idom)
           A2_),
    semiring_no_zero_divisors_cancel_ring_no_zero_divisors =
      semiring_no_zero_divisors_cancel_poly (A1_, A2_)}
  : 'a poly ring_no_zero_divisors;

fun neg_numeral_poly (A1_, A2_) =
  {group_add_neg_numeral =
     group_add_poly
       ((ab_group_add_ring o ring_ring_1 o ring_1_comm_ring_1) A2_, A1_),
    numeral_neg_numeral =
      numeral_poly
        (A1_, (comm_semiring_1_comm_semiring_1_cancel o
                comm_semiring_1_cancel_comm_ring_1)
                A2_)}
  : 'a poly neg_numeral;

fun ring_1_poly (A1_, A2_, A3_) =
  {neg_numeral_ring_1 = neg_numeral_poly (A1_, A2_),
    ring_ring_1 = ring_poly (A1_, comm_ring_comm_ring_1 A2_, A3_),
    semiring_1_cancel_ring_1 = semiring_1_cancel_poly (A1_, A2_, A3_)}
  : 'a poly ring_1;

fun ring_1_no_zero_divisors_poly (A1_, A2_) =
  {ring_1_ring_1_no_zero_divisors =
     ring_1_poly
       (A1_, comm_ring_1_idom A2_,
         (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
           semiring_1_no_zero_divisors_semidom o semidom_idom)
           A2_),
    ring_no_zero_divisors_ring_1_no_zero_divisors =
      ring_no_zero_divisors_poly (A1_, A2_),
    semiring_1_no_zero_divisors_ring_1_no_zero_divisors =
      semiring_1_no_zero_divisors_poly
        (A1_, (comm_semiring_1_comm_semiring_1_cancel o
                comm_semiring_1_cancel_semidom o semidom_idom)
                A2_,
          (semiring_1_no_zero_divisors_semidom o semidom_idom) A2_)}
  : 'a poly ring_1_no_zero_divisors;

fun comm_ring_poly (A1_, A2_, A3_) =
  {comm_semiring_0_cancel_comm_ring =
     comm_semiring_0_cancel_poly
       ((ab_group_add_ring o ring_comm_ring) A2_, A1_,
         comm_semiring_0_cancel_comm_ring A2_, A3_),
    ring_comm_ring = ring_poly (A1_, A2_, A3_)}
  : 'a poly comm_ring;

fun comm_ring_1_poly (A1_, A2_, A3_) =
  {comm_ring_comm_ring_1 = comm_ring_poly (A1_, comm_ring_comm_ring_1 A2_, A3_),
    comm_semiring_1_cancel_comm_ring_1 =
      comm_semiring_1_cancel_poly (A1_, A2_, A3_),
    ring_1_comm_ring_1 = ring_1_poly (A1_, A2_, A3_)}
  : 'a poly comm_ring_1;

fun idom_poly (A1_, A2_) =
  {comm_ring_1_idom =
     comm_ring_1_poly
       (A1_, comm_ring_1_idom A2_,
         (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
           semiring_1_no_zero_divisors_semidom o semidom_idom)
           A2_),
    ring_1_no_zero_divisors_idom = ring_1_no_zero_divisors_poly (A1_, A2_),
    semidom_idom = semidom_poly (A1_, A2_),
    comm_semiring_1_cancel_crossproduct_idom =
      comm_semiring_1_cancel_crossproduct_poly (A1_, A2_)}
  : 'a poly idom;

fun idom_divide_poly (A1_, A2_) =
  {idom_idom_divide = idom_poly (A1_, idom_idom_divide A2_),
    semidom_divide_idom_divide = semidom_divide_poly (A1_, A2_)}
  : 'a poly idom_divide;

fun idom_gcd_poly (A1_, A2_) =
  {idom_idom_gcd =
     idom_poly (A2_, (idom_idom_divide o idom_divide_factorial_ring_gcd) A1_),
    comm_monoid_gcd_idom_gcd = comm_monoid_gcd_poly (A1_, A2_)}
  : 'a poly idom_gcd;

fun ring_gcd_poly (A1_, A2_) =
  {semiring_gcd_ring_gcd = semiring_gcd_poly (A1_, A2_),
    idom_gcd_ring_gcd = idom_gcd_poly (A1_, A2_)}
  : 'a poly ring_gcd;

fun factorial_ring_gcd_poly (A1_, A2_) =
  {factorial_semiring_gcd_factorial_ring_gcd =
     factorial_semiring_gcd_poly (A1_, A2_),
    ring_gcd_factorial_ring_gcd = ring_gcd_poly (A1_, A2_),
    idom_divide_factorial_ring_gcd =
      idom_divide_poly (A2_, idom_divide_factorial_ring_gcd A1_)}
  : 'a poly factorial_ring_gcd;

fun poly_div (A1_, A2_) p q =
  resultant
    (factorial_ring_gcd_poly (A1_, A2_),
      equal_poly
        ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
           semiring_Gcd_factorial_semiring_gcd o
           factorial_semiring_gcd_factorial_ring_gcd)
           A1_,
          A2_))
    (poly_x_mult_y
      ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
         semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
         comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
         idom_divide_factorial_ring_gcd)
         A1_,
        A2_)
      p)
    (poly_lift
      ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
         semiring_Gcd_factorial_semiring_gcd o
         factorial_semiring_gcd_factorial_ring_gcd)
         A1_,
        A2_)
      q);

fun poly_multa (A1_, A2_) p q =
  poly_div (A1_, A2_) p
    (reflect_poly
      ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
         semiring_Gcd_factorial_semiring_gcd o
         factorial_semiring_gcd_factorial_ring_gcd)
         A1_,
        A2_)
      q);

fun mult_1_pos (p1, (l1, r1)) (p2, (l2, r2)) =
  select_correct_factor_int_poly (tighten_poly_bounds_binary p1 p2)
    (fn (a, b) =>
      let
        val (l1a, (r1a, _)) = a;
      in
        (fn (l2a, (r2a, _)) => (times_rata l1a l2a, times_rata r1a r2a))
      end
        b)
    ((l1, (r1, sgn_rata
                 (fold_coeffs zero_int
                   (fn a => fn b => plus_rata (of_int a) (times_rata r1 b)) p1
                   zero_rata))),
      (l2, (r2, sgn_rata
                  (fold_coeffs zero_int
                    (fn a => fn b => plus_rata (of_int a) (times_rata r2 b)) p2
                    zero_rata))))
    (poly_multa (factorial_ring_gcd_int, equal_int) p1 p2);

fun mult_1 x y =
  let
    val ((_, (_, r1)), (_, (_, r2))) = (x, y);
  in
    (if less_rat zero_rata r1
      then (if less_rat zero_rata r2 then mult_1_pos x y
             else uminus_2 (mult_1_pos x (uminus_1 y)))
      else (if less_rat zero_rata r2 then uminus_2 (mult_1_pos (uminus_1 x) y)
             else mult_1_pos (uminus_1 x) (uminus_1 y)))
  end;

fun mult_2 (Rationala r) (Rationala q) = Rationala (times_rata r q)
  | mult_2 (Rationala r) (Irrational (n, y)) = mult_rat_1 r y
  | mult_2 (Irrational (n, x)) (Rationala q) = mult_rat_1 q x
  | mult_2 (Irrational (n, x)) (Irrational (m, y)) = mult_1 x y;

fun mult_3 xb xc =
  Real_Alg_Invariant (mult_2 (rep_real_alg_3 xb) (rep_real_alg_3 xc));

fun times_real_alg (Real_Alg_Quotient xa) (Real_Alg_Quotient x) =
  Real_Alg_Quotient (mult_3 xa x);

fun divide_real_alg x y = times_real_alg x (inverse_real_alg y);

fun divide_reala (Real_of x) (Real_of y) = Real_of (divide_real_alg x y);

fun times_reala (Real_of x) (Real_of y) = Real_of (times_real_alg x y);

fun pcompose (A1_, A2_, A3_) p q =
  fold_coeffs
    ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_comm_semiring_0) A2_)
    (fn a => fn c =>
      plus_polya
        ((comm_monoid_add_semiring_0 o semiring_0_comm_semiring_0) A2_, A1_)
        (pCons
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_comm_semiring_0)
             A2_,
            A1_)
          a (zero_polyb
              ((zero_mult_zero o mult_zero_semiring_0 o
                 semiring_0_comm_semiring_0)
                A2_)))
        (times_polya (A1_, A2_, A3_) q c))
    p (zero_polyb
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_comm_semiring_0)
          A2_));

fun poly_add_rat r p =
  let
    val (n, d) = quotient_of r;
    val pa =
      let
        val fs = coeffs zero_int p;
        val k = size_list fs;
      in
        poly_of_list (comm_monoid_add_int, equal_int)
          (map (fn (fi, i) =>
                 times_inta fi
                   (binary_power monoid_mult_int d (minus_nata k (suc i))))
            (zip fs (upt zero_nata k)))
      end;
    val pb =
      pcompose (equal_int, comm_semiring_0_int, semiring_no_zero_divisors_int)
        pa (pCons (zero_int, equal_int) (uminus_inta n)
             (pCons (zero_int, equal_int) d (zero_polyb zero_int)));
  in
    pb
  end;

fun add_rat_1 r1 (p2, (l2, r2)) =
  let
    val p = cf_pos_poly (poly_add_rat r1 p2);
    val (l, (r, _)) =
      tighten_poly_bounds_for_x p zero_rata (plus_rata l2 r1) (plus_rata r2 r1)
        (sgn_rata
          (fold_coeffs zero_int
            (fn a => fn b =>
              plus_rata (of_int a) (times_rata (plus_rata r2 r1) b))
            p zero_rata));
  in
    (p, (l, r))
  end;

fun x_y (A1_, A2_, A3_) =
  pCons (zero_poly
           ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add)
             A1_),
          equal_poly
            ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add)
               A1_,
              A2_))
    (pCons
      ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add) A1_,
        A2_)
      (zerob
        ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add) A1_))
      (pCons
        ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add) A1_,
          A2_)
        (onea ((one_numeral o numeral_semiring_numeral o
                 semiring_numeral_semiring_1 o semiring_1_comm_semiring_1)
                A3_))
        (zero_polyb
          ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add)
            A1_))))
    (pCons
      (zero_poly
         ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add)
           A1_),
        equal_poly
          ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add)
             A1_,
            A2_))
      (uminus_polya A1_ (one_polyb A3_))
      (zero_polyb
        (zero_poly
          ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add)
            A1_))));

fun poly_x_minus_y (A1_, A2_, A3_, A4_) p =
  pcompose
    (equal_poly
       ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_comm_semiring_0 o
          comm_semiring_0_comm_semiring_1)
          A3_,
         A2_),
      comm_semiring_0_poly (A2_, comm_semiring_0_comm_semiring_1 A3_, A4_),
      semiring_no_zero_divisors_poly
        (A2_, comm_semiring_0_comm_semiring_1 A3_, A4_))
    (poly_lift
      ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add) A1_,
        A2_)
      p)
    (x_y (A1_, A2_, A3_));

fun poly_adda (A1_, A2_) p q =
  resultant
    (factorial_ring_gcd_poly (A1_, A2_),
      equal_poly
        ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
           semiring_Gcd_factorial_semiring_gcd o
           factorial_semiring_gcd_factorial_ring_gcd)
           A1_,
          A2_))
    (poly_x_minus_y
      ((ab_group_add_ring o ring_ring_1 o ring_1_comm_ring_1 o
         comm_ring_1_idom o idom_idom_divide o idom_divide_factorial_ring_gcd)
         A1_,
        A2_,
        (comm_semiring_1_comm_semiring_1_cancel o
          comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
          idom_divide_factorial_ring_gcd)
          A1_,
        (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
          semiring_1_no_zero_divisors_semidom o semidom_idom o
          idom_idom_divide o idom_divide_factorial_ring_gcd)
          A1_)
      p)
    (poly_lift
      ((zero_gcd o gcd_Gcd o gcd_semiring_Gcd o
         semiring_Gcd_factorial_semiring_gcd o
         factorial_semiring_gcd_factorial_ring_gcd)
         A1_,
        A2_)
      q);

fun add_1 (p1, (l1, r1)) (p2, (l2, r2)) =
  select_correct_factor_int_poly (tighten_poly_bounds_binary p1 p2)
    (fn (a, b) =>
      let
        val (l1a, (r1a, _)) = a;
      in
        (fn (l2a, (r2a, _)) => (plus_rata l1a l2a, plus_rata r1a r2a))
      end
        b)
    ((l1, (r1, sgn_rata
                 (fold_coeffs zero_int
                   (fn a => fn b => plus_rata (of_int a) (times_rata r1 b)) p1
                   zero_rata))),
      (l2, (r2, sgn_rata
                  (fold_coeffs zero_int
                    (fn a => fn b => plus_rata (of_int a) (times_rata r2 b)) p2
                    zero_rata))))
    (poly_adda (factorial_ring_gcd_int, equal_int) p1 p2);

fun add_2 (Rationala r) (Rationala q) = Rationala (plus_rata r q)
  | add_2 (Rationala r) (Irrational (n, x)) = Irrational (n, add_rat_1 r x)
  | add_2 (Irrational (n, x)) (Rationala q) = Irrational (n, add_rat_1 q x)
  | add_2 (Irrational (n, x)) (Irrational (m, y)) = add_1 x y;

fun add_3 xb xc =
  Real_Alg_Invariant (add_2 (rep_real_alg_3 xb) (rep_real_alg_3 xc));

fun plus_real_alg (Real_Alg_Quotient xa) (Real_Alg_Quotient x) =
  Real_Alg_Quotient (add_3 xa x);

fun minus_real_alg x y = plus_real_alg x (uminus_real_alg y);

fun minus_reala (Real_of x) (Real_of y) = Real_of (minus_real_alg x y);

val zero_real_alg : real_alg = of_rat_real_alg zero_rata;

val zero_reala : real = Real_of zero_real_alg;

fun plus_reala (Real_of x) (Real_of y) = Real_of (plus_real_alg x y);

val one_real_alg : real_alg = of_rat_real_alg one_rata;

val one_reala : real = Real_of one_real_alg;

val plus_real = {plus = plus_reala} : real plus;

val semigroup_add_real = {plus_semigroup_add = plus_real} : real semigroup_add;

val cancel_semigroup_add_real =
  {semigroup_add_cancel_semigroup_add = semigroup_add_real} :
  real cancel_semigroup_add;

val ab_semigroup_add_real =
  {semigroup_add_ab_semigroup_add = semigroup_add_real} : real ab_semigroup_add;

val minus_real = {minus = minus_reala} : real minus;

val cancel_ab_semigroup_add_real =
  {ab_semigroup_add_cancel_ab_semigroup_add = ab_semigroup_add_real,
    cancel_semigroup_add_cancel_ab_semigroup_add = cancel_semigroup_add_real,
    minus_cancel_ab_semigroup_add = minus_real}
  : real cancel_ab_semigroup_add;

val zero_real = {zerob = zero_reala} : real zero;

val monoid_add_real =
  {semigroup_add_monoid_add = semigroup_add_real, zero_monoid_add = zero_real} :
  real monoid_add;

val comm_monoid_add_real =
  {ab_semigroup_add_comm_monoid_add = ab_semigroup_add_real,
    monoid_add_comm_monoid_add = monoid_add_real}
  : real comm_monoid_add;

val cancel_comm_monoid_add_real =
  {cancel_ab_semigroup_add_cancel_comm_monoid_add =
     cancel_ab_semigroup_add_real,
    comm_monoid_add_cancel_comm_monoid_add = comm_monoid_add_real}
  : real cancel_comm_monoid_add;

val times_real = {times = times_reala} : real times;

val mult_zero_real = {times_mult_zero = times_real, zero_mult_zero = zero_real}
  : real mult_zero;

val semigroup_mult_real = {times_semigroup_mult = times_real} :
  real semigroup_mult;

val semiring_real =
  {ab_semigroup_add_semiring = ab_semigroup_add_real,
    semigroup_mult_semiring = semigroup_mult_real}
  : real semiring;

val semiring_0_real =
  {comm_monoid_add_semiring_0 = comm_monoid_add_real,
    mult_zero_semiring_0 = mult_zero_real, semiring_semiring_0 = semiring_real}
  : real semiring_0;

val semiring_0_cancel_real =
  {cancel_comm_monoid_add_semiring_0_cancel = cancel_comm_monoid_add_real,
    semiring_0_semiring_0_cancel = semiring_0_real}
  : real semiring_0_cancel;

val ab_semigroup_mult_real =
  {semigroup_mult_ab_semigroup_mult = semigroup_mult_real} :
  real ab_semigroup_mult;

val comm_semiring_real =
  {ab_semigroup_mult_comm_semiring = ab_semigroup_mult_real,
    semiring_comm_semiring = semiring_real}
  : real comm_semiring;

val comm_semiring_0_real =
  {comm_semiring_comm_semiring_0 = comm_semiring_real,
    semiring_0_comm_semiring_0 = semiring_0_real}
  : real comm_semiring_0;

val comm_semiring_0_cancel_real =
  {comm_semiring_0_comm_semiring_0_cancel = comm_semiring_0_real,
    semiring_0_cancel_comm_semiring_0_cancel = semiring_0_cancel_real}
  : real comm_semiring_0_cancel;

val one_real = {onea = one_reala} : real one;

val power_real = {one_power = one_real, times_power = times_real} : real power;

val monoid_mult_real =
  {semigroup_mult_monoid_mult = semigroup_mult_real,
    power_monoid_mult = power_real}
  : real monoid_mult;

val numeral_real =
  {one_numeral = one_real, semigroup_add_numeral = semigroup_add_real} :
  real numeral;

val semiring_numeral_real =
  {monoid_mult_semiring_numeral = monoid_mult_real,
    numeral_semiring_numeral = numeral_real,
    semiring_semiring_numeral = semiring_real}
  : real semiring_numeral;

val zero_neq_one_real =
  {one_zero_neq_one = one_real, zero_zero_neq_one = zero_real} :
  real zero_neq_one;

val semiring_1_real =
  {semiring_numeral_semiring_1 = semiring_numeral_real,
    semiring_0_semiring_1 = semiring_0_real,
    zero_neq_one_semiring_1 = zero_neq_one_real}
  : real semiring_1;

val semiring_1_cancel_real =
  {semiring_0_cancel_semiring_1_cancel = semiring_0_cancel_real,
    semiring_1_semiring_1_cancel = semiring_1_real}
  : real semiring_1_cancel;

val dvd_real = {times_dvd = times_real} : real dvd;

val comm_monoid_mult_real =
  {ab_semigroup_mult_comm_monoid_mult = ab_semigroup_mult_real,
    monoid_mult_comm_monoid_mult = monoid_mult_real,
    dvd_comm_monoid_mult = dvd_real}
  : real comm_monoid_mult;

val comm_semiring_1_real =
  {comm_monoid_mult_comm_semiring_1 = comm_monoid_mult_real,
    comm_semiring_0_comm_semiring_1 = comm_semiring_0_real,
    semiring_1_comm_semiring_1 = semiring_1_real}
  : real comm_semiring_1;

val comm_semiring_1_cancel_real =
  {comm_semiring_0_cancel_comm_semiring_1_cancel = comm_semiring_0_cancel_real,
    comm_semiring_1_comm_semiring_1_cancel = comm_semiring_1_real,
    semiring_1_cancel_comm_semiring_1_cancel = semiring_1_cancel_real}
  : real comm_semiring_1_cancel;

val comm_semiring_1_cancel_crossproduct_real =
  {comm_semiring_1_cancel_comm_semiring_1_cancel_crossproduct =
     comm_semiring_1_cancel_real}
  : real comm_semiring_1_cancel_crossproduct;

val semiring_no_zero_divisors_real =
  {semiring_0_semiring_no_zero_divisors = semiring_0_real} :
  real semiring_no_zero_divisors;

val semiring_1_no_zero_divisors_real =
  {semiring_1_semiring_1_no_zero_divisors = semiring_1_real,
    semiring_no_zero_divisors_semiring_1_no_zero_divisors =
      semiring_no_zero_divisors_real}
  : real semiring_1_no_zero_divisors;

val semiring_no_zero_divisors_cancel_real =
  {semiring_no_zero_divisors_semiring_no_zero_divisors_cancel =
     semiring_no_zero_divisors_real}
  : real semiring_no_zero_divisors_cancel;

val uminus_real = {uminus = uminus_reala} : real uminus;

val group_add_real =
  {cancel_semigroup_add_group_add = cancel_semigroup_add_real,
    minus_group_add = minus_real, monoid_add_group_add = monoid_add_real,
    uminus_group_add = uminus_real}
  : real group_add;

val ab_group_add_real =
  {cancel_comm_monoid_add_ab_group_add = cancel_comm_monoid_add_real,
    group_add_ab_group_add = group_add_real}
  : real ab_group_add;

val ring_real =
  {ab_group_add_ring = ab_group_add_real,
    semiring_0_cancel_ring = semiring_0_cancel_real}
  : real ring;

val ring_no_zero_divisors_real =
  {ring_ring_no_zero_divisors = ring_real,
    semiring_no_zero_divisors_cancel_ring_no_zero_divisors =
      semiring_no_zero_divisors_cancel_real}
  : real ring_no_zero_divisors;

val neg_numeral_real =
  {group_add_neg_numeral = group_add_real, numeral_neg_numeral = numeral_real} :
  real neg_numeral;

val ring_1_real =
  {neg_numeral_ring_1 = neg_numeral_real, ring_ring_1 = ring_real,
    semiring_1_cancel_ring_1 = semiring_1_cancel_real}
  : real ring_1;

val ring_1_no_zero_divisors_real =
  {ring_1_ring_1_no_zero_divisors = ring_1_real,
    ring_no_zero_divisors_ring_1_no_zero_divisors = ring_no_zero_divisors_real,
    semiring_1_no_zero_divisors_ring_1_no_zero_divisors =
      semiring_1_no_zero_divisors_real}
  : real ring_1_no_zero_divisors;

val comm_ring_real =
  {comm_semiring_0_cancel_comm_ring = comm_semiring_0_cancel_real,
    ring_comm_ring = ring_real}
  : real comm_ring;

val comm_ring_1_real =
  {comm_ring_comm_ring_1 = comm_ring_real,
    comm_semiring_1_cancel_comm_ring_1 = comm_semiring_1_cancel_real,
    ring_1_comm_ring_1 = ring_1_real}
  : real comm_ring_1;

val semidom_real =
  {comm_semiring_1_cancel_semidom = comm_semiring_1_cancel_real,
    semiring_1_no_zero_divisors_semidom = semiring_1_no_zero_divisors_real}
  : real semidom;

val idom_real =
  {comm_ring_1_idom = comm_ring_1_real,
    ring_1_no_zero_divisors_idom = ring_1_no_zero_divisors_real,
    semidom_idom = semidom_real,
    comm_semiring_1_cancel_crossproduct_idom =
      comm_semiring_1_cancel_crossproduct_real}
  : real idom;

val ufd_real = {idom_ufd = idom_real} : real ufd;

val divide_real = {divide = divide_reala} : real divide;

val inverse_real = {divide_inverse = divide_real, inverse = inverse_reala} :
  real inverse;

val division_ring_real =
  {inverse_division_ring = inverse_real,
    ring_1_no_zero_divisors_division_ring = ring_1_no_zero_divisors_real}
  : real division_ring;

val semidom_divide_real =
  {divide_semidom_divide = divide_real, semidom_semidom_divide = semidom_real,
    semiring_no_zero_divisors_cancel_semidom_divide =
      semiring_no_zero_divisors_cancel_real}
  : real semidom_divide;

val idom_divide_real =
  {idom_idom_divide = idom_real,
    semidom_divide_idom_divide = semidom_divide_real}
  : real idom_divide;

val field_real =
  {division_ring_field = division_ring_real,
    idom_divide_field = idom_divide_real, ufd_field = ufd_real}
  : real field;

fun equal_2 (Rationala r) (Rationala q) = equal_rata r q
  | equal_2 (Irrational (n, (p, uu))) (Irrational (m, (q, uv))) =
    equal_polya (zero_int, equal_int) p q andalso equal_nata n m
  | equal_2 (Rationala r) (Irrational (uw, yy)) = false
  | equal_2 (Irrational (ux, xx)) (Rationala q) = false;

fun equal_3 xa xc = equal_2 (rep_real_alg_3 xa) (rep_real_alg_3 xc);

fun equal_real_alg (Real_Alg_Quotient xc) (Real_Alg_Quotient xa) =
  equal_3 xc xa;

fun equal_reala (Real_of x) (Real_of y) = equal_real_alg x y;

val equal_real = {equal = equal_reala} : real equal;

fun euclidean_size_real x = euclidean_size_field (field_real, equal_real) x;

fun normalize_field (A1_, A2_) x =
  (if eq A2_ x
        (zerob
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_comm_semiring_1 o
             comm_semiring_1_comm_semiring_1_cancel o
             comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
             idom_divide_field)
            A1_))
    then zerob ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
                  semiring_1_comm_semiring_1 o
                  comm_semiring_1_comm_semiring_1_cancel o
                  comm_semiring_1_cancel_semidom o semidom_idom o
                  idom_idom_divide o idom_divide_field)
                 A1_)
    else onea ((one_numeral o numeral_neg_numeral o neg_numeral_ring_1 o
                 ring_1_comm_ring_1 o comm_ring_1_idom o idom_idom_divide o
                 idom_divide_field)
                A1_));

fun normalize_real x = normalize_field (field_real, equal_real) x;

fun unit_factor_field A_ x = x;

fun unit_factor_reala x = unit_factor_field field_real x;

fun mod_field (A1_, A2_) x y =
  (if eq A2_ y
        (zerob
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_comm_semiring_1 o
             comm_semiring_1_comm_semiring_1_cancel o
             comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
             idom_divide_field)
            A1_))
    then x
    else zerob ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
                  semiring_1_comm_semiring_1 o
                  comm_semiring_1_comm_semiring_1_cancel o
                  comm_semiring_1_cancel_semidom o semidom_idom o
                  idom_idom_divide o idom_divide_field)
                 A1_));

fun modulo_reala x = mod_field (field_real, equal_real) x;

val unit_factor_real = {unit_factor = unit_factor_reala} : real unit_factor;

val semidom_divide_unit_factor_real =
  {semidom_divide_semidom_divide_unit_factor = semidom_divide_real,
    unit_factor_semidom_divide_unit_factor = unit_factor_real}
  : real semidom_divide_unit_factor;

val algebraic_semidom_real =
  {semidom_divide_algebraic_semidom = semidom_divide_real} :
  real algebraic_semidom;

val normalization_semidom_real =
  {algebraic_semidom_normalization_semidom = algebraic_semidom_real,
    semidom_divide_unit_factor_normalization_semidom =
      semidom_divide_unit_factor_real,
    normalizeb = normalize_real}
  : real normalization_semidom;

val factorial_semiring_real =
  {normalization_semidom_factorial_semiring = normalization_semidom_real} :
  real factorial_semiring;

val modulo_real =
  {divide_modulo = divide_real, dvd_modulo = dvd_real, modulo = modulo_reala} :
  real modulo;

val semiring_modulo_real =
  {comm_semiring_1_cancel_semiring_modulo = comm_semiring_1_cancel_real,
    modulo_semiring_modulo = modulo_real}
  : real semiring_modulo;

val semidom_modulo_real =
  {algebraic_semidom_semidom_modulo = algebraic_semidom_real,
    semiring_modulo_semidom_modulo = semiring_modulo_real}
  : real semidom_modulo;

val euclidean_semiring_real =
  {semidom_modulo_euclidean_semiring = semidom_modulo_real,
    factorial_semiring_euclidean_semiring = factorial_semiring_real,
    euclidean_size = euclidean_size_real}
  : real euclidean_semiring;

fun lcm_reala x = lcmc (euclidean_semiring_real, equal_real) x;

fun gcd_realc x = gcdc (euclidean_semiring_real, equal_real) x;

fun lcmb _ = raise Fail "Euclidean_Algorithm.euclidean_semiring_class.Lcm";

fun lcm_real x = lcmb x;

fun gcdb _ = raise Fail "Euclidean_Algorithm.euclidean_semiring_class.Gcd";

fun gcd_realb x = gcdb x;

val gcd_reala =
  {one_gcd = one_real, zero_gcd = zero_real, dvd_gcd = dvd_real,
    gcda = gcd_realc, lcma = lcm_reala}
  : real gcda;

val gcd_real = {gcd_Gcd = gcd_reala, gcd = gcd_realb, lcm = lcm_real} :
  real gcd;

fun floor_1 (p, (l, r)) =
  let
    val (la, (ra, sr)) =
      tighten_poly_bounds_epsilon p
        (divide_rata one_rata (of_int (Int_of_integer (2 : IntInf.int)))) l r
        (sgn_rata
          (fold_coeffs zero_int
            (fn a => fn b => plus_rata (of_int a) (times_rata r b)) p
            zero_rata));
    val fr = floor_rat ra;
    val fl = floor_rat la;
    val fra = of_int fr;
  in
    (if equal_inta fr fl then fr
      else let
             val (lb, (_, _)) = tighten_poly_bounds_for_x p fra la ra sr;
           in
             (if less_rat fra lb then fr else fl)
           end)
  end;

fun floor_2 (Rationala r) = floor_rat r
  | floor_2 (Irrational (n, rai)) = floor_1 rai;

fun floor_3 xa = floor_2 (rep_real_alg_3 xa);

fun floor_real_alg (Real_Alg_Quotient xa) = floor_3 xa;

datatype ('a, 'b) sum = Inl of 'a | Inr of 'b;

fun info_2 (Rationala x) = Inl x
  | info_2 (Irrational (n, (p, (l, r)))) = Inr (p, n);

fun info_3 xa = info_2 (rep_real_alg_3 xa);

fun info_real_alg (Real_Alg_Quotient xa) = info_3 xa;

datatype real_alg_show_info = Rat_Info of rat | Sqrt_Info of rat * rat |
  Real_Alg_Info of int poly * nat;

fun convert_info (Inl q) = Rat_Info q
  | convert_info (Inr (f, n)) =
    (if equal_nata (degreea zero_int f) (nat_of_integer (2 : IntInf.int))
      then let
             val a = coeff zero_int f (nat_of_integer (2 : IntInf.int));
             val b = coeff zero_int f one_nata;
             val c = (case coeffs zero_int f of [] => zero_inta | x :: _ => x);
             val b2a =
               fract (uminus_inta b)
                 (times_inta (Int_of_integer (2 : IntInf.int)) a);
             val below =
               fract (minus_inta (times_inta b b)
                       (times_inta
                         (times_inta (Int_of_integer (4 : IntInf.int)) a) c))
                 (times_inta (times_inta (Int_of_integer (4 : IntInf.int)) a)
                   a);
           in
             Sqrt_Info
               (b2a, (if equal_nata n one_nata then uminus_rata below
                       else below))
           end
      else Real_Alg_Info (f, n));

fun real_alg_show_info x = convert_info (info_real_alg x);

fun show_factor va =
  (if equal_nata va zero_nata then []
    else (if equal_nata (minus_nata va one_nata) zero_nata then [#"x"]
           else [#"x", #"^"] @
                  shows_prec_nat zero_nata
                    (suc (suc (minus_nata (minus_nata va one_nata) one_nata)))
                    []));

fun show_coeff_factor (A1_, A2_, A3_) c n =
  (if equal_nata n zero_nata then shows_prec A3_ zero_nata c []
    else (if eq A2_ c (onea A1_) then show_factor n
           else shows_prec A3_ zero_nata c [] @ show_factor n));

fun show_poly_main (A1_, A2_, A3_, A4_) uu [] = [#"0"]
  | show_poly_main (A1_, A2_, A3_, A4_) n [c] =
    show_coeff_factor (A1_, A3_, A4_) c n
  | show_poly_main (A1_, A2_, A3_, A4_) n (c :: v :: va) =
    (if eq A3_ c (zerob A2_)
      then show_poly_main (A1_, A2_, A3_, A4_) (suc n) (v :: va)
      else show_coeff_factor (A1_, A3_, A4_) c n @
             [#" ", #"+", #" "] @
               show_poly_main (A1_, A2_, A3_, A4_) (suc n) (v :: va));

fun show_poly (A1_, A2_, A3_, A4_) p =
  show_poly_main (A1_, A2_, A3_, A4_) zero_nata (coeffs A2_ p);

fun showsp_poly (A1_, A2_, A3_, A4_) p x =
  shows_string (show_poly (A1_, A2_, A3_, A4_) x);

fun shows_prec_poly (A1_, A2_, A3_, A4_) p x =
  showsp_poly (A1_, A2_, A3_, A4_) p x;

fun show_rai_info fl (Rat_Info r) = shows_prec_rat zero_nata r []
  | show_rai_info fl (Sqrt_Info (r, sq)) =
    let
      val sqrt =
        [#"s", #"q", #"r", #"t", #"("] @
          shows_prec_rat zero_nata (abs_rata sq) [] @ [#")"];
    in
      (if equal_rata r zero_rata
        then (if less_rat sq zero_rata then [#" ", #"-"] else []) @ sqrt
        else [#"("] @
               shows_prec_rat zero_nata r [] @
                 (if less_rat sq zero_rata then [#"-"] else [#"+"]) @
                   sqrt @ [#")"])
    end
  | show_rai_info fl (Real_Alg_Info (p, n)) =
    [#"(", #"r", #"o", #"o", #"t", #" ", #"#"] @
      shows_prec_nat zero_nata n [] @
        [#" ", #"o", #"f", #" "] @
          shows_prec_poly (one_int, zero_int, equal_int, show_int) zero_nata p
            [] @
            [#",", #" ", #"i", #"n", #" ", #"("] @
              shows_prec_int zero_nata fl [] @
                [#","] @
                  shows_prec_int zero_nata (plus_inta fl one_inta) [] @
                    [#")", #")"];

fun show_real_alg x = show_rai_info (floor_real_alg x) (real_alg_show_info x);

fun show_reala (Real_of x) = show_real_alg x;

fun showsp_real p x y = show_reala x @ y;

fun shows_prec_real x = showsp_real x;

fun shows_list_real x = showsp_list shows_prec_real zero_nata x;

val show_real = {shows_prec = shows_prec_real, shows_list = shows_list_real} :
  real show;

fun compare_rat_1 x (p, (l, r)) =
  (if less_rat x l then Lt
    else (if less_rat r x then Gt
           else (if equal_rata
                      (sgn_rata
                        (fold_coeffs zero_int
                          (fn a => fn b =>
                            plus_rata (of_int a) (times_rata x b))
                          p zero_rata))
                      (sgn_rata
                        (fold_coeffs zero_int
                          (fn a => fn b =>
                            plus_rata (of_int a) (times_rata r b))
                          p zero_rata))
                  then Gt else Lt)));

fun compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =
  (if less_rat r1 l2 then Lt
    else (if less_rat r2 l1 then Gt
           else let
                  val (l1a, (r1a, sr1a)) = tighten_poly_bounds p1 l1 r1 sr1;
                  val a = tighten_poly_bounds p2 l2 r2 sr2;
                  val (l2a, aa) = a;
                  val (ab, b) = aa;
                in
                  compare_1 p1 p2 l1a r1a sr1a l2a ab b
                end));

fun invert_order Lt = Gt
  | invert_order Gt = Lt
  | invert_order Eq = Eq;

fun compare_2 (Rationala r) (Rationala q) = compare_rata r q
  | compare_2 (Irrational (n, (p, (la, ra)))) (Irrational (m, (q, (l, r)))) =
    (if equal_polya (zero_int, equal_int) p q andalso equal_nata n m then Eq
      else compare_1 p q la ra
             (sgn_rata
               (fold_coeffs zero_int
                 (fn a => fn b => plus_rata (of_int a) (times_rata ra b)) p
                 zero_rata))
             l r (sgn_rata
                   (fold_coeffs zero_int
                     (fn a => fn b => plus_rata (of_int a) (times_rata r b)) q
                     zero_rata)))
  | compare_2 (Rationala r) (Irrational (uu, xx)) = compare_rat_1 r xx
  | compare_2 (Irrational (uv, xx)) (Rationala r) =
    invert_order (compare_rat_1 r xx);

fun compare_3 xa xc = compare_2 (rep_real_alg_3 xa) (rep_real_alg_3 xc);

fun compare_real_alg (Real_Alg_Quotient xc) (Real_Alg_Quotient xa) =
  compare_3 xc xa;

fun less_real_alg x = lt_of_comp compare_real_alg x;

fun less_real (Real_of x) (Real_of y) = less_real_alg x y;

fun abs_real_alg x =
  (if less_real (Real_of x) zero_reala then uminus_real_alg x else x);

fun abs_reala (Real_of x) = Real_of (abs_real_alg x);

val abs_real = {abs = abs_reala} : real abs;

fun rai_ub (uu, (uv, r)) = r;

fun sgn_1 x = sgn_rata (rai_ub x);

fun sgn_2 (Rationala r) = sgn_rata r
  | sgn_2 (Irrational (n, rai)) = sgn_1 rai;

fun sgn_3 xa = sgn_2 (rep_real_alg_3 xa);

fun sgn_real_alg_rat (Real_Alg_Quotient xa) = sgn_3 xa;

fun sgn_real_alg x = of_rat_real_alg (sgn_real_alg_rat x);

fun sgn_reala (Real_of x) = Real_of (sgn_real_alg x);

val sgn_real = {sgn = sgn_reala} : real sgn;

val comm_monoid_gcd_real =
  {gcd_comm_monoid_gcd = gcd_reala,
    comm_semiring_1_comm_monoid_gcd = comm_semiring_1_real}
  : real comm_monoid_gcd;

val idom_gcd_real =
  {idom_idom_gcd = idom_real, comm_monoid_gcd_idom_gcd = comm_monoid_gcd_real} :
  real idom_gcd;

val semiring_gcd_real =
  {normalization_semidom_semiring_gcd = normalization_semidom_real,
    comm_monoid_gcd_semiring_gcd = comm_monoid_gcd_real}
  : real semiring_gcd;

val ring_gcd_real =
  {semiring_gcd_ring_gcd = semiring_gcd_real, idom_gcd_ring_gcd = idom_gcd_real}
  : real ring_gcd;

fun less_eq_real_alg x = le_of_comp compare_real_alg x;

fun less_eq_real (Real_of x) (Real_of y) = less_eq_real_alg x y;

val ord_real = {less_eq = less_eq_real, less = less_real} : real ord;

val abs_if_real =
  {abs_abs_if = abs_real, minus_abs_if = minus_real,
    uminus_abs_if = uminus_real, zero_abs_if = zero_real, ord_abs_if = ord_real}
  : real abs_if;

fun compare_reala (Real_of x) (Real_of y) = compare_real_alg x y;

val compare_real = {compare = compare_reala} : real compare;

val semiring_char_0_real = {semiring_1_semiring_char_0 = semiring_1_real} :
  real semiring_char_0;

val ring_char_0_real =
  {semiring_char_0_ring_char_0 = semiring_char_0_real,
    ring_1_ring_char_0 = ring_1_real}
  : real ring_char_0;

val quasi_order_real = {ord_quasi_order = ord_real} : real quasi_order;

val weak_order_real = {quasi_order_weak_order = quasi_order_real} :
  real weak_order;

val preorder_real = {ord_preorder = ord_real} : real preorder;

val order_real =
  {preorder_order = preorder_real, weak_order_order = weak_order_real} :
  real order;

val semiring_Gcd_real =
  {gcd_semiring_Gcd = gcd_real, semiring_gcd_semiring_Gcd = semiring_gcd_real} :
  real semiring_Gcd;

val no_bot_real = {order_no_bot = order_real} : real no_bot;

val no_top_real = {order_no_top = order_real} : real no_top;

val ceq_reala : (real -> real -> bool) option = SOME equal_reala;

val ceq_real = {ceq = ceq_reala} : real ceq;

val set_impl_reala : (real, set_impla) phantom = Phantom Set_DList;

val set_impl_real = {set_impl = set_impl_reala} : real set_impl;

val linorder_real = {order_linorder = order_real} : real linorder;

val idom_abs_sgn_real =
  {abs_idom_abs_sgn = abs_real, sgn_idom_abs_sgn = sgn_real,
    idom_idom_abs_sgn = idom_real}
  : real idom_abs_sgn;

val ordered_ab_semigroup_add_real =
  {ab_semigroup_add_ordered_ab_semigroup_add = ab_semigroup_add_real,
    order_ordered_ab_semigroup_add = order_real}
  : real ordered_ab_semigroup_add;

val strict_ordered_ab_semigroup_add_real =
  {ordered_ab_semigroup_add_strict_ordered_ab_semigroup_add =
     ordered_ab_semigroup_add_real}
  : real strict_ordered_ab_semigroup_add;

val ordered_cancel_ab_semigroup_add_real =
  {cancel_ab_semigroup_add_ordered_cancel_ab_semigroup_add =
     cancel_ab_semigroup_add_real,
    strict_ordered_ab_semigroup_add_ordered_cancel_ab_semigroup_add =
      strict_ordered_ab_semigroup_add_real}
  : real ordered_cancel_ab_semigroup_add;

val ordered_semigroup_mult_zero_real =
  {semigroup_mult_ordered_semigroup_mult_zero = semigroup_mult_real,
    order_ordered_semigroup_mult_zero = order_real,
    mult_zero_ordered_semigroup_mult_zero = mult_zero_real}
  : real ordered_semigroup_mult_zero;

val ordered_comm_monoid_add_real =
  {comm_monoid_add_ordered_comm_monoid_add = comm_monoid_add_real,
    ordered_ab_semigroup_add_ordered_comm_monoid_add =
      ordered_ab_semigroup_add_real}
  : real ordered_comm_monoid_add;

val ordered_semiring_real =
  {ordered_comm_monoid_add_ordered_semiring = ordered_comm_monoid_add_real,
    semiring_ordered_semiring = semiring_real}
  : real ordered_semiring;

val ordered_semiring_0_real =
  {ordered_semigroup_mult_zero_ordered_semiring_0 =
     ordered_semigroup_mult_zero_real,
    ordered_semiring_ordered_semiring_0 = ordered_semiring_real,
    semiring_0_ordered_semiring_0 = semiring_0_real}
  : real ordered_semiring_0;

val ordered_cancel_semiring_real =
  {ordered_cancel_ab_semigroup_add_ordered_cancel_semiring =
     ordered_cancel_ab_semigroup_add_real,
    ordered_semiring_0_ordered_cancel_semiring = ordered_semiring_0_real,
    semiring_0_cancel_ordered_cancel_semiring = semiring_0_cancel_real}
  : real ordered_cancel_semiring;

val ordered_ab_semigroup_add_imp_le_real =
  {ordered_cancel_ab_semigroup_add_ordered_ab_semigroup_add_imp_le =
     ordered_cancel_ab_semigroup_add_real}
  : real ordered_ab_semigroup_add_imp_le;

val strict_ordered_comm_monoid_add_real =
  {comm_monoid_add_strict_ordered_comm_monoid_add = comm_monoid_add_real,
    strict_ordered_ab_semigroup_add_strict_ordered_comm_monoid_add =
      strict_ordered_ab_semigroup_add_real}
  : real strict_ordered_comm_monoid_add;

val ordered_cancel_comm_monoid_add_real =
  {ordered_cancel_ab_semigroup_add_ordered_cancel_comm_monoid_add =
     ordered_cancel_ab_semigroup_add_real,
    ordered_comm_monoid_add_ordered_cancel_comm_monoid_add =
      ordered_comm_monoid_add_real,
    strict_ordered_comm_monoid_add_ordered_cancel_comm_monoid_add =
      strict_ordered_comm_monoid_add_real}
  : real ordered_cancel_comm_monoid_add;

val ordered_ab_semigroup_monoid_add_imp_le_real =
  {cancel_comm_monoid_add_ordered_ab_semigroup_monoid_add_imp_le =
     cancel_comm_monoid_add_real,
    ordered_ab_semigroup_add_imp_le_ordered_ab_semigroup_monoid_add_imp_le =
      ordered_ab_semigroup_add_imp_le_real,
    ordered_cancel_comm_monoid_add_ordered_ab_semigroup_monoid_add_imp_le =
      ordered_cancel_comm_monoid_add_real}
  : real ordered_ab_semigroup_monoid_add_imp_le;

val ordered_ab_group_add_real =
  {ab_group_add_ordered_ab_group_add = ab_group_add_real,
    ordered_ab_semigroup_monoid_add_imp_le_ordered_ab_group_add =
      ordered_ab_semigroup_monoid_add_imp_le_real}
  : real ordered_ab_group_add;

val ordered_ring_real =
  {ordered_ab_group_add_ordered_ring = ordered_ab_group_add_real,
    ordered_cancel_semiring_ordered_ring = ordered_cancel_semiring_real,
    ring_ordered_ring = ring_real}
  : real ordered_ring;

val field_char_0_real =
  {field_field_char_0 = field_real, ring_char_0_field_char_0 = ring_char_0_real}
  : real field_char_0;

val zero_less_one_real =
  {order_zero_less_one = order_real,
    zero_neq_one_zero_less_one = zero_neq_one_real}
  : real zero_less_one;

val field_abs_sgn_real =
  {field_field_abs_sgn = field_real,
    idom_abs_sgn_field_abs_sgn = idom_abs_sgn_real}
  : real field_abs_sgn;

val cEnum_real :
  (real list * (((real -> bool) -> bool) * ((real -> bool) -> bool))) option
  = NONE;

val cenum_real = {cEnum = cEnum_real} : real cenum;

val dense_order_real = {order_dense_order = order_real} : real dense_order;

val linordered_ab_semigroup_add_real =
  {ordered_ab_semigroup_add_linordered_ab_semigroup_add =
     ordered_ab_semigroup_add_real,
    linorder_linordered_ab_semigroup_add = linorder_real}
  : real linordered_ab_semigroup_add;

val linordered_cancel_ab_semigroup_add_real =
  {linordered_ab_semigroup_add_linordered_cancel_ab_semigroup_add =
     linordered_ab_semigroup_add_real,
    ordered_ab_semigroup_add_imp_le_linordered_cancel_ab_semigroup_add =
      ordered_ab_semigroup_add_imp_le_real}
  : real linordered_cancel_ab_semigroup_add;

val linordered_semiring_real =
  {linordered_cancel_ab_semigroup_add_linordered_semiring =
     linordered_cancel_ab_semigroup_add_real,
    ordered_ab_semigroup_monoid_add_imp_le_linordered_semiring =
      ordered_ab_semigroup_monoid_add_imp_le_real,
    ordered_cancel_semiring_linordered_semiring = ordered_cancel_semiring_real}
  : real linordered_semiring;

val linordered_semiring_strict_real =
  {linordered_semiring_linordered_semiring_strict = linordered_semiring_real} :
  real linordered_semiring_strict;

val linordered_semiring_1_real =
  {linordered_semiring_linordered_semiring_1 = linordered_semiring_real,
    semiring_1_linordered_semiring_1 = semiring_1_real}
  : real linordered_semiring_1;

val linordered_semiring_1_strict_real =
  {linordered_semiring_1_linordered_semiring_1_strict =
     linordered_semiring_1_real,
    linordered_semiring_strict_linordered_semiring_1_strict =
      linordered_semiring_strict_real}
  : real linordered_semiring_1_strict;

val ordered_ab_group_add_abs_real =
  {abs_ordered_ab_group_add_abs = abs_real,
    ordered_ab_group_add_ordered_ab_group_add_abs = ordered_ab_group_add_real}
  : real ordered_ab_group_add_abs;

val linordered_ab_group_add_real =
  {linordered_cancel_ab_semigroup_add_linordered_ab_group_add =
     linordered_cancel_ab_semigroup_add_real,
    ordered_ab_group_add_linordered_ab_group_add = ordered_ab_group_add_real}
  : real linordered_ab_group_add;

val linordered_ring_real =
  {linordered_ab_group_add_linordered_ring = linordered_ab_group_add_real,
    ordered_ab_group_add_abs_linordered_ring = ordered_ab_group_add_abs_real,
    abs_if_linordered_ring = abs_if_real,
    linordered_semiring_linordered_ring = linordered_semiring_real,
    ordered_ring_linordered_ring = ordered_ring_real}
  : real linordered_ring;

val linordered_ring_strict_real =
  {linordered_ring_linordered_ring_strict = linordered_ring_real,
    linordered_semiring_strict_linordered_ring_strict =
      linordered_semiring_strict_real,
    ring_no_zero_divisors_linordered_ring_strict = ring_no_zero_divisors_real}
  : real linordered_ring_strict;

val ordered_comm_semiring_real =
  {comm_semiring_0_ordered_comm_semiring = comm_semiring_0_real,
    ordered_semiring_ordered_comm_semiring = ordered_semiring_real}
  : real ordered_comm_semiring;

val ordered_cancel_comm_semiring_real =
  {comm_semiring_0_cancel_ordered_cancel_comm_semiring =
     comm_semiring_0_cancel_real,
    ordered_cancel_semiring_ordered_cancel_comm_semiring =
      ordered_cancel_semiring_real,
    ordered_comm_semiring_ordered_cancel_comm_semiring =
      ordered_comm_semiring_real}
  : real ordered_cancel_comm_semiring;

val linordered_comm_semiring_strict_real =
  {linordered_semiring_strict_linordered_comm_semiring_strict =
     linordered_semiring_strict_real,
    ordered_cancel_comm_semiring_linordered_comm_semiring_strict =
      ordered_cancel_comm_semiring_real}
  : real linordered_comm_semiring_strict;

val linordered_nonzero_semiring_real =
  {linorder_linordered_nonzero_semiring = linorder_real,
    comm_semiring_1_linordered_nonzero_semiring = comm_semiring_1_real,
    ordered_comm_semiring_linordered_nonzero_semiring =
      ordered_comm_semiring_real,
    zero_less_one_linordered_nonzero_semiring = zero_less_one_real}
  : real linordered_nonzero_semiring;

val linordered_semidom_real =
  {semiring_char_0_linordered_semidom = semiring_char_0_real,
    linordered_comm_semiring_strict_linordered_semidom =
      linordered_comm_semiring_strict_real,
    linordered_nonzero_semiring_linordered_semidom =
      linordered_nonzero_semiring_real,
    semidom_linordered_semidom = semidom_real}
  : real linordered_semidom;

val ordered_comm_ring_real =
  {comm_ring_ordered_comm_ring = comm_ring_real,
    ordered_cancel_comm_semiring_ordered_comm_ring =
      ordered_cancel_comm_semiring_real,
    ordered_ring_ordered_comm_ring = ordered_ring_real}
  : real ordered_comm_ring;

val ordered_ring_abs_real =
  {ordered_ab_group_add_abs_ordered_ring_abs = ordered_ab_group_add_abs_real,
    ordered_ring_ordered_ring_abs = ordered_ring_real}
  : real ordered_ring_abs;

val linordered_idom_real =
  {ring_char_0_linordered_idom = ring_char_0_real,
    idom_abs_sgn_linordered_idom = idom_abs_sgn_real,
    linordered_ring_strict_linordered_idom = linordered_ring_strict_real,
    linordered_semidom_linordered_idom = linordered_semidom_real,
    linordered_semiring_1_strict_linordered_idom =
      linordered_semiring_1_strict_real,
    ordered_comm_ring_linordered_idom = ordered_comm_ring_real,
    ordered_ring_abs_linordered_idom = ordered_ring_abs_real}
  : real linordered_idom;

val non_strict_order_real = {ord_non_strict_order = ord_real} :
  real non_strict_order;

val ordered_ab_semigroup_real =
  {ab_semigroup_add_ordered_ab_semigroup = ab_semigroup_add_real,
    monoid_add_ordered_ab_semigroup = monoid_add_real,
    non_strict_order_ordered_ab_semigroup = non_strict_order_real}
  : real ordered_ab_semigroup;

val ordered_semiring_0_reala =
  {semiring_0_ordered_semiring_0a = semiring_0_real,
    ordered_ab_semigroup_ordered_semiring_0 = ordered_ab_semigroup_real}
  : real ordered_semiring_0a;

val ordered_semiring_1_real =
  {semiring_1_ordered_semiring_1 = semiring_1_real,
    ordered_semiring_0_ordered_semiring_1 = ordered_semiring_0_reala}
  : real ordered_semiring_1;

val poly_carrier_real =
  {comm_semiring_1_poly_carrier = comm_semiring_1_real,
    ordered_semiring_1_poly_carrier = ordered_semiring_1_real}
  : real poly_carrier;

val dense_linorder_real =
  {dense_order_dense_linorder = dense_order_real,
    linorder_dense_linorder = linorder_real}
  : real dense_linorder;

val unbounded_dense_linorder_real =
  {dense_linorder_unbounded_dense_linorder = dense_linorder_real,
    no_bot_unbounded_dense_linorder = no_bot_real,
    no_top_unbounded_dense_linorder = no_top_real}
  : real unbounded_dense_linorder;

val linordered_field_real =
  {field_abs_sgn_linordered_field = field_abs_sgn_real,
    field_char_0_linordered_field = field_char_0_real,
    unbounded_dense_linorder_linordered_field = unbounded_dense_linorder_real,
    linordered_idom_linordered_field = linordered_idom_real}
  : real linordered_field;

fun dist_reala x y = abs_reala (minus_reala x y);

type 'a dist = {dist : 'a -> 'a -> real};
val dist = #dist : 'a dist -> 'a -> 'a -> real;

val dist_real = {dist = dist_reala} : real dist;

fun norm_reala r = abs_reala r;

type 'a norm = {norm : 'a -> real};
val norm = #norm : 'a norm -> 'a -> real;

val norm_real = {norm = norm_reala} : real norm;

fun open_reala _ = raise Fail "Real_Vector_Spaces.open_real_inst.open_real";

type 'a opena = {opena : 'a set -> bool};
val opena = #opena : 'a opena -> 'a set -> bool;

val open_real = {opena = open_reala} : real opena;

val ccompare_reala : (real -> real -> ordera) option = SOME compare_reala;

val ccompare_real = {ccompare = ccompare_reala} : real ccompare;

fun scaleR_reala a x = times_reala a x;

type 'a scaleR = {scaleR : real -> 'a -> 'a};
val scaleR = #scaleR : 'a scaleR -> real -> 'a -> 'a;

val scaleR_real = {scaleR = scaleR_reala} : real scaleR;

type 'a topological_space = {open_topological_space : 'a opena};
val open_topological_space = #open_topological_space :
  'a topological_space -> 'a opena;

type 'a t0_space = {topological_space_t0_space : 'a topological_space};
val topological_space_t0_space = #topological_space_t0_space :
  'a t0_space -> 'a topological_space;

val topological_space_real = {open_topological_space = open_real} :
  real topological_space;

val t0_space_real = {topological_space_t0_space = topological_space_real} :
  real t0_space;

type 'a t1_space = {t0_space_t1_space : 'a t0_space};
val t0_space_t1_space = #t0_space_t1_space : 'a t1_space -> 'a t0_space;

val t1_space_real = {t0_space_t1_space = t0_space_real} : real t1_space;

type 'a t2_space = {t1_space_t2_space : 'a t1_space};
val t1_space_t2_space = #t1_space_t2_space : 'a t2_space -> 'a t1_space;

val t2_space_real = {t1_space_t2_space = t1_space_real} : real t2_space;

type 'a topological_monoid_add =
  {monoid_add_topological_monoid_add : 'a monoid_add,
    topological_space_topological_monoid_add : 'a topological_space};
val monoid_add_topological_monoid_add = #monoid_add_topological_monoid_add :
  'a topological_monoid_add -> 'a monoid_add;
val topological_space_topological_monoid_add =
  #topological_space_topological_monoid_add :
  'a topological_monoid_add -> 'a topological_space;

type 'a topological_group_add =
  {group_add_topological_group_add : 'a group_add,
    topological_monoid_add_topological_group_add : 'a topological_monoid_add};
val group_add_topological_group_add = #group_add_topological_group_add :
  'a topological_group_add -> 'a group_add;
val topological_monoid_add_topological_group_add =
  #topological_monoid_add_topological_group_add :
  'a topological_group_add -> 'a topological_monoid_add;

val topological_monoid_add_real =
  {monoid_add_topological_monoid_add = monoid_add_real,
    topological_space_topological_monoid_add = topological_space_real}
  : real topological_monoid_add;

val topological_group_add_real =
  {group_add_topological_group_add = group_add_real,
    topological_monoid_add_topological_group_add = topological_monoid_add_real}
  : real topological_group_add;

type 'a dist_norm =
  {minus_dist_norm : 'a minus, dist_dist_norm : 'a dist,
    norm_dist_norm : 'a norm};
val minus_dist_norm = #minus_dist_norm : 'a dist_norm -> 'a minus;
val dist_dist_norm = #dist_dist_norm : 'a dist_norm -> 'a dist;
val norm_dist_norm = #norm_dist_norm : 'a dist_norm -> 'a norm;

val dist_norm_real =
  {minus_dist_norm = minus_real, dist_dist_norm = dist_real,
    norm_dist_norm = norm_real}
  : real dist_norm;

datatype 'a filter = Principal of 'a set |
  Abstract_filter of (unit -> 'a filter);

fun uniformity_reala () =
  Abstract_filter
    (fn _ =>
      (raise Fail "uniformity is not executable")
        (fn _ => uniformity_reala ()));
val uniformity_reala = uniformity_reala ();

type 'a uniformity = {uniformity : ('a * 'a) filter};
val uniformity = #uniformity : 'a uniformity -> ('a * 'a) filter;

val uniformity_real = {uniformity = uniformity_reala} : real uniformity;

type 'a real_vector =
  {ab_group_add_real_vector : 'a ab_group_add, scaleR_real_vector : 'a scaleR};
val ab_group_add_real_vector = #ab_group_add_real_vector :
  'a real_vector -> 'a ab_group_add;
val scaleR_real_vector = #scaleR_real_vector : 'a real_vector -> 'a scaleR;

val real_vector_real =
  {ab_group_add_real_vector = ab_group_add_real,
    scaleR_real_vector = scaleR_real}
  : real real_vector;

fun real_of_real x = x;

val real_embedding_real =
  {linordered_idom_real_embedding = linordered_idom_real,
    real_of = real_of_real}
  : real real_embedding;

fun floor_real (Real_of x) = floor_real_alg x;

val archimedean_field_real =
  {linordered_field_archimedean_field = linordered_field_real} :
  real archimedean_field;

val large_ordered_semiring_1_real =
  {poly_carrier_large_ordered_semiring_1 = poly_carrier_real} :
  real large_ordered_semiring_1;

val floor_ceiling_real =
  {archimedean_field_floor_ceiling = archimedean_field_real,
    large_ordered_semiring_1_floor_ceiling = large_ordered_semiring_1_real,
    floor = floor_real}
  : real floor_ceiling;

type 'a topological_comm_monoid_add =
  {comm_monoid_add_topological_comm_monoid_add : 'a comm_monoid_add,
    topological_monoid_add_topological_comm_monoid_add :
      'a topological_monoid_add};
val comm_monoid_add_topological_comm_monoid_add =
  #comm_monoid_add_topological_comm_monoid_add :
  'a topological_comm_monoid_add -> 'a comm_monoid_add;
val topological_monoid_add_topological_comm_monoid_add =
  #topological_monoid_add_topological_comm_monoid_add :
  'a topological_comm_monoid_add -> 'a topological_monoid_add;

type 'a topological_ab_group_add =
  {ab_group_add_topological_ab_group_add : 'a ab_group_add,
    topological_comm_monoid_add_topological_ab_group_add :
      'a topological_comm_monoid_add,
    topological_group_add_topological_ab_group_add : 'a topological_group_add};
val ab_group_add_topological_ab_group_add =
  #ab_group_add_topological_ab_group_add :
  'a topological_ab_group_add -> 'a ab_group_add;
val topological_comm_monoid_add_topological_ab_group_add =
  #topological_comm_monoid_add_topological_ab_group_add :
  'a topological_ab_group_add -> 'a topological_comm_monoid_add;
val topological_group_add_topological_ab_group_add =
  #topological_group_add_topological_ab_group_add :
  'a topological_ab_group_add -> 'a topological_group_add;

val topological_comm_monoid_add_real =
  {comm_monoid_add_topological_comm_monoid_add = comm_monoid_add_real,
    topological_monoid_add_topological_comm_monoid_add =
      topological_monoid_add_real}
  : real topological_comm_monoid_add;

val topological_ab_group_add_real =
  {ab_group_add_topological_ab_group_add = ab_group_add_real,
    topological_comm_monoid_add_topological_ab_group_add =
      topological_comm_monoid_add_real,
    topological_group_add_topological_ab_group_add = topological_group_add_real}
  : real topological_ab_group_add;

type 'a first_countable_topology =
  {topological_space_first_countable_topology : 'a topological_space};
val topological_space_first_countable_topology =
  #topological_space_first_countable_topology :
  'a first_countable_topology -> 'a topological_space;

type 'a uniformity_dist =
  {dist_uniformity_dist : 'a dist, uniformity_uniformity_dist : 'a uniformity};
val dist_uniformity_dist = #dist_uniformity_dist :
  'a uniformity_dist -> 'a dist;
val uniformity_uniformity_dist = #uniformity_uniformity_dist :
  'a uniformity_dist -> 'a uniformity;

type 'a open_uniformity =
  {open_open_uniformity : 'a opena, uniformity_open_uniformity : 'a uniformity};
val open_open_uniformity = #open_open_uniformity :
  'a open_uniformity -> 'a opena;
val uniformity_open_uniformity = #uniformity_open_uniformity :
  'a open_uniformity -> 'a uniformity;

type 'a uniform_space =
  {open_uniformity_uniform_space : 'a open_uniformity,
    topological_space_uniform_space : 'a topological_space};
val open_uniformity_uniform_space = #open_uniformity_uniform_space :
  'a uniform_space -> 'a open_uniformity;
val topological_space_uniform_space = #topological_space_uniform_space :
  'a uniform_space -> 'a topological_space;

type 'a metric_space =
  {uniformity_dist_metric_space : 'a uniformity_dist,
    first_countable_topology_metric_space : 'a first_countable_topology,
    t2_space_metric_space : 'a t2_space,
    uniform_space_metric_space : 'a uniform_space};
val uniformity_dist_metric_space = #uniformity_dist_metric_space :
  'a metric_space -> 'a uniformity_dist;
val first_countable_topology_metric_space =
  #first_countable_topology_metric_space :
  'a metric_space -> 'a first_countable_topology;
val t2_space_metric_space = #t2_space_metric_space :
  'a metric_space -> 'a t2_space;
val uniform_space_metric_space = #uniform_space_metric_space :
  'a metric_space -> 'a uniform_space;

val first_countable_topology_real =
  {topological_space_first_countable_topology = topological_space_real} :
  real first_countable_topology;

val uniformity_dist_real =
  {dist_uniformity_dist = dist_real,
    uniformity_uniformity_dist = uniformity_real}
  : real uniformity_dist;

val open_uniformity_real =
  {open_open_uniformity = open_real,
    uniformity_open_uniformity = uniformity_real}
  : real open_uniformity;

val uniform_space_real =
  {open_uniformity_uniform_space = open_uniformity_real,
    topological_space_uniform_space = topological_space_real}
  : real uniform_space;

val metric_space_real =
  {uniformity_dist_metric_space = uniformity_dist_real,
    first_countable_topology_metric_space = first_countable_topology_real,
    t2_space_metric_space = t2_space_real,
    uniform_space_metric_space = uniform_space_real}
  : real metric_space;

type 'a sgn_div_norm =
  {sgn_sgn_div_norm : 'a sgn, norm_sgn_div_norm : 'a norm,
    scaleR_sgn_div_norm : 'a scaleR};
val sgn_sgn_div_norm = #sgn_sgn_div_norm : 'a sgn_div_norm -> 'a sgn;
val norm_sgn_div_norm = #norm_sgn_div_norm : 'a sgn_div_norm -> 'a norm;
val scaleR_sgn_div_norm = #scaleR_sgn_div_norm : 'a sgn_div_norm -> 'a scaleR;

val sgn_div_norm_real =
  {sgn_sgn_div_norm = sgn_real, norm_sgn_div_norm = norm_real,
    scaleR_sgn_div_norm = scaleR_real}
  : real sgn_div_norm;

val factorial_semiring_gcd_real =
  {factorial_semiring_factorial_semiring_gcd = factorial_semiring_real,
    semiring_Gcd_factorial_semiring_gcd = semiring_Gcd_real}
  : real factorial_semiring_gcd;

val factorial_ring_gcd_real =
  {factorial_semiring_gcd_factorial_ring_gcd = factorial_semiring_gcd_real,
    ring_gcd_factorial_ring_gcd = ring_gcd_real,
    idom_divide_factorial_ring_gcd = idom_divide_real}
  : real factorial_ring_gcd;

type 'a real_normed_vector =
  {topological_ab_group_add_real_normed_vector : 'a topological_ab_group_add,
    dist_norm_real_normed_vector : 'a dist_norm,
    metric_space_real_normed_vector : 'a metric_space,
    real_vector_real_normed_vector : 'a real_vector,
    sgn_div_norm_real_normed_vector : 'a sgn_div_norm};
val topological_ab_group_add_real_normed_vector =
  #topological_ab_group_add_real_normed_vector :
  'a real_normed_vector -> 'a topological_ab_group_add;
val dist_norm_real_normed_vector = #dist_norm_real_normed_vector :
  'a real_normed_vector -> 'a dist_norm;
val metric_space_real_normed_vector = #metric_space_real_normed_vector :
  'a real_normed_vector -> 'a metric_space;
val real_vector_real_normed_vector = #real_vector_real_normed_vector :
  'a real_normed_vector -> 'a real_vector;
val sgn_div_norm_real_normed_vector = #sgn_div_norm_real_normed_vector :
  'a real_normed_vector -> 'a sgn_div_norm;

val real_normed_vector_real =
  {topological_ab_group_add_real_normed_vector = topological_ab_group_add_real,
    dist_norm_real_normed_vector = dist_norm_real,
    metric_space_real_normed_vector = metric_space_real,
    real_vector_real_normed_vector = real_vector_real,
    sgn_div_norm_real_normed_vector = sgn_div_norm_real}
  : real real_normed_vector;

val large_real_ordered_semiring_1_real =
  {real_embedding_large_real_ordered_semiring_1 = real_embedding_real,
    large_ordered_semiring_1_large_real_ordered_semiring_1 =
      large_ordered_semiring_1_real}
  : real large_real_ordered_semiring_1;

datatype ('a, 'b) term = Var of 'b | Fun of 'a * ('a, 'b) term list;

datatype ('a, 'b) ctxt = Hole |
  More of 'a * ('a, 'b) term list * ('a, 'b) ctxt * ('a, 'b) term list;

fun equal_term A_ B_ = {equal = equal_terma A_ B_} : ('a, 'b) term equal
and equal_terma A_ B_ (Var x1) (Fun (x21, x22)) = false
  | equal_terma A_ B_ (Fun (x21, x22)) (Var x1) = false
  | equal_terma A_ B_ (Fun (x21, x22)) (Fun (y21, y22)) =
    eq A_ x21 y21 andalso equal_lista (equal_term A_ B_) x22 y22
  | equal_terma A_ B_ (Var x1) (Var y1) = eq B_ x1 y1;

fun equal_ctxta A_ B_ Hole (More (x21, x22, x23, x24)) = false
  | equal_ctxta A_ B_ (More (x21, x22, x23, x24)) Hole = false
  | equal_ctxta A_ B_ (More (x21, x22, x23, x24)) (More (y21, y22, y23, y24)) =
    eq A_ x21 y21 andalso
      (equal_lista (equal_term A_ B_) x22 y22 andalso
        (equal_ctxta A_ B_ x23 y23 andalso
          equal_lista (equal_term A_ B_) x24 y24))
  | equal_ctxta A_ B_ Hole Hole = true;

fun equal_ctxt A_ B_ = {equal = equal_ctxta A_ B_} : ('a, 'b) ctxt equal;

fun ceq_ctxta A_ B_ = SOME (equal_ctxta A_ B_);

fun ceq_ctxt A_ B_ = {ceq = ceq_ctxta A_ B_} : ('a, 'b) ctxt ceq;

val set_impl_ctxta : (('a, 'b) ctxt, set_impla) phantom = Phantom Set_RBT;

val set_impl_ctxt = {set_impl = set_impl_ctxta} : ('a, 'b) ctxt set_impl;

fun comparator_term comp_f comp_v (Fun (x, xa)) (Fun (ya, yb)) =
  (case comp_f x ya
    of Eq => comparator_list (comparator_term comp_f comp_v) xa yb | Lt => Lt
    | Gt => Gt)
  | comparator_term comp_f comp_v (Fun (x, xa)) (Var y) = Gt
  | comparator_term comp_f comp_v (Var x) (Fun (ya, yb)) = Lt
  | comparator_term comp_f comp_v (Var x) (Var y) = comp_v x y;

fun comparator_ctxt comp_f comp_v (More (x, xa, xb, xc)) (More (y, ya, yb, yc))
  = (case comp_f x y
      of Eq =>
        (case comparator_list (comparator_term comp_f comp_v) xa ya
          of Eq =>
            (case comparator_ctxt comp_f comp_v xb yb
              of Eq => comparator_list (comparator_term comp_f comp_v) xc yc
              | Lt => Lt | Gt => Gt)
          | Lt => Lt | Gt => Gt)
      | Lt => Lt | Gt => Gt)
  | comparator_ctxt comp_f comp_v (More (x, xa, xb, xc)) Hole = Gt
  | comparator_ctxt comp_f comp_v Hole (More (y, ya, yb, yc)) = Lt
  | comparator_ctxt comp_f comp_v Hole Hole = Eq;

fun compare_ctxt A_ B_ = comparator_ctxt (compare A_) (compare B_);

fun ccompare_ctxta A_ B_ = SOME (compare_ctxt A_ B_);

fun ccompare_ctxt A_ B_ = {ccompare = ccompare_ctxta A_ B_} :
  ('a, 'b) ctxt ccompare;

fun shows_term funa var (Var x) = var x
  | shows_term funa var (Fun (f, ts)) =
    funa f o
      shows_list_gen id [] [#"("] [#",", #" "] [#")"]
        (map (shows_term funa var) ts);

fun shows_prec_term A_ B_ d t =
  shows_term (shows_prec A_ zero_nata) (shows_prec B_ zero_nata) t;

fun shows_list_term A_ B_ ts = showsp_list (shows_prec_term A_ B_) zero_nata ts;

fun show_term A_ B_ =
  {shows_prec = shows_prec_term A_ B_, shows_list = shows_list_term A_ B_} :
  ('a, 'b) term show;

fun compare_terma A_ B_ = comparator_term (compare A_) (compare B_);

fun less_eq_term A_ B_ = le_of_comp (compare_terma A_ B_);

fun less_term A_ B_ = lt_of_comp (compare_terma A_ B_);

fun ord_term A_ B_ = {less_eq = less_eq_term A_ B_, less = less_term A_ B_} :
  ('a, 'b) term ord;

fun quasi_order_term A_ B_ = {ord_quasi_order = ord_term A_ B_} :
  ('a, 'b) term quasi_order;

fun weak_order_term A_ B_ = {quasi_order_weak_order = quasi_order_term A_ B_} :
  ('a, 'b) term weak_order;

fun preorder_term A_ B_ = {ord_preorder = ord_term A_ B_} :
  ('a, 'b) term preorder;

fun order_term A_ B_ =
  {preorder_order = preorder_term A_ B_,
    weak_order_order = weak_order_term A_ B_}
  : ('a, 'b) term order;

fun linorder_term A_ B_ = {order_linorder = order_term A_ B_} :
  ('a, 'b) term linorder;

fun compare_term A_ B_ = {compare = compare_terma A_ B_} :
  ('a, 'b) term compare;

fun compare_order_term A_ B_ =
  {compare_compare_order = compare_term A_ B_,
    linorder_compare_order = linorder_term A_ B_}
  : ('a, 'b) term compare_order;

fun key_term A_ B_ =
  {compare_order_key =
     compare_order_term ((compare_compare_order o compare_order_key) A_)
       ((compare_compare_order o compare_order_key) B_)}
  : ('a, 'b) term key;

fun ceq_terma A_ B_ = SOME (equal_terma A_ B_);

fun ceq_term A_ B_ = {ceq = ceq_terma A_ B_} : ('a, 'b) term ceq;

val set_impl_terma : (('a, 'b) term, set_impla) phantom = Phantom Set_RBT;

val set_impl_term = {set_impl = set_impl_terma} : ('a, 'b) term set_impl;

val cEnum_term :
  (('a, 'b) term list *
    (((('a, 'b) term -> bool) -> bool) *
      ((('a, 'b) term -> bool) -> bool))) option
  = NONE;

val cenum_term = {cEnum = cEnum_term} : ('a, 'b) term cenum;

val finite_UNIV_terma : (('a, 'b) term, bool) phantom = Phantom false;

val finite_UNIV_term = {finite_UNIV = finite_UNIV_terma} :
  ('a, 'b) term finite_UNIV;

fun ccompare_terma A_ B_ = SOME (compare_terma A_ B_);

fun ccompare_term A_ B_ = {ccompare = ccompare_terma A_ B_} :
  ('a, 'b) term ccompare;

fun cproper_interval_terma A_ B_ = (fn _ => fn _ => false);

fun cproper_interval_term A_ B_ =
  {ccompare_cproper_interval = ccompare_term A_ B_,
    cproper_interval = cproper_interval_terma A_ B_}
  : ('a, 'b) term cproper_interval;

fun equal_iarraya A_ asa bs = equal_lista A_ (list_of asa) (list_of bs);

fun equal_iarray A_ = {equal = equal_iarraya A_} : ('a Vector.vector) equal;

fun mat_equal_impl A_ xa xc =
  let
    val (nr1, (nc1, m1)) = rep_mat_impl xa;
  in
    (fn (nr2, (nc2, m2)) =>
      equal_nata nr1 nr2 andalso
        (equal_nata nc1 nc2 andalso equal_iarraya (equal_iarray A_) m1 m2))
  end
    (rep_mat_impl xc);

fun equal_mata A_ (Mat_impl m1) (Mat_impl m2) = mat_equal_impl A_ m1 m2;

fun equal_mat A_ = {equal = equal_mata A_} : 'a mat equal;

fun mat_to_list a =
  map (fn i => map (fn j => index_mat a (i, j)) (upt zero_nata (dim_col a)))
    (upt zero_nata (dim_row a));

fun shows_mat A_ a = shows_prec_list (show_list A_) zero_nata (mat_to_list a);

fun shows_prec_mat A_ p a = shows_mat A_ a;

fun shows_prec_char p c = (fn a => c :: a);

fun shows_list_char cs = shows_string cs;

val show_char = {shows_prec = shows_prec_char, shows_list = shows_list_char} :
  char show;

fun shows_list_mat A_ asa =
  shows_sep (shows_mat A_) (shows_prec_list show_char zero_nata [#",", #" "])
    asa;

fun show_mat A_ =
  {shows_prec = shows_prec_mat A_, shows_list = shows_list_mat A_} :
  'a mat show;

fun ceq_mata A_ = SOME (equal_mata A_);

fun ceq_mat A_ = {ceq = ceq_mata A_} : 'a mat ceq;

val set_impl_mata : ('a mat, set_impla) phantom = Phantom Set_DList;

val set_impl_mat = {set_impl = set_impl_mata} : 'a mat set_impl;

val cEnum_mat :
  ('a mat list *
    ((('a mat -> bool) -> bool) * (('a mat -> bool) -> bool))) option
  = NONE;

val cenum_mat = {cEnum = cEnum_mat} : 'a mat cenum;

val ccompare_mata : ('a mat -> 'a mat -> ordera) option = NONE;

val ccompare_mat = {ccompare = ccompare_mata} : 'a mat ccompare;

val equal_char = {equal = (fn a => fn b => ((a : char) = b))} : char equal;

val ord_char =
  {less_eq = (fn a => fn b => ((a : char) <= b)),
    less = (fn a => fn b => ((a : char) < b))}
  : char ord;

val quasi_order_char = {ord_quasi_order = ord_char} : char quasi_order;

val weak_order_char = {quasi_order_weak_order = quasi_order_char} :
  char weak_order;

val preorder_char = {ord_preorder = ord_char} : char preorder;

val order_char =
  {preorder_order = preorder_char, weak_order_order = weak_order_char} :
  char order;

val linorder_char = {order_linorder = order_char} : char linorder;

fun compare_chara x = comparator_of (equal_char, linorder_char) x;

val compare_char = {compare = compare_chara} : char compare;

val compare_order_char =
  {compare_compare_order = compare_char, linorder_compare_order = linorder_char}
  : char compare_order;

val key_char = {compare_order_key = compare_order_char} : char key;

val ceq_chara : (char -> char -> bool) option =
  SOME (fn a => fn b => ((a : char) = b));

val ceq_char = {ceq = ceq_chara} : char ceq;

val countable_char = {} : char countable;

val ccompare_chara : (char -> char -> ordera) option = SOME compare_chara;

val ccompare_char = {ccompare = ccompare_chara} : char ccompare;

datatype 'a hint = Default | Base of 'a | Distribute of nat * 'a hint list |
  Erase of nat * 'a hint | LexStrict of 'a hint list | LexWeak of 'a hint list;

fun default_hinta A_ = Default;

fun default_hint A_ = {default = default_hinta A_} : 'a hint default;

datatype pos = Empty | PCons of nat * pos;

fun equal_posa Empty (PCons (x21, x22)) = false
  | equal_posa (PCons (x21, x22)) Empty = false
  | equal_posa (PCons (x21, x22)) (PCons (y21, y22)) =
    equal_nata x21 y21 andalso equal_posa x22 y22
  | equal_posa Empty Empty = true;

val equal_pos = {equal = equal_posa} : pos equal;

fun shows_pos (PCons (i, Empty)) = shows_prec_nat zero_nata (suc i)
  | shows_pos (PCons (i, PCons (v, va))) =
    shows_prec_nat zero_nata (suc i) o shows_pos (PCons (v, va))
  | shows_pos Empty = shows_string [#"e", #"p", #"s", #"i", #"l", #"o", #"n"];

fun shows_prec_pos d p = shows_pos p;

fun shows_list_pos ps = showsp_list shows_prec_pos zero_nata ps;

val show_pos = {shows_prec = shows_prec_pos, shows_list = shows_list_pos} :
  pos show;

val one_posa : pos = Empty;

val one_pos = {onea = one_posa} : pos one;

fun append Empty q = q
  | append (PCons (i, p)) q = PCons (i, append p q);

fun times_posa p q = append p q;

val times_pos = {times = times_posa} : pos times;

val power_pos = {one_power = one_pos, times_power = times_pos} : pos power;

val ceq_posa : (pos -> pos -> bool) option = SOME equal_posa;

val ceq_pos = {ceq = ceq_posa} : pos ceq;

val set_impl_posa : (pos, set_impla) phantom = Phantom Set_RBT;

val set_impl_pos = {set_impl = set_impl_posa} : pos set_impl;

val cEnum_pos :
  (pos list * (((pos -> bool) -> bool) * ((pos -> bool) -> bool))) option
  = NONE;

val cenum_pos = {cEnum = cEnum_pos} : pos cenum;

val finite_UNIV_posa : (pos, bool) phantom = Phantom false;

val finite_UNIV_pos = {finite_UNIV = finite_UNIV_posa} : pos finite_UNIV;

fun comparator_pos (PCons (x, xa)) (PCons (y, ya)) =
  (case comparator_of (equal_nat, linorder_nat) x y
    of Eq => comparator_pos xa ya | Lt => Lt | Gt => Gt)
  | comparator_pos (PCons (x, xa)) Empty = Gt
  | comparator_pos Empty (PCons (y, ya)) = Lt
  | comparator_pos Empty Empty = Eq;

fun compare_pos x = comparator_pos x;

val ccompare_posa : (pos -> pos -> ordera) option = SOME compare_pos;

val ccompare_pos = {ccompare = ccompare_posa} : pos ccompare;

fun cproper_interval_posa x = (fn _ => fn _ => false) x;

val cproper_interval_pos =
  {ccompare_cproper_interval = ccompare_pos,
    cproper_interval = cproper_interval_posa}
  : pos cproper_interval;

fun equal_suma A_ B_ (Inl x1) (Inr x2) = false
  | equal_suma A_ B_ (Inr x2) (Inl x1) = false
  | equal_suma A_ B_ (Inr x2) (Inr y2) = eq B_ x2 y2
  | equal_suma A_ B_ (Inl x1) (Inl y1) = eq A_ x1 y1;

fun equal_sum A_ B_ = {equal = equal_suma A_ B_} : ('a, 'b) sum equal;

fun shows_space x = shows_prec_char zero_nata #" " x;

fun shows_pr p =
  (if less_nat zero_nata p then shows_prec_char zero_nata #")" else id);

fun shows_pl p =
  (if less_nat zero_nata p then shows_prec_char zero_nata #"(" else id);

fun showsp_sum show_a show_b p (Inr x) =
  shows_pl p o shows_string [#"I", #"n", #"r"] o shows_space o
    show_b one_nata x o
    shows_pr p
  | showsp_sum show_a show_b p (Inl x) =
    shows_pl p o shows_string [#"I", #"n", #"l"] o shows_space o
      show_a one_nata x o
      shows_pr p;

fun shows_prec_sum A_ B_ = showsp_sum (shows_prec A_) (shows_prec B_);

fun shows_list_sum A_ B_ = showsp_list (shows_prec_sum A_ B_) zero_nata;

fun show_sum A_ B_ =
  {shows_prec = shows_prec_sum A_ B_, shows_list = shows_list_sum A_ B_} :
  ('a, 'b) sum show;

datatype 'a trans_var = Pre of 'a | Post of 'a | Intermediate of 'a;

fun equal_trans_vara A_ (Post x2) (Intermediate x3) = false
  | equal_trans_vara A_ (Intermediate x3) (Post x2) = false
  | equal_trans_vara A_ (Pre x1) (Intermediate x3) = false
  | equal_trans_vara A_ (Intermediate x3) (Pre x1) = false
  | equal_trans_vara A_ (Pre x1) (Post x2) = false
  | equal_trans_vara A_ (Post x2) (Pre x1) = false
  | equal_trans_vara A_ (Intermediate x3) (Intermediate y3) = eq A_ x3 y3
  | equal_trans_vara A_ (Post x2) (Post y2) = eq A_ x2 y2
  | equal_trans_vara A_ (Pre x1) (Pre y1) = eq A_ x1 y1;

fun equal_trans_var A_ = {equal = equal_trans_vara A_} : 'a trans_var equal;

fun showsp_trans_var show_v p (Intermediate x) =
  shows_pl p o
    shows_string
      [#"I", #"n", #"t", #"e", #"r", #"m", #"e", #"d", #"i", #"a", #"t", #"e"] o
    shows_space o
    show_v one_nata x o
    shows_pr p
  | showsp_trans_var show_v p (Post x) =
    shows_pl p o shows_string [#"P", #"o", #"s", #"t"] o shows_space o
      show_v one_nata x o
      shows_pr p
  | showsp_trans_var show_v p (Pre x) =
    shows_pl p o shows_string [#"P", #"r", #"e"] o shows_space o
      show_v one_nata x o
      shows_pr p;

fun shows_prec_trans_var A_ = showsp_trans_var (shows_prec A_);

fun shows_list_trans_var A_ = showsp_list (shows_prec_trans_var A_) zero_nata;

fun show_trans_var A_ =
  {shows_prec = shows_prec_trans_var A_, shows_list = shows_list_trans_var A_} :
  'a trans_var show;

fun comparator_trans_var comp_v (Intermediate x) (Intermediate yb) = comp_v x yb
  | comparator_trans_var comp_v (Intermediate x) (Post ya) = Gt
  | comparator_trans_var comp_v (Intermediate x) (Pre y) = Gt
  | comparator_trans_var comp_v (Post x) (Intermediate yb) = Lt
  | comparator_trans_var comp_v (Post x) (Post ya) = comp_v x ya
  | comparator_trans_var comp_v (Post x) (Pre y) = Gt
  | comparator_trans_var comp_v (Pre x) (Intermediate yb) = Lt
  | comparator_trans_var comp_v (Pre x) (Post ya) = Lt
  | comparator_trans_var comp_v (Pre x) (Pre y) = comp_v x y;

fun compare_trans_var A_ = comparator_trans_var (compare A_);

fun less_eq_trans_var A_ = le_of_comp (compare_trans_var A_);

fun less_trans_var A_ = lt_of_comp (compare_trans_var A_);

fun ord_trans_var A_ =
  {less_eq = less_eq_trans_var A_, less = less_trans_var A_} : 'a trans_var ord;

fun quasi_order_trans_var A_ = {ord_quasi_order = ord_trans_var A_} :
  'a trans_var quasi_order;

fun weak_order_trans_var A_ =
  {quasi_order_weak_order = quasi_order_trans_var A_} : 'a trans_var weak_order;

fun preorder_trans_var A_ = {ord_preorder = ord_trans_var A_} :
  'a trans_var preorder;

fun order_trans_var A_ =
  {preorder_order = preorder_trans_var A_,
    weak_order_order = weak_order_trans_var A_}
  : 'a trans_var order;

fun linorder_trans_var A_ = {order_linorder = order_trans_var A_} :
  'a trans_var linorder;

fun ccompare_trans_vara A_ =
  (case ccompare A_ of NONE => NONE
    | SOME comp_v => SOME (comparator_trans_var comp_v));

fun ccompare_trans_var A_ = {ccompare = ccompare_trans_vara A_} :
  'a trans_var ccompare;

val mapping_impl_trans_vara : ('a trans_var, mapping_impla) phantom =
  Phantom Mapping_RBT;

val mapping_impl_trans_var = {mapping_impl = mapping_impl_trans_vara} :
  'a trans_var mapping_impl;

datatype ('a, 'b) lab = Lab of ('a, 'b) lab * 'b |
  FunLab of ('a, 'b) lab * ('a, 'b) lab list | UnLab of 'a |
  Sharp of ('a, 'b) lab;

fun equal_lab A_ B_ = {equal = equal_laba A_ B_} : ('a, 'b) lab equal
and equal_laba A_ B_ (UnLab x3) (Sharp x4) = false
  | equal_laba A_ B_ (Sharp x4) (UnLab x3) = false
  | equal_laba A_ B_ (FunLab (x21, x22)) (Sharp x4) = false
  | equal_laba A_ B_ (Sharp x4) (FunLab (x21, x22)) = false
  | equal_laba A_ B_ (FunLab (x21, x22)) (UnLab x3) = false
  | equal_laba A_ B_ (UnLab x3) (FunLab (x21, x22)) = false
  | equal_laba A_ B_ (Lab (x11, x12)) (Sharp x4) = false
  | equal_laba A_ B_ (Sharp x4) (Lab (x11, x12)) = false
  | equal_laba A_ B_ (Lab (x11, x12)) (UnLab x3) = false
  | equal_laba A_ B_ (UnLab x3) (Lab (x11, x12)) = false
  | equal_laba A_ B_ (Lab (x11, x12)) (FunLab (x21, x22)) = false
  | equal_laba A_ B_ (FunLab (x21, x22)) (Lab (x11, x12)) = false
  | equal_laba A_ B_ (Sharp x4) (Sharp y4) = equal_laba A_ B_ x4 y4
  | equal_laba A_ B_ (UnLab x3) (UnLab y3) = eq A_ x3 y3
  | equal_laba A_ B_ (FunLab (x21, x22)) (FunLab (y21, y22)) =
    equal_laba A_ B_ x21 y21 andalso equal_lista (equal_lab A_ B_) x22 y22
  | equal_laba A_ B_ (Lab (x11, x12)) (Lab (y11, y12)) =
    equal_laba A_ B_ x11 y11 andalso eq B_ x12 y12;

fun shows_lab funa lab (UnLab f) = funa f
  | shows_lab funa lab (Lab (f, l)) =
    shows_lab funa lab f o (shows_string [#"["] o (lab l o shows_string [#"]"]))
  | shows_lab funa lab (Sharp f) = shows_lab funa lab f o shows_string [#"#"]
  | shows_lab funa lab (FunLab (f, l)) =
    shows_lab funa lab f o
      (shows_string [#"["] o
        (shows_list_gen (shows_lab funa lab) [] [] [] [] l o
          shows_string [#"]"]));

fun shows_prec_lab A_ B_ d l =
  shows_lab (shows_prec A_ zero_nata) (shows_prec B_ zero_nata) l;

fun shows_list_lab A_ B_ fs = showsp_list (shows_prec_lab A_ B_) zero_nata fs;

fun show_lab A_ B_ =
  {shows_prec = shows_prec_lab A_ B_, shows_list = shows_list_lab A_ B_} :
  ('a, 'b) lab show;

fun default_laba A_ = UnLab (default A_);

fun default_lab A_ = {default = default_laba A_} : ('a, 'b) lab default;

fun comparator_lab comp_f comp_l (Sharp x) (Sharp ye) =
  comparator_lab comp_f comp_l x ye
  | comparator_lab comp_f comp_l (Sharp x) (UnLab yd) = Gt
  | comparator_lab comp_f comp_l (Sharp x) (FunLab (yb, yc)) = Gt
  | comparator_lab comp_f comp_l (Sharp x) (Lab (y, ya)) = Gt
  | comparator_lab comp_f comp_l (UnLab x) (Sharp ye) = Lt
  | comparator_lab comp_f comp_l (UnLab x) (UnLab yd) = comp_f x yd
  | comparator_lab comp_f comp_l (UnLab x) (FunLab (yb, yc)) = Gt
  | comparator_lab comp_f comp_l (UnLab x) (Lab (y, ya)) = Gt
  | comparator_lab comp_f comp_l (FunLab (x, xa)) (Sharp ye) = Lt
  | comparator_lab comp_f comp_l (FunLab (x, xa)) (UnLab yd) = Lt
  | comparator_lab comp_f comp_l (FunLab (x, xa)) (FunLab (yb, yc)) =
    (case comparator_lab comp_f comp_l x yb
      of Eq => comparator_list (comparator_lab comp_f comp_l) xa yc | Lt => Lt
      | Gt => Gt)
  | comparator_lab comp_f comp_l (FunLab (x, xa)) (Lab (y, ya)) = Gt
  | comparator_lab comp_f comp_l (Lab (x, xa)) (Sharp ye) = Lt
  | comparator_lab comp_f comp_l (Lab (x, xa)) (UnLab yd) = Lt
  | comparator_lab comp_f comp_l (Lab (x, xa)) (FunLab (yb, yc)) = Lt
  | comparator_lab comp_f comp_l (Lab (x, xa)) (Lab (y, ya)) =
    (case comparator_lab comp_f comp_l x y of Eq => comp_l xa ya | Lt => Lt
      | Gt => Gt);

fun compare_laba A_ B_ = comparator_lab (compare A_) (compare B_);

fun less_eq_lab A_ B_ = le_of_comp (compare_laba A_ B_);

fun less_lab A_ B_ = lt_of_comp (compare_laba A_ B_);

fun ord_lab A_ B_ = {less_eq = less_eq_lab A_ B_, less = less_lab A_ B_} :
  ('a, 'b) lab ord;

fun quasi_order_lab A_ B_ = {ord_quasi_order = ord_lab A_ B_} :
  ('a, 'b) lab quasi_order;

fun weak_order_lab A_ B_ = {quasi_order_weak_order = quasi_order_lab A_ B_} :
  ('a, 'b) lab weak_order;

fun preorder_lab A_ B_ = {ord_preorder = ord_lab A_ B_} : ('a, 'b) lab preorder;

fun order_lab A_ B_ =
  {preorder_order = preorder_lab A_ B_, weak_order_order = weak_order_lab A_ B_}
  : ('a, 'b) lab order;

fun linorder_lab A_ B_ = {order_linorder = order_lab A_ B_} :
  ('a, 'b) lab linorder;

fun compare_lab A_ B_ = {compare = compare_laba A_ B_} : ('a, 'b) lab compare;

fun compare_order_lab A_ B_ =
  {compare_compare_order = compare_lab A_ B_,
    linorder_compare_order = linorder_lab A_ B_}
  : ('a, 'b) lab compare_order;

fun key_lab A_ B_ =
  {compare_order_key =
     compare_order_lab ((compare_compare_order o compare_order_key) A_)
       ((compare_compare_order o compare_order_key) B_)}
  : ('a, 'b) lab key;

fun ceq_laba A_ B_ = SOME (equal_laba A_ B_);

fun ceq_lab A_ B_ = {ceq = ceq_laba A_ B_} : ('a, 'b) lab ceq;

val set_impl_laba : (('a, 'b) lab, set_impla) phantom = Phantom Set_RBT;

val set_impl_lab = {set_impl = set_impl_laba} : ('a, 'b) lab set_impl;

val finite_UNIV_laba : (('a, 'b) lab, bool) phantom = Phantom false;

val card_UNIV_laba : (('a, 'b) lab, nat) phantom = Phantom zero_nata;

val finite_UNIV_lab = {finite_UNIV = finite_UNIV_laba} :
  ('a, 'b) lab finite_UNIV;

val card_UNIV_lab =
  {finite_UNIV_card_UNIV = finite_UNIV_lab, card_UNIVa = card_UNIV_laba} :
  ('a, 'b) lab card_UNIV;

val cEnum_lab :
  (('a, 'b) lab list *
    (((('a, 'b) lab -> bool) -> bool) *
      ((('a, 'b) lab -> bool) -> bool))) option
  = NONE;

val cenum_lab = {cEnum = cEnum_lab} : ('a, 'b) lab cenum;

fun ccompare_laba A_ B_ = SOME (compare_laba A_ B_);

fun ccompare_lab A_ B_ = {ccompare = ccompare_laba A_ B_} :
  ('a, 'b) lab ccompare;

val mapping_impl_laba : (('a, 'b) lab, mapping_impla) phantom =
  Phantom Mapping_RBT;

val mapping_impl_lab = {mapping_impl = mapping_impl_laba} :
  ('a, 'b) lab mapping_impl;

fun cproper_interval_laba A_ B_ = (fn _ => fn _ => false);

fun cproper_interval_lab A_ B_ =
  {ccompare_cproper_interval = ccompare_lab A_ B_,
    cproper_interval = cproper_interval_laba A_ B_}
  : ('a, 'b) lab cproper_interval;

fun equal_option A_ = {equal = equal_optiona A_} : ('a option) equal;

fun equality_option eq_a (SOME x) (SOME y) = eq_a x y
  | equality_option eq_a (SOME x) NONE = false
  | equality_option eq_a NONE (SOME y) = false
  | equality_option eq_a NONE NONE = true;

fun ceq_optiona A_ =
  (case ceq A_ of NONE => NONE | SOME eq_a => SOME (equality_option eq_a));

fun ceq_option A_ = {ceq = ceq_optiona A_} : ('a option) ceq;

fun set_impl_optiona A_ = Phantom (of_phantom (set_impl A_));

fun set_impl_option A_ = {set_impl = set_impl_optiona A_} :
  ('a option) set_impl;

fun cEnum_option A_ =
  (case cEnum A_ of NONE => NONE
    | SOME (enum_a, (enum_all_a, enum_ex_a)) =>
      SOME (NONE :: map SOME enum_a,
             ((fn p => p NONE andalso enum_all_a (fn x => p (SOME x))),
               (fn p => p NONE orelse enum_ex_a (fn x => p (SOME x))))));

fun cenum_option A_ = {cEnum = cEnum_option A_} : ('a option) cenum;

fun finite_UNIV_optiona A_ = Phantom (of_phantom (finite_UNIV A_));

fun finite_UNIV_option A_ = {finite_UNIV = finite_UNIV_optiona A_} :
  ('a option) finite_UNIV;

fun comparator_option comp_a (SOME x) (SOME y) = comp_a x y
  | comparator_option comp_a (SOME x) NONE = Gt
  | comparator_option comp_a NONE (SOME y) = Lt
  | comparator_option comp_a NONE NONE = Eq;

fun ccompare_optiona A_ =
  (case ccompare A_ of NONE => NONE
    | SOME comp_a => SOME (comparator_option comp_a));

fun ccompare_option A_ = {ccompare = ccompare_optiona A_} :
  ('a option) ccompare;

fun mapping_impl_optiona A_ = Phantom (of_phantom (mapping_impl A_));

fun mapping_impl_option A_ = {mapping_impl = mapping_impl_optiona A_} :
  ('a option) mapping_impl;

fun cproper_interval_optiona A_ NONE NONE = true
  | cproper_interval_optiona A_ NONE (SOME x) = not (is_none x)
  | cproper_interval_optiona A_ (SOME x) NONE = cproper_interval A_ x NONE
  | cproper_interval_optiona A_ (SOME x) (SOME NONE) = false
  | cproper_interval_optiona A_ (SOME x) (SOME (SOME y)) =
    cproper_interval A_ x (SOME y);

fun cproper_interval_option A_ =
  {ccompare_cproper_interval = ccompare_option (ccompare_cproper_interval A_),
    cproper_interval = cproper_interval_optiona A_}
  : ('a option) cproper_interval;

datatype qDelta = QDelta of rat * rat;

fun equal_QDeltaa (QDelta (x1, x2)) (QDelta (y1, y2)) =
  equal_rata x1 y1 andalso equal_rata x2 y2;

val equal_QDelta = {equal = equal_QDeltaa} : qDelta equal;

val one_QDeltaa : qDelta = QDelta (one_rata, zero_rata);

val one_QDelta = {onea = one_QDeltaa} : qDelta one;

fun qdsnd (QDelta (a, b)) = b;

fun qdfst (QDelta (a, b)) = a;

fun scaleRat_QDeltaa r qd =
  QDelta (times_rata r (qdfst qd), times_rata r (qdsnd qd));

fun uminus_QDeltaa qd = QDelta (uminus_rata (qdfst qd), uminus_rata (qdsnd qd));

fun less_eq_QDelta qd1 qd2 =
  less_rat (qdfst qd1) (qdfst qd2) orelse
    equal_rata (qdfst qd1) (qdfst qd2) andalso
      less_eq_rat (qdsnd qd1) (qdsnd qd2);

fun minus_QDeltaa qd1 qd2 =
  QDelta
    (minus_rata (qdfst qd1) (qdfst qd2), minus_rata (qdsnd qd1) (qdsnd qd2));

val zero_QDeltaa : qDelta = QDelta (zero_rata, zero_rata);

fun plus_QDeltaa qd1 qd2 =
  QDelta (plus_rata (qdfst qd1) (qdfst qd2), plus_rata (qdsnd qd1) (qdsnd qd2));

fun less_QDelta qd1 qd2 =
  less_rat (qdfst qd1) (qdfst qd2) orelse
    equal_rata (qdfst qd1) (qdfst qd2) andalso less_rat (qdsnd qd1) (qdsnd qd2);

type 'a scaleRat = {scaleRat : rat -> 'a -> 'a};
val scaleRat = #scaleRat : 'a scaleRat -> rat -> 'a -> 'a;

type 'a rational_vector =
  {scaleRat_rational_vector : 'a scaleRat,
    ab_group_add_rational_vector : 'a ab_group_add};
val scaleRat_rational_vector = #scaleRat_rational_vector :
  'a rational_vector -> 'a scaleRat;
val ab_group_add_rational_vector = #ab_group_add_rational_vector :
  'a rational_vector -> 'a ab_group_add;

type 'a ordered_rational_vector =
  {rational_vector_ordered_rational_vector : 'a rational_vector,
    order_ordered_rational_vector : 'a order};
val rational_vector_ordered_rational_vector =
  #rational_vector_ordered_rational_vector :
  'a ordered_rational_vector -> 'a rational_vector;
val order_ordered_rational_vector = #order_ordered_rational_vector :
  'a ordered_rational_vector -> 'a order;

type 'a linordered_rational_vector =
  {ordered_rational_vector_linordered_rational_vector :
     'a ordered_rational_vector,
    ordered_ab_semigroup_add_linordered_rational_vector :
      'a ordered_ab_semigroup_add,
    linorder_linordered_rational_vector : 'a linorder};
val ordered_rational_vector_linordered_rational_vector =
  #ordered_rational_vector_linordered_rational_vector :
  'a linordered_rational_vector -> 'a ordered_rational_vector;
val ordered_ab_semigroup_add_linordered_rational_vector =
  #ordered_ab_semigroup_add_linordered_rational_vector :
  'a linordered_rational_vector -> 'a ordered_ab_semigroup_add;
val linorder_linordered_rational_vector = #linorder_linordered_rational_vector :
  'a linordered_rational_vector -> 'a linorder;

type 'a lrv =
  {linordered_rational_vector_lrv : 'a linordered_rational_vector,
    one_lrv : 'a one};
val linordered_rational_vector_lrv = #linordered_rational_vector_lrv :
  'a lrv -> 'a linordered_rational_vector;
val one_lrv = #one_lrv : 'a lrv -> 'a one;

val plus_QDelta = {plus = plus_QDeltaa} : qDelta plus;

val semigroup_add_QDelta = {plus_semigroup_add = plus_QDelta} :
  qDelta semigroup_add;

val ab_semigroup_add_QDelta =
  {semigroup_add_ab_semigroup_add = semigroup_add_QDelta} :
  qDelta ab_semigroup_add;

val ord_QDelta = {less_eq = less_eq_QDelta, less = less_QDelta} : qDelta ord;

val quasi_order_QDelta = {ord_quasi_order = ord_QDelta} : qDelta quasi_order;

val weak_order_QDelta = {quasi_order_weak_order = quasi_order_QDelta} :
  qDelta weak_order;

val preorder_QDelta = {ord_preorder = ord_QDelta} : qDelta preorder;

val order_QDelta =
  {preorder_order = preorder_QDelta, weak_order_order = weak_order_QDelta} :
  qDelta order;

val ordered_ab_semigroup_add_QDelta =
  {ab_semigroup_add_ordered_ab_semigroup_add = ab_semigroup_add_QDelta,
    order_ordered_ab_semigroup_add = order_QDelta}
  : qDelta ordered_ab_semigroup_add;

val cancel_semigroup_add_QDelta =
  {semigroup_add_cancel_semigroup_add = semigroup_add_QDelta} :
  qDelta cancel_semigroup_add;

val minus_QDelta = {minus = minus_QDeltaa} : qDelta minus;

val cancel_ab_semigroup_add_QDelta =
  {ab_semigroup_add_cancel_ab_semigroup_add = ab_semigroup_add_QDelta,
    cancel_semigroup_add_cancel_ab_semigroup_add = cancel_semigroup_add_QDelta,
    minus_cancel_ab_semigroup_add = minus_QDelta}
  : qDelta cancel_ab_semigroup_add;

val zero_QDelta = {zerob = zero_QDeltaa} : qDelta zero;

val monoid_add_QDelta =
  {semigroup_add_monoid_add = semigroup_add_QDelta,
    zero_monoid_add = zero_QDelta}
  : qDelta monoid_add;

val comm_monoid_add_QDelta =
  {ab_semigroup_add_comm_monoid_add = ab_semigroup_add_QDelta,
    monoid_add_comm_monoid_add = monoid_add_QDelta}
  : qDelta comm_monoid_add;

val cancel_comm_monoid_add_QDelta =
  {cancel_ab_semigroup_add_cancel_comm_monoid_add =
     cancel_ab_semigroup_add_QDelta,
    comm_monoid_add_cancel_comm_monoid_add = comm_monoid_add_QDelta}
  : qDelta cancel_comm_monoid_add;

val uminus_QDelta = {uminus = uminus_QDeltaa} : qDelta uminus;

val group_add_QDelta =
  {cancel_semigroup_add_group_add = cancel_semigroup_add_QDelta,
    minus_group_add = minus_QDelta, monoid_add_group_add = monoid_add_QDelta,
    uminus_group_add = uminus_QDelta}
  : qDelta group_add;

val ab_group_add_QDelta =
  {cancel_comm_monoid_add_ab_group_add = cancel_comm_monoid_add_QDelta,
    group_add_ab_group_add = group_add_QDelta}
  : qDelta ab_group_add;

val scaleRat_QDelta = {scaleRat = scaleRat_QDeltaa} : qDelta scaleRat;

val rational_vector_QDelta =
  {scaleRat_rational_vector = scaleRat_QDelta,
    ab_group_add_rational_vector = ab_group_add_QDelta}
  : qDelta rational_vector;

val ordered_rational_vector_QDelta =
  {rational_vector_ordered_rational_vector = rational_vector_QDelta,
    order_ordered_rational_vector = order_QDelta}
  : qDelta ordered_rational_vector;

val linorder_QDelta = {order_linorder = order_QDelta} : qDelta linorder;

val linordered_rational_vector_QDelta =
  {ordered_rational_vector_linordered_rational_vector =
     ordered_rational_vector_QDelta,
    ordered_ab_semigroup_add_linordered_rational_vector =
      ordered_ab_semigroup_add_QDelta,
    linorder_linordered_rational_vector = linorder_QDelta}
  : qDelta linordered_rational_vector;

val lrv_QDelta =
  {linordered_rational_vector_lrv = linordered_rational_vector_QDelta,
    one_lrv = one_QDelta}
  : qDelta lrv;

datatype complex = Complex of real * real;

fun equal_complexa (Complex (x1, x2)) (Complex (y1, y2)) =
  equal_reala x1 y1 andalso equal_reala x2 y2;

val equal_complex = {equal = equal_complexa} : complex equal;

fun re (Complex (x1, x2)) = x1;

fun im (Complex (x1, x2)) = x2;

fun times_complexa x y =
  Complex
    (minus_reala (times_reala (re x) (re y)) (times_reala (im x) (im y)),
      plus_reala (times_reala (re x) (im y)) (times_reala (im x) (re y)));

val times_complex = {times = times_complexa} : complex times;

val dvd_complex = {times_dvd = times_complex} : complex dvd;

val one_complexa : complex = Complex (one_reala, zero_reala);

val one_complex = {onea = one_complexa} : complex one;

fun uminus_complexa x = Complex (uminus_reala (re x), uminus_reala (im x));

fun minus_complexa x y =
  Complex (minus_reala (re x) (re y), minus_reala (im x) (im y));

val zero_complexa : complex = Complex (zero_reala, zero_reala);

fun plus_complexa x y =
  Complex (plus_reala (re x) (re y), plus_reala (im x) (im y));

val plus_complex = {plus = plus_complexa} : complex plus;

val semigroup_add_complex = {plus_semigroup_add = plus_complex} :
  complex semigroup_add;

val cancel_semigroup_add_complex =
  {semigroup_add_cancel_semigroup_add = semigroup_add_complex} :
  complex cancel_semigroup_add;

val ab_semigroup_add_complex =
  {semigroup_add_ab_semigroup_add = semigroup_add_complex} :
  complex ab_semigroup_add;

val minus_complex = {minus = minus_complexa} : complex minus;

val cancel_ab_semigroup_add_complex =
  {ab_semigroup_add_cancel_ab_semigroup_add = ab_semigroup_add_complex,
    cancel_semigroup_add_cancel_ab_semigroup_add = cancel_semigroup_add_complex,
    minus_cancel_ab_semigroup_add = minus_complex}
  : complex cancel_ab_semigroup_add;

val zero_complex = {zerob = zero_complexa} : complex zero;

val monoid_add_complex =
  {semigroup_add_monoid_add = semigroup_add_complex,
    zero_monoid_add = zero_complex}
  : complex monoid_add;

val comm_monoid_add_complex =
  {ab_semigroup_add_comm_monoid_add = ab_semigroup_add_complex,
    monoid_add_comm_monoid_add = monoid_add_complex}
  : complex comm_monoid_add;

val cancel_comm_monoid_add_complex =
  {cancel_ab_semigroup_add_cancel_comm_monoid_add =
     cancel_ab_semigroup_add_complex,
    comm_monoid_add_cancel_comm_monoid_add = comm_monoid_add_complex}
  : complex cancel_comm_monoid_add;

val mult_zero_complex =
  {times_mult_zero = times_complex, zero_mult_zero = zero_complex} :
  complex mult_zero;

val semigroup_mult_complex = {times_semigroup_mult = times_complex} :
  complex semigroup_mult;

val semiring_complex =
  {ab_semigroup_add_semiring = ab_semigroup_add_complex,
    semigroup_mult_semiring = semigroup_mult_complex}
  : complex semiring;

val semiring_0_complex =
  {comm_monoid_add_semiring_0 = comm_monoid_add_complex,
    mult_zero_semiring_0 = mult_zero_complex,
    semiring_semiring_0 = semiring_complex}
  : complex semiring_0;

val semiring_0_cancel_complex =
  {cancel_comm_monoid_add_semiring_0_cancel = cancel_comm_monoid_add_complex,
    semiring_0_semiring_0_cancel = semiring_0_complex}
  : complex semiring_0_cancel;

val ab_semigroup_mult_complex =
  {semigroup_mult_ab_semigroup_mult = semigroup_mult_complex} :
  complex ab_semigroup_mult;

val comm_semiring_complex =
  {ab_semigroup_mult_comm_semiring = ab_semigroup_mult_complex,
    semiring_comm_semiring = semiring_complex}
  : complex comm_semiring;

val comm_semiring_0_complex =
  {comm_semiring_comm_semiring_0 = comm_semiring_complex,
    semiring_0_comm_semiring_0 = semiring_0_complex}
  : complex comm_semiring_0;

val comm_semiring_0_cancel_complex =
  {comm_semiring_0_comm_semiring_0_cancel = comm_semiring_0_complex,
    semiring_0_cancel_comm_semiring_0_cancel = semiring_0_cancel_complex}
  : complex comm_semiring_0_cancel;

val power_complex = {one_power = one_complex, times_power = times_complex} :
  complex power;

val monoid_mult_complex =
  {semigroup_mult_monoid_mult = semigroup_mult_complex,
    power_monoid_mult = power_complex}
  : complex monoid_mult;

val numeral_complex =
  {one_numeral = one_complex, semigroup_add_numeral = semigroup_add_complex} :
  complex numeral;

val semiring_numeral_complex =
  {monoid_mult_semiring_numeral = monoid_mult_complex,
    numeral_semiring_numeral = numeral_complex,
    semiring_semiring_numeral = semiring_complex}
  : complex semiring_numeral;

val zero_neq_one_complex =
  {one_zero_neq_one = one_complex, zero_zero_neq_one = zero_complex} :
  complex zero_neq_one;

val semiring_1_complex =
  {semiring_numeral_semiring_1 = semiring_numeral_complex,
    semiring_0_semiring_1 = semiring_0_complex,
    zero_neq_one_semiring_1 = zero_neq_one_complex}
  : complex semiring_1;

val semiring_1_cancel_complex =
  {semiring_0_cancel_semiring_1_cancel = semiring_0_cancel_complex,
    semiring_1_semiring_1_cancel = semiring_1_complex}
  : complex semiring_1_cancel;

val comm_monoid_mult_complex =
  {ab_semigroup_mult_comm_monoid_mult = ab_semigroup_mult_complex,
    monoid_mult_comm_monoid_mult = monoid_mult_complex,
    dvd_comm_monoid_mult = dvd_complex}
  : complex comm_monoid_mult;

val comm_semiring_1_complex =
  {comm_monoid_mult_comm_semiring_1 = comm_monoid_mult_complex,
    comm_semiring_0_comm_semiring_1 = comm_semiring_0_complex,
    semiring_1_comm_semiring_1 = semiring_1_complex}
  : complex comm_semiring_1;

val comm_semiring_1_cancel_complex =
  {comm_semiring_0_cancel_comm_semiring_1_cancel =
     comm_semiring_0_cancel_complex,
    comm_semiring_1_comm_semiring_1_cancel = comm_semiring_1_complex,
    semiring_1_cancel_comm_semiring_1_cancel = semiring_1_cancel_complex}
  : complex comm_semiring_1_cancel;

val comm_semiring_1_cancel_crossproduct_complex =
  {comm_semiring_1_cancel_comm_semiring_1_cancel_crossproduct =
     comm_semiring_1_cancel_complex}
  : complex comm_semiring_1_cancel_crossproduct;

val semiring_no_zero_divisors_complex =
  {semiring_0_semiring_no_zero_divisors = semiring_0_complex} :
  complex semiring_no_zero_divisors;

val semiring_1_no_zero_divisors_complex =
  {semiring_1_semiring_1_no_zero_divisors = semiring_1_complex,
    semiring_no_zero_divisors_semiring_1_no_zero_divisors =
      semiring_no_zero_divisors_complex}
  : complex semiring_1_no_zero_divisors;

val semiring_no_zero_divisors_cancel_complex =
  {semiring_no_zero_divisors_semiring_no_zero_divisors_cancel =
     semiring_no_zero_divisors_complex}
  : complex semiring_no_zero_divisors_cancel;

val uminus_complex = {uminus = uminus_complexa} : complex uminus;

val group_add_complex =
  {cancel_semigroup_add_group_add = cancel_semigroup_add_complex,
    minus_group_add = minus_complex, monoid_add_group_add = monoid_add_complex,
    uminus_group_add = uminus_complex}
  : complex group_add;

val ab_group_add_complex =
  {cancel_comm_monoid_add_ab_group_add = cancel_comm_monoid_add_complex,
    group_add_ab_group_add = group_add_complex}
  : complex ab_group_add;

val ring_complex =
  {ab_group_add_ring = ab_group_add_complex,
    semiring_0_cancel_ring = semiring_0_cancel_complex}
  : complex ring;

val ring_no_zero_divisors_complex =
  {ring_ring_no_zero_divisors = ring_complex,
    semiring_no_zero_divisors_cancel_ring_no_zero_divisors =
      semiring_no_zero_divisors_cancel_complex}
  : complex ring_no_zero_divisors;

val neg_numeral_complex =
  {group_add_neg_numeral = group_add_complex,
    numeral_neg_numeral = numeral_complex}
  : complex neg_numeral;

val ring_1_complex =
  {neg_numeral_ring_1 = neg_numeral_complex, ring_ring_1 = ring_complex,
    semiring_1_cancel_ring_1 = semiring_1_cancel_complex}
  : complex ring_1;

val ring_1_no_zero_divisors_complex =
  {ring_1_ring_1_no_zero_divisors = ring_1_complex,
    ring_no_zero_divisors_ring_1_no_zero_divisors =
      ring_no_zero_divisors_complex,
    semiring_1_no_zero_divisors_ring_1_no_zero_divisors =
      semiring_1_no_zero_divisors_complex}
  : complex ring_1_no_zero_divisors;

val comm_ring_complex =
  {comm_semiring_0_cancel_comm_ring = comm_semiring_0_cancel_complex,
    ring_comm_ring = ring_complex}
  : complex comm_ring;

val comm_ring_1_complex =
  {comm_ring_comm_ring_1 = comm_ring_complex,
    comm_semiring_1_cancel_comm_ring_1 = comm_semiring_1_cancel_complex,
    ring_1_comm_ring_1 = ring_1_complex}
  : complex comm_ring_1;

val semidom_complex =
  {comm_semiring_1_cancel_semidom = comm_semiring_1_cancel_complex,
    semiring_1_no_zero_divisors_semidom = semiring_1_no_zero_divisors_complex}
  : complex semidom;

val idom_complex =
  {comm_ring_1_idom = comm_ring_1_complex,
    ring_1_no_zero_divisors_idom = ring_1_no_zero_divisors_complex,
    semidom_idom = semidom_complex,
    comm_semiring_1_cancel_crossproduct_idom =
      comm_semiring_1_cancel_crossproduct_complex}
  : complex idom;

fun inverse_complexa x =
  Complex
    (divide_reala (re x)
       (plus_reala
         (binary_power monoid_mult_real (re x)
           (nat_of_integer (2 : IntInf.int)))
         (binary_power monoid_mult_real (im x)
           (nat_of_integer (2 : IntInf.int)))),
      divide_reala (uminus_reala (im x))
        (plus_reala
          (binary_power monoid_mult_real (re x)
            (nat_of_integer (2 : IntInf.int)))
          (binary_power monoid_mult_real (im x)
            (nat_of_integer (2 : IntInf.int)))));

fun divide_complexa x y = times_complexa x (inverse_complexa y);

val ufd_complex = {idom_ufd = idom_complex} : complex ufd;

val divide_complex = {divide = divide_complexa} : complex divide;

val inverse_complex =
  {divide_inverse = divide_complex, inverse = inverse_complexa} :
  complex inverse;

val division_ring_complex =
  {inverse_division_ring = inverse_complex,
    ring_1_no_zero_divisors_division_ring = ring_1_no_zero_divisors_complex}
  : complex division_ring;

val semidom_divide_complex =
  {divide_semidom_divide = divide_complex,
    semidom_semidom_divide = semidom_complex,
    semiring_no_zero_divisors_cancel_semidom_divide =
      semiring_no_zero_divisors_cancel_complex}
  : complex semidom_divide;

val idom_divide_complex =
  {idom_idom_divide = idom_complex,
    semidom_divide_idom_divide = semidom_divide_complex}
  : complex idom_divide;

val field_complex =
  {division_ring_field = division_ring_complex,
    idom_divide_field = idom_divide_complex, ufd_field = ufd_complex}
  : complex field;

val semiring_char_0_complex = {semiring_1_semiring_char_0 = semiring_1_complex}
  : complex semiring_char_0;

val ring_char_0_complex =
  {semiring_char_0_ring_char_0 = semiring_char_0_complex,
    ring_1_ring_char_0 = ring_1_complex}
  : complex ring_char_0;

val ceq_complexa : (complex -> complex -> bool) option = SOME equal_complexa;

val ceq_complex = {ceq = ceq_complexa} : complex ceq;

val set_impl_complexa : (complex, set_impla) phantom = Phantom Set_DList;

val set_impl_complex = {set_impl = set_impl_complexa} : complex set_impl;

fun comparator_prod comp_a comp_b (x, xa) (y, ya) =
  (case comp_a x y of Eq => comp_b xa ya | Lt => Lt | Gt => Gt);

fun compare_proda A_ B_ = comparator_prod (compare A_) (compare B_);

fun compare_complex x y =
  compare_proda compare_real compare_real (re x, im x) (re y, im y);

val ccompare_complexa : (complex -> complex -> ordera) option =
  SOME compare_complex;

val ccompare_complex = {ccompare = ccompare_complexa} : complex ccompare;

fun scaleR_complexa r x = Complex (times_reala r (re x), times_reala r (im x));

val scaleR_complex = {scaleR = scaleR_complexa} : complex scaleR;

val real_vector_complex =
  {ab_group_add_real_vector = ab_group_add_complex,
    scaleR_real_vector = scaleR_complex}
  : complex real_vector;

type 'a real_algebra =
  {real_vector_real_algebra : 'a real_vector, ring_real_algebra : 'a ring};
val real_vector_real_algebra = #real_vector_real_algebra :
  'a real_algebra -> 'a real_vector;
val ring_real_algebra = #ring_real_algebra : 'a real_algebra -> 'a ring;

val real_algebra_complex =
  {real_vector_real_algebra = real_vector_complex,
    ring_real_algebra = ring_complex}
  : complex real_algebra;

type 'a real_algebra_1 =
  {ring_char_0_real_algebra_1 : 'a ring_char_0,
    real_algebra_real_algebra_1 : 'a real_algebra};
val ring_char_0_real_algebra_1 = #ring_char_0_real_algebra_1 :
  'a real_algebra_1 -> 'a ring_char_0;
val real_algebra_real_algebra_1 = #real_algebra_real_algebra_1 :
  'a real_algebra_1 -> 'a real_algebra;

val real_algebra_1_complex =
  {ring_char_0_real_algebra_1 = ring_char_0_complex,
    real_algebra_real_algebra_1 = real_algebra_complex}
  : complex real_algebra_1;

datatype 'a formula = Atom of 'a | NegAtom of 'a |
  Conjunction of 'a formula list | Disjunction of 'a formula list;

fun equal_formula A_ = {equal = equal_formulaa A_} : 'a formula equal
and equal_formulaa A_ (Conjunction x3) (Disjunction x4) = false
  | equal_formulaa A_ (Disjunction x4) (Conjunction x3) = false
  | equal_formulaa A_ (NegAtom x2) (Disjunction x4) = false
  | equal_formulaa A_ (Disjunction x4) (NegAtom x2) = false
  | equal_formulaa A_ (NegAtom x2) (Conjunction x3) = false
  | equal_formulaa A_ (Conjunction x3) (NegAtom x2) = false
  | equal_formulaa A_ (Atom x1) (Disjunction x4) = false
  | equal_formulaa A_ (Disjunction x4) (Atom x1) = false
  | equal_formulaa A_ (Atom x1) (Conjunction x3) = false
  | equal_formulaa A_ (Conjunction x3) (Atom x1) = false
  | equal_formulaa A_ (Atom x1) (NegAtom x2) = false
  | equal_formulaa A_ (NegAtom x2) (Atom x1) = false
  | equal_formulaa A_ (Disjunction x4) (Disjunction y4) =
    equal_lista (equal_formula A_) x4 y4
  | equal_formulaa A_ (Conjunction x3) (Conjunction y3) =
    equal_lista (equal_formula A_) x3 y3
  | equal_formulaa A_ (NegAtom x2) (NegAtom y2) = eq A_ x2 y2
  | equal_formulaa A_ (Atom x1) (Atom y1) = eq A_ x1 y1;

fun modulo_poly (A1_, A2_) =
  {divide_modulo = divide_poly (A2_, idom_divide_field A1_),
    dvd_modulo =
      dvd_poly
        (A2_, (comm_semiring_1_comm_semiring_1_cancel o
                comm_semiring_1_cancel_semidom o semidom_idom o
                idom_idom_divide o idom_divide_field)
                A1_,
          (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
            semiring_1_no_zero_divisors_semidom o semidom_idom o
            idom_idom_divide o idom_divide_field)
            A1_),
    modulo = modulo_polya (A1_, A2_)}
  : 'a poly modulo;

fun semiring_modulo_poly (A1_, A2_) =
  {comm_semiring_1_cancel_semiring_modulo =
     comm_semiring_1_cancel_poly
       (A2_, (comm_ring_1_idom o idom_idom_divide o idom_divide_field) A1_,
         (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
           semiring_1_no_zero_divisors_semidom o semidom_idom o
           idom_idom_divide o idom_divide_field)
           A1_),
    modulo_semiring_modulo = modulo_poly (A1_, A2_)}
  : 'a poly semiring_modulo;

fun semidom_modulo_poly (A1_, A2_) =
  {algebraic_semidom_semidom_modulo =
     algebraic_semidom_poly (A2_, idom_divide_field A1_),
    semiring_modulo_semidom_modulo = semiring_modulo_poly (A1_, A2_)}
  : 'a poly semidom_modulo;

datatype hints = Hints of int list | Simplex;

fun showsp_hints p Simplex =
  shows_string [#"S", #"i", #"m", #"p", #"l", #"e", #"x"]
  | showsp_hints p (Hints x) =
    shows_pl p o shows_string [#"H", #"i", #"n", #"t", #"s"] o shows_space o
      showsp_list showsp_int one_nata x o
      shows_pr p;

fun shows_prec_hints x = showsp_hints x;

fun shows_list_hints x = showsp_list shows_prec_hints zero_nata x;

val show_hints = {shows_prec = shows_prec_hints, shows_list = shows_list_hints}
  : hints show;

val default_hintsa : hints = Simplex;

val default_hints = {default = default_hintsa} : hints default;

fun count_of A_ xs x = (case map_of A_ xs x of NONE => zero_nata | SOME n => n);

datatype ('b, 'a) alist = Alist of ('b * 'a) list;

fun impl_ofa (Alist x) = x;

datatype 'a multiset = Bag of ('a, nat) alist;

fun count A_ (Bag xs) = count_of A_ (impl_ofa xs);

fun subseteq_mset A_ (Bag xs) a =
  list_all (fn (x, n) => less_eq_nat n (count A_ a x)) (impl_ofa xs);

fun equal_multiseta A_ m1 m2 =
  subseteq_mset A_ m1 m2 andalso subseteq_mset A_ m2 m1;

fun equal_multiset A_ = {equal = equal_multiseta A_} : 'a multiset equal;

fun map_default A_ k v f [] = [(k, v)]
  | map_default A_ k v f (p :: ps) =
    (if eq A_ (fst p) k then (k, f (snd p)) :: ps
      else p :: map_default A_ k v f ps);

fun join_raw A_ f xs ys =
  foldr (fn (k, v) => map_default A_ k v (fn va => f k (va, v))) ys xs;

fun joina A_ xc xd xe = Alist (join_raw A_ xc (impl_ofa xd) (impl_ofa xe));

fun plus_multiseta A_ (Bag xs) (Bag ys) =
  Bag (joina A_ (fn _ => fn (a, b) => plus_nata a b) xs ys);

fun plus_multiset A_ = {plus = plus_multiseta A_} : 'a multiset plus;

val emptya : ('a, 'b) alist = Alist [];

val zero_multiseta : 'a multiset = Bag emptya;

val zero_multiset = {zerob = zero_multiseta} : 'a multiset zero;

fun semigroup_add_multiset A_ = {plus_semigroup_add = plus_multiset A_} :
  'a multiset semigroup_add;

fun monoid_add_multiset A_ =
  {semigroup_add_monoid_add = semigroup_add_multiset A_,
    zero_monoid_add = zero_multiset}
  : 'a multiset monoid_add;

fun ab_semigroup_add_multiset A_ =
  {semigroup_add_ab_semigroup_add = semigroup_add_multiset A_} :
  'a multiset ab_semigroup_add;

fun comm_monoid_add_multiset A_ =
  {ab_semigroup_add_comm_monoid_add = ab_semigroup_add_multiset A_,
    monoid_add_comm_monoid_add = monoid_add_multiset A_}
  : 'a multiset comm_monoid_add;

datatype 'a monom = Abs_monom of ('a * nat) list;

fun rep_monom A_ (Abs_monom x) = x;

fun equal_prod A_ B_ = {equal = equal_proda A_ B_} : ('a * 'b) equal;

fun equal_monoma (A1_, A2_) xa xc =
  equal_lista (equal_prod A1_ equal_nat) (rep_monom A2_ xa) (rep_monom A2_ xc);

fun equal_monom (A1_, A2_) = {equal = equal_monoma (A1_, A2_)} : 'a monom equal;

fun showsp_prod s1 s2 p (x, y) =
  shows_string [#"("] o s1 one_nata x o shows_string [#",", #" "] o
    s2 one_nata y o
    shows_string [#")"];

fun shows_prec_prod A_ B_ = showsp_prod (shows_prec A_) (shows_prec B_);

fun shows_list_prod A_ B_ = showsp_list (shows_prec_prod A_ B_) zero_nata;

fun show_prod A_ B_ =
  {shows_prec = shows_prec_prod A_ B_, shows_list = shows_list_prod A_ B_} :
  ('a * 'b) show;

fun less_eq_prod A_ B_ (x1, y1) (x2, y2) =
  less A_ x1 x2 orelse less_eq A_ x1 x2 andalso less_eq B_ y1 y2;

fun less_prod A_ B_ (x1, y1) (x2, y2) =
  less A_ x1 x2 orelse less_eq A_ x1 x2 andalso less B_ y1 y2;

fun ord_prod A_ B_ = {less_eq = less_eq_prod A_ B_, less = less_prod A_ B_} :
  ('a * 'b) ord;

fun quasi_order_prod A_ B_ =
  {ord_quasi_order =
     ord_prod ((ord_preorder o preorder_order) A_)
       ((ord_preorder o preorder_order) B_)}
  : ('a * 'b) quasi_order;

fun weak_order_prod A_ B_ = {quasi_order_weak_order = quasi_order_prod A_ B_} :
  ('a * 'b) weak_order;

fun preorder_prod A_ B_ =
  {ord_preorder = ord_prod (ord_preorder A_) (ord_preorder B_)} :
  ('a * 'b) preorder;

fun order_prod A_ B_ =
  {preorder_order = preorder_prod (preorder_order A_) (preorder_order B_),
    weak_order_order = weak_order_prod A_ B_}
  : ('a * 'b) order;

fun linorder_prod A_ B_ =
  {order_linorder = order_prod (order_linorder A_) (order_linorder B_)} :
  ('a * 'b) linorder;

fun compare_prod A_ B_ = {compare = compare_proda A_ B_} : ('a * 'b) compare;

fun compare_order_prod A_ B_ =
  {compare_compare_order =
     compare_prod (compare_compare_order A_) (compare_compare_order B_),
    linorder_compare_order =
      linorder_prod (linorder_compare_order A_) (linorder_compare_order B_)}
  : ('a * 'b) compare_order;

fun key_prod A_ B_ =
  {compare_order_key =
     compare_order_prod (compare_order_key A_) (compare_order_key B_)}
  : ('a * 'b) key;

fun equality_prod eq_a eq_b (x, xa) (y, ya) = eq_a x y andalso eq_b xa ya;

fun ceq_proda A_ B_ =
  (case ceq A_ of NONE => NONE
    | SOME eq_a =>
      (case ceq B_ of NONE => NONE
        | SOME eq_b => SOME (equality_prod eq_a eq_b)));

fun ceq_prod A_ B_ = {ceq = ceq_proda A_ B_} : ('a * 'b) ceq;

fun set_impl_choose2 Set_Monada Set_Monada = Set_Monada
  | set_impl_choose2 Set_RBT Set_RBT = Set_RBT
  | set_impl_choose2 Set_DList Set_DList = Set_DList
  | set_impl_choose2 Set_Collect Set_Collect = Set_Collect
  | set_impl_choose2 x y = Set_Choose;

fun set_impl_proda A_ B_ =
  Phantom
    (set_impl_choose2 (of_phantom (set_impl A_)) (of_phantom (set_impl B_)));

fun set_impl_prod A_ B_ = {set_impl = set_impl_proda A_ B_} :
  ('a * 'b) set_impl;

fun finite_UNIV_proda A_ B_ =
  Phantom (of_phantom (finite_UNIV A_) andalso of_phantom (finite_UNIV B_));

fun card_UNIV_proda A_ B_ =
  Phantom
    (times_nata (of_phantom (card_UNIVa A_)) (of_phantom (card_UNIVa B_)));

fun finite_UNIV_prod A_ B_ = {finite_UNIV = finite_UNIV_proda A_ B_} :
  ('a * 'b) finite_UNIV;

fun card_UNIV_prod A_ B_ =
  {finite_UNIV_card_UNIV =
     finite_UNIV_prod (finite_UNIV_card_UNIV A_) (finite_UNIV_card_UNIV B_),
    card_UNIVa = card_UNIV_proda A_ B_}
  : ('a * 'b) card_UNIV;

fun product [] uu = []
  | product (x :: xs) ys = map (fn a => (x, a)) ys @ product xs ys;

fun cEnum_prod A_ B_ =
  (case cEnum A_ of NONE => NONE
    | SOME (enum_a, (enum_all_a, enum_ex_a)) =>
      (case cEnum B_ of NONE => NONE
        | SOME (enum_b, (enum_all_b, enum_ex_b)) =>
          SOME (product enum_a enum_b,
                 ((fn p => enum_all_a (fn x => enum_all_b (fn y => p (x, y)))),
                   (fn p =>
                     enum_ex_a (fn x => enum_ex_b (fn y => p (x, y))))))));

fun cenum_prod A_ B_ = {cEnum = cEnum_prod A_ B_} : ('a * 'b) cenum;

fun ccompare_proda A_ B_ =
  (case ccompare A_ of NONE => NONE
    | SOME comp_a =>
      (case ccompare B_ of NONE => NONE
        | SOME comp_b => SOME (comparator_prod comp_a comp_b)));

fun ccompare_prod A_ B_ = {ccompare = ccompare_proda A_ B_} :
  ('a * 'b) ccompare;

fun mapping_impl_choose2 Mapping_RBT Mapping_RBT = Mapping_RBT
  | mapping_impl_choose2 Mapping_Assoc_List Mapping_Assoc_List =
    Mapping_Assoc_List
  | mapping_impl_choose2 Mapping_Mapping Mapping_Mapping = Mapping_Mapping
  | mapping_impl_choose2 x y = Mapping_Choose;

fun mapping_impl_proda A_ B_ =
  Phantom
    (mapping_impl_choose2 (of_phantom (mapping_impl A_))
      (of_phantom (mapping_impl B_)));

fun mapping_impl_prod A_ B_ = {mapping_impl = mapping_impl_proda A_ B_} :
  ('a * 'b) mapping_impl;

fun cproper_interval_proda A_ B_ NONE NONE = true
  | cproper_interval_proda A_ B_ NONE (SOME (y1, y2)) =
    cproper_interval A_ NONE (SOME y1) orelse cproper_interval B_ NONE (SOME y2)
  | cproper_interval_proda A_ B_ (SOME (x1, x2)) NONE =
    cproper_interval A_ (SOME x1) NONE orelse cproper_interval B_ (SOME x2) NONE
  | cproper_interval_proda A_ B_ (SOME (x1, x2)) (SOME (y1, y2)) =
    cproper_interval A_ (SOME x1) (SOME y1) orelse
      (lt_of_comp (the (ccompare (ccompare_cproper_interval A_))) x1 y1 andalso
         (cproper_interval B_ (SOME x2) NONE orelse
           cproper_interval B_ NONE (SOME y2)) orelse
        not (lt_of_comp (the (ccompare (ccompare_cproper_interval A_))) y1
              x1) andalso
          cproper_interval B_ (SOME x2) (SOME y2));

fun cproper_interval_prod A_ B_ =
  {ccompare_cproper_interval =
     ccompare_prod (ccompare_cproper_interval A_)
       (ccompare_cproper_interval B_),
    cproper_interval = cproper_interval_proda A_ B_}
  : ('a * 'b) cproper_interval;

fun comparator_unit x y = Eq;

fun compare_unita x = comparator_unit x;

val compare_unit = {compare = compare_unita} : unit compare;

datatype ('a, 'b, 'c, 'd) transition_rule =
  Transition of 'd * 'd * ('a, ('b trans_var * 'c)) term formula;

fun equal_transition_rule A_ B_ C_ D_ (Transition (x1, x2, x3))
  (Transition (y1, y2, y3)) =
  eq D_ x1 y1 andalso
    (eq D_ x2 y2 andalso
      equal_formulaa (equal_term A_ (equal_prod (equal_trans_var B_) C_)) x3
        y3);

fun ceq_transition_rulea A_ B_ C_ D_ = SOME (equal_transition_rule A_ B_ C_ D_);

fun ceq_transition_rule A_ B_ C_ D_ = {ceq = ceq_transition_rulea A_ B_ C_ D_} :
  ('a, 'b, 'c, 'd) transition_rule ceq;

val set_impl_transition_rulea :
  (('a, 'b, 'c, 'd) transition_rule, set_impla) phantom
  = Phantom Set_RBT;

val set_impl_transition_rule = {set_impl = set_impl_transition_rulea} :
  ('a, 'b, 'c, 'd) transition_rule set_impl;

fun comparator_formula comp_a (Disjunction x) (Disjunction yc) =
  comparator_list (comparator_formula comp_a) x yc
  | comparator_formula comp_a (Disjunction x) (Conjunction yb) = Gt
  | comparator_formula comp_a (Disjunction x) (NegAtom ya) = Gt
  | comparator_formula comp_a (Disjunction x) (Atom y) = Gt
  | comparator_formula comp_a (Conjunction x) (Disjunction yc) = Lt
  | comparator_formula comp_a (Conjunction x) (Conjunction yb) =
    comparator_list (comparator_formula comp_a) x yb
  | comparator_formula comp_a (Conjunction x) (NegAtom ya) = Gt
  | comparator_formula comp_a (Conjunction x) (Atom y) = Gt
  | comparator_formula comp_a (NegAtom x) (Disjunction yc) = Lt
  | comparator_formula comp_a (NegAtom x) (Conjunction yb) = Lt
  | comparator_formula comp_a (NegAtom x) (NegAtom ya) = comp_a x ya
  | comparator_formula comp_a (NegAtom x) (Atom y) = Gt
  | comparator_formula comp_a (Atom x) (Disjunction yc) = Lt
  | comparator_formula comp_a (Atom x) (Conjunction yb) = Lt
  | comparator_formula comp_a (Atom x) (NegAtom ya) = Lt
  | comparator_formula comp_a (Atom x) (Atom y) = comp_a x y;

fun comparator_transition_rule comp_f comp_v comp_t comp_l
  (Transition (x, xa, xb)) (Transition (y, ya, yb)) =
  (case comp_l x y
    of Eq =>
      (case comp_l xa ya
        of Eq =>
          comparator_formula
            (comparator_term comp_f
              (comparator_prod (comparator_trans_var comp_v) comp_t))
            xb yb
        | Lt => Lt | Gt => Gt)
    | Lt => Lt | Gt => Gt);

fun ccompare_transition_rulea A_ B_ C_ D_ =
  (case ccompare A_ of NONE => NONE
    | SOME comp_f =>
      (case ccompare B_ of NONE => NONE
        | SOME comp_v =>
          (case ccompare C_ of NONE => NONE
            | SOME comp_t =>
              (case ccompare D_ of NONE => NONE
                | SOME comp_l =>
                  SOME (comparator_transition_rule comp_f comp_v comp_t
                         comp_l)))));

fun ccompare_transition_rule A_ B_ C_ D_ =
  {ccompare = ccompare_transition_rulea A_ B_ C_ D_} :
  ('a, 'b, 'c, 'd) transition_rule ccompare;

datatype ('a, 'b) gctxt = GCHole | GCFun of 'a * ('a, 'b) gctxt list;

fun equal_gctxt A_ = {equal = equal_gctxta A_} : ('a, 'b) gctxt equal
and equal_gctxta A_ GCHole (GCFun (x21, x22)) = false
  | equal_gctxta A_ (GCFun (x21, x22)) GCHole = false
  | equal_gctxta A_ (GCFun (x21, x22)) (GCFun (y21, y22)) =
    eq A_ x21 y21 andalso equal_lista (equal_gctxt A_) x22 y22
  | equal_gctxta A_ GCHole GCHole = true;

fun ceq_gctxta A_ = SOME (equal_gctxta A_);

fun ceq_gctxt A_ = {ceq = ceq_gctxta A_} : ('a, 'b) gctxt ceq;

val set_impl_gctxta : (('a, 'b) gctxt, set_impla) phantom = Phantom Set_RBT;

val set_impl_gctxt = {set_impl = set_impl_gctxta} : ('a, 'b) gctxt set_impl;

fun comparator_gctxt comp_f (GCFun (x, xa)) (GCFun (y, ya)) =
  (case comp_f x y of Eq => comparator_list (comparator_gctxt comp_f) xa ya
    | Lt => Lt | Gt => Gt)
  | comparator_gctxt comp_f (GCFun (x, xa)) GCHole = Gt
  | comparator_gctxt comp_f GCHole (GCFun (y, ya)) = Lt
  | comparator_gctxt comp_f GCHole GCHole = Eq;

fun compare_gctxt A_ = comparator_gctxt (compare A_);

fun ccompare_gctxta A_ B_ = SOME (compare_gctxt A_);

fun ccompare_gctxt A_ B_ = {ccompare = ccompare_gctxta A_ B_} :
  ('a, 'b) gctxt ccompare;

datatype ('a, 'b) acterm = AVar of 'b | AFun of 'a * ('a, 'b) acterm list |
  AAC of 'a * ('a, 'b) acterm multiset;

fun equal_acterm A_ B_ = {equal = equal_acterma A_ B_} : ('a, 'b) acterm equal
and equal_acterma A_ B_ (AFun (x21, x22)) (AAC (x31, x32)) = false
  | equal_acterma A_ B_ (AAC (x31, x32)) (AFun (x21, x22)) = false
  | equal_acterma A_ B_ (AVar x1) (AAC (x31, x32)) = false
  | equal_acterma A_ B_ (AAC (x31, x32)) (AVar x1) = false
  | equal_acterma A_ B_ (AVar x1) (AFun (x21, x22)) = false
  | equal_acterma A_ B_ (AFun (x21, x22)) (AVar x1) = false
  | equal_acterma A_ B_ (AAC (x31, x32)) (AAC (y31, y32)) =
    eq A_ x31 y31 andalso equal_multiseta (equal_acterm A_ B_) x32 y32
  | equal_acterma A_ B_ (AFun (x21, x22)) (AFun (y21, y22)) =
    eq A_ x21 y21 andalso equal_lista (equal_acterm A_ B_) x22 y22
  | equal_acterma A_ B_ (AVar x1) (AVar y1) = eq B_ x1 y1;

datatype ('a, 'b) ta_rule = TA_rule of 'b * 'a list * 'a;

fun equal_ta_rulea A_ B_ (TA_rule (x1, x2, x3)) (TA_rule (y1, y2, y3)) =
  eq B_ x1 y1 andalso (equal_lista A_ x2 y2 andalso eq A_ x3 y3);

fun equal_ta_rule A_ B_ = {equal = equal_ta_rulea A_ B_} :
  ('a, 'b) ta_rule equal;

fun show_ta_rulea A_ B_ (TA_rule (f, qs, q)) =
  shows_prec B_ zero_nata f o shows_prec_list A_ zero_nata qs o
    shows_prec_list show_char zero_nata [#" ", #"-", #">", #" "] o
    shows_prec A_ zero_nata q;

fun shows_prec_ta_rule A_ B_ p r = show_ta_rulea A_ B_ r;

fun shows_list_ta_rule A_ B_ ps =
  showsp_list (shows_prec_ta_rule A_ B_) zero_nata ps;

fun show_ta_rule A_ B_ =
  {shows_prec = shows_prec_ta_rule A_ B_, shows_list = shows_list_ta_rule A_ B_}
  : ('a, 'b) ta_rule show;

fun comparator_ta_rule comp_q comp_f (TA_rule (x, xa, xb)) (TA_rule (y, ya, yb))
  = (case comp_f x y
      of Eq =>
        (case comparator_list comp_q xa ya of Eq => comp_q xb yb | Lt => Lt
          | Gt => Gt)
      | Lt => Lt | Gt => Gt);

fun compare_ta_rule A_ B_ = comparator_ta_rule (compare A_) (compare B_);

fun less_eq_ta_rule A_ B_ = le_of_comp (compare_ta_rule A_ B_);

fun less_ta_rule A_ B_ = lt_of_comp (compare_ta_rule A_ B_);

fun ord_ta_rule A_ B_ =
  {less_eq = less_eq_ta_rule A_ B_, less = less_ta_rule A_ B_} :
  ('a, 'b) ta_rule ord;

fun quasi_order_ta_rule A_ B_ = {ord_quasi_order = ord_ta_rule A_ B_} :
  ('a, 'b) ta_rule quasi_order;

fun weak_order_ta_rule A_ B_ =
  {quasi_order_weak_order = quasi_order_ta_rule A_ B_} :
  ('a, 'b) ta_rule weak_order;

fun preorder_ta_rule A_ B_ = {ord_preorder = ord_ta_rule A_ B_} :
  ('a, 'b) ta_rule preorder;

fun order_ta_rule A_ B_ =
  {preorder_order = preorder_ta_rule A_ B_,
    weak_order_order = weak_order_ta_rule A_ B_}
  : ('a, 'b) ta_rule order;

fun ceq_ta_rulea A_ B_ = SOME (equal_ta_rulea A_ B_);

fun ceq_ta_rule A_ B_ = {ceq = ceq_ta_rulea A_ B_} : ('a, 'b) ta_rule ceq;

val set_impl_ta_rulea : (('a, 'b) ta_rule, set_impla) phantom = Phantom Set_RBT;

val set_impl_ta_rule = {set_impl = set_impl_ta_rulea} :
  ('a, 'b) ta_rule set_impl;

fun linorder_ta_rule A_ B_ = {order_linorder = order_ta_rule A_ B_} :
  ('a, 'b) ta_rule linorder;

val cEnum_ta_rule :
  (('a, 'b) ta_rule list *
    (((('a, 'b) ta_rule -> bool) -> bool) *
      ((('a, 'b) ta_rule -> bool) -> bool))) option
  = NONE;

val cenum_ta_rule = {cEnum = cEnum_ta_rule} : ('a, 'b) ta_rule cenum;

val finite_UNIV_ta_rulea : (('a, 'b) ta_rule, bool) phantom = Phantom false;

val finite_UNIV_ta_rule = {finite_UNIV = finite_UNIV_ta_rulea} :
  ('a, 'b) ta_rule finite_UNIV;

fun ccompare_ta_rulea A_ B_ =
  (case ccompare A_ of NONE => NONE
    | SOME comp_q =>
      (case ccompare B_ of NONE => NONE
        | SOME comp_f => SOME (comparator_ta_rule comp_q comp_f)));

fun ccompare_ta_rule A_ B_ = {ccompare = ccompare_ta_rulea A_ B_} :
  ('a, 'b) ta_rule ccompare;

fun cproper_interval_ta_rulea A_ B_ = (fn _ => fn _ => false);

fun cproper_interval_ta_rule A_ B_ =
  {ccompare_cproper_interval = ccompare_ta_rule A_ B_,
    cproper_interval = cproper_interval_ta_rulea A_ B_}
  : ('a, 'b) ta_rule cproper_interval;

datatype ('a, 'b) mctxt = MVar of 'b | MHole | MFun of 'a * ('a, 'b) mctxt list;

fun equal_mctxt A_ B_ = {equal = equal_mctxta A_ B_} : ('a, 'b) mctxt equal
and equal_mctxta A_ B_ MHole (MFun (x31, x32)) = false
  | equal_mctxta A_ B_ (MFun (x31, x32)) MHole = false
  | equal_mctxta A_ B_ (MVar x1) (MFun (x31, x32)) = false
  | equal_mctxta A_ B_ (MFun (x31, x32)) (MVar x1) = false
  | equal_mctxta A_ B_ (MVar x1) MHole = false
  | equal_mctxta A_ B_ MHole (MVar x1) = false
  | equal_mctxta A_ B_ (MFun (x31, x32)) (MFun (y31, y32)) =
    eq A_ x31 y31 andalso equal_lista (equal_mctxt A_ B_) x32 y32
  | equal_mctxta A_ B_ (MVar x1) (MVar y1) = eq B_ x1 y1
  | equal_mctxta A_ B_ MHole MHole = true;

fun ceq_mctxta A_ B_ = SOME (equal_mctxta A_ B_);

fun ceq_mctxt A_ B_ = {ceq = ceq_mctxta A_ B_} : ('a, 'b) mctxt ceq;

val set_impl_mctxta : (('a, 'b) mctxt, set_impla) phantom = Phantom Set_RBT;

val set_impl_mctxt = {set_impl = set_impl_mctxta} : ('a, 'b) mctxt set_impl;

fun comparator_mctxt comp_f comp_v (MFun (x, xa)) (MFun (ya, yb)) =
  (case comp_f x ya
    of Eq => comparator_list (comparator_mctxt comp_f comp_v) xa yb | Lt => Lt
    | Gt => Gt)
  | comparator_mctxt comp_f comp_v (MFun (x, xa)) MHole = Gt
  | comparator_mctxt comp_f comp_v (MFun (x, xa)) (MVar y) = Gt
  | comparator_mctxt comp_f comp_v MHole (MFun (ya, yb)) = Lt
  | comparator_mctxt comp_f comp_v MHole MHole = Eq
  | comparator_mctxt comp_f comp_v MHole (MVar y) = Gt
  | comparator_mctxt comp_f comp_v (MVar x) (MFun (ya, yb)) = Lt
  | comparator_mctxt comp_f comp_v (MVar x) MHole = Lt
  | comparator_mctxt comp_f comp_v (MVar x) (MVar y) = comp_v x y;

fun compare_mctxt A_ B_ = comparator_mctxt (compare A_) (compare B_);

fun ccompare_mctxta A_ B_ = SOME (compare_mctxt A_ B_);

fun ccompare_mctxt A_ B_ = {ccompare = ccompare_mctxta A_ B_} :
  ('a, 'b) mctxt ccompare;

datatype arctic = MinInfty | Num_arc of int;

fun equal_arctica MinInfty (Num_arc x2) = false
  | equal_arctica (Num_arc x2) MinInfty = false
  | equal_arctica (Num_arc x2) (Num_arc y2) = equal_inta x2 y2
  | equal_arctica MinInfty MinInfty = true;

val equal_arctic = {equal = equal_arctica} : arctic equal;

fun shows_arctic (Num_arc i) = shows_prec_int zero_nata i
  | shows_arctic MinInfty =
    shows_prec_list show_char zero_nata [#"-", #"i", #"n", #"f"];

fun shows_prec_arctic p ai = shows_arctic ai;

fun shows_list_arctic asa = showsp_list shows_prec_arctic zero_nata asa;

val show_arctic =
  {shows_prec = shows_prec_arctic, shows_list = shows_list_arctic} :
  arctic show;

val one_arctica : arctic = Num_arc zero_inta;

val one_arctic = {onea = one_arctica} : arctic one;

fun plus_arctica MinInfty y = y
  | plus_arctica (Num_arc v) MinInfty = Num_arc v
  | plus_arctica (Num_arc x) (Num_arc y) = Num_arc (max ord_int x y);

val plus_arctic = {plus = plus_arctica} : arctic plus;

val zero_arctica : arctic = MinInfty;

val zero_arctic = {zerob = zero_arctica} : arctic zero;

val semigroup_add_arctic = {plus_semigroup_add = plus_arctic} :
  arctic semigroup_add;

val numeral_arctic =
  {one_numeral = one_arctic, semigroup_add_numeral = semigroup_add_arctic} :
  arctic numeral;

fun times_arctica MinInfty y = MinInfty
  | times_arctica (Num_arc v) MinInfty = MinInfty
  | times_arctica (Num_arc x) (Num_arc y) = Num_arc (plus_inta x y);

val times_arctic = {times = times_arctica} : arctic times;

val power_arctic = {one_power = one_arctic, times_power = times_arctic} :
  arctic power;

fun less_eq_arctic MinInfty x = true
  | less_eq_arctic (Num_arc uu) MinInfty = false
  | less_eq_arctic (Num_arc y) (Num_arc x) = less_eq_int y x;

fun less_arctic MinInfty x = true
  | less_arctic (Num_arc uu) MinInfty = false
  | less_arctic (Num_arc y) (Num_arc x) = less_int y x;

val ord_arctic = {less_eq = less_eq_arctic, less = less_arctic} : arctic ord;

val ab_semigroup_add_arctic =
  {semigroup_add_ab_semigroup_add = semigroup_add_arctic} :
  arctic ab_semigroup_add;

val semigroup_mult_arctic = {times_semigroup_mult = times_arctic} :
  arctic semigroup_mult;

val semiring_arctic =
  {ab_semigroup_add_semiring = ab_semigroup_add_arctic,
    semigroup_mult_semiring = semigroup_mult_arctic}
  : arctic semiring;

val mult_zero_arctic =
  {times_mult_zero = times_arctic, zero_mult_zero = zero_arctic} :
  arctic mult_zero;

val monoid_add_arctic =
  {semigroup_add_monoid_add = semigroup_add_arctic,
    zero_monoid_add = zero_arctic}
  : arctic monoid_add;

val comm_monoid_add_arctic =
  {ab_semigroup_add_comm_monoid_add = ab_semigroup_add_arctic,
    monoid_add_comm_monoid_add = monoid_add_arctic}
  : arctic comm_monoid_add;

val semiring_0_arctic =
  {comm_monoid_add_semiring_0 = comm_monoid_add_arctic,
    mult_zero_semiring_0 = mult_zero_arctic,
    semiring_semiring_0 = semiring_arctic}
  : arctic semiring_0;

val monoid_mult_arctic =
  {semigroup_mult_monoid_mult = semigroup_mult_arctic,
    power_monoid_mult = power_arctic}
  : arctic monoid_mult;

val semiring_numeral_arctic =
  {monoid_mult_semiring_numeral = monoid_mult_arctic,
    numeral_semiring_numeral = numeral_arctic,
    semiring_semiring_numeral = semiring_arctic}
  : arctic semiring_numeral;

val zero_neq_one_arctic =
  {one_zero_neq_one = one_arctic, zero_zero_neq_one = zero_arctic} :
  arctic zero_neq_one;

val semiring_1_arctic =
  {semiring_numeral_semiring_1 = semiring_numeral_arctic,
    semiring_0_semiring_1 = semiring_0_arctic,
    zero_neq_one_semiring_1 = zero_neq_one_arctic}
  : arctic semiring_1;

val ceq_arctica : (arctic -> arctic -> bool) option = SOME equal_arctica;

val ceq_arctic = {ceq = ceq_arctica} : arctic ceq;

val set_impl_arctica : (arctic, set_impla) phantom = Phantom Set_RBT;

val set_impl_arctic = {set_impl = set_impl_arctica} : arctic set_impl;

val cEnum_arctic :
  (arctic list *
    (((arctic -> bool) -> bool) * ((arctic -> bool) -> bool))) option
  = NONE;

val cenum_arctic = {cEnum = cEnum_arctic} : arctic cenum;

fun comparator_arctic (Num_arc x) (Num_arc y) =
  comparator_of (equal_int, linorder_int) x y
  | comparator_arctic (Num_arc x) MinInfty = Gt
  | comparator_arctic MinInfty (Num_arc y) = Lt
  | comparator_arctic MinInfty MinInfty = Eq;

fun compare_arctic x = comparator_arctic x;

val ccompare_arctica : (arctic -> arctic -> ordera) option =
  SOME compare_arctic;

val ccompare_arctic = {ccompare = ccompare_arctica} : arctic ccompare;

val non_strict_order_arctic = {ord_non_strict_order = ord_arctic} :
  arctic non_strict_order;

val ordered_ab_semigroup_arctic =
  {ab_semigroup_add_ordered_ab_semigroup = ab_semigroup_add_arctic,
    monoid_add_ordered_ab_semigroup = monoid_add_arctic,
    non_strict_order_ordered_ab_semigroup = non_strict_order_arctic}
  : arctic ordered_ab_semigroup;

val ordered_semiring_0_arctic =
  {semiring_0_ordered_semiring_0a = semiring_0_arctic,
    ordered_ab_semigroup_ordered_semiring_0 = ordered_ab_semigroup_arctic}
  : arctic ordered_semiring_0a;

val ordered_semiring_1_arctic =
  {semiring_1_ordered_semiring_1 = semiring_1_arctic,
    ordered_semiring_0_ordered_semiring_1 = ordered_semiring_0_arctic}
  : arctic ordered_semiring_1;

datatype 'a filtered = FPair of 'a * nat;

fun equal_filtereda A_ (FPair (x1, x2)) (FPair (y1, y2)) =
  eq A_ x1 y1 andalso equal_nata x2 y2;

fun equal_filtered A_ = {equal = equal_filtereda A_} : 'a filtered equal;

fun filtered_fun (FPair (f, n)) = f;

fun shows_prec_filtered A_ p f = shows_prec A_ zero_nata (filtered_fun f);

fun shows_list_filtered A_ fs =
  showsp_list (shows_prec_filtered A_) zero_nata fs;

fun show_filtered A_ =
  {shows_prec = shows_prec_filtered A_, shows_list = shows_list_filtered A_} :
  'a filtered show;

fun comparator_filtered comp_f (FPair (x, xa)) (FPair (y, ya)) =
  (case comp_f x y of Eq => comparator_of (equal_nat, linorder_nat) xa ya
    | Lt => Lt | Gt => Gt);

fun compare_filtereda A_ = comparator_filtered (compare A_);

fun less_eq_filtered A_ = le_of_comp (compare_filtereda A_);

fun less_filtered A_ = lt_of_comp (compare_filtereda A_);

fun ord_filtered A_ = {less_eq = less_eq_filtered A_, less = less_filtered A_} :
  'a filtered ord;

fun quasi_order_filtered A_ = {ord_quasi_order = ord_filtered A_} :
  'a filtered quasi_order;

fun weak_order_filtered A_ = {quasi_order_weak_order = quasi_order_filtered A_}
  : 'a filtered weak_order;

fun preorder_filtered A_ = {ord_preorder = ord_filtered A_} :
  'a filtered preorder;

fun order_filtered A_ =
  {preorder_order = preorder_filtered A_,
    weak_order_order = weak_order_filtered A_}
  : 'a filtered order;

fun linorder_filtered A_ = {order_linorder = order_filtered A_} :
  'a filtered linorder;

fun compare_filtered A_ = {compare = compare_filtereda A_} :
  'a filtered compare;

fun compare_order_filtered A_ =
  {compare_compare_order = compare_filtered A_,
    linorder_compare_order = linorder_filtered A_}
  : 'a filtered compare_order;

fun key_filtered A_ =
  {compare_order_key =
     compare_order_filtered ((compare_compare_order o compare_order_key) A_)}
  : 'a filtered key;

datatype ('a, 'b) l_poly = LPoly of 'b * ('a * 'b) list;

val cEnum_l_poly :
  (('a, 'b) l_poly list *
    (((('a, 'b) l_poly -> bool) -> bool) *
      ((('a, 'b) l_poly -> bool) -> bool))) option
  = NONE;

val cenum_l_poly = {cEnum = cEnum_l_poly} : ('a, 'b) l_poly cenum;

datatype 'a sharp = Flat of 'a | Sharpa of 'a;

fun equal_sharpa A_ (Flat x1) (Sharpa x2) = false
  | equal_sharpa A_ (Sharpa x2) (Flat x1) = false
  | equal_sharpa A_ (Sharpa x2) (Sharpa y2) = eq A_ x2 y2
  | equal_sharpa A_ (Flat x1) (Flat y1) = eq A_ x1 y1;

fun equal_sharp A_ = {equal = equal_sharpa A_} : 'a sharp equal;

fun showsp_sharp show_l p (Sharpa x) =
  shows_pl p o shows_string [#"S", #"h", #"a", #"r", #"p"] o shows_space o
    show_l one_nata x o
    shows_pr p
  | showsp_sharp show_l p (Flat x) =
    shows_pl p o shows_string [#"F", #"l", #"a", #"t"] o shows_space o
      show_l one_nata x o
      shows_pr p;

fun shows_prec_sharp A_ = showsp_sharp (shows_prec A_);

fun shows_list_sharp A_ = showsp_list (shows_prec_sharp A_) zero_nata;

fun show_sharp A_ =
  {shows_prec = shows_prec_sharp A_, shows_list = shows_list_sharp A_} :
  'a sharp show;

fun comparator_sharp comp_l (Sharpa x) (Sharpa ya) = comp_l x ya
  | comparator_sharp comp_l (Sharpa x) (Flat y) = Gt
  | comparator_sharp comp_l (Flat x) (Sharpa ya) = Lt
  | comparator_sharp comp_l (Flat x) (Flat y) = comp_l x y;

fun compare_sharpa A_ = comparator_sharp (compare A_);

fun less_eq_sharp A_ = le_of_comp (compare_sharpa A_);

fun less_sharp A_ = lt_of_comp (compare_sharpa A_);

fun ord_sharp A_ = {less_eq = less_eq_sharp A_, less = less_sharp A_} :
  'a sharp ord;

fun quasi_order_sharp A_ = {ord_quasi_order = ord_sharp A_} :
  'a sharp quasi_order;

fun weak_order_sharp A_ = {quasi_order_weak_order = quasi_order_sharp A_} :
  'a sharp weak_order;

fun preorder_sharp A_ = {ord_preorder = ord_sharp A_} : 'a sharp preorder;

fun order_sharp A_ =
  {preorder_order = preorder_sharp A_, weak_order_order = weak_order_sharp A_} :
  'a sharp order;

fun linorder_sharp A_ = {order_linorder = order_sharp A_} : 'a sharp linorder;

fun compare_sharp A_ = {compare = compare_sharpa A_} : 'a sharp compare;

fun compare_order_sharp A_ =
  {compare_compare_order = compare_sharp A_,
    linorder_compare_order = linorder_sharp A_}
  : 'a sharp compare_order;

fun key_sharp A_ = {compare_order_key = compare_order_sharp A_} : 'a sharp key;

fun ceq_sharpa A_ = SOME (equal_sharpa A_);

fun ceq_sharp A_ = {ceq = ceq_sharpa A_} : 'a sharp ceq;

val set_impl_sharpa : ('a sharp, set_impla) phantom = Phantom Set_RBT;

val set_impl_sharp = {set_impl = set_impl_sharpa} : 'a sharp set_impl;

val cEnum_sharp :
  ('a sharp list *
    ((('a sharp -> bool) -> bool) * (('a sharp -> bool) -> bool))) option
  = NONE;

val cenum_sharp = {cEnum = cEnum_sharp} : 'a sharp cenum;

fun ccompare_sharpa A_ =
  (case ccompare A_ of NONE => NONE
    | SOME comp_l => SOME (comparator_sharp comp_l));

fun ccompare_sharp A_ = {ccompare = ccompare_sharpa A_} : 'a sharp ccompare;

val mapping_impl_sharpa : ('a sharp, mapping_impla) phantom =
  Phantom Mapping_RBT;

val mapping_impl_sharp = {mapping_impl = mapping_impl_sharpa} :
  'a sharp mapping_impl;

datatype location = H | A | Ba | Ra;

fun equal_locationa Ba Ra = false
  | equal_locationa Ra Ba = false
  | equal_locationa A Ra = false
  | equal_locationa Ra A = false
  | equal_locationa A Ba = false
  | equal_locationa Ba A = false
  | equal_locationa H Ra = false
  | equal_locationa Ra H = false
  | equal_locationa H Ba = false
  | equal_locationa Ba H = false
  | equal_locationa H A = false
  | equal_locationa A H = false
  | equal_locationa Ra Ra = true
  | equal_locationa Ba Ba = true
  | equal_locationa A A = true
  | equal_locationa H H = true;

val equal_location = {equal = equal_locationa} : location equal;

val ceq_locationa : (location -> location -> bool) option =
  SOME equal_locationa;

val ceq_location = {ceq = ceq_locationa} : location ceq;

val set_impl_locationa : (location, set_impla) phantom = Phantom Set_RBT;

val set_impl_location = {set_impl = set_impl_locationa} : location set_impl;

fun comparator_location Ra Ra = Eq
  | comparator_location Ra Ba = Gt
  | comparator_location Ra A = Gt
  | comparator_location Ra H = Gt
  | comparator_location Ba Ra = Lt
  | comparator_location Ba Ba = Eq
  | comparator_location Ba A = Gt
  | comparator_location Ba H = Gt
  | comparator_location A Ra = Lt
  | comparator_location A Ba = Lt
  | comparator_location A A = Eq
  | comparator_location A H = Gt
  | comparator_location H Ra = Lt
  | comparator_location H Ba = Lt
  | comparator_location H A = Lt
  | comparator_location H H = Eq;

fun compare_location x = comparator_location x;

val ccompare_locationa : (location -> location -> ordera) option =
  SOME compare_location;

val ccompare_location = {ccompare = ccompare_locationa} : location ccompare;

datatype ('a, 'b) scg = Null | Scg of 'a * 'a * ('b * 'b) list * ('b * 'b) list;

fun equal_scga A_ B_ Null (Scg (x21, x22, x23, x24)) = false
  | equal_scga A_ B_ (Scg (x21, x22, x23, x24)) Null = false
  | equal_scga A_ B_ (Scg (x21, x22, x23, x24)) (Scg (y21, y22, y23, y24)) =
    eq A_ x21 y21 andalso
      (eq A_ x22 y22 andalso
        (equal_lista (equal_prod B_ B_) x23 y23 andalso
          equal_lista (equal_prod B_ B_) x24 y24))
  | equal_scga A_ B_ Null Null = true;

fun equal_scg A_ B_ = {equal = equal_scga A_ B_} : ('a, 'b) scg equal;

fun comparator_scg comp_p_p comp_a_p (Scg (x, xa, xb, xc)) (Scg (y, ya, yb, yc))
  = (case comp_p_p x y
      of Eq =>
        (case comp_p_p xa ya
          of Eq =>
            (case comparator_list (comparator_prod comp_a_p comp_a_p) xb yb
              of Eq => comparator_list (comparator_prod comp_a_p comp_a_p) xc yc
              | Lt => Lt | Gt => Gt)
          | Lt => Lt | Gt => Gt)
      | Lt => Lt | Gt => Gt)
  | comparator_scg comp_p_p comp_a_p (Scg (x, xa, xb, xc)) Null = Gt
  | comparator_scg comp_p_p comp_a_p Null (Scg (y, ya, yb, yc)) = Lt
  | comparator_scg comp_p_p comp_a_p Null Null = Eq;

fun compare_scga A_ B_ = comparator_scg (compare A_) (compare B_);

fun less_eq_scg A_ B_ = le_of_comp (compare_scga A_ B_);

fun less_scg A_ B_ = lt_of_comp (compare_scga A_ B_);

fun ord_scg A_ B_ = {less_eq = less_eq_scg A_ B_, less = less_scg A_ B_} :
  ('a, 'b) scg ord;

fun compare_scg A_ B_ = {compare = compare_scga A_ B_} : ('a, 'b) scg compare;

fun quasi_order_scg A_ B_ = {ord_quasi_order = ord_scg A_ B_} :
  ('a, 'b) scg quasi_order;

fun weak_order_scg A_ B_ = {quasi_order_weak_order = quasi_order_scg A_ B_} :
  ('a, 'b) scg weak_order;

fun preorder_scg A_ B_ = {ord_preorder = ord_scg A_ B_} : ('a, 'b) scg preorder;

fun order_scg A_ B_ =
  {preorder_order = preorder_scg A_ B_, weak_order_order = weak_order_scg A_ B_}
  : ('a, 'b) scg order;

fun linorder_scg A_ B_ = {order_linorder = order_scg A_ B_} :
  ('a, 'b) scg linorder;

fun compare_order_scg A_ B_ =
  {compare_compare_order = compare_scg A_ B_,
    linorder_compare_order = linorder_scg A_ B_}
  : ('a, 'b) scg compare_order;

datatype 'a arctic_delta = MinInfty_delta | Num_arc_delta of 'a;

fun equal_arctic_deltaa A_ MinInfty_delta (Num_arc_delta x2) = false
  | equal_arctic_deltaa A_ (Num_arc_delta x2) MinInfty_delta = false
  | equal_arctic_deltaa A_ (Num_arc_delta x2) (Num_arc_delta y2) = eq A_ x2 y2
  | equal_arctic_deltaa A_ MinInfty_delta MinInfty_delta = true;

fun equal_arctic_delta A_ = {equal = equal_arctic_deltaa A_} :
  'a arctic_delta equal;

fun shows_arctic_delta A_ (Num_arc_delta i) = shows_prec A_ zero_nata i
  | shows_arctic_delta A_ MinInfty_delta =
    shows_prec_list show_char zero_nata [#"-", #"i", #"n", #"f"];

fun shows_prec_arctic_delta A_ d ari = shows_arctic_delta A_ ari;

fun shows_list_arctic_delta A_ ps =
  showsp_list (shows_prec_arctic_delta A_) zero_nata ps;

fun show_arctic_delta A_ =
  {shows_prec = shows_prec_arctic_delta A_,
    shows_list = shows_list_arctic_delta A_}
  : 'a arctic_delta show;

fun one_arctic_deltaa A_ =
  Num_arc_delta
    (zerob
      ((zero_abs_if o abs_if_linordered_ring o
         linordered_ring_linordered_ring_strict o
         linordered_ring_strict_linordered_idom o
         linordered_idom_linordered_field)
        A_));

fun one_arctic_delta A_ = {onea = one_arctic_deltaa A_} : 'a arctic_delta one;

fun plus_arctic_deltaa A_ MinInfty_delta y = y
  | plus_arctic_deltaa A_ (Num_arc_delta v) MinInfty_delta = Num_arc_delta v
  | plus_arctic_deltaa A_ (Num_arc_delta x) (Num_arc_delta y) =
    Num_arc_delta
      (max ((ord_abs_if o abs_if_linordered_ring o
              linordered_ring_linordered_ring_strict o
              linordered_ring_strict_linordered_idom o
              linordered_idom_linordered_field)
             A_)
        x y);

fun plus_arctic_delta A_ = {plus = plus_arctic_deltaa A_} :
  'a arctic_delta plus;

fun zero_arctic_deltaa A_ = MinInfty_delta;

fun zero_arctic_delta A_ = {zerob = zero_arctic_deltaa A_} :
  'a arctic_delta zero;

fun semigroup_add_arctic_delta A_ = {plus_semigroup_add = plus_arctic_delta A_}
  : 'a arctic_delta semigroup_add;

fun numeral_arctic_delta A_ =
  {one_numeral = one_arctic_delta A_,
    semigroup_add_numeral = semigroup_add_arctic_delta A_}
  : 'a arctic_delta numeral;

fun times_arctic_deltaa A_ MinInfty_delta y = MinInfty_delta
  | times_arctic_deltaa A_ (Num_arc_delta v) MinInfty_delta = MinInfty_delta
  | times_arctic_deltaa A_ (Num_arc_delta x) (Num_arc_delta y) =
    Num_arc_delta
      (plus ((plus_semigroup_add o semigroup_add_numeral o numeral_neg_numeral o
               neg_numeral_ring_1 o ring_1_ring_char_0 o
               ring_char_0_field_char_0 o field_char_0_linordered_field)
              A_)
        x y);

fun times_arctic_delta A_ = {times = times_arctic_deltaa A_} :
  'a arctic_delta times;

fun power_arctic_delta A_ =
  {one_power = one_arctic_delta A_, times_power = times_arctic_delta A_} :
  'a arctic_delta power;

fun less_eq_arctic_delta A_ MinInfty_delta x = true
  | less_eq_arctic_delta A_ (Num_arc_delta uu) MinInfty_delta = false
  | less_eq_arctic_delta A_ (Num_arc_delta y) (Num_arc_delta x) =
    less_eq A_ y x;

fun less_arctic_delta A_ MinInfty_delta x = true
  | less_arctic_delta A_ (Num_arc_delta uu) MinInfty_delta = false
  | less_arctic_delta A_ (Num_arc_delta y) (Num_arc_delta x) = less A_ y x;

fun ord_arctic_delta A_ =
  {less_eq = less_eq_arctic_delta A_, less = less_arctic_delta A_} :
  'a arctic_delta ord;

fun ab_semigroup_add_arctic_delta A_ =
  {semigroup_add_ab_semigroup_add = semigroup_add_arctic_delta A_} :
  'a arctic_delta ab_semigroup_add;

fun semigroup_mult_arctic_delta A_ =
  {times_semigroup_mult = times_arctic_delta A_} :
  'a arctic_delta semigroup_mult;

fun semiring_arctic_delta A_ =
  {ab_semigroup_add_semiring = ab_semigroup_add_arctic_delta A_,
    semigroup_mult_semiring = semigroup_mult_arctic_delta A_}
  : 'a arctic_delta semiring;

fun mult_zero_arctic_delta A_ =
  {times_mult_zero = times_arctic_delta A_,
    zero_mult_zero = zero_arctic_delta A_}
  : 'a arctic_delta mult_zero;

fun monoid_add_arctic_delta A_ =
  {semigroup_add_monoid_add = semigroup_add_arctic_delta A_,
    zero_monoid_add = zero_arctic_delta A_}
  : 'a arctic_delta monoid_add;

fun comm_monoid_add_arctic_delta A_ =
  {ab_semigroup_add_comm_monoid_add = ab_semigroup_add_arctic_delta A_,
    monoid_add_comm_monoid_add = monoid_add_arctic_delta A_}
  : 'a arctic_delta comm_monoid_add;

fun semiring_0_arctic_delta A_ =
  {comm_monoid_add_semiring_0 = comm_monoid_add_arctic_delta A_,
    mult_zero_semiring_0 = mult_zero_arctic_delta A_,
    semiring_semiring_0 = semiring_arctic_delta A_}
  : 'a arctic_delta semiring_0;

fun monoid_mult_arctic_delta A_ =
  {semigroup_mult_monoid_mult = semigroup_mult_arctic_delta A_,
    power_monoid_mult = power_arctic_delta A_}
  : 'a arctic_delta monoid_mult;

fun semiring_numeral_arctic_delta A_ =
  {monoid_mult_semiring_numeral = monoid_mult_arctic_delta A_,
    numeral_semiring_numeral = numeral_arctic_delta A_,
    semiring_semiring_numeral = semiring_arctic_delta A_}
  : 'a arctic_delta semiring_numeral;

fun zero_neq_one_arctic_delta A_ =
  {one_zero_neq_one = one_arctic_delta A_,
    zero_zero_neq_one = zero_arctic_delta A_}
  : 'a arctic_delta zero_neq_one;

fun semiring_1_arctic_delta A_ =
  {semiring_numeral_semiring_1 = semiring_numeral_arctic_delta A_,
    semiring_0_semiring_1 = semiring_0_arctic_delta A_,
    zero_neq_one_semiring_1 = zero_neq_one_arctic_delta A_}
  : 'a arctic_delta semiring_1;

fun ceq_arctic_deltaa A_ = SOME (equal_arctic_deltaa A_);

fun ceq_arctic_delta A_ = {ceq = ceq_arctic_deltaa A_} : 'a arctic_delta ceq;

val set_impl_arctic_deltaa : ('a arctic_delta, set_impla) phantom =
  Phantom Set_RBT;

val set_impl_arctic_delta = {set_impl = set_impl_arctic_deltaa} :
  'a arctic_delta set_impl;

val cEnum_arctic_delta :
  ('a arctic_delta list *
    ((('a arctic_delta -> bool) -> bool) *
      (('a arctic_delta -> bool) -> bool))) option
  = NONE;

val cenum_arctic_delta = {cEnum = cEnum_arctic_delta} : 'a arctic_delta cenum;

fun comparator_arctic_delta comp_a (Num_arc_delta x) (Num_arc_delta y) =
  comp_a x y
  | comparator_arctic_delta comp_a (Num_arc_delta x) MinInfty_delta = Gt
  | comparator_arctic_delta comp_a MinInfty_delta (Num_arc_delta y) = Lt
  | comparator_arctic_delta comp_a MinInfty_delta MinInfty_delta = Eq;

fun compare_arctic_delta A_ = comparator_arctic_delta (compare A_);

fun ccompare_arctic_deltaa A_ = SOME (compare_arctic_delta A_);

fun ccompare_arctic_delta A_ = {ccompare = ccompare_arctic_deltaa A_} :
  'a arctic_delta ccompare;

fun non_strict_order_arctic_delta A_ =
  {ord_non_strict_order =
     ord_arctic_delta
       ((ord_abs_if o abs_if_linordered_ring o
          linordered_ring_linordered_ring_strict o
          linordered_ring_strict_linordered_idom o
          linordered_idom_linordered_field)
         A_)}
  : 'a arctic_delta non_strict_order;

fun ordered_ab_semigroup_arctic_delta A_ =
  {ab_semigroup_add_ordered_ab_semigroup = ab_semigroup_add_arctic_delta A_,
    monoid_add_ordered_ab_semigroup = monoid_add_arctic_delta A_,
    non_strict_order_ordered_ab_semigroup = non_strict_order_arctic_delta A_}
  : 'a arctic_delta ordered_ab_semigroup;

fun ordered_semiring_0_arctic_delta A_ =
  {semiring_0_ordered_semiring_0a = semiring_0_arctic_delta A_,
    ordered_ab_semigroup_ordered_semiring_0 =
      ordered_ab_semigroup_arctic_delta A_}
  : 'a arctic_delta ordered_semiring_0a;

fun ordered_semiring_1_arctic_delta A_ =
  {semiring_1_ordered_semiring_1 = semiring_1_arctic_delta A_,
    ordered_semiring_0_ordered_semiring_1 = ordered_semiring_0_arctic_delta A_}
  : 'a arctic_delta ordered_semiring_1;

datatype ty = BoolT | IntT;

fun equal_tya BoolT IntT = false
  | equal_tya IntT BoolT = false
  | equal_tya IntT IntT = true
  | equal_tya BoolT BoolT = true;

val equal_ty = {equal = equal_tya} : ty equal;

fun showsp_ty p IntT = shows_string [#"I", #"n", #"t", #"T"]
  | showsp_ty p BoolT = shows_string [#"B", #"o", #"o", #"l", #"T"];

fun shows_prec_ty x = showsp_ty x;

fun shows_list_ty x = showsp_list shows_prec_ty zero_nata x;

val show_ty = {shows_prec = shows_prec_ty, shows_list = shows_list_ty} :
  ty show;

val ceq_tya : (ty -> ty -> bool) option = SOME equal_tya;

val ceq_ty = {ceq = ceq_tya} : ty ceq;

fun comparator_ty IntT IntT = Eq
  | comparator_ty IntT BoolT = Gt
  | comparator_ty BoolT IntT = Lt
  | comparator_ty BoolT BoolT = Eq;

val ccompare_tya : (ty -> ty -> ordera) option = SOME comparator_ty;

val ccompare_ty = {ccompare = ccompare_tya} : ty ccompare;

datatype siga = LessF | LeF | SumF of nat | ConstF of int | ProdF of nat | EqF;

fun equal_sigc (ProdF x5) EqF = false
  | equal_sigc EqF (ProdF x5) = false
  | equal_sigc (ConstF x4) EqF = false
  | equal_sigc EqF (ConstF x4) = false
  | equal_sigc (ConstF x4) (ProdF x5) = false
  | equal_sigc (ProdF x5) (ConstF x4) = false
  | equal_sigc (SumF x3) EqF = false
  | equal_sigc EqF (SumF x3) = false
  | equal_sigc (SumF x3) (ProdF x5) = false
  | equal_sigc (ProdF x5) (SumF x3) = false
  | equal_sigc (SumF x3) (ConstF x4) = false
  | equal_sigc (ConstF x4) (SumF x3) = false
  | equal_sigc LeF EqF = false
  | equal_sigc EqF LeF = false
  | equal_sigc LeF (ProdF x5) = false
  | equal_sigc (ProdF x5) LeF = false
  | equal_sigc LeF (ConstF x4) = false
  | equal_sigc (ConstF x4) LeF = false
  | equal_sigc LeF (SumF x3) = false
  | equal_sigc (SumF x3) LeF = false
  | equal_sigc LessF EqF = false
  | equal_sigc EqF LessF = false
  | equal_sigc LessF (ProdF x5) = false
  | equal_sigc (ProdF x5) LessF = false
  | equal_sigc LessF (ConstF x4) = false
  | equal_sigc (ConstF x4) LessF = false
  | equal_sigc LessF (SumF x3) = false
  | equal_sigc (SumF x3) LessF = false
  | equal_sigc LessF LeF = false
  | equal_sigc LeF LessF = false
  | equal_sigc (ProdF x5) (ProdF y5) = equal_nata x5 y5
  | equal_sigc (ConstF x4) (ConstF y4) = equal_inta x4 y4
  | equal_sigc (SumF x3) (SumF y3) = equal_nata x3 y3
  | equal_sigc EqF EqF = true
  | equal_sigc LeF LeF = true
  | equal_sigc LessF LessF = true;

val equal_sig = {equal = equal_sigc} : siga equal;

fun showsp_sig p EqF = shows_string [#"E", #"q", #"F"]
  | showsp_sig p (ProdF x) =
    shows_pl p o shows_string [#"P", #"r", #"o", #"d", #"F"] o shows_space o
      showsp_nat one_nata x o
      shows_pr p
  | showsp_sig p (ConstF x) =
    shows_pl p o shows_string [#"C", #"o", #"n", #"s", #"t", #"F"] o
      shows_space o
      showsp_int one_nata x o
      shows_pr p
  | showsp_sig p (SumF x) =
    shows_pl p o shows_string [#"S", #"u", #"m", #"F"] o shows_space o
      showsp_nat one_nata x o
      shows_pr p
  | showsp_sig p LeF = shows_string [#"L", #"e", #"F"]
  | showsp_sig p LessF = shows_string [#"L", #"e", #"s", #"s", #"F"];

fun shows_prec_sig x = showsp_sig x;

fun shows_list_sig x = showsp_list shows_prec_sig zero_nata x;

val show_sig = {shows_prec = shows_prec_sig, shows_list = shows_list_sig} :
  siga show;

fun comparator_siga EqF EqF = Eq
  | comparator_siga EqF (ProdF yb) = Gt
  | comparator_siga EqF (ConstF ya) = Gt
  | comparator_siga EqF (SumF y) = Gt
  | comparator_siga EqF LeF = Gt
  | comparator_siga EqF LessF = Gt
  | comparator_siga (ProdF x) EqF = Lt
  | comparator_siga (ProdF x) (ProdF yb) =
    comparator_of (equal_nat, linorder_nat) x yb
  | comparator_siga (ProdF x) (ConstF ya) = Gt
  | comparator_siga (ProdF x) (SumF y) = Gt
  | comparator_siga (ProdF x) LeF = Gt
  | comparator_siga (ProdF x) LessF = Gt
  | comparator_siga (ConstF x) EqF = Lt
  | comparator_siga (ConstF x) (ProdF yb) = Lt
  | comparator_siga (ConstF x) (ConstF ya) =
    comparator_of (equal_int, linorder_int) x ya
  | comparator_siga (ConstF x) (SumF y) = Gt
  | comparator_siga (ConstF x) LeF = Gt
  | comparator_siga (ConstF x) LessF = Gt
  | comparator_siga (SumF x) EqF = Lt
  | comparator_siga (SumF x) (ProdF yb) = Lt
  | comparator_siga (SumF x) (ConstF ya) = Lt
  | comparator_siga (SumF x) (SumF y) =
    comparator_of (equal_nat, linorder_nat) x y
  | comparator_siga (SumF x) LeF = Gt
  | comparator_siga (SumF x) LessF = Gt
  | comparator_siga LeF EqF = Lt
  | comparator_siga LeF (ProdF yb) = Lt
  | comparator_siga LeF (ConstF ya) = Lt
  | comparator_siga LeF (SumF y) = Lt
  | comparator_siga LeF LeF = Eq
  | comparator_siga LeF LessF = Gt
  | comparator_siga LessF EqF = Lt
  | comparator_siga LessF (ProdF yb) = Lt
  | comparator_siga LessF (ConstF ya) = Lt
  | comparator_siga LessF (SumF y) = Lt
  | comparator_siga LessF LeF = Lt
  | comparator_siga LessF LessF = Eq;

val ccompare_siga : (siga -> siga -> ordera) option = SOME comparator_siga;

val ccompare_sig = {ccompare = ccompare_siga} : siga ccompare;

datatype sigb = ConstFa of nat | SumFa | ProdFa | MaxF;

fun equal_sigb ProdFa MaxF = false
  | equal_sigb MaxF ProdFa = false
  | equal_sigb SumFa MaxF = false
  | equal_sigb MaxF SumFa = false
  | equal_sigb SumFa ProdFa = false
  | equal_sigb ProdFa SumFa = false
  | equal_sigb (ConstFa x1) MaxF = false
  | equal_sigb MaxF (ConstFa x1) = false
  | equal_sigb (ConstFa x1) ProdFa = false
  | equal_sigb ProdFa (ConstFa x1) = false
  | equal_sigb (ConstFa x1) SumFa = false
  | equal_sigb SumFa (ConstFa x1) = false
  | equal_sigb (ConstFa x1) (ConstFa y1) = equal_nata x1 y1
  | equal_sigb MaxF MaxF = true
  | equal_sigb ProdFa ProdFa = true
  | equal_sigb SumFa SumFa = true;

val equal_siga = {equal = equal_sigb} : sigb equal;

fun comparator_sig MaxF MaxF = Eq
  | comparator_sig MaxF ProdFa = Gt
  | comparator_sig MaxF SumFa = Gt
  | comparator_sig MaxF (ConstFa y) = Gt
  | comparator_sig ProdFa MaxF = Lt
  | comparator_sig ProdFa ProdFa = Eq
  | comparator_sig ProdFa SumFa = Gt
  | comparator_sig ProdFa (ConstFa y) = Gt
  | comparator_sig SumFa MaxF = Lt
  | comparator_sig SumFa ProdFa = Lt
  | comparator_sig SumFa SumFa = Eq
  | comparator_sig SumFa (ConstFa y) = Gt
  | comparator_sig (ConstFa x) MaxF = Lt
  | comparator_sig (ConstFa x) ProdFa = Lt
  | comparator_sig (ConstFa x) SumFa = Lt
  | comparator_sig (ConstFa x) (ConstFa y) =
    comparator_of (equal_nat, linorder_nat) x y;

fun compare_siga x = comparator_sig x;

val compare_sig = {compare = compare_siga} : sigb compare;

datatype ('a, 'b) cond_constraint =
  CC_cond of bool * (('a, 'b) term * ('a, 'b) term) |
  CC_rewr of ('a, 'b) term * ('a, 'b) term |
  CC_impl of ('a, 'b) cond_constraint list * ('a, 'b) cond_constraint |
  CC_all of 'b * ('a, 'b) cond_constraint;

fun equal_cond_constraint A_ B_ = {equal = equal_cond_constrainta A_ B_} :
  ('a, 'b) cond_constraint equal
and equal_cond_constrainta A_ B_ (CC_impl (x31, x32)) (CC_all (x41, x42)) =
  false
  | equal_cond_constrainta A_ B_ (CC_all (x41, x42)) (CC_impl (x31, x32)) =
    false
  | equal_cond_constrainta A_ B_ (CC_rewr (x21, x22)) (CC_all (x41, x42)) =
    false
  | equal_cond_constrainta A_ B_ (CC_all (x41, x42)) (CC_rewr (x21, x22)) =
    false
  | equal_cond_constrainta A_ B_ (CC_rewr (x21, x22)) (CC_impl (x31, x32)) =
    false
  | equal_cond_constrainta A_ B_ (CC_impl (x31, x32)) (CC_rewr (x21, x22)) =
    false
  | equal_cond_constrainta A_ B_ (CC_cond (x11, x12)) (CC_all (x41, x42)) =
    false
  | equal_cond_constrainta A_ B_ (CC_all (x41, x42)) (CC_cond (x11, x12)) =
    false
  | equal_cond_constrainta A_ B_ (CC_cond (x11, x12)) (CC_impl (x31, x32)) =
    false
  | equal_cond_constrainta A_ B_ (CC_impl (x31, x32)) (CC_cond (x11, x12)) =
    false
  | equal_cond_constrainta A_ B_ (CC_cond (x11, x12)) (CC_rewr (x21, x22)) =
    false
  | equal_cond_constrainta A_ B_ (CC_rewr (x21, x22)) (CC_cond (x11, x12)) =
    false
  | equal_cond_constrainta A_ B_ (CC_all (x41, x42)) (CC_all (y41, y42)) =
    eq B_ x41 y41 andalso equal_cond_constrainta A_ B_ x42 y42
  | equal_cond_constrainta A_ B_ (CC_impl (x31, x32)) (CC_impl (y31, y32)) =
    equal_lista (equal_cond_constraint A_ B_) x31 y31 andalso
      equal_cond_constrainta A_ B_ x32 y32
  | equal_cond_constrainta A_ B_ (CC_rewr (x21, x22)) (CC_rewr (y21, y22)) =
    equal_terma A_ B_ x21 y21 andalso equal_terma A_ B_ x22 y22
  | equal_cond_constrainta A_ B_ (CC_cond (x11, x12)) (CC_cond (y11, y12)) =
    equal_boola x11 y11 andalso
      equal_proda (equal_term A_ B_) (equal_term A_ B_) x12 y12;

datatype 'a itself = Type;

datatype ('b, 'a) rbt = RBT of ('b, 'a) rbta;

datatype xml = XML of char list * (char list * char list) list * xml list |
  XML_text of char list;

datatype 'a fset = Abs_fset of 'a set;

datatype xmldoc = XMLDOC of (char list) list * xml;

datatype ('a, 'b, 'c, 'd, 'e) lts_impl =
  Lts_Impl of
    'd list * ('e * ('a, 'b, 'c, 'd) transition_rule) list *
      ('d * ('a, ('b * 'c)) term formula) list;

datatype 'a atom = Leq of nat * 'a | Geq of nat * 'a;

datatype order_tag = Lex | Mul;

datatype ('a, 'b) fmap = Fmap_of_list of ('a * 'b) list;

datatype ('a, 'b, 'c, 'd, 'e) lts_ext =
  Lts_ext of
    'd set * ('a, 'b, 'c, 'd) transition_rule set *
      ('d -> ('a, ('b * 'c)) term formula) * 'e;

datatype ('a, 'b) mapping = Assoc_List_Mapping of ('a, 'b) alist |
  RBT_Mapping of ('a, 'b) mapping_rbt | Mapping of ('a -> 'b option);

datatype 'a xml_error = TagMismatch of (char list) list | Fatal of 'a;

datatype domain = Natural of nat | Integer | Arctic | Arctic_rat |
  Int_mat of nat * nat | Arctic_mat of nat | Arctic_rat_mat of nat |
  Rational of rat * nat | Rat_mat of nat * nat | Mini_Alg of real * nat |
  Mini_Alg_mat of nat * nat;

datatype enat = Enat of nat | Infinity_enat;

datatype ('a, 'b) tpoly = PVar of 'a | PNum of 'b | PSum of ('a, 'b) tpoly list
  | PMult of ('a, 'b) tpoly list;

datatype 'a status = Abs_status of ('a * nat -> nat list);

datatype ('a, 'b) claim = Yes | No | Terminating | Upperbound of nat |
  Nonterminating | Confluent | Nonconfluent | Completed | Ordered_Completed |
  Anything;

datatype 'a reduction_order_input =
  RPO_Input of (('a * nat) * (nat * order_tag)) list |
  KBO_Input of ((('a * nat) * (nat * (nat * (nat list) option))) list * nat);

datatype ('a, 'b) tree_automaton =
  Tree_Automaton of 'a list * ('a, 'b) ta_rule list * ('a * 'a) list;

datatype ('a, 'b) complexity_measure =
  Derivational_Complexity of ('a * nat) list |
  Runtime_Complexity of ('a * nat) list * ('a * nat) list;

datatype ('a, 'b) equation_literal = Equation of (('a, 'b) term * ('a, 'b) term)
  | Inequality of (('a, 'b) term * ('a, 'b) term);

datatype complexity_class = Comp_Poly of nat;

datatype ('a, 'b) fp_strategy = Outermost |
  Context_Sensitive of (('a * nat) * nat list) list |
  Forbidden_Patterns of (('a, 'b) ctxt * (('a, 'b) term * location)) list;

datatype start_term = Full | Constructor_Based;

datatype ('a, 'b) strategy = No_Strategy | Innermost |
  Innermost_Q of ('a, 'b) term list;

datatype ('a, 'b) input =
  DP_input of
    bool * (('a, 'b) term * ('a, 'b) term) list * ('a, 'b) strategy *
      (('a, 'b) term * ('a, 'b) term) list
  | Inn_TRS_input of
      ('a, 'b) strategy * (('a, 'b) term * ('a, 'b) term) list *
        (('a, 'b) term * ('a, 'b) term) list * start_term
  | CPX_input of
      ('a, 'b) strategy * (('a, 'b) term * ('a, 'b) term) list *
        (('a, 'b) term * ('a, 'b) term) list * ('a, 'b) complexity_measure *
        complexity_class
  | COMP_input of
      (('a, 'b) term * ('a, 'b) term) list *
        (('a, 'b) term * ('a, 'b) term) list
  | OCOMP_input of
      (('a, 'b) term * ('a, 'b) term) list *
        (('a, 'b) term * ('a, 'b) term) list *
        (('a, 'b) term * ('a, 'b) term) list * 'a reduction_order_input
  | EQ_input of (('a, 'b) term * ('a, 'b) term) list * ('a, 'b) equation_literal
  | FP_TRS_input of ('a, 'b) fp_strategy * (('a, 'b) term * ('a, 'b) term) list
  | CTRS_input of
      ((('a, 'b) term * ('a, 'b) term) *
        (('a, 'b) term * ('a, 'b) term) list) list
  | TA_input of
      ((char list), 'a) tree_automaton * (('a, 'b) term * ('a, 'b) term) list
  | AC_input of (('a, 'b) term * ('a, 'b) term) list * 'a list * 'a list |
  LTS_input of (siga, 'b, ty, (char list), (char list)) lts_impl |
  LTS_safety_input of
    (siga, 'b, ty, (char list), (char list)) lts_impl * (char list) list
  | Unknown_input of char list;

datatype ('a, 'b) const_string_sound_proof =
  Const_string_sound_proof of
    'b * ('a * 'a) list * (('a, 'b) term * ('a, 'b) term) list *
      (('a, 'b) term * ('a, 'b) term) list;

datatype af_entry = Collapse of nat | AFList of nat list;

datatype 'a redtriple_impl = Int_carrier of (('a * nat) * (int * int list)) list
  | Int_nl_carrier of (('a * nat) * (nat monom * int) list) list |
  Rat_carrier of (('a * nat) * (rat * rat list)) list |
  Rat_nl_carrier of rat * (('a * nat) * (nat monom * rat) list) list |
  Real_carrier of (('a * nat) * (real * real list)) list |
  Real_nl_carrier of real * (('a * nat) * (nat monom * real) list) list |
  Arctic_carrier of (('a * nat) * (arctic * arctic list)) list |
  Arctic_rat_carrier of
    (('a * nat) * (rat arctic_delta * rat arctic_delta list)) list
  | Int_mat_carrier of nat * nat * (('a * nat) * (int mat * int mat list)) list
  | Rat_mat_carrier of nat * nat * (('a * nat) * (rat mat * rat mat list)) list
  | Real_mat_carrier of
      nat * nat * (('a * nat) * (real mat * real mat list)) list
  | Arctic_mat_carrier of
      nat * (('a * nat) * (arctic mat * arctic mat list)) list
  | Arctic_rat_mat_carrier of
      nat * (('a * nat) *
              (rat arctic_delta mat * rat arctic_delta mat list)) list
  | RPO of (('a * nat) * (nat * order_tag)) list * (('a * nat) * af_entry) list
  | KBO of
      ((('a * nat) * (nat * (nat * (nat list) option))) list * nat) *
        (('a * nat) * af_entry) list
  | WPO of (('a * nat) * (nat * nat list)) list * 'a redtriple_impl |
  Max_poly of (('a * nat) * (sigb, nat) term) list;

datatype ('a, 'b) complex_constant_removal_prf =
  Complex_Constant_Removal_Proof of
    ('a, 'b) term *
      ((('a, 'b) term * ('a, 'b) term) * (('a, 'b) term * ('a, 'b) term)) list;

datatype list_order_type = MS_Ext | Max_Ext | Min_Ext | Dms_Ext;

datatype 'a root_redtriple_impl =
  SCNP of
    list_order_type * (('a * nat) * (nat * nat) list) list * 'a redtriple_impl;

datatype ('a, 'b) cond_constraint_prf = Final |
  Delete_Condition of ('a, 'b) cond_constraint * ('a, 'b) cond_constraint_prf |
  Different_Constructor of ('a, 'b) cond_constraint |
  Same_Constructor of
    ('a, 'b) cond_constraint * ('a, 'b) cond_constraint *
      ('a, 'b) cond_constraint_prf
  | Variable_Equation of
      'b * ('a, 'b) term * ('a, 'b) cond_constraint *
        ('a, 'b) cond_constraint_prf
  | Funarg_Into_Var of
      ('a, 'b) cond_constraint * nat * 'b * ('a, 'b) cond_constraint *
        ('a, 'b) cond_constraint_prf
  | Simplify_Condition of
      ('a, 'b) cond_constraint * ('b * ('a, 'b) term) list *
        ('a, 'b) cond_constraint * ('a, 'b) cond_constraint_prf
  | Induction of
      ('a, 'b) cond_constraint * ('a, 'b) cond_constraint list *
        ((('a, 'b) term * ('a, 'b) term) *
          ((('a, 'b) term * 'b list) list *
            (('a, 'b) cond_constraint * ('a, 'b) cond_constraint_prf))) list;

datatype ('a, 'b) cond_red_pair_prf =
  Cond_Red_Pair_Prf of
    'a * (('a, 'b) cond_constraint *
           ((('a, 'b) term * ('a, 'b) term) list *
             ('a, 'b) cond_constraint_prf)) list *
      nat * nat;

datatype arithFun = Arg of nat | Const of nat | Sum of arithFun list |
  Max of arithFun list | Min of arithFun list | Prod of arithFun list |
  IfEqual of arithFun * arithFun * arithFun * arithFun;

datatype 'a sl_inter = SL_Inter of nat * (('a * nat) * arithFun) list;

datatype ('a, 'b) sl_variant = Rootlab of ('a * nat) option |
  Finitelab of 'a sl_inter | QuasiFinitelab of 'a sl_inter * 'b;

datatype ('a, 'b, 'c, 'd, 'e, 'f, 'g, 'h) generic_assm_proof =
  SN_assm_proof of
    (bool *
      ((('a, 'b) lab, 'c) term list *
        (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
          ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list))) *
      'd
  | Finite_assm_proof of
      (bool *
        (bool *
          (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
            (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
              ((('a, 'b) lab, 'c) term list *
                (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
                  ((('a, 'b) lab, 'c) term *
                    (('a, 'b) lab, 'c) term) list)))))) *
        'e
  | SN_FP_assm_proof of
      (((('a, 'b) lab, 'c) ctxt * ((('a, 'b) lab, 'c) term * location)) list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) *
        'f
  | Not_SN_assm_proof of
      (bool *
        ((('a, 'b) lab, 'c) term list *
          ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list)) *
        'd
  | Infinite_assm_proof of
      (bool *
        (bool *
          (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
            (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
              ((('a, 'b) lab, 'c) term list *
                (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
                  ((('a, 'b) lab, 'c) term *
                    (('a, 'b) lab, 'c) term) list)))))) *
        'e
  | Not_RelSN_assm_proof of
      (bool *
        ((('a, 'b) lab, 'c) term list *
          (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
            ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list))) *
        'f
  | Not_SN_FP_assm_proof of
      (((('a, 'b) lab, 'c) ctxt * ((('a, 'b) lab, 'c) term * location)) list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) *
        'g
  | Complexity_assm_proof of
      ((('a, 'b) lab, 'c) term list *
        (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
          (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
            ((('a, 'b) lab, 'c) complexity_measure * complexity_class)))) *
        'd
  | Unknown_assm_proof of char list * 'h;

datatype 'a join_info =
  Guided of
    (('a, (char list)) term *
      ((pos *
         ((('a, (char list)) term * ('a, (char list)) term) *
           ('a, (char list)) term)) list *
        (('a, (char list)) term *
          (pos *
            ((('a, (char list)) term * ('a, (char list)) term) *
              ('a, (char list)) term)) list))) list
  | Join_NF | Join_BFS of nat;

datatype 'a projL = Projection of (('a * nat) * nat) list;

datatype 'a ta_relation = Decision_Proc_Old | Decision_Proc | Id_Relation |
  Some_Relation of ('a * 'a) list;

datatype boundstype = Roof | Match;

datatype ('a, 'b) bounds_info =
  Bounds_Info of
    boundstype * nat * 'b list * ('b, ('a * nat)) tree_automaton *
      'b ta_relation;

datatype ('a, 'b, 'c) trs_termination_proof =
  DP_Trans of
    bool * bool * ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
      ('a, 'b, 'c) dp_termination_proof
  | Rule_Removal of
      ('a, 'b) lab redtriple_impl *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) trs_termination_proof
  | String_Reversal of ('a, 'b, 'c) trs_termination_proof |
  Constant_String of
    (('a, 'b) lab, 'c) const_string_sound_proof *
      ('a, 'b, 'c) trs_termination_proof
  | Bounds of (('a, 'b) lab, 'c) bounds_info |
  Uncurry of
    (('a, 'b) lab *
      (((('a, 'b) lab * nat) * ('a, 'b) lab list) list *
        (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
          ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list))) *
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
      ('a, 'b, 'c) trs_termination_proof
  | Semlab of
      (('a, 'b) lab, 'c) sl_variant * (('a, 'b) lab, 'c) term list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) trs_termination_proof
  | R_is_Empty |
  Fcc of
    (('a, 'b) lab, 'c) ctxt list *
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
      ('a, 'b, 'c) trs_termination_proof
  | Split of
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) trs_termination_proof * ('a, 'b, 'c) trs_termination_proof
  | Switch_Innermost of
      ('a, 'b) lab join_info * ('a, 'b, 'c) trs_termination_proof
  | Drop_Equality of ('a, 'b, 'c) trs_termination_proof |
  Remove_Nonapplicable_Rules of
    ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
      ('a, 'b, 'c) trs_termination_proof
  | Permuting_AFS of
      ((('a, 'b) lab * nat) * af_entry) list *
        ('a, 'b, 'c) trs_termination_proof
  | Assume_SN of
      (bool *
        ((('a, 'b) lab, 'c) term list *
          (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
            ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list))) *
        ('a, 'b, 'c, ('a, 'b, 'c) trs_termination_proof,
          ('a, 'b, 'c) dp_termination_proof,
          ('a, 'b, 'c) fptrs_termination_proof, unit,
          ('a, 'b, 'c) unknown_proof)
          generic_assm_proof list
and ('a, 'b, 'c) fptrs_termination_proof =
  Assume_FP_SN of
    (((('a, 'b) lab, 'c) ctxt * ((('a, 'b) lab, 'c) term * location)) list *
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) *
      ('a, 'b, 'c, ('a, 'b, 'c) trs_termination_proof,
        ('a, 'b, 'c) dp_termination_proof, ('a, 'b, 'c) fptrs_termination_proof,
        unit, ('a, 'b, 'c) unknown_proof)
        generic_assm_proof list
and ('a, 'b, 'c) dp_termination_proof = P_is_Empty |
  Subterm_Criterion_Proc of
    ('a, 'b) lab projL *
      (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
        (pos *
          (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
            (('a, 'b) lab, 'c) term)) list) list *
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
      ('a, 'b, 'c) dp_termination_proof
  | Gen_Subterm_Criterion_Proc of
      ((('a, 'b) lab * nat) * nat list) list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) dp_termination_proof
  | Redpair_Proc of
      (('a, 'b) lab root_redtriple_impl, ('a, 'b) lab redtriple_impl) sum *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) dp_termination_proof
  | Redpair_UR_Proc of
      (('a, 'b) lab root_redtriple_impl, ('a, 'b) lab redtriple_impl) sum *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) dp_termination_proof
  | Usable_Rules_Proc of
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) dp_termination_proof
  | Dep_Graph_Proc of
      (('a, 'b, 'c) dp_termination_proof option *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) list
  | Mono_Redpair_Proc of
      ('a, 'b) lab redtriple_impl *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) dp_termination_proof
  | Mono_URM_Redpair_Proc of
      ('a, 'b) lab redtriple_impl *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) dp_termination_proof
  | Mono_Redpair_UR_Proc of
      ('a, 'b) lab redtriple_impl *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) dp_termination_proof
  | Size_Change_Subterm_Proc of
      (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
        ((nat * nat) list * (nat * nat) list)) list
  | Size_Change_Redpair_Proc of
      ('a, 'b) lab redtriple_impl *
        (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) option *
        (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
          ((nat * nat) list * (nat * nat) list)) list
  | Uncurry_Proc of
      nat option *
        (('a, 'b) lab *
          (((('a, 'b) lab * nat) * ('a, 'b) lab list) list *
            (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
              ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list))) *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) dp_termination_proof
  | Fcc_Proc of
      ('a, 'b) lab * (('a, 'b) lab, 'c) ctxt list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) dp_termination_proof
  | Split_Proc of
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) dp_termination_proof * ('a, 'b, 'c) dp_termination_proof
  | Semlab_Proc of
      (('a, 'b) lab, 'c) sl_variant *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        (('a, 'b) lab, 'c) term list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) dp_termination_proof
  | Switch_Innermost_Proc of
      ('a, 'b) lab join_info * ('a, 'b, 'c) dp_termination_proof
  | Rewriting_Proc of
      (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) option *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) * pos *
        ('a, 'b, 'c) dp_termination_proof
  | Instantiation_Proc of
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) dp_termination_proof
  | Forward_Instantiation_Proc of
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) option *
        ('a, 'b, 'c) dp_termination_proof
  | Narrowing_Proc of
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) * pos *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) dp_termination_proof
  | Assume_Finite of
      (bool *
        (bool *
          (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
            (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
              ((('a, 'b) lab, 'c) term list *
                (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
                  ((('a, 'b) lab, 'c) term *
                    (('a, 'b) lab, 'c) term) list)))))) *
        ('a, 'b, 'c, ('a, 'b, 'c) trs_termination_proof,
          ('a, 'b, 'c) dp_termination_proof,
          ('a, 'b, 'c) fptrs_termination_proof, unit,
          ('a, 'b, 'c) unknown_proof)
          generic_assm_proof list
  | Unlab_Proc of
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) dp_termination_proof
  | Q_Reduction_Proc of
      (('a, 'b) lab, 'c) term list * ('a, 'b, 'c) dp_termination_proof
  | Complex_Constant_Removal_Proc of
      (('a, 'b) lab, 'c) complex_constant_removal_prf *
        ('a, 'b, 'c) dp_termination_proof
  | General_Redpair_Proc of
      ('a, 'b) lab redtriple_impl *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        (('a, 'b) lab, 'c) cond_red_pair_prf *
        ('a, 'b, 'c) dp_termination_proof list
  | To_Trs_Proc of ('a, 'b, 'c) trs_termination_proof
and ('a, 'b, 'c) unknown_proof =
  Assume_Unknown of
    char list *
      ('a, 'b, 'c, ('a, 'b, 'c) trs_termination_proof,
        ('a, 'b, 'c) dp_termination_proof, ('a, 'b, 'c) fptrs_termination_proof,
        unit, ('a, 'b, 'c) unknown_proof)
        generic_assm_proof list;

datatype ('a, 'b, 'c) cr_proof =
  SN_WCR of ('a, 'b) lab join_info * ('a, 'b, 'c) trs_termination_proof |
  Weakly_Orthogonal | Strongly_Closed of nat |
  Rule_Labeling of
    (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) * nat) list *
      ((('a, 'b) lab, (char list)) term *
        ((pos *
           (((('a, 'b) lab, (char list)) term *
              (('a, 'b) lab, (char list)) term) *
             (('a, 'b) lab, (char list)) term)) list *
          ((('a, 'b) lab, (char list)) term *
            (pos *
              (((('a, 'b) lab, (char list)) term *
                 (('a, 'b) lab, (char list)) term) *
                (('a, 'b) lab, (char list)) term)) list))) list *
      ('a, 'b, 'c) trs_termination_proof option
  | Rule_Labeling_Conv of
      (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) * nat) list *
        ((('a, 'b) lab, (char list)) term *
          ((('a, 'b) lab, (char list)) term *
            ((pos *
               (((('a, 'b) lab, (char list)) term *
                  (('a, 'b) lab, (char list)) term) *
                 (bool * (('a, 'b) lab, (char list)) term))) list *
              ((pos *
                 (((('a, 'b) lab, (char list)) term *
                    (('a, 'b) lab, (char list)) term) *
                   (('a, 'b) lab, (char list)) term)) list *
                ((pos *
                   (((('a, 'b) lab, (char list)) term *
                      (('a, 'b) lab, (char list)) term) *
                     (bool * (('a, 'b) lab, (char list)) term))) list *
                  ((('a, 'b) lab, (char list)) term *
                    ((pos *
                       (((('a, 'b) lab, (char list)) term *
                          (('a, 'b) lab, (char list)) term) *
                         (bool * (('a, 'b) lab, (char list)) term))) list *
                      ((pos *
                         (((('a, 'b) lab, (char list)) term *
                            (('a, 'b) lab, (char list)) term) *
                           (('a, 'b) lab, (char list)) term)) list *
                        (pos *
                          (((('a, 'b) lab, (char list)) term *
                             (('a, 'b) lab, (char list)) term) *
                            (bool *
                              (('a, 'b) lab, (char list))
                                term))) list)))))))) list *
        (nat * ('a, 'b, 'c) trs_termination_proof) option
  | Redundant_Rules of
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list * nat *
        ((pos *
           (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
             (bool * (('a, 'b) lab, 'c) term))) list) list *
        ('a, 'b, 'c) cr_proof
  | Parallel_Closed of nat option |
  Critical_Pair_Closing_System of
    ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
      ('a, 'b, 'c) trs_termination_proof * nat;

datatype comp_res = LESS | EQUAL | GREATER;

datatype ('a, 'b) multimap =
  Abs_multimap of (('b -> 'a) * (('a, ('b list)) mapping * 'b list));

datatype ('a, 'b) ring_ext = Ring_ext of 'a * ('a -> 'a -> 'a) * 'b;

datatype linear_poly = LinearPoly of (nat, rat) fmap;

datatype constraint = LTa of linear_poly * rat | GTa of linear_poly * rat |
  LEQ of linear_poly * rat | GEQ of linear_poly * rat | EQa of linear_poly * rat
  | LTPP of linear_poly * linear_poly | GTPP of linear_poly * linear_poly |
  LEQPP of linear_poly * linear_poly | GEQPP of linear_poly * linear_poly |
  EQPP of linear_poly * linear_poly;

datatype ('a, 'b) sum_bot = Sumbot of ('a, 'b) sum;

datatype 'a afs = Abs_afs of (('a * nat -> af_entry) * ('a * nat) set);

datatype ('a, 'b, 'c) non_join_info = Diff_NFs |
  Tcap_Non_Unif of (('a, 'b) term -> ('a, 'b) term -> 'b -> ('a, 'b) term) |
  Tree_Aut_Intersect_Empty of
    ('c, 'a) tree_automaton * 'c ta_relation * ('c, 'a) tree_automaton *
      'c ta_relation
  | Finite_Model_Gt of ('a, 'b) sl_variant |
  Reduction_Pair_Gt of 'a redtriple_impl |
  Usable_Rules_Reach_NJ of ('a, 'b, 'c) non_join_info |
  Usable_Rules_Reach_Unif_NJ of
    (((('a, 'b) term * ('a, 'b) term) list),
      ((('a, 'b) term * ('a, 'b) term) list))
      sum *
      ('a, 'b, 'c) non_join_info
  | Argument_Filter_NJ of
      (('a * nat) * af_entry) list * ('a, 'b, 'c) non_join_info
  | Grounding of ('b * ('a, 'b) term) list * ('a, 'b, 'c) non_join_info |
  Subterm_NJ of pos * ('a, 'b, 'c) non_join_info;

datatype ('a, 'b, 'c, 'd) ncr_proof =
  SN_NWCR of ('a, 'b, 'c) trs_termination_proof |
  Non_Join of
    (('a, 'b) lab, 'c) term *
      (pos *
        (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
          (('a, 'b) lab, 'c) term)) list *
      (pos *
        (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
          (('a, 'b) lab, 'c) term)) list *
      (('a, 'b) lab, 'c, 'd) non_join_info
  | NCR_Disj_Subtrs of
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c, 'd) ncr_proof
  | NCR_Redundant_Rules of
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list * nat *
        ('a, 'b, 'c, 'd) ncr_proof;

datatype ('a, 'b) rule_removal_nonterm_reltrs_prf =
  Rule_removal_nonterm_reltrs_prf of
    ((('a, 'b) term * ('a, 'b) term) list) option *
      ((('a, 'b) term * ('a, 'b) term) list) option;

datatype ('a, 'b, 'c) dp_trans_nontermination_tt_prf =
  DP_trans_nontermination_tt_prf of
    ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list;

datatype ('a, 'b) const_string_complete_proof =
  Const_string_complete_proof of
    'b * ('a * 'a) list * (('a, 'b) term * ('a, 'b) term) list;

datatype ('a, 'b) rule_removal_nonterm_trs_prf =
  Rule_removal_nonterm_trs_prf of (('a, 'b) term * ('a, 'b) term) list;

datatype ('a, 'b) q_increase_nonterm_trs_prf =
  Q_increase_nonterm_trs_prf of ('a, 'b) term list;

datatype ('a, 'b) instantiation_complete_proc_prf =
  Instantiation_complete_proc_prf of (('a, 'b) term * ('a, 'b) term) list;

datatype ('a, 'b) rule_removal_nonterm_dp_prf =
  Rule_removal_nonterm_dp_prf of
    ((('a, 'b) term * ('a, 'b) term) list) option *
      ((('a, 'b) term * ('a, 'b) term) list) option;

datatype ('a, 'b) q_increase_nonterm_dp_prf =
  Q_increase_nonterm_dp_prf of ('a, 'b) term list;

datatype ('a, 'b) dp_q_reduction_nonterm_prf =
  DP_q_reduction_nonterm_prf of ('a, 'b) term list;

datatype ('a, 'b) rewriting_complete_proc_prf =
  Rewriting_complete_proc_prf of
    ((('a, 'b) term * ('a, 'b) term) list) option *
      (('a, 'b) term * ('a, 'b) term) * (('a, 'b) term * ('a, 'b) term) *
      (('a, 'b) term * ('a, 'b) term) * (('a, 'b) term * ('a, 'b) term) * pos;

datatype ('a, 'b) narrowing_complete_proc_prf =
  Narrowing_complete_proc_prf of
    (('a, 'b) term * ('a, 'b) term) * pos *
      (('a, 'b) term * ('a, 'b) term) list;

datatype pat_rule_pos = Pat_Base | Pat_Pump | Pat_Close;

datatype ('a, 'b) pat_eqv_prf = Pat_Dom_Renaming of ('b * ('a, 'b) term) list |
  Pat_Irrelevant of ('b * ('a, 'b) term) list * ('b * ('a, 'b) term) list |
  Pat_Simplify of ('b * ('a, 'b) term) list * ('b * ('a, 'b) term) list;

datatype ('a, 'b) pat_rule_prf =
  Pat_OrigRule of (('a, 'b) term * ('a, 'b) term) * bool |
  Pat_InitPump of
    ('a, 'b) pat_rule_prf * ('b * ('a, 'b) term) list *
      ('b * ('a, 'b) term) list
  | Pat_InitPumpCtxt of
      ('a, 'b) pat_rule_prf * ('b * ('a, 'b) term) list * pos * 'b
  | Pat_Equiv of ('a, 'b) pat_rule_prf * bool * ('a, 'b) pat_eqv_prf |
  Pat_Narrow of ('a, 'b) pat_rule_prf * ('a, 'b) pat_rule_prf * pos |
  Pat_Inst of ('a, 'b) pat_rule_prf * ('b * ('a, 'b) term) list * pat_rule_pos |
  Pat_Rewr of
    ('a, 'b) pat_rule_prf *
      (('a, 'b) term *
        (pos * ((('a, 'b) term * ('a, 'b) term) * ('a, 'b) term)) list) *
      pat_rule_pos * 'b
  | Pat_Exp_Sigma of ('a, 'b) pat_rule_prf * nat;

datatype ('a, 'b) non_loop_prf =
  Non_loop_prf of
    ('a, 'b) pat_rule_prf * ('b * ('a, 'b) term) list *
      ('b * ('a, 'b) term) list * nat * nat * pos;

datatype ('a, 'b) dp_loop_prf =
  DP_loop_prf of
    ('a, 'b) term *
      (pos * ((('a, 'b) term * ('a, 'b) term) * (bool * ('a, 'b) term))) list *
      ('b * ('a, 'b) term) list * ('a, 'b) ctxt;

datatype ('a, 'b) not_wn_ta_prf =
  Not_wn_ta_prf of ('b, 'a) tree_automaton * 'b ta_relation;

datatype 'a dp_proof_step = OC1 of ('a list * 'a list) * bool |
  OC2 of
    ('a list * 'a list) * ('a list * 'a list) * ('a list * 'a list) * 'a list *
      'a list * 'a list
  | OC2p of
      ('a list * 'a list) * ('a list * 'a list) * ('a list * 'a list) *
        'a list * 'a list * 'a list
  | OC3 of
      ('a list * 'a list) * ('a list * 'a list) * ('a list * 'a list) *
        'a list * 'a list
  | OC3p of
      ('a list * 'a list) * ('a list * 'a list) * ('a list * 'a list) *
        'a list * 'a list
  | OCDP1 of
      (('a list * ((nat * (nat * 'a list)) * 'a list)) *
        ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        ('a list * 'a list)
  | OCDP2 of
      (('a list * ((nat * (nat * 'a list)) * 'a list)) *
        ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        ('a list * 'a list)
  | WPEQ of
      (('a list * ((nat * (nat * 'a list)) * 'a list)) *
        ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list)))
  | Lift of
      (('a list * ((nat * (nat * 'a list)) * 'a list)) *
        ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list)))
  | DPOC1_1 of
      (('a list * ((nat * (nat * 'a list)) * 'a list)) *
        ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        ('a list * 'a list) * 'a list * 'a list
  | DPOC1_2 of
      (('a list * ((nat * (nat * 'a list)) * 'a list)) *
        ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        ('a list * 'a list) * 'a list * 'a list * 'a list
  | DPOC2 of
      (('a list * ((nat * (nat * 'a list)) * 'a list)) *
        ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        ('a list * 'a list) * 'a list * 'a list
  | DPOC3_1 of
      (('a list * ((nat * (nat * 'a list)) * 'a list)) *
        ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        ('a list * 'a list) * 'a list * 'a list
  | DPOC3_2 of
      (('a list * ((nat * (nat * 'a list)) * 'a list)) *
        ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        ('a list * 'a list) * 'a list * 'a list * 'a list
  | DPDP1_1 of
      (('a list * ((nat * (nat * 'a list)) * 'a list)) *
        ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        'a list * 'a list
  | DPDP1_2 of
      (('a list * ((nat * (nat * 'a list)) * 'a list)) *
        ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        'a list * 'a list
  | DPDP2_1 of
      (('a list * ((nat * (nat * 'a list)) * 'a list)) *
        ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        'a list * 'a list
  | DPDP2_2 of
      (('a list * ((nat * (nat * 'a list)) * 'a list)) *
        ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        (('a list * ((nat * (nat * 'a list)) * 'a list)) *
          ('a list * ((nat * (nat * 'a list)) * 'a list))) *
        'a list * 'a list;

datatype 'a non_loop_srs_proof =
  SE_OC of ('a list * 'a list) * 'a list * 'a list * 'a dp_proof_step list |
  SE_DP of
    (('a list * ((nat * (nat * 'a list)) * 'a list)) *
      ('a list * ((nat * (nat * 'a list)) * 'a list))) *
      'a list * 'a list * 'a dp_proof_step list;

datatype ('a, 'b, 'c) uncurry_nt_proof =
  Uncurry_nt_proof of
    (('a, 'b) lab *
      (((('a, 'b) lab * nat) * ('a, 'b) lab list) list *
        (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
          ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list))) *
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list;

datatype ('a, 'b) trs_loop_prf =
  TRS_loop_prf of
    ('a, 'b) term *
      (pos * ((('a, 'b) term * ('a, 'b) term) * ('a, 'b) term)) list *
      ('b * ('a, 'b) term) list * ('a, 'b) ctxt;

datatype ('a, 'b) rel_trs_loop_prf =
  Rel_trs_loop_prf of
    ('a, 'b) term *
      (pos * ((('a, 'b) term * ('a, 'b) term) * (bool * ('a, 'b) term))) list *
      ('b * ('a, 'b) term) list * ('a, 'b) ctxt;

datatype ('a, 'b, 'c) reltrs_nontermination_proof =
  Rel_Loop of (('a, 'b) lab, 'c) rel_trs_loop_prf |
  Rel_TRS_String_Reversal of ('a, 'b, 'c) reltrs_nontermination_proof |
  Rel_Not_Well_Formed |
  Rel_Rule_Removal of
    (('a, 'b) lab, 'c) rule_removal_nonterm_reltrs_prf *
      ('a, 'b, 'c) reltrs_nontermination_proof
  | Rel_R_Not_SN of ('a, 'b, 'c) trs_nontermination_proof |
  Rel_TRS_Assume_Not_SN of
    (bool *
      ((('a, 'b) lab, 'c) term list *
        (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
          ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list))) *
      ('a, 'b, 'c, ('a, 'b, 'c) trs_nontermination_proof,
        ('a, 'b, 'c) dp_nontermination_proof,
        ('a, 'b, 'c) reltrs_nontermination_proof,
        ('a, 'b, 'c) trs_nontermination_proof, ('a, 'b, 'c) neg_unknown_proof)
        generic_assm_proof list
and ('a, 'b, 'c) trs_nontermination_proof =
  TRS_Loop of (('a, 'b) lab, 'c) trs_loop_prf | TRS_Not_Well_Formed |
  TRS_Rule_Removal of
    (('a, 'b) lab, 'c) rule_removal_nonterm_trs_prf *
      ('a, 'b, 'c) trs_nontermination_proof
  | TRS_String_Reversal of ('a, 'b, 'c) trs_nontermination_proof |
  TRS_Constant_String of
    (('a, 'b) lab, 'c) const_string_complete_proof *
      ('a, 'b, 'c) trs_nontermination_proof
  | TRS_DP_Trans of
      ('a, 'b, 'c) dp_trans_nontermination_tt_prf *
        ('a, 'b, 'c) dp_nontermination_proof
  | TRS_Termination_Switch of
      ('a, 'b) lab join_info * ('a, 'b, 'c) trs_nontermination_proof
  | TRS_Nonloop of (('a, 'b) lab, 'c) non_loop_prf |
  TRS_Nonloop_SRS of ('a, 'b) lab non_loop_srs_proof |
  TRS_Q_Increase of
    (('a, 'b) lab, 'c) q_increase_nonterm_trs_prf *
      ('a, 'b, 'c) trs_nontermination_proof
  | TRS_Uncurry of
      ('a, 'b, 'c) uncurry_nt_proof * ('a, 'b, 'c) trs_nontermination_proof
  | TRS_Not_WN_Tree_Automaton of (('a, 'b) lab, 'c) not_wn_ta_prf |
  TRS_Assume_Not_SN of
    (bool *
      ((('a, 'b) lab, 'c) term list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list)) *
      ('a, 'b, 'c, ('a, 'b, 'c) trs_nontermination_proof,
        ('a, 'b, 'c) dp_nontermination_proof,
        ('a, 'b, 'c) reltrs_nontermination_proof,
        ('a, 'b, 'c) trs_nontermination_proof, ('a, 'b, 'c) neg_unknown_proof)
        generic_assm_proof list
  | FPTRS_Assume_Not_SN of
      (((('a, 'b) lab, 'c) ctxt * ((('a, 'b) lab, 'c) term * location)) list *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) *
        ('a, 'b, 'c, ('a, 'b, 'c) trs_nontermination_proof,
          ('a, 'b, 'c) dp_nontermination_proof,
          ('a, 'b, 'c) reltrs_nontermination_proof,
          ('a, 'b, 'c) trs_nontermination_proof, ('a, 'b, 'c) neg_unknown_proof)
          generic_assm_proof list
and ('a, 'b, 'c) dp_nontermination_proof =
  DP_Loop of (('a, 'b) lab, 'c) dp_loop_prf |
  DP_Nonloop of (('a, 'b) lab, 'c) non_loop_prf |
  DP_Rule_Removal of
    (('a, 'b) lab, 'c) rule_removal_nonterm_dp_prf *
      ('a, 'b, 'c) dp_nontermination_proof
  | DP_Q_Increase of
      (('a, 'b) lab, 'c) q_increase_nonterm_dp_prf *
        ('a, 'b, 'c) dp_nontermination_proof
  | DP_Q_Reduction of
      (('a, 'b) lab, 'c) dp_q_reduction_nonterm_prf *
        ('a, 'b, 'c) dp_nontermination_proof
  | DP_Termination_Switch of
      ('a, 'b) lab join_info * ('a, 'b, 'c) dp_nontermination_proof
  | DP_Instantiation of
      (('a, 'b) lab, 'c) instantiation_complete_proc_prf *
        ('a, 'b, 'c) dp_nontermination_proof
  | DP_Rewriting of
      (('a, 'b) lab, 'c) rewriting_complete_proc_prf *
        ('a, 'b, 'c) dp_nontermination_proof
  | DP_Narrowing of
      (('a, 'b) lab, 'c) narrowing_complete_proc_prf *
        ('a, 'b, 'c) dp_nontermination_proof
  | DP_Assume_Infinite of
      (bool *
        (bool *
          (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
            (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
              ((('a, 'b) lab, 'c) term list *
                (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
                  ((('a, 'b) lab, 'c) term *
                    (('a, 'b) lab, 'c) term) list)))))) *
        ('a, 'b, 'c, ('a, 'b, 'c) trs_nontermination_proof,
          ('a, 'b, 'c) dp_nontermination_proof,
          ('a, 'b, 'c) reltrs_nontermination_proof,
          ('a, 'b, 'c) trs_nontermination_proof, ('a, 'b, 'c) neg_unknown_proof)
          generic_assm_proof list
and ('a, 'b, 'c) neg_unknown_proof =
  Assume_NT_Unknown of
    char list *
      ('a, 'b, 'c, ('a, 'b, 'c) trs_nontermination_proof,
        ('a, 'b, 'c) dp_nontermination_proof,
        ('a, 'b, 'c) reltrs_nontermination_proof,
        ('a, 'b, 'c) trs_nontermination_proof, ('a, 'b, 'c) neg_unknown_proof)
        generic_assm_proof list;

datatype ('a, 'b) oc_irule =
  OC_Deduce of ('a, 'b) term * ('a, 'b) term * ('a, 'b) term |
  OC_Orientl of ('a, 'b) term * ('a, 'b) term |
  OC_Orientr of ('a, 'b) term * ('a, 'b) term | OC_Delete of ('a, 'b) term |
  OC_Compose of ('a, 'b) term * ('a, 'b) term * ('a, 'b) term |
  OC_Simplifyl of ('a, 'b) term * ('a, 'b) term * ('a, 'b) term |
  OC_Simplifyr of ('a, 'b) term * ('a, 'b) term * ('a, 'b) term |
  OC_Collapse of ('a, 'b) term * ('a, 'b) term * ('a, 'b) term;

datatype ('a, 'b, 'c) ordered_completion_proof =
  OKB of (('a, 'b) lab, 'c) oc_irule list;

datatype ('a, 'b, 'c) quasi_reductive_proof =
  Unravel of
    ((((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
       ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) *
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) list *
      ('a, 'b, 'c) trs_termination_proof;

datatype ('a, 'b) nonreachability_proof = Nonreachable_Tcap | Nonreachable_Gtcap
  | Nonreachable_ETAC of
      ('a * nat) list * 'a * 'a * (('a, 'b) term, 'a) tree_automaton
  | Nonreachable_Subst_Approx of
      (('a, 'b) term * ('a, 'b) term) list * ('a, 'b) nonreachability_proof
  | Nonreachable_Reverse of ('a, 'b) nonreachability_proof;

datatype ('a, 'b) nonjoinability_proof = Nonjoinable_Tcap |
  Nonjoinable_Ground_NF of ('a, 'b) nonreachability_proof;

datatype ('a, 'b) infeasibility_proof =
  Infeasible_Compound_Conditions of 'a * ('a, 'b) nonreachability_proof |
  Infeasible_Equation of
    ('a, 'b) term * ('a, 'b) term * ('a, 'b) nonreachability_proof
  | Infeasible_Subset of
      (('a, 'b) term * ('a, 'b) term) list * ('a, 'b) infeasibility_proof
  | Infeasible_Rhss_Equal of
      ('a, 'b) term * ('a, 'b) term * ('a, 'b) term *
        ('a, 'b) nonjoinability_proof;

datatype ('a, 'b, 'c) ccr_transformation =
  Inline_Conditions_CCRT of
    (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) list *
      ((((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
         ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) list
  | Infeasible_Rule_Removal_CCRT of
      ((((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
         ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) *
        (('a, 'b) lab, 'c) infeasibility_proof) list;

datatype ('a, 'b) cstep_proof =
  Cstep_step of
    ((('a, 'b) term * ('a, 'b) term) * (('a, 'b) term * ('a, 'b) term) list) *
      pos * ('b -> ('a, 'b) term) * ('a, 'b) term * ('a, 'b) term *
      (('a, 'b) cstep_proof list) list;

datatype ('a, 'b, 'c, 'd) conditional_ncr_proof =
  Unconditional_CNCR of ('a, 'b, 'c, 'd) ncr_proof |
  Transformation_CNCR of
    ('a, 'b, 'c) ccr_transformation * ('a, 'b, 'c, 'd) conditional_ncr_proof
  | Non_Join_CNCR of
      (('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term *
        (('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) cstep_proof list *
        (('a, 'b) lab, 'c) cstep_proof list *
        (('a, 'b) lab, 'c, 'd) non_join_info;

datatype ('a, 'b, 'c) completion_proof =
  SN_WCR_Eq of
    ('a, 'b) lab join_info * ('a, 'b, 'c) trs_termination_proof *
      (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
        (pos *
          (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
            (bool * (('a, 'b) lab, 'c) term))) list) list *
      ((((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
         (pos *
           (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
             (bool * (('a, 'b) lab, 'c) term))) list) list) option;

datatype ('a, 'b, 'c) equational_disproof =
  Completion_and_Normalization_Different of
    ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
      ('a, 'b, 'c) completion_proof
  | Convertible_Instance of
      (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
        (pos *
          (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
            (bool * (('a, 'b) lab, 'c) term))) list) list;

datatype ('a, 'b) ao_infeasibility_proof =
  AO_Infeasibility_Proof of ('a, 'b) infeasibility_proof |
  AO_Lhss_Equal of
    ('a, 'b) term * ('a, 'b) term * ('a, 'b) term *
      ('a, 'b) nonjoinability_proof;

datatype ('a, 'b) context_joinable_proof =
  Contextual_Join of
    ('a, 'b) term * ('a, 'b) cstep_proof list * ('a, 'b) cstep_proof list;

datatype ('a, 'b) unfeasible_proof =
  UnfeasibleOverlap of
    ('a, 'b) term * ('a, 'b) term * ('a, 'b) term * ('a, 'b) cstep_proof list *
      ('a, 'b) cstep_proof list *
      ((('a, 'b) term * ('a, 'b) term) * (('a, 'b) term * ('a, 'b) term) list) *
      ((('a, 'b) term * ('a, 'b) term) * (('a, 'b) term * ('a, 'b) term) list);

datatype ('a, 'b, 'c) conditional_cr_proof =
  Unconditional_CR of ('a, 'b, 'c) cr_proof |
  Unravel_CR of
    ((((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
       ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) *
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) list *
      ('a, 'b, 'c) cr_proof
  | Transformation_CR of
      ('a, 'b, 'c) ccr_transformation * ('a, 'b, 'c) conditional_cr_proof
  | Almost_Orthogonal_CR |
  Almost_Orthogonal_Modulo_Infeasibility_CR of
    (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
      (('a, 'b) lab, 'c) infeasibility_proof) list
  | Almost_Orthogonal_Modulo_Infeasibility_CRa of
      (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
          (('a, 'b) lab, 'c) ao_infeasibility_proof)) list
  | AL94_CR of
      ('a, 'b, 'c) quasi_reductive_proof *
        ((('a, 'b) lab, 'c) term *
          ((('a, 'b) lab, 'c) term *
            (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
              (('a, 'b) lab, 'c) context_joinable_proof))) list *
        (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
          (('a, 'b) lab, 'c) infeasibility_proof) list *
        (('c -> (('a, 'b) lab, 'c) term) *
          (('a, 'b) lab, 'c) unfeasible_proof) list;

datatype ('a, 'b) ac_dependency_pairs_proof =
  AC_dependency_pairs_proof of
    (('a, 'b) term * ('a, 'b) term) list *
      (('a, 'b) term * ('a, 'b) term) list *
      (('a, 'b) term * ('a, 'b) term) list *
      (('a, 'b) term * ('a, 'b) term) list;

datatype ('a, 'b) ac_dp_termination_proof = AC_P_is_Empty |
  AC_Subterm_Proc of
    (('a * nat) * nat list) list * (('a, 'b) term * ('a, 'b) term) list *
      ('a, 'b) ac_dp_termination_proof
  | AC_Redpair_UR_Proc of
      'a redtriple_impl * (('a, 'b) term * ('a, 'b) term) list *
        (('a, 'b) term * ('a, 'b) term) list * ('a, 'b) ac_dp_termination_proof
  | AC_Mono_Redpair_UR_Proc of
      'a redtriple_impl * (('a, 'b) term * ('a, 'b) term) list *
        (('a, 'b) term * ('a, 'b) term) list *
        (('a, 'b) term * ('a, 'b) term) list * ('a, 'b) ac_dp_termination_proof
  | AC_Dep_Graph_Proc of
      (('a, 'b) ac_dp_termination_proof option *
        (('a, 'b) term * ('a, 'b) term) list) list;

datatype ('a, 'b, 'c) ac_termination_proof =
  AC_DP_Trans of
    (('a, 'b) lab, 'c) ac_dependency_pairs_proof *
      (('a, 'b) lab, 'c) ac_dp_termination_proof *
      (('a, 'b) lab, 'c) ac_dp_termination_proof
  | AC_DP_Trans_Single of
      (('a, 'b) lab, 'c) ac_dependency_pairs_proof *
        (('a, 'b) lab, 'c) ac_dp_termination_proof
  | AC_Rule_Removal of
      ('a, 'b) lab redtriple_impl *
        ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) ac_termination_proof
  | AC_R_is_Empty;

datatype ('a, 'b, 'c, 'd) fresh_variable_addition_info =
  Fresh_Variable_Addition_Info of
    'b * 'c * ('d * ('a, ('b trans_var * 'c)) term formula) list;

datatype ('a, 'b, 'c, 'd, 'e) transition_removal_info =
  Transition_removal_info of
    ('c sharp -> 'a) * 'd list * 'b * 'a * ('d -> 'e hint);

datatype ('a, 'b, 'c, 'd, 'e) location_addition_info =
  Location_Addition_Info of 'd * 'd * 'e * ('a, 'b, 'c, 'd) transition_rule;

datatype ('a, 'b, 'c) art_edge_impl = Cover_Edge of 'a * 'c |
  Children_Edge of ('b * ('a * 'c)) list;

datatype ('a, 'b, 'c, 'd, 'e, 'f, 'g) art_node_impl =
  Art_Node of
    'e * ('a, ('b * 'c)) term formula * 'd * ('e, 'f, 'g) art_edge_impl;

datatype ('a, 'b, 'c, 'd, 'e, 'f, 'g, 'h) art_impl_ext =
  Art_impl_ext of
    'e list * ('a, 'b, 'c, 'd, 'e, 'f, 'g) art_node_impl list * 'h;

datatype ('a, 'b, 'c, 'd, 'e, 'f, 'g) invariant_proof =
  Impact of
    ('d * ('a, ('b * 'c)) term formula) list *
      ('a, 'b, 'c, 'd, 'e, 'f, 'g hint, unit) art_impl_ext;

datatype ('a, 'b, 'c, 'd, 'e, 'f) cooperation_proof = Triviala |
  Invariants_Update of
    ('a, 'b, 'c, 'd sharp, (char list), 'e, 'f) invariant_proof *
      ('a, 'b, 'c, 'd, 'e, 'f) cooperation_proof
  | Location_Addition of
      ('a, 'b, 'c, 'd sharp, 'e) location_addition_info *
        ('a, 'b, 'c, 'd, 'e, 'f) cooperation_proof
  | Fresh_Variable_Addition of
      ('a, 'b, 'c, 'e) fresh_variable_addition_info *
        ('a, 'b, 'c, 'd, 'e, 'f) cooperation_proof
  | Transition_Removal of
      ((('a, ('b * 'c)) term list), 'c, 'd, 'e, 'f) transition_removal_info *
        ('a, 'b, 'c, 'd, 'e, 'f) cooperation_proof
  | Scc_Decomp of
      ('d sharp list * ('a, 'b, 'c, 'd, 'e, 'f) cooperation_proof) list
  | Cut_Transition_Split of
      ('e list * ('a, 'b, 'c, 'd, 'e, 'f) cooperation_proof) list;

datatype ('a, 'b, 'c, 'd, 'e, 'f) termination_proof = Trivialb |
  Via_Cooperation of
    (('e sharp * ('a, 'b, 'c, 'd sharp) transition_rule) list *
      ('a, 'b, 'c, 'd, 'e sharp, 'f) cooperation_proof) list
  | Invariants_Update_LTS of
      ('a, 'b, 'c, 'd, (char list), 'e, 'f) invariant_proof *
        ('a, 'b, 'c, 'd, 'e, 'f) termination_proof;

datatype ('a, 'b) eq_proof = Refl of ('a, 'b) term | Sym of ('a, 'b) eq_proof |
  Trans of ('a, 'b) eq_proof * ('a, 'b) eq_proof |
  Assm of (('a, 'b) term * ('a, 'b) term) * ('b -> ('a, 'b) term) |
  Cong of 'a * ('a, 'b) eq_proof list;

datatype ('a, 'b, 'c) equational_proof =
  Equational_Proof_Tree of (('a, 'b) lab, 'c) eq_proof |
  Completion_and_Normalization of
    ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
      ('a, 'b, 'c) completion_proof
  | Conversion of
      (pos *
        (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
          (bool * (('a, 'b) lab, 'c) term))) list
  | Conversion_With_History of
      (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
        (pos *
          (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) *
            (bool * (('a, 'b) lab, 'c) term))) list) list;

datatype ('a, 'b) dt_transformation_info =
  DT_Transformation_Info of
    ((('a, 'b) term * ('a, 'b) term) * (('a, 'b) term * ('a, 'b) term)) list *
      ((('a, 'b) term * ('a, 'b) term) * (('a, 'b) term * ('a, 'b) term)) list *
      ('a, 'b) term list;

datatype ('a, 'b) wdp_trans_info =
  WDP_Trans_Info of
    ('a * nat) set *
      ((('a, 'b) term * ('a, 'b) term) * (('a, 'b) term * ('a, 'b) term)) list *
      ((('a, 'b) term * ('a, 'b) term) * (('a, 'b) term * ('a, 'b) term)) list *
      ('a, 'b) term list;

datatype ('a, 'b, 'c) complexity_proof =
  Rule_Shift_Complexity of
    ('a, 'b) lab redtriple_impl *
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
      (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list) option *
      ('a, 'b, 'c) complexity_proof
  | RisEmpty_Complexity |
  Remove_Nonapplicable_Rules_Complexity of
    ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
      ('a, 'b, 'c) complexity_proof
  | Matchbounds_Complexity of (('a, 'b) lab, 'c) bounds_info |
  Matchbounds_Rel_Complexity of
    (('a, 'b) lab, 'c) bounds_info *
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
      ('a, 'b, 'c) complexity_proof
  | DT_Transformation of
      (('a, 'b) lab, 'c) dt_transformation_info * ('a, 'b, 'c) complexity_proof
  | WDP_Transformation of
      (('a, 'b) lab, 'c) wdp_trans_info * ('a, 'b, 'c) complexity_proof
  | Complexity_Assumption of
      ((('a, 'b) lab, 'c) term list *
        (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
          (((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
            ((('a, 'b) lab, 'c) complexity_measure * complexity_class)))) *
        ('a, 'b, 'c, ('a, 'b, 'c) complexity_proof, unit, unit, unit, unit)
          generic_assm_proof list
  | Usable_Rules_Complexity of
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) complexity_proof
  | Split_Complexity of
      ((('a, 'b) lab, 'c) term * (('a, 'b) lab, 'c) term) list *
        ('a, 'b, 'c) complexity_proof * ('a, 'b, 'c) complexity_proof;

datatype ('a, 'b, 'c, 'd, 'e, 'f, 'g) safety_proof = Trivial |
  Invariant_Assertion of
    ('a, 'b, 'c, 'd, 'e, 'f, 'g) invariant_proof *
      ('a, 'b, 'c, 'd, 'e, 'f, 'g) safety_proof;

datatype ('a, 'b, 'c) proof =
  TRS_Termination_Proof of ('a, 'b, 'c) trs_termination_proof |
  Complexity_Proof of ('a, 'b, 'c) complexity_proof |
  DP_Termination_Proof of ('a, 'b, 'c) dp_termination_proof |
  DP_Nontermination_Proof of ('a, 'b, 'c) dp_nontermination_proof |
  TRS_Nontermination_Proof of ('a, 'b, 'c) trs_nontermination_proof |
  FP_Termination_Proof of ('a, 'b, 'c) fptrs_termination_proof |
  Relative_TRS_Nontermination_Proof of ('a, 'b, 'c) reltrs_nontermination_proof
  | TRS_Confluence_Proof of ('a, 'b, 'c) cr_proof |
  TRS_Non_Confluence_Proof of ('a, 'b, 'c, 'c) ncr_proof |
  Completion_Proof of ('a, 'b, 'c) completion_proof |
  Ordered_Completion_Proof of ('a, 'b, 'c) ordered_completion_proof |
  Equational_Proof of ('a, 'b, 'c) equational_proof |
  Equational_Disproof of ('a, 'b, 'c) equational_disproof |
  Quasi_Reductive_Proof of ('a, 'b, 'c) quasi_reductive_proof |
  Conditional_CR_Proof of ('a, 'b, 'c) conditional_cr_proof |
  Conditional_Non_CR_Proof of ('a, 'b, 'c, 'c) conditional_ncr_proof |
  Tree_Automata_Closed_Proof of (char list) ta_relation |
  AC_Termination_Proof of ('a, 'b, 'c) ac_termination_proof |
  LTS_Termination_Proof of
    (siga, 'c, ty, (char list), (char list), hints) termination_proof
  | LTS_Safety_Proof of
      (siga, 'c, ty, (char list), (char list), (char list), hints) safety_proof
  | Unknown_Proof of ('a, 'b, 'c) unknown_proof |
  Unknown_Disproof of ('a, 'b, 'c) neg_unknown_proof;

datatype 'a linearity = Non_Linear | Onea | Variable of 'a;

datatype 'a ns_constraint = LEQ_ns of linear_poly * 'a |
  GEQ_ns of linear_poly * 'a;

datatype ('b, 'a) comp_fun_idem = Abs_comp_fun_idem of ('b -> 'a -> 'a);

datatype ('a, 'b) monoid_ext = Monoid_ext of ('a -> 'a -> 'a) * 'a * 'b;

datatype ('a, 'b) state_ext =
  State_ext of
    (nat * linear_poly) list * (nat -> 'a option) * (nat -> 'a option) *
      (nat, 'a) mapping * bool * 'b;

datatype ('a, 'b, 'c) ta_ext =
  Ta_ext of 'a set * ('a, 'b) ta_rule set * ('a * 'a) set * 'c;

datatype dependance = Ignore | Increase | Decrease | Wild;

datatype 'a semilattice_set = Abs_semilattice_set of ('a -> 'a -> 'a);

datatype 'a interpretation = Int_linear_poly of (('a * nat) * (int * int list))
  | Rat_linear_poly of (('a * nat) * (rat * rat list)) |
  Arctic_linear_poly of (('a * nat) * (arctic * arctic list)) |
  Arctic_rat_linear_poly of
    (('a * nat) * (rat arctic_delta * rat arctic_delta list))
  | Real_linear_poly of (('a * nat) * (real * real list)) |
  Int_matrix of (('a * nat) * (int mat * int mat list)) |
  Rat_matrix of (('a * nat) * (rat mat * rat mat list)) |
  Arctic_matrix of (('a * nat) * (arctic mat * arctic mat list)) |
  Arctic_rat_matrix of
    (('a * nat) * (rat arctic_delta mat * rat arctic_delta mat list))
  | Real_matrix of (('a * nat) * (real mat * real mat list)) |
  Int_non_linear_poly of (('a * nat) * (nat monom * int) list) |
  Rat_non_linear_poly of (('a * nat) * (nat monom * rat) list) |
  Real_non_linear_poly of (('a * nat) * (nat monom * real) list);

datatype relation_kind = Strict_TRS | Weak_TRS of nat option;

datatype cert_result = Certified | Unsupported of char list |
  Error of char list;

datatype 'a istate_ext =
  Istate_ext of nat * (nat * linear_poly) list * qDelta atom list * 'a;

datatype ('a, 'b) subst_incr =
  Abs_subst_incr of
    (('b -> ('a, 'b) term) * ('b set * (('a, 'b) term -> 'b list)));

datatype ('a, 'b, 'c, 'd, 'e) art_edge = Cover of 'e |
  Children of (('a, 'b, 'c, 'd) transition_rule * 'e) list;

datatype ('a, 'b, 'c, 'd) memory_ext =
  Memory_ext of
    (unit -> 'a) * ('a -> 'b -> 'c option) * ('a -> 'b * 'c -> 'a) * 'd;

datatype real_alg_2_list = Abs_real_alg_2_list of real_alg_2 list;

datatype ('a, 'b) ta_rule_impl =
  TA_rule_impl of 'b * 'a list * 'a * ('a, unit) rbt;

datatype ('a, 'b) ta_impl =
  TA_Impl of
    ('a, unit) rbt * (('b * nat), (('a, 'b) ta_rule_impl list)) rbt * 'a list *
      ('a, unit) rbt * ('a * 'a) list * ('a -> ('a, unit) rbt) *
      ('a -> ('a, unit) rbt);

datatype ('b, 'a) tp =
  TP of (bool *
          (('b, 'a) term list *
            (bool *
              ((('b, 'a) term * ('b, 'a) term) list *
                ((('b, 'a) term * ('b, 'a) term) list *
                  ((('b * nat), ((bool * (('b, 'a) term * ('b, 'a) term)) list))
                     rbt *
                    (('b, 'a) term -> bool)))))));

datatype 'a interval = Interval of 'a * 'a;

datatype ('a, 'b, 'c, 'd, 'e, 'f) art_ext =
  Art_ext of
    'e list * 'e list * ('e -> ('a, 'b, 'c, 'd, 'e) art_edge) * ('e -> 'd) *
      ('e -> ('a, ('b * 'c)) term formula) * 'f;

datatype ('b, 'a) ta_code =
  Abs_ta_code of
    (('b, unit) rbta *
      ((('b, 'a) ta_rule, unit) rbta *
        (('b * 'b) list *
          (('b, unit) rbta *
            ((('a * nat), (('b list * 'b), unit) rbta) rbta *
              (bool * (('b -> ('b, unit) rbta) * ('b -> ('b, unit) rbta))))))));

datatype ('a, 'b) c_constraint =
  Conditional_C of
    bool * (('a, 'b) term * ('a, 'b) term) * (('a, 'b) term * ('a, 'b) term)
  | Unconditional_C of bool * (('a, 'b) term * ('a, 'b) term);

datatype ('a, 'b) direction_ext =
  Direction_ext of
    ('a -> 'a -> bool) * (('a, unit) state_ext -> nat -> 'a option) *
      (('a, unit) state_ext -> nat -> 'a option) *
      (((nat -> 'a option) -> nat -> 'a option) ->
        ('a, unit) state_ext -> ('a, unit) state_ext) *
      (nat -> 'a -> 'a atom) * 'b;

datatype ('b, 'a) dpp =
  DPP of
    (bool *
      (bool *
        ((('b, 'a) term * ('b, 'a) term) list *
          ((('b, 'a) term * ('b, 'a) term) list *
            (('b, 'a) term list *
              (bool *
                (bool *
                  ((('b, 'a) term * ('b, 'a) term) list *
                    ((('b, 'a) term * ('b, 'a) term) list *
                      ((('b * nat),
                         ((bool * (('b, 'a) term * ('b, 'a) term)) list))
                         rbt *
                        ((('b * nat),
                           ((bool * (('b, 'a) term * ('b, 'a) term)) list))
                           rbt *
                          (bool * (('b, 'a) term -> bool)))))))))))));

datatype 'a poly_constraint = Poly_Ge of ('a monom * int) list |
  Poly_Eq of ('a monom * int) list;

datatype ('a, 'b, 'c, 'd, 'e) hinter_ext =
  Hinter_ext of
    'c list * ('b -> 'd list) * ('c -> 'a) * ('c -> ('a list) option) * 'e;

datatype complex_interval = Complex_Interval of real interval * real interval;

datatype ('b, 'a) ac_dpp =
  AC_DPP of
    ((('b, 'a) term * ('b, 'a) term) list *
      ((('b, 'a) term * ('b, 'a) term) list *
        ((('b, 'a) term * ('b, 'a) term) list *
          ((('b, 'a) term * ('b, 'a) term) list *
            ((('b, 'a) term * ('b, 'a) term) list *
              (('b * nat), ((unit * (('b, 'a) term * ('b, 'a) term)) list))
                rbt)))));

datatype ('a, 'b, 'c, 'd) gen_g_impl_ext = Gen_g_impl_ext of 'a * 'b * 'c * 'd;

datatype ('a, 'b, 'c) redord_ext =
  Redord_ext of
    (('a * nat) list -> ((char list -> char list), unit) sum) *
      (('a, 'b) term -> ('a, 'b) term -> bool) * 'a * 'c;

datatype condition_type = Bound | Strict | Non_Strict;

datatype ('a, 'b, 'c) redtriple_ext =
  Redtriple_ext of
    ((char list -> char list), unit) sum *
      (('a, 'b) term * ('a, 'b) term -> ((char list -> char list), unit) sum) *
      (('a, 'b) term * ('a, 'b) term -> ((char list -> char list), unit) sum) *
      (('a, 'b) term * ('a, 'b) term -> ((char list -> char list), unit) sum) *
      ('a * nat -> nat set) * ('a * nat -> nat set) *
      ((('a, 'b) term * ('a, 'b) term) list ->
        ((char list -> char list), unit) sum) *
      (char list -> char list) * (('a * nat) list) option *
      (('a, 'b) complexity_measure ->
        complexity_class -> ((char list -> char list), unit) sum) *
      'c;

datatype ('a, 'b) fp_loop_prf =
  FP_loop_prf of
    ('a, 'b) ctxt * ('b * ('a, 'b) term) list * ('a, 'b) term *
      (pos * ((('a, 'b) term * ('a, 'b) term) * ('a, 'b) term)) list;

datatype ('a, 'b, 'c, 'd, 'e) sl_ops_ext =
  Sl_ops_ext of
    ('a -> 'b list -> 'c) * ('a -> nat -> 'c -> bool) * ('a -> 'b list -> 'b) *
      'b list * 'b *
      ((('a, 'd) term * ('a, 'd) term) list ->
        ((char list -> char list), unit) sum) *
      ('a -> 'b list -> 'c) * ('a -> nat -> 'c -> bool) * ('c -> 'c list) *
      ('a -> nat -> 'c list) * 'e;

datatype ('a, 'b, 'c, 'd) slm_ops_ext =
  Slm_ops_ext of
    ('a -> 'b list -> 'c) * ('a -> 'b list -> 'b) * 'b list * 'b *
      ('a -> 'b list -> 'c) * 'd;

datatype ('a, 'b, 'c, 'd) tp_ops_ext =
  Tp_ops_ext of
    ('a ->
      bool *
        (('b, 'c) term set *
          ((('b, 'c) term * ('b, 'c) term) set *
            (('b, 'c) term * ('b, 'c) term) set))) *
      ('a -> ('b, 'c) term list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) * ('a -> bool) *
      ('a -> ('b, 'c) term -> bool) * ('a -> bool) *
      ('a -> 'b * nat -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a ->
        (('b, 'c) term * ('b, 'c) term) list ->
          (('b, 'c) term * ('b, 'c) term) list -> 'a) *
      ('a ->
        (('b, 'c) term * ('b, 'c) term) list ->
          (('b, 'c) term * ('b, 'c) term) list *
            (('b, 'c) term * ('b, 'c) term) list) *
      (bool ->
        ('b, 'c) term list ->
          (('b, 'c) term * ('b, 'c) term) list ->
            (('b, 'c) term * ('b, 'c) term) list -> 'a) *
      ('a -> bool) * 'd;

datatype ('a, 'b) partial_object_ext = Partial_object_ext of 'a set * 'b;

datatype 'a cut_transition_split_info =
  Cut_Transition_Split_Info of ('a list) list;

datatype ('a, 'b, 'c, 'd) dpp_ops_ext =
  Dpp_ops_ext of
    ('a ->
      bool *
        (bool *
          ((('b, 'c) term * ('b, 'c) term) set *
            ((('b, 'c) term * ('b, 'c) term) set *
              (('b, 'c) term set *
                ((('b, 'c) term * ('b, 'c) term) set *
                  (('b, 'c) term * ('b, 'c) term) set)))))) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> ('b, 'c) term list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) * ('a -> bool) *
      ('a -> bool) * ('a -> bool) * ('a -> ('b, 'c) term -> bool) *
      ('a -> bool) * ('a -> 'b * nat -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> 'b * nat -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list -> 'a) *
      ('a ->
        ('b, 'c) term * ('b, 'c) term ->
          (('b, 'c) term * ('b, 'c) term) list -> 'a) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list -> 'a) *
      ('a ->
        (('b, 'c) term * ('b, 'c) term) list ->
          (('b, 'c) term * ('b, 'c) term) list -> 'a) *
      ('a ->
        (('b, 'c) term * ('b, 'c) term) list ->
          (('b, 'c) term * ('b, 'c) term) list -> 'a) *
      ('a ->
        (('b, 'c) term * ('b, 'c) term) list ->
          (('b, 'c) term * ('b, 'c) term) list *
            (('b, 'c) term * ('b, 'c) term) list) *
      ('a ->
        (('b, 'c) term * ('b, 'c) term) list ->
          (('b, 'c) term * ('b, 'c) term) list *
            (('b, 'c) term * ('b, 'c) term) list) *
      (bool ->
        bool ->
          (('b, 'c) term * ('b, 'c) term) list ->
            (('b, 'c) term * ('b, 'c) term) list ->
              ('b, 'c) term list ->
                (('b, 'c) term * ('b, 'c) term) list ->
                  (('b, 'c) term * ('b, 'c) term) list -> 'a) *
      ('a -> bool) * ('a -> bool) * ('a -> bool) * 'd;

datatype ('a, 'b, 'c) root_redtriple_ext =
  Root_redtriple_ext of
    ((char list -> char list), unit) sum *
      (('a, 'b) term * ('a, 'b) term -> ((char list -> char list), unit) sum) *
      (('a, 'b) term * ('a, 'b) term -> ((char list -> char list), unit) sum) *
      (('a, 'b) term * ('a, 'b) term -> ((char list -> char list), unit) sum) *
      ('a * nat -> nat set) * ('a * nat -> nat set) * (char list -> char list) *
      'c;

datatype ('a, 'b, 'c) non_inf_order_ext =
  Non_inf_order_ext of
    ((char list -> char list), unit) sum *
      (('a, 'b) term * ('a, 'b) term -> ((char list -> char list), unit) sum) *
      (('a, 'b) c_constraint -> ((char list -> char list), unit) sum) *
      ('a * nat -> nat -> dependance) * (char list -> char list) * 'c;

datatype ('a, 'b, 'c, 'd) ac_tp_ops_ext =
  Ac_tp_ops_ext of
    ('a -> (('b, 'c) term * ('b, 'c) term) set * ('b set * 'b set)) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) * ('a -> 'b list) *
      ('a -> 'b list) *
      ((('b, 'c) term * ('b, 'c) term) list -> 'b list -> 'b list -> 'a) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list -> 'a) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) * 'd;

datatype ('a, 'b) ordered_semiring_ext =
  Ordered_semiring_ext of
    ('a -> 'a -> bool) * ('a -> 'a -> bool) * ('a -> 'a -> 'a) * 'b;

datatype ('a, 'b, 'c, 'd) ac_dpp_ops_ext =
  Ac_dpp_ops_ext of
    ('a ->
      (('b, 'c) term * ('b, 'c) term) set *
        ((('b, 'c) term * ('b, 'c) term) set *
          ((('b, 'c) term * ('b, 'c) term) set *
            ((('b, 'c) term * ('b, 'c) term) set *
              (('b, 'c) term * ('b, 'c) term) set)))) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list) *
      ((('b, 'c) term * ('b, 'c) term) list ->
        (('b, 'c) term * ('b, 'c) term) list ->
          (('b, 'c) term * ('b, 'c) term) list ->
            (('b, 'c) term * ('b, 'c) term) list ->
              (('b, 'c) term * ('b, 'c) term) list -> 'a) *
      ('a -> 'b * nat -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a -> 'b * nat -> (('b, 'c) term * ('b, 'c) term) list) *
      ('a ->
        (('b, 'c) term * ('b, 'c) term) list ->
          (('b, 'c) term * ('b, 'c) term) list -> 'a) *
      ('a -> bool) * ('a -> bool) *
      ('a -> (('b, 'c) term * ('b, 'c) term) list -> 'a) * 'd;

datatype ('a, 'b) lpoly_order_semiring_ext =
  Lpoly_order_semiring_ext of
    bool * 'a * ('a -> bool) * ('a -> bool) * ('a -> nat) *
      ('a -> nat -> ((char list -> char list), unit) sum) * char list * 'b;

datatype 'a x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option =
  Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option of
    ('a * nat -> nat list) option;

datatype
  'a x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
  = Abs_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
      of (('a * nat -> af_entry) * ('a * nat) set) option;

fun dom A_ m = collect A_ (fn a => not (is_none (m a)));

fun dlist_ex A_ x xc = list_ex x (list_of_dlist A_ xc);

fun rBT_Impl_rbt_ex p (Branch (c, l, k, v, r)) =
  p k v orelse (rBT_Impl_rbt_ex p l orelse rBT_Impl_rbt_ex p r)
  | rBT_Impl_rbt_ex p Emptya = false;

fun ex A_ xb xc = rBT_Impl_rbt_ex xb (impl_ofb A_ xc);

fun bex (A1_, A2_) (RBT_set rbt) p =
  (case ccompare A2_
    of NONE =>
      (raise Fail "Bex RBT_set: ccompare = None")
        (fn _ => bex (A1_, A2_) (RBT_set rbt) p)
    | SOME _ => ex A2_ (fn k => fn _ => p k) rbt)
  | bex (A1_, A2_) (DList_set dxs) p =
    (case ceq A1_
      of NONE =>
        (raise Fail "Bex DList_set: ceq = None")
          (fn _ => bex (A1_, A2_) (DList_set dxs) p)
      | SOME _ => dlist_ex A1_ p dxs)
  | bex (A1_, A2_) (Set_Monad xs) p = list_ex p xs;

fun tag (XML (name, uu, uv)) = name
  | tag (XML_text uw) = [];

fun rBT_Impl_rbt_all p (Branch (c, l, k, v, r)) =
  p k v andalso (rBT_Impl_rbt_all p l andalso rBT_Impl_rbt_all p r)
  | rBT_Impl_rbt_all p Emptya = true;

fun all A_ xb xc = rBT_Impl_rbt_all xb (impl_ofb A_ xc);

fun ball (A1_, A2_) (RBT_set rbt) p =
  (case ccompare A2_
    of NONE =>
      (raise Fail "Ball RBT_set: ccompare = None")
        (fn _ => ball (A1_, A2_) (RBT_set rbt) p)
    | SOME _ => all A2_ (fn k => fn _ => p k) rbt)
  | ball (A1_, A2_) (DList_set dxs) p =
    (case ceq A1_
      of NONE =>
        (raise Fail "Ball DList_set: ceq = None")
          (fn _ => ball (A1_, A2_) (DList_set dxs) p)
      | SOME _ => dlist_all A1_ p dxs)
  | ball (A1_, A2_) (Set_Monad xs) p = list_all p xs;

fun return x = Sumbot (Inr x);

fun error x = Sumbot (Inl x);

fun int_of_digit x =
  (if ((x : char) = #"0") then return zero_inta
    else (if ((x : char) = #"1") then return one_inta
           else (if ((x : char) = #"2")
                  then return (Int_of_integer (2 : IntInf.int))
                  else (if ((x : char) = #"3")
                         then return (Int_of_integer (3 : IntInf.int))
                         else (if ((x : char) = #"4")
                                then return (Int_of_integer (4 : IntInf.int))
                                else (if ((x : char) = #"5")
                                       then return
      (Int_of_integer (5 : IntInf.int))
                                       else (if ((x : char) = #"6")
      then return (Int_of_integer (6 : IntInf.int))
      else (if ((x : char) = #"7") then return (Int_of_integer (7 : IntInf.int))
             else (if ((x : char) = #"8")
                    then return (Int_of_integer (8 : IntInf.int))
                    else (if ((x : char) = #"9")
                           then return (Int_of_integer (9 : IntInf.int))
                           else error [x, #" ", #"i", #"s", #" ", #"n", #"o",
#"t", #" ", #"a", #" ", #"d", #"i", #"g", #"i", #"t"]))))))))));

fun binda (Sumbot a) f = (case a of Inl b => Sumbot (Inl b) | Inr aa => f aa);

fun int_of_string_aux n [] = return n
  | int_of_string_aux n (d :: s) =
    binda (int_of_digit d)
      (fn m =>
        int_of_string_aux
          (plus_inta (times_inta (Int_of_integer (10 : IntInf.int)) n) m) s);

fun take n [] = []
  | take n (x :: xs) =
    (if equal_nata n zero_nata then []
      else x :: take (minus_nata n one_nata) xs);

fun int_of_string s =
  (if null s
    then error [#"c", #"a", #"n", #"n", #"o", #"t", #" ", #"c", #"o", #"n",
                 #"v", #"e", #"r", #"t", #" ", #"e", #"m", #"p", #"t", #"y",
                 #" ", #"s", #"t", #"r", #"i", #"n", #"g", #" ", #"i", #"n",
                 #"t", #"o", #" ", #"n", #"u", #"m", #"b", #"e", #"r"]
    else (if equal_lista equal_char (take one_nata s) [#"-"]
           then binda (int_of_string_aux zero_inta (tla s))
                  (fn i => return (minus_inta zero_inta i))
           else int_of_string_aux zero_inta s));

fun shows_attr av =
  shows_prec_list show_char zero_nata (fst av) o
    shows_string ([#"=", #"\""] @ snd av @ [#"\""]);

fun shows_attrs asa = foldr (fn a => shows_string [#" "] o shows_attr a) asa;

fun shows_XML_indent ind i (XML (n, a, c)) =
  shows_string [#"\n"] o
    (shows_string ind o
      (shows_string [#"<"] o
        (shows_prec_list show_char zero_nata n o
          (shows_attrs a o
            (if null c then shows_string [#"/", #">"]
              else shows_string [#">"] o
                     (foldr (shows_XML_indent (replicate i #" " @ ind) i) c o
                       (shows_string [#"\n"] o
                         (shows_string ind o
                           (shows_string [#"<", #"/"] o
                             (shows_prec_list show_char zero_nata n o
                               shows_string [#">"]))))))))))
  | shows_XML_indent ind i (XML_text t) = shows_string t;

fun shows_prec_xml d xml =
  shows_XML_indent [] (nat_of_integer (2 : IntInf.int)) xml;

fun concat xss = foldr (fn a => fn b => a @ b) xss [];

fun text tag (XML (n, atts, [XML_text t])) =
  (if equal_lista equal_char n tag andalso null atts then return t
    else error (concat
                 [[#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                    #"e", #"x", #"t", #"r", #"a", #"c", #"t", #" ", #"t", #"e",
                    #"x", #"t", #" ", #"f", #"o", #"r", #" "],
                   tag, [#" ", #"f", #"r", #"o", #"m", #" "], [#"\n"],
                   shows_prec_xml zero_nata (XML (n, atts, [XML_text t])) []]))
  | text tag (XML (v, va, [])) =
    error (concat
            [[#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"e",
               #"x", #"t", #"r", #"a", #"c", #"t", #" ", #"t", #"e", #"x", #"t",
               #" ", #"f", #"o", #"r", #" "],
              tag, [#" ", #"f", #"r", #"o", #"m", #" "], [#"\n"],
              shows_prec_xml zero_nata (XML (v, va, [])) []])
  | text tag (XML (v, va, XML (ve, vf, vg) :: vd)) =
    error (concat
            [[#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"e",
               #"x", #"t", #"r", #"a", #"c", #"t", #" ", #"t", #"e", #"x", #"t",
               #" ", #"f", #"o", #"r", #" "],
              tag, [#" ", #"f", #"r", #"o", #"m", #" "], [#"\n"],
              shows_prec_xml zero_nata (XML (v, va, XML (ve, vf, vg) :: vd))
                []])
  | text tag (XML (v, va, vc :: ve :: vf)) =
    error (concat
            [[#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"e",
               #"x", #"t", #"r", #"a", #"c", #"t", #" ", #"t", #"e", #"x", #"t",
               #" ", #"f", #"o", #"r", #" "],
              tag, [#" ", #"f", #"r", #"o", #"m", #" "], [#"\n"],
              shows_prec_xml zero_nata (XML (v, va, vc :: ve :: vf)) []])
  | text tag (XML_text v) =
    error (concat
            [[#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"e",
               #"x", #"t", #"r", #"a", #"c", #"t", #" ", #"t", #"e", #"x", #"t",
               #" ", #"f", #"o", #"r", #" "],
              tag, [#" ", #"f", #"r", #"o", #"m", #" "], [#"\n"],
              shows_prec_xml zero_nata (XML_text v) []]);

fun int tag x = binda (text tag x) int_of_string;

fun nata tag x =
  binda (text tag x)
    (fn txt => binda (int_of_string txt) (fn i => return (nat i)));

fun options ps x =
  (case map_of (equal_list equal_char) ps (tag x)
    of NONE =>
      error (concat
              [[#"e", #"x", #"p", #"e", #"c", #"t", #"e", #"d", #" ", #"o",
                 #"n", #"e", #" ", #"o", #"f", #":", #" "],
                maps (fn p => fst p @ [#" "]) ps, [#"\n"],
                [#"b", #"u", #"t", #" ", #"f", #"o", #"u", #"n", #"d"], [#"\n"],
                shows_prec_xml zero_nata x []])
    | SOME p => p x);

fun change p f x = binda (p x) (return o f);

fun list2elements [x, y] = SOME (x, y)
  | list2elements [] = NONE
  | list2elements [v] = NONE
  | list2elements (v :: vb :: vd :: ve) = NONE;

fun fail tag xml =
  error (concat
          [[#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"t",
             #"r", #"a", #"n", #"s", #"f", #"o", #"r", #"m", #" ", #"t", #"h",
             #"e", #" ", #"f", #"o", #"l", #"l", #"o", #"w", #"i", #"n", #"g",
             #" ", #"x", #"m", #"l", #" ", #"e", #"l", #"e", #"m", #"e", #"n",
             #"t", #" ", #"(", #"e", #"x", #"p", #"e", #"c", #"t", #"e", #"d",
             #" "],
            tag, [#")"], [#"\n"], shows_prec_xml zero_nata xml []]);

fun pair tag p1 p2 f xml =
  (case xml
    of XML (name, atts, cs) =>
      (if equal_lista equal_char name tag andalso null atts
        then (case list2elements cs of NONE => fail tag xml
               | SOME (cs1, cs2) =>
                 binda (p1 cs1)
                   (fn a => binda (p2 cs2) (fn b => return (f a b))))
        else fail tag xml)
    | XML_text _ => fail tag xml);

fun rat x =
  options
    [([#"i", #"n", #"t", #"e", #"g", #"e", #"r"],
       change (int [#"i", #"n", #"t", #"e", #"g", #"e", #"r"]) of_int),
      ([#"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l"],
        pair [#"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l"]
          (int [#"n", #"u", #"m", #"e", #"r", #"a", #"t", #"o", #"r"])
          (int [#"d", #"e", #"n", #"o", #"m", #"i", #"n", #"a", #"t", #"o",
                 #"r"])
          (fn xa => fn y => divide_rata (of_int xa) (of_int y)))]
    x;

fun skol (A1_, A2_) v (Var x) =
  (if member (A1_, A2_) x v then Fun (Inr x, []) else Var x)
  | skol (A1_, A2_) v (Fun (f, ts)) = Fun (Inl f, map (skol (A1_, A2_) v) ts);

fun empty A_ = RBT Emptya;

fun foldb A_ x xc = folda (fn a => fn _ => x a) (impl_ofb A_ xc);

fun image (A1_, A2_) (B1_, B2_, B3_) h (RBT_set rbt) =
  (case ccompare A2_
    of NONE =>
      (raise Fail "image RBT_set: ccompare = None")
        (fn _ => image (A1_, A2_) (B1_, B2_, B3_) h (RBT_set rbt))
    | SOME _ =>
      foldb A2_ (inserta (B1_, B2_) o h) rbt (bot_set (B1_, B2_, B3_)))
  | image (A1_, A2_) (B1_, B2_, B3_) g (DList_set dxs) =
    (case ceq A1_
      of NONE =>
        (raise Fail "image DList_set: ceq = None")
          (fn _ => image (A1_, A2_) (B1_, B2_, B3_) g (DList_set dxs))
      | SOME _ =>
        foldc A1_ (inserta (B1_, B2_) o g) dxs (bot_set (B1_, B2_, B3_)))
  | image (A1_, A2_) (B1_, B2_, B3_) f (Complement (Complement b)) =
    image (A1_, A2_) (B1_, B2_, B3_) f b
  | image (A1_, A2_) (B1_, B2_, B3_) f (Collect_set a) =
    (raise Fail "image Collect_set")
      (fn _ => image (A1_, A2_) (B1_, B2_, B3_) f (Collect_set a))
  | image (A1_, A2_) (B1_, B2_, B3_) f (Set_Monad xs) = Set_Monad (map f xs);

fun bind NONE f = NONE
  | bind (SOME x) f = f x;

fun zip_option [] [] = SOME []
  | zip_option (x :: xs) (y :: ys) =
    bind (zip_option xs ys) (fn zs => SOME ((x, y) :: zs))
  | zip_option (x :: xs) [] = NONE
  | zip_option [] (y :: ys) = NONE;

fun guarda b = (if b then SOME () else NONE);

fun match_lista A_ ((GCFun (f, ss), Var x) :: ps) =
  bind (match_lista A_ ps) (fn psa => SOME ((GCFun (f, ss), x) :: psa))
  | match_lista A_ ((GCFun (f, ss), Fun (g, ts)) :: ps) =
    bind (guarda (eq A_ f g))
      (fn _ => bind (zip_option ss ts) (fn psa => match_lista A_ (psa @ ps)))
  | match_lista A_ ((GCHole, t) :: ps) = match_lista A_ ps
  | match_lista A_ [] = SOME [];

fun merge_lists A_ (c :: cs) [] = NONE
  | merge_lists A_ [] (d :: ds) = NONE
  | merge_lists A_ (GCFun (f, ss) :: cs) (GCFun (g, ts) :: ds) =
    bind (guarda (eq A_ f g))
      (fn _ =>
        bind (merge_lists A_ ss ts)
          (fn us =>
            bind (merge_lists A_ cs ds) (fn es => SOME (GCFun (f, us) :: es))))
  | merge_lists A_ (c :: cs) (GCHole :: ds) =
    bind (merge_lists A_ cs ds) (fn es => SOME (c :: es))
  | merge_lists A_ (GCHole :: cs) (d :: ds) =
    bind (merge_lists A_ cs ds) (fn es => SOME (d :: es))
  | merge_lists A_ [] [] = SOME [];

fun mergea A_ c d =
  bind (merge_lists A_ [c] [d]) (fn es => SOME (nth es zero_nata));

fun merge_var A_ B_ x c ((d, y) :: ps) =
  (if eq A_ x y then bind (mergea B_ c d) (fn e => merge_var A_ B_ x e ps)
    else bind (merge_var A_ B_ x c ps) (fn (b, psa) => SOME (b, (d, y) :: psa)))
  | merge_var A_ B_ x c [] = SOME ((c, x), []);

fun merge_all A_ B_ [] = SOME []
  | merge_all A_ B_ ((c, x) :: ps) =
    bind (merge_var B_ A_ x c ps)
      (fn (cx, psa) => bind (merge_all A_ B_ psa) (fn psb => SOME (cx :: psb)));

fun matchc A_ B_ (c, t) = bind (match_lista A_ [(c, t)]) (merge_all A_ B_);

fun matchb A_ B_ c t = not (is_none (matchc A_ B_ (c, t)));

fun tcap (A1_, A2_) (B1_, B2_) uu (Var uv) = GCHole
  | tcap (A1_, A2_) (B1_, B2_) r (Fun (f, ts)) =
    let
      val h = GCFun (f, map (tcap (A1_, A2_) (B1_, B2_) r) ts);
    in
      (if bex (ceq_prod (ceq_term A2_ B2_) (ceq_term A2_ B2_),
                ccompare_prod (ccompare_term A1_ B1_) (ccompare_term A1_ B1_))
            r (fn ra => matchb A2_ B2_ h (fst ra))
        then GCHole else h)
    end;

fun root (Var x) = NONE
  | root (Fun (f, ts)) = SOME (f, size_list ts);

fun leaf tag x (XML (name, atts, cs)) =
  (if equal_lista equal_char name tag andalso (null atts andalso null cs)
    then return x else fail tag (XML (name, atts, cs)))
  | leaf tag x (XML_text v) = fail tag (XML_text v);

fun map_sum_bot f [] = return []
  | map_sum_bot f (x :: xs) =
    binda (f x) (fn y => binda (map_sum_bot f xs) (fn ys => return (y :: ys)));

fun many tag p f (XML (name, atts, cs)) =
  (if equal_lista equal_char name tag andalso null atts
    then binda (map_sum_bot p cs) (return o f)
    else fail tag (XML (name, atts, cs)))
  | many tag p f (XML_text v) = fail tag (XML_text v);

fun transitions_impl (Lts_Impl (x1, x2, x3)) = x2;

fun initiala (Lts_Impl (x1, x2, x3)) = x1;

fun assertion_impl (Lts_Impl (x1, x2, x3)) = x3;

fun lookupa A_ xa = map_of A_ (impl_ofa xa);

fun lookupb (A1_, A2_) (RBT_Mapping t) = lookupd A1_ t
  | lookupb (A1_, A2_) (Assoc_List_Mapping al) = lookupa A2_ al;

fun lookup_default (B1_, B2_) d m k =
  (case lookupb (B1_, B2_) m k of NONE => d | SOME v => v);

fun update A_ k v [] = [(k, v)]
  | update A_ k v (p :: ps) =
    (if eq A_ (fst p) k then (k, v) :: ps else p :: update A_ k v ps);

fun updatea A_ xc xd xe = Alist (update A_ xc xd (impl_ofa xe));

fun fun_upd A_ f a b = (fn x => (if eq A_ x a then b else f x));

fun updateb (A1_, A2_) k v (RBT_Mapping t) =
  (case ccompare A1_
    of NONE =>
      (raise Fail "update RBT_Mapping: ccompare = None")
        (fn _ => updateb (A1_, A2_) k v (RBT_Mapping t))
    | SOME _ => RBT_Mapping (inserte A1_ k v t))
  | updateb (A1_, A2_) k v (Assoc_List_Mapping al) =
    Assoc_List_Mapping (updatea A2_ k v al)
  | updateb (A1_, A2_) k v (Mapping m) = Mapping (fun_upd A2_ m k (SOME v));

fun mapping_empty_choose A_ =
  (case ccompare A_ of NONE => Assoc_List_Mapping emptya
    | SOME _ => RBT_Mapping (emptye A_));

fun mapping_empty A_ Mapping_RBT = RBT_Mapping (emptye A_)
  | mapping_empty A_ Mapping_Assoc_List = Assoc_List_Mapping emptya
  | mapping_empty A_ Mapping_Mapping = Mapping (fn _ => NONE)
  | mapping_empty A_ Mapping_Choose = mapping_empty_choose A_;

fun emptyb (A1_, A2_) = mapping_empty A1_ (of_phantom (mapping_impl A2_));

fun of_alist (A1_, A2_, A3_) xs =
  foldr (fn (a, b) => updateb (A1_, A2_) a b) xs (emptyb (A1_, A3_));

fun map_of_default (B1_, B2_, B3_) d xs =
  lookup_default (B1_, B2_) d (of_alist (B1_, B2_, B3_) xs);

fun assertion_of (D1_, D2_, D3_) pi =
  map_of_default (D1_, D2_, D3_) (Conjunction []) (assertion_impl pi);

fun lts_of (A1_, A2_) (B1_, B2_) (C1_, C2_) (D1_, D2_, D3_, D4_, D5_)
  (E1_, E2_, E3_) pi =
  Lts_ext
    (set (D1_, D2_, D5_) (initiala pi),
      image (ceq_prod E1_ (ceq_transition_rule A2_ B2_ C2_ D3_),
              ccompare_prod E2_ (ccompare_transition_rule A1_ B1_ C1_ D2_))
        (ceq_transition_rule A2_ B2_ C2_ D3_,
          ccompare_transition_rule A1_ B1_ C1_ D2_, set_impl_transition_rule)
        snd (set (ceq_prod E1_ (ceq_transition_rule A2_ B2_ C2_ D3_),
                   ccompare_prod E2_ (ccompare_transition_rule A1_ B1_ C1_ D2_),
                   set_impl_prod E3_ set_impl_transition_rule)
              (transitions_impl pi)),
      assertion_of (D2_, D3_, D4_) pi, ());

fun source (Transition (l, uu, uv)) = l;

fun target (Transition (uu, r, uv)) = r;

fun insertb A_ x xs = (if membera A_ xs x then xs else x :: xs);

fun union A_ = fold (insertb A_);

fun col a j = vec (dim_row a) (fn i => index_mat a (i, j));

fun row a i = vec (dim_col a) (fn j => index_mat a (i, j));

fun funpow n f =
  (if equal_nata n zero_nata then id else f o funpow (minus_nata n one_nata) f);

fun vala qd delta = plus_rata (qdfst qd) (times_rata delta (qdsnd qd));

fun rbt_del A_ x (Branch (c, a, y, s, b)) =
  (case compare (compare_compare_order A_) x y of Eq => combine a b
    | Lt => rbt_del_from_left A_ x a y s b
    | Gt => rbt_del_from_right A_ x a y s b)
  | rbt_del A_ x Emptya = Emptya
and rbt_del_from_left A_ x (Branch (B, lt, z, v, rt)) y s b =
  balance_left (rbt_del A_ x (Branch (B, lt, z, v, rt))) y s b
  | rbt_del_from_left A_ x Emptya y s b =
    Branch (R, rbt_del A_ x Emptya, y, s, b)
  | rbt_del_from_left A_ x (Branch (R, va, vb, vc, vd)) y s b =
    Branch (R, rbt_del A_ x (Branch (R, va, vb, vc, vd)), y, s, b)
and rbt_del_from_right A_ x a y s (Branch (B, lt, z, v, rt)) =
  balance_right a y s (rbt_del A_ x (Branch (B, lt, z, v, rt)))
  | rbt_del_from_right A_ x a y s Emptya =
    Branch (R, a, y, s, rbt_del A_ x Emptya)
  | rbt_del_from_right A_ x a y s (Branch (R, va, vb, vc, vd)) =
    Branch (R, a, y, s, rbt_del A_ x (Branch (R, va, vb, vc, vd)));

fun rbt_delete A_ k t = paint B (rbt_del A_ k t);

fun impl_of B_ (RBT x) = x;

fun delete A_ xb xc =
  RBT (rbt_delete A_ xb (impl_of (linorder_compare_order A_) xc));

fun rbt_ins A_ f k v (Branch (R, l, x, y, r)) =
  (case compare (compare_compare_order A_) k x
    of Eq => Branch (R, l, x, f k y v, r)
    | Lt => Branch (R, rbt_ins A_ f k v l, x, y, r)
    | Gt => Branch (R, l, x, y, rbt_ins A_ f k v r))
  | rbt_ins A_ f k v (Branch (B, l, x, y, r)) =
    (case compare (compare_compare_order A_) k x
      of Eq => Branch (B, l, x, f k y v, r)
      | Lt => balance (rbt_ins A_ f k v l) x y r
      | Gt => balance l x y (rbt_ins A_ f k v r))
  | rbt_ins A_ f k v Emptya = Branch (R, Emptya, k, v, Emptya);

fun rbt_insert_with_key A_ f k v t = paint B (rbt_ins A_ f k v t);

fun rbt_insert A_ = rbt_insert_with_key A_ (fn _ => fn _ => fn nv => nv);

fun insert A_ xc xd xe =
  RBT (rbt_insert A_ xc xd (impl_of (linorder_compare_order A_) xe));

fun rbt_lookupa A_ (Branch (uu, l, x, y, r)) k =
  (case compare (compare_compare_order A_) k x of Eq => SOME y
    | Lt => rbt_lookupa A_ l k | Gt => rbt_lookupa A_ r k)
  | rbt_lookupa A_ Emptya k = NONE;

fun lookup A_ x = rbt_lookupa A_ (impl_of (linorder_compare_order A_) x);

fun proja (Fun (f, ts)) i =
  (if less_nat i (size_list ts) then nth ts i else Fun (f, ts));

fun filter (A1_, A2_) p a = inf_seta (A1_, A2_) a (Collect_set p);

fun subst A_ x t = fun_upd A_ Var x t;

fun debug i t x = x;

fun guard p p1 p2 x = (if p x then p1 x else p2 x);

fun merge A_ qs ps = foldr (fn (a, b) => update A_ a b) ps qs;

fun cnj z = Complex (re z, uminus_reala (im z));

fun fset (Abs_fset x) = x;

fun fimage (B1_, B2_) (A1_, A2_, A3_) xb xc =
  Abs_fset (image (B1_, B2_) (A1_, A2_, A3_) xb (fset xc));

fun lterms pi =
  (fn Fun (f, ts) =>
    map (fn (i, a) => (proja (Fun (f, ts)) i, a)) (pi (f, size_list ts)));

fun lhs (l, r) = l;

fun rhs (l, r) = r;

fun ground (Var x) = false
  | ground (Fun (f, ts)) = list_all ground ts;

fun insert_vars_term B_ (Var x) xs = insertb B_ x xs
  | insert_vars_term B_ (Fun (f, ts)) xs = foldr (insert_vars_term B_) ts xs;

fun is_Var (Var x1) = true
  | is_Var (Fun (x21, x22)) = false;

fun wf_rule B_ r =
  not (is_Var (fst r)) andalso
    list_all (membera B_ (insert_vars_term B_ (fst r) []))
      (insert_vars_term B_ (snd r) []);

fun fun_of A_ vec x = the (map_of A_ vec x);

val letters : char list =
  [#"a", #"b", #"c", #"d", #"e", #"f", #"g", #"h", #"i", #"j", #"k", #"l", #"m",
    #"n", #"o", #"p", #"q", #"r", #"s", #"t", #"u", #"v", #"w", #"x", #"y",
    #"z", #"A", #"B", #"C", #"D", #"E", #"F", #"G", #"H", #"I", #"J", #"K",
    #"L", #"M", #"N", #"O", #"P", #"Q", #"R", #"S", #"T", #"U", #"V", #"W",
    #"X", #"Y", #"Z", #"_", #"0", #"1", #"2", #"3", #"4", #"5", #"6", #"7",
    #"8", #"9", #"&", #";", #":", #"-"];

fun list3elements [x, y, z] = SOME (x, (y, z))
  | list3elements [] = NONE
  | list3elements [v] = NONE
  | list3elements [v, vb] = NONE
  | list3elements (v :: vb :: vd :: vf :: vg) = NONE;

fun triple tag p1 p2 p3 f xml =
  (case xml
    of XML (name, atts, cs) =>
      (if equal_lista equal_char name tag andalso null atts
        then (case list3elements cs of NONE => fail tag xml
               | SOME (cs1, (cs2, cs3)) =>
                 binda (p1 cs1)
                   (fn a =>
                     binda (p2 cs2)
                       (fn b => binda (p3 cs3) (fn c => return (f a b c)))))
        else fail tag xml)
    | XML_text _ => fail tag xml);

fun list4elements [x, y, z, u] = SOME (x, (y, (z, u)))
  | list4elements [] = NONE
  | list4elements [v] = NONE
  | list4elements [v, vb] = NONE
  | list4elements [v, vb, vd] = NONE
  | list4elements (v :: vb :: vd :: vf :: vh :: vi) = NONE;

fun tuple4 tag p1 p2 p3 p4 f xml =
  (case xml
    of XML (name, atts, cs) =>
      (if equal_lista equal_char name tag andalso null atts
        then (case list4elements cs of NONE => fail tag xml
               | SOME (cs1, (cs2, (cs3, cs4))) =>
                 binda (p1 cs1)
                   (fn a =>
                     binda (p2 cs2)
                       (fn b =>
                         binda (p3 cs3)
                           (fn c =>
                             binda (p4 cs4) (fn d => return (f a b c d))))))
        else fail tag xml)
    | XML_text _ => fail tag xml);

fun hd A_ xa = hda (list_of_dlist A_ xa);

fun tl A_ xa = Abs_dlist (tla (list_of_dlist A_ xa));

fun foldli [] c f sigma = sigma
  | foldli (x :: xs) c f sigma =
    (if c sigma then foldli xs c f (f x sigma) else sigma);

fun scf_list scf xs =
  maps (fn (x, i) => replicate (scf i) x)
    (zip xs (upt zero_nata (size_list xs)));

fun scf_term scf (Var x) = Var x
  | scf_term scf (Fun (f, ts)) =
    Fun (f, scf_list (scf (f, size_list ts)) (map (scf_term scf) ts));

fun butlast [] = []
  | butlast (x :: xs) = (if null xs then [] else x :: butlast xs);

fun extract p (x :: xs) =
  (if p x then SOME ([], (x, xs))
    else (case extract p xs of NONE => NONE
           | SOME (ys, (y, zs)) => SOME (x :: ys, (y, zs))))
  | extract p [] = NONE;

fun productb A_ B_ dxs1 dxs2 =
  Abs_dlist
    (foldc A_ (fn a => foldc B_ (fn c => (fn b => (a, c) :: b)) dxs2) dxs1 []);

fun rbt_product f rbt1 rbt2 =
  rbtreeify
    (rev (folda
           (fn a => fn b =>
             folda (fn c => fn d => (fn e => ((a, c), f a b c d) :: e)) rbt2)
           rbt1 []));

fun productd A_ B_ xc xd xe =
  Mapping_RBTa (rbt_product xc (impl_ofb A_ xd) (impl_ofb B_ xe));

fun producta A_ B_ rbt1 rbt2 =
  productd A_ B_ (fn _ => fn _ => fn _ => fn _ => ()) rbt1 rbt2;

fun productc (A1_, A2_, A3_) (B1_, B2_, B3_) (RBT_set rbt1) (RBT_set rbt2) =
  (case ccompare A2_
    of NONE =>
      (raise Fail "product RBT_set RBT_set: ccompare1 = None")
        (fn _ =>
          productc (A1_, A2_, A3_) (B1_, B2_, B3_) (RBT_set rbt1)
            (RBT_set rbt2))
    | SOME _ =>
      (case ccompare B2_
        of NONE =>
          (raise Fail "product RBT_set RBT_set: ccompare2 = None")
            (fn _ =>
              productc (A1_, A2_, A3_) (B1_, B2_, B3_) (RBT_set rbt1)
                (RBT_set rbt2))
        | SOME _ => RBT_set (producta A2_ B2_ rbt1 rbt2)))
  | productc (A1_, A2_, A3_) (B1_, B2_, B3_) a2 (RBT_set rbt2) =
    (case ccompare B2_
      of NONE =>
        (raise Fail "product RBT_set: ccompare2 = None")
          (fn _ => productc (A1_, A2_, A3_) (B1_, B2_, B3_) a2 (RBT_set rbt2))
      | SOME _ =>
        foldb B2_
          (fn y =>
            sup_seta (ceq_prod A1_ B1_, ccompare_prod A2_ B2_)
              (image (A1_, A2_)
                (ceq_prod A1_ B1_, ccompare_prod A2_ B2_, set_impl_prod A3_ B3_)
                (fn x => (x, y)) a2))
          rbt2
          (bot_set
            (ceq_prod A1_ B1_, ccompare_prod A2_ B2_, set_impl_prod A3_ B3_)))
  | productc (A1_, A2_, A3_) (B1_, B2_, B3_) (RBT_set rbt1) b2 =
    (case ccompare A2_
      of NONE =>
        (raise Fail "product RBT_set: ccompare1 = None")
          (fn _ => productc (A1_, A2_, A3_) (B1_, B2_, B3_) (RBT_set rbt1) b2)
      | SOME _ =>
        foldb A2_
          (fn x =>
            sup_seta (ceq_prod A1_ B1_, ccompare_prod A2_ B2_)
              (image (B1_, B2_)
                (ceq_prod A1_ B1_, ccompare_prod A2_ B2_, set_impl_prod A3_ B3_)
                (fn a => (x, a)) b2))
          rbt1
          (bot_set
            (ceq_prod A1_ B1_, ccompare_prod A2_ B2_, set_impl_prod A3_ B3_)))
  | productc (A1_, A2_, A3_) (B1_, B2_, B3_) (DList_set dxs) (DList_set dys) =
    (case ceq A1_
      of NONE =>
        (raise Fail "product DList_set DList_set: ceq1 = None")
          (fn _ =>
            productc (A1_, A2_, A3_) (B1_, B2_, B3_) (DList_set dxs)
              (DList_set dys))
      | SOME _ =>
        (case ceq B1_
          of NONE =>
            (raise Fail "product DList_set DList_set: ceq2 = None")
              (fn _ =>
                productc (A1_, A2_, A3_) (B1_, B2_, B3_) (DList_set dxs)
                  (DList_set dys))
          | SOME _ => DList_set (productb A1_ B1_ dxs dys)))
  | productc (A1_, A2_, A3_) (B1_, B2_, B3_) a1 (DList_set dys) =
    (case ceq B1_
      of NONE =>
        (raise Fail "product DList_set2: ceq = None")
          (fn _ => productc (A1_, A2_, A3_) (B1_, B2_, B3_) a1 (DList_set dys))
      | SOME _ =>
        foldc B1_
          (fn y =>
            sup_seta (ceq_prod A1_ B1_, ccompare_prod A2_ B2_)
              (image (A1_, A2_)
                (ceq_prod A1_ B1_, ccompare_prod A2_ B2_, set_impl_prod A3_ B3_)
                (fn x => (x, y)) a1))
          dys (bot_set
                (ceq_prod A1_ B1_, ccompare_prod A2_ B2_,
                  set_impl_prod A3_ B3_)))
  | productc (A1_, A2_, A3_) (B1_, B2_, B3_) (DList_set dxs) b1 =
    (case ceq A1_
      of NONE =>
        (raise Fail "product DList_set1: ceq = None")
          (fn _ => productc (A1_, A2_, A3_) (B1_, B2_, B3_) (DList_set dxs) b1)
      | SOME _ =>
        foldc A1_
          (fn x =>
            sup_seta (ceq_prod A1_ B1_, ccompare_prod A2_ B2_)
              (image (B1_, B2_)
                (ceq_prod A1_ B1_, ccompare_prod A2_ B2_, set_impl_prod A3_ B3_)
                (fn a => (x, a)) b1))
          dxs (bot_set
                (ceq_prod A1_ B1_, ccompare_prod A2_ B2_,
                  set_impl_prod A3_ B3_)))
  | productc (A1_, A2_, A3_) (B1_, B2_, B3_) (Set_Monad xs) (Set_Monad ys) =
    Set_Monad (fold (fn x => fold (fn y => (fn a => (x, y) :: a)) ys) xs [])
  | productc (A1_, A2_, A3_) (B1_, B2_, B3_) a b =
    Collect_set
      (fn (x, y) => member (A1_, A2_) x a andalso member (B1_, B2_) y b);

fun set_Cons (A1_, A2_, A3_) a xs =
  image (ceq_prod A1_ (ceq_list A1_), ccompare_prod A2_ (ccompare_list A2_))
    (ceq_list A1_, ccompare_list A2_, set_impl_list) (fn (aa, b) => aa :: b)
    (productc (A1_, A2_, A3_) (ceq_list A1_, ccompare_list A2_, set_impl_list)
      (inf_seta (A1_, A2_) (image (A1_, A2_) (A1_, A2_, A3_) (fn x => x) a)
        (top_set (A1_, A2_, A3_)))
      (inf_seta (ceq_list A1_, ccompare_list A2_)
        (top_set (ceq_list A1_, ccompare_list A2_, set_impl_list))
        (image (ceq_list A1_, ccompare_list A2_)
          (ceq_list A1_, ccompare_list A2_, set_impl_list) (fn xsa => xsa)
          xs)));

fun listset (A1_, A2_, A3_) [] =
  inserta (ceq_list A1_, ccompare_list A2_) []
    (set_empty (ceq_list A1_, ccompare_list A2_) (of_phantom set_impl_lista))
  | listset (A1_, A2_, A3_) (a :: asa) =
    set_Cons (A1_, A2_, A3_) a (listset (A1_, A2_, A3_) asa);

fun remdups A_ [] = []
  | remdups A_ (x :: xs) =
    (if membera A_ xs x then remdups A_ xs else x :: remdups A_ xs);

fun l2m_lookup A_ B_ [] uu = NONE
  | l2m_lookup A_ B_ ((a, kvs) :: reca) (k1, k2) =
    (case eq A_ k1 a of true => map_of B_ kvs k2
      | false => l2m_lookup A_ B_ reca (k1, k2));

fun lm_store_acc A_ [] kv accu = kv :: accu
  | lm_store_acc A_ ((a, uu) :: reca) (k, v) accu =
    (case eq A_ k a of true => accu
      | false => lm_store_acc A_ reca (k, v) accu);

fun lm_store A_ m kv = lm_store_acc A_ m kv m;

fun l2m_store A_ B_ [] ((k1, k2), v) = [(k1, [(k2, v)])]
  | l2m_store A_ B_ ((a, kvs) :: reca) ((k1, k2), v) =
    (case eq A_ k1 a of true => (a, lm_store B_ kvs (k2, v)) :: reca
      | false => (a, kvs) :: l2m_store A_ B_ reca ((k1, k2), v));

fun l2m A_ B_ =
  Memory_ext ((fn _ => []), l2m_lookup A_ B_, l2m_store A_ B_, ());

fun aux A_ B_ key ma v m =
  (case key v of NONE => m
    | SOME k =>
      (case lookup B_ ma k of NONE => m
        | SOME ws =>
          (if membera A_ ws v
            then (case lookup B_ m k of NONE => insert B_ k [v] m
                   | SOME vs => insert B_ k (insertb A_ v vs) m)
            else m)));

fun poly_rat x =
  let
    val (n, d) = quotient_of x;
  in
    pCons (zero_int, equal_int) (uminus_inta n)
      (pCons (zero_int, equal_int) d (zero_polyb zero_int))
  end;

fun of_rat_1 x = (poly_rat x, (x, x));

fun real_alg_1 (Rationala r) = of_rat_1 r
  | real_alg_1 (Irrational (n, rai)) = rai;

fun root_rat_floor p x =
  let
    val (a, b) = quotient_of x;
  in
    divide_inta
      (root_int_floor p
        (times_inta a (binary_power monoid_mult_int b (minus_nata p one_nata))))
      b
  end;

fun root_rat_ceiling p x = uminus_inta (root_rat_floor p (uminus_rata x));

fun initial_upper_bound n r = of_int (root_rat_ceiling n r);

fun initial_lower_bound n l =
  (if less_eq_rat l one_rata then l else of_int (root_rat_floor n l));

fun tighten_bound_root n cmpx (l, r) =
  let
    val m =
      divide_rata (plus_rata l r) (of_int (Int_of_integer (2 : IntInf.int)));
    val ma = binary_power monoid_mult_rat m n;
  in
    (case cmpx ma of Eq => (m, m) | Lt => (m, r) | Gt => (l, m))
  end;

fun poly_nth_root (A1_, A2_) n p =
  pcompose
    (A1_, (comm_semiring_0_comm_semiring_1 o
            comm_semiring_1_comm_semiring_1_cancel o
            comm_semiring_1_cancel_semidom o semidom_idom)
            A2_,
      (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
        semiring_1_no_zero_divisors_semidom o semidom_idom)
        A2_)
    p (monom
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_semidom o semidom_idom)
           A2_,
          A1_)
        (onea ((one_numeral o numeral_neg_numeral o neg_numeral_ring_1 o
                 ring_1_comm_ring_1 o comm_ring_1_idom)
                A2_))
        n);

fun compare_1_rat rai =
  let
    val p = poly_real_alg_1 rai;
  in
    (if equal_nata (degreea zero_int p) one_nata
      then let
             val x =
               fract (uminus_inta
                       (case coeffs zero_int p of [] => zero_inta
                         | x :: _ => x))
                 (coeff zero_int p one_nata);
           in
             (fn y => compare_rata y x)
           end
      else (fn y => compare_rat_1 y rai))
  end;

fun root_pos_1 n (p, (l, r)) =
  select_correct_factor_int_poly
    (tighten_bound_root n (compare_1_rat (p, (l, r)))) (fn x => x)
    (initial_lower_bound n l, initial_upper_bound n r)
    (poly_nth_root (equal_int, idom_int) n p);

fun root_1 n (p, (l, r)) =
  (if equal_nata n zero_nata orelse equal_rata r zero_rata
    then Rationala zero_rata
    else (if less_rat zero_rata r then root_pos_1 n (p, (l, r))
           else uminus_2 (root_pos_1 n (uminus_1 (p, (l, r))))));

fun root_2 n x = root_1 n (real_alg_1 x);

fun root_3 xb xc = Real_Alg_Invariant (root_2 xb (rep_real_alg_3 xc));

fun root_real_alg xa (Real_Alg_Quotient x) = Real_Alg_Quotient (root_3 xa x);

fun roota n (Real_of x) = Real_of (root_real_alg n x);

fun sqrt x = roota (nat_of_integer (2 : IntInf.int)) x;

fun these (A1_, A2_, A3_) a =
  image (ceq_option A1_, ccompare_option A2_) (A1_, A2_, A3_) the
    (filter (ceq_option A1_, ccompare_option A2_) (fn x => not (is_none x)) a);

fun reva Empty = Empty
  | reva (PCons (i, p)) = append (reva p) (PCons (i, Empty));

fun key (uu, (Fun (f, ts), uv)) = SOME (f, size_list ts)
  | key (uw, (Var ux, uy)) = NONE;

fun gelb A_ lt c b =
  (case b of NONE => true | SOME ba => lt ba c orelse eq A_ ba c);

fun geub A_ lt c b =
  (case b of NONE => false | SOME ba => lt ba c orelse eq A_ ba c);

fun gtlb lt c b = (case b of NONE => true | SOME ba => lt ba c);

fun leub A_ lt c b =
  (case b of NONE => true | SOME ba => lt c ba orelse eq A_ c ba);

fun ltlb lt c b = (case b of NONE => false | SOME a => lt c a);

fun ltub lt c b = (case b of NONE => true | SOME a => lt c a);

fun poly (LEQ_ns (p, a)) = p
  | poly (GEQ_ns (p, a)) = p;

fun subt_at s Empty = s
  | subt_at (Fun (f, ss)) (PCons (i, p)) = subt_at (nth ss i) p;

fun comp_fun_idem_apply (Abs_comp_fun_idem x) = x;

fun set_fold_cfi (A1_, A2_) f b (RBT_set rbt) =
  (case ccompare A2_
    of NONE =>
      (raise Fail "set_fold_cfi RBT_set: ccompare = None")
        (fn _ => set_fold_cfi (A1_, A2_) f b (RBT_set rbt))
    | SOME _ => foldb A2_ (comp_fun_idem_apply f) rbt b)
  | set_fold_cfi (A1_, A2_) f b (DList_set dxs) =
    (case ceq A1_
      of NONE =>
        (raise Fail "set_fold_cfi DList_set: ceq = None")
          (fn _ => set_fold_cfi (A1_, A2_) f b (DList_set dxs))
      | SOME _ => foldc A1_ (comp_fun_idem_apply f) dxs b)
  | set_fold_cfi (A1_, A2_) f b (Set_Monad xs) =
    fold (comp_fun_idem_apply f) xs b
  | set_fold_cfi (A1_, A2_) f b (Collect_set p) =
    (raise Fail "set_fold_cfi not supported on Collect_set")
      (fn _ => set_fold_cfi (A1_, A2_) f b (Collect_set p))
  | set_fold_cfi (A1_, A2_) f b (Complement a) =
    (raise Fail "set_fold_cfi not supported on Complement")
      (fn _ => set_fold_cfi (A1_, A2_) f b (Complement a));

fun sup_cfi A_ =
  Abs_comp_fun_idem
    (sup ((sup_quasi_order_sup o quasi_order_sup_quasi_semilattice_sup o
            quasi_semilattice_sup_semilattice_sup o semilattice_sup_lattice)
           A_));

fun sup_setb (A1_, A2_, A3_, A4_, A5_) a =
  (if finite
        (finite_UNIV_set A1_, ceq_set (A2_, A3_, ccompare_cproper_interval A4_),
          ccompare_set (A1_, A3_, A4_, A5_))
        a
    then set_fold_cfi
           (ceq_set (A2_, A3_, ccompare_cproper_interval A4_),
             ccompare_set (A1_, A3_, A4_, A5_))
           (sup_cfi (lattice_set (A2_, A3_, ccompare_cproper_interval A4_)))
           (bot_set (A3_, ccompare_cproper_interval A4_, A5_)) a
    else (raise Fail "Sup: infinite")
           (fn _ => sup_setb (A1_, A2_, A3_, A4_, A5_) a));

fun varposs (Var x) =
  inserta (ceq_pos, ccompare_pos) Empty
    (set_empty (ceq_pos, ccompare_pos) (of_phantom set_impl_posa))
  | varposs (Fun (f, ts)) =
    sup_setb
      (finite_UNIV_pos, cenum_pos, ceq_pos, cproper_interval_pos, set_impl_pos)
      (image (ceq_nat, ccompare_nat)
        (ceq_set
           (cenum_pos, ceq_pos, ccompare_cproper_interval cproper_interval_pos),
          ccompare_set
            (finite_UNIV_pos, ceq_pos, cproper_interval_pos, set_impl_pos),
          set_impl_set)
        (fn i =>
          image (ceq_pos, ccompare_pos) (ceq_pos, ccompare_pos, set_impl_pos)
            (fn a => PCons (i, a)) (varposs (nth ts i)))
        (set (ceq_nat, ccompare_nat, set_impl_nat)
          (upt zero_nata (size_list ts))));

fun vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) (Var x1) =
  inserta (B3_, ccompare_cproper_interval B4_) x1
    (bot_set (B3_, ccompare_cproper_interval B4_, B7_))
  | vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) (Fun (x21, x22)) =
    sup_setb (B1_, B2_, B3_, B4_, B7_)
      (image (ceq_term A2_ B6_, ccompare_term A1_ B5_)
        (ceq_set (B2_, B3_, ccompare_cproper_interval B4_),
          ccompare_set (B1_, B3_, B4_, B7_), set_impl_set)
        (vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_))
        (set (ceq_term A2_ B6_, ccompare_term A1_ B5_, set_impl_term) x22));

fun vars_rule (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) r =
  sup_seta (B3_, ccompare_cproper_interval B4_)
    (vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) (fst r))
    (vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) (snd r));

fun vars_trs (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) r =
  sup_setb (B1_, B2_, B3_, B4_, B7_)
    (image
      (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_),
        ccompare_prod (ccompare_term A1_ B5_) (ccompare_term A1_ B5_))
      (ceq_set (B2_, B3_, ccompare_cproper_interval B4_),
        ccompare_set (B1_, B3_, B4_, B7_), set_impl_set)
      (vars_rule (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_)) r);

fun xml_error D_ str x =
  let
    val (xmls, (_, (_, (_, pos)))) = x;
    val next =
      (case xmls of [] => [#"t", #"a", #"g", #" ", #"c", #"l", #"o", #"s", #"e"]
        | XML (tag, _, _) :: _ => [#"<"] @ tag @ [#">"]
        | XML_text stra :: _ =>
          [#"t", #"e", #"x", #"t", #" ", #"e", #"l", #"e", #"m", #"e", #"n",
            #"t", #" ", #"\""] @
            stra @ [#"\""]);
  in
    Inl (Fatal
          ([#"p", #"a", #"r", #"s", #"e", #" ", #"e", #"r", #"r", #"o", #"r",
             #" ", #"o", #"n", #" "] @
            next @
              [#" ", #"a", #"t", #" "] @
                shows_prec D_ zero_nata pos [] @ [#":", #"\n"] @ str))
  end;

fun mismatch B_ tag x =
  (case x of (_, (_, (true, (cands, _)))) => Inl (TagMismatch (tag :: cands))
    | (_, (_, (false, (cands, _)))) =>
      xml_error B_
        ([#"e", #"x", #"p", #"e", #"c", #"t", #"i", #"n", #"g", #" "] @
          shows_prec_list (show_list show_char) zero_nata (tag :: cands) [])
        x);

fun xml_do tag p x =
  (case x
    of (XML (nam, atts, xmls), (_, (_, (_, pos)))) =>
      (if equal_lista equal_char nam tag
        then p (xmls, (atts, (false, ([], tag :: pos))))
        else mismatch (show_list (show_list show_char)) tag ([fst x], snd x))
    | (XML_text _, _) =>
      mismatch (show_list (show_list show_char)) tag ([fst x], snd x));

fun xml_or p1 p2 x =
  let
    val (x1, (atts, (flag, (cands, rest)))) = x;
  in
    (case p1 (x1, (atts, (true, (cands, rest))))
      of Inl a =>
        (case a of TagMismatch cands1 => p2 (x1, (atts, (flag, (cands1, rest))))
          | Fatal aa => Inl (Fatal aa))
      | Inr a => Inr a)
  end;

fun norm_complex z =
  sqrt (plus_reala
         (binary_power monoid_mult_real (re z)
           (nat_of_integer (2 : IntInf.int)))
         (binary_power monoid_mult_real (im z)
           (nat_of_integer (2 : IntInf.int))));

fun csqrt z =
  Complex
    (sqrt (divide_reala (plus_reala (norm_complex z) (re z))
            (ratreal (of_int (Int_of_integer (2 : IntInf.int))))),
      times_reala
        (if equal_reala (im z) zero_reala then one_reala else sgn_reala (im z))
        (sqrt (divide_reala (minus_reala (norm_complex z) (re z))
                (ratreal (of_int (Int_of_integer (2 : IntInf.int)))))));

fun or_ok (Inl a) b = b
  | or_ok (Inr a) b = Inr a;

fun distinct A_ [] = true
  | distinct A_ (x :: xs) = not (membera A_ xs x) andalso distinct A_ xs;

fun add_mset A_ x (Bag xs) =
  Bag (joina A_ (fn _ => fn (a, b) => plus_nata a b)
        (updatea A_ x one_nata emptya) xs);

fun mset A_ (a :: x) = add_mset A_ a (mset A_ x)
  | mset A_ [] = zero_multiseta;

fun add
  (Partial_object_ext
    (carrier, Monoid_ext (mult, one, Ring_ext (zero, add, more))))
  = add;

fun shows_nl x = shows_prec_char zero_nata #"\n" x;

fun lvars t = set (ceq_nat, ccompare_nat, set_impl_nat) (map lhs t);

fun linear_poly_map (LinearPoly x) = x;

fun fmmap f (Fmap_of_list m) = Fmap_of_list (map (apsnd f) m);

val fmempty : ('a, 'b) fmap = Fmap_of_list [];

fun scale r lp =
  (if equal_rata r zero_rata then fmempty else fmmap (times_rata r) lp);

fun scaleRat_linear_poly r p = LinearPoly (scale r (linear_poly_map p));

fun uminus_linear_poly lp = scaleRat_linear_poly (uminus_rata one_rata) lp;

fun fmlookup A_ (Fmap_of_list m) = map_of A_ m;

fun get_var_coeff lp v =
  (case fmlookup equal_nat lp v of NONE => zero_rata | SOME c => c);

fun sorted_list_of_set (A1_, A2_, A3_, A4_) (RBT_set rbt) =
  (case ccompare A2_
    of NONE =>
      (raise Fail "sorted_list_of_set RBT_set: ccompare = None")
        (fn _ => sorted_list_of_set (A1_, A2_, A3_, A4_) (RBT_set rbt))
    | SOME _ => sort_key A4_ (fn x => x) (keysa A2_ rbt))
  | sorted_list_of_set (A1_, A2_, A3_, A4_) (DList_set dxs) =
    (case ceq A1_
      of NONE =>
        (raise Fail "sorted_list_of_set DList_set: ceq = None")
          (fn _ => sorted_list_of_set (A1_, A2_, A3_, A4_) (DList_set dxs))
      | SOME _ => sort_key A4_ (fn x => x) (list_of_dlist A1_ dxs))
  | sorted_list_of_set (A1_, A2_, A3_, A4_) (Set_Monad xs) =
    sort_key A4_ (fn x => x) (remdups A3_ xs);

fun fset_of_list (A1_, A2_, A3_) xa = Abs_fset (set (A1_, A2_, A3_) xa);

fun fmdom (A1_, A2_, A3_) (B1_, B2_, B3_) (Fmap_of_list m) =
  fimage (ceq_prod A1_ B1_, ccompare_prod A2_ B2_) (A1_, A2_, A3_) fst
    (fset_of_list
      (ceq_prod A1_ B1_, ccompare_prod A2_ B2_, set_impl_prod A3_ B3_) m);

fun ordered_keys (A1_, A2_, A3_, A4_, A5_) (B1_, B2_, B3_) m =
  sorted_list_of_set (A1_, A2_, A3_, A4_)
    (fset (fmdom (A1_, A2_, A5_) (B1_, B2_, B3_) m));

fun fmfilter p (Fmap_of_list m) = Fmap_of_list (filtera (fn (k, _) => p k) m);

fun fmdrop A_ a = fmfilter (fn aa => not (eq A_ aa a));

fun fmadd A_ (Fmap_of_list m) (Fmap_of_list n) = Fmap_of_list (merge A_ m n);

fun fmupd A_ k v m = fmadd A_ m (Fmap_of_list [(k, v)]);

fun set_var_coeff v c lp =
  (if equal_rata c zero_rata then fmdrop equal_nat v lp
    else fmupd equal_nat v c lp);

fun add_monom c v lp = set_var_coeff v (plus_rata c (get_var_coeff lp v)) lp;

fun adda lp1 lp2 =
  foldl (fn lp => fn v => add_monom (get_var_coeff lp1 v) v lp) lp2
    (ordered_keys (ceq_nat, ccompare_nat, equal_nat, linorder_nat, set_impl_nat)
      (ceq_rat, ccompare_rat, set_impl_rat) lp1);

fun plus_linear_poly p1 p2 =
  LinearPoly (adda (linear_poly_map p1) (linear_poly_map p2));

fun minus_linear_poly lp1 lp2 = plus_linear_poly lp1 (uminus_linear_poly lp2);

fun constraint_to_qdelta_constraint (LTa (l, r)) =
  [LEQ_ns (l, QDelta (r, uminus_rata one_rata))]
  | constraint_to_qdelta_constraint (GTa (l, r)) =
    [GEQ_ns (l, QDelta (r, one_rata))]
  | constraint_to_qdelta_constraint (LEQ (l, r)) =
    [LEQ_ns (l, QDelta (r, zero_rata))]
  | constraint_to_qdelta_constraint (GEQ (l, r)) =
    [GEQ_ns (l, QDelta (r, zero_rata))]
  | constraint_to_qdelta_constraint (EQa (l, r)) =
    [LEQ_ns (l, QDelta (r, zero_rata)), GEQ_ns (l, QDelta (r, zero_rata))]
  | constraint_to_qdelta_constraint (LTPP (l1, l2)) =
    [LEQ_ns (minus_linear_poly l1 l2, QDelta (zero_rata, uminus_rata one_rata))]
  | constraint_to_qdelta_constraint (GTPP (l1, l2)) =
    [GEQ_ns (minus_linear_poly l1 l2, QDelta (zero_rata, one_rata))]
  | constraint_to_qdelta_constraint (LEQPP (l1, l2)) =
    [LEQ_ns (minus_linear_poly l1 l2, zero_QDeltaa)]
  | constraint_to_qdelta_constraint (GEQPP (l1, l2)) =
    [GEQ_ns (minus_linear_poly l1 l2, zero_QDeltaa)]
  | constraint_to_qdelta_constraint (EQPP (l1, l2)) =
    [LEQ_ns (minus_linear_poly l1 l2, zero_QDeltaa),
      GEQ_ns (minus_linear_poly l1 l2, zero_QDeltaa)];

fun to_ns l = maps constraint_to_qdelta_constraint l;

fun hole_pos Hole = Empty
  | hole_pos (More (f, ss, d, ts)) = PCons (size_list ss, hole_pos d);

fun mk_subst A_ d xts =
  (fn x => (case map_of A_ xts x of NONE => d x | SOME t => t));

fun funas_term (A1_, A2_, A3_) (Var uu) =
  bot_set
    (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat,
      set_impl_prod A3_ set_impl_nat)
  | funas_term (A1_, A2_, A3_) (Fun (f, ts)) =
    sup_seta (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat)
      (inserta (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat)
        (f, size_list ts)
        (bot_set
          (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat,
            set_impl_prod A3_ set_impl_nat)))
      (foldr
        (sup_seta (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat) o
          funas_term (A1_, A2_, A3_))
        ts (bot_set
             (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat,
               set_impl_prod A3_ set_impl_nat)));

fun funas_rule (A1_, A2_, A3_) r =
  sup_seta (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat)
    (funas_term (A1_, A2_, A3_) (fst r)) (funas_term (A1_, A2_, A3_) (snd r));

fun funas_trs (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_) r =
  sup_setb
    (finite_UNIV_prod A1_ finite_UNIV_nat, cenum_prod A2_ cenum_nat,
      ceq_prod A3_ ceq_nat, cproper_interval_prod A4_ cproper_interval_nat,
      set_impl_prod A7_ set_impl_nat)
    (image
      (ceq_prod (ceq_term A6_ B2_) (ceq_term A6_ B2_),
        ccompare_prod (ccompare_term A5_ B1_) (ccompare_term A5_ B1_))
      (ceq_set
         (cenum_prod A2_ cenum_nat, ceq_prod A3_ ceq_nat,
           ccompare_cproper_interval
             (cproper_interval_prod A4_ cproper_interval_nat)),
        ccompare_set
          (finite_UNIV_prod A1_ finite_UNIV_nat, ceq_prod A3_ ceq_nat,
            cproper_interval_prod A4_ cproper_interval_nat,
            set_impl_prod A7_ set_impl_nat),
        set_impl_set)
      (funas_rule (A3_, ccompare_cproper_interval A4_, A7_)) r);

fun unapp A_ a (Var x) = (Var x, [])
  | unapp A_ a (Fun (f, ss)) =
    (if eq A_ f a andalso
          equal_nata (size_list ss) (nat_of_integer (2 : IntInf.int))
      then let
             val (r, ts) = unapp A_ a (nth ss zero_nata);
           in
             (r, ts @ [nth ss one_nata])
           end
      else (Fun (f, ss), []));

fun is_letter c =
  ((#"a" : char) <= c) andalso ((c : char) <= #"z") orelse
    (((#"A" : char) <= c) andalso ((c : char) <= #"Z") orelse
      (((#"0" : char) <= c) andalso ((c : char) <= #"9") orelse
        membera equal_char [#"_", #"&", #";", #":", #"-"] c));

fun update_tokens f ts = Inr (ts, f ts);

fun remove_comments_aux_acc a false (c :: cs) =
  (if ((c : char) = #"<") andalso
        equal_lista equal_char (take (nat_of_integer (3 : IntInf.int)) cs)
          [#"!", #"-", #"-"]
    then remove_comments_aux_acc a true (tla cs)
    else remove_comments_aux_acc (c :: a) false cs)
  | remove_comments_aux_acc a true (c :: cs) =
    (if ((c : char) = #"-") andalso
          equal_lista equal_char (take (nat_of_integer (2 : IntInf.int)) cs)
            [#"-", #">"]
      then remove_comments_aux_acc a false
             (drop (nat_of_integer (2 : IntInf.int)) cs)
      else remove_comments_aux_acc a true cs)
  | remove_comments_aux_acc a uu [] = a;

fun remove_comments_aux false (c :: cs) =
  (if ((c : char) = #"<") andalso
        equal_lista equal_char (take (nat_of_integer (3 : IntInf.int)) cs)
          [#"!", #"-", #"-"]
    then remove_comments_aux true (tla cs)
    else c :: remove_comments_aux false cs)
  | remove_comments_aux true (c :: cs) =
    (if ((c : char) = #"-") andalso
          equal_lista equal_char (take (nat_of_integer (2 : IntInf.int)) cs)
            [#"-", #">"]
      then remove_comments_aux false (drop (nat_of_integer (2 : IntInf.int)) cs)
      else remove_comments_aux true cs)
  | remove_comments_aux uu [] = [];

fun remove_comments x =
  (if false then rev o remove_comments_aux_acc [] false
    else remove_comments_aux false)
    x;

fun returna x = (fn ts => Inr (x, ts));

fun bindb m f = (case m of Inl a => Inl a | Inr a => f a);

fun bindc m f ts = bindb (m ts) (fn (a, b) => f a b);

fun shows_quote s =
  shows_prec_char zero_nata #"'" o s o shows_prec_char zero_nata #"'";

fun scan_upto enda (t :: ts) =
  (if equal_lista equal_char (map snd (zip enda (t :: ts))) enda
    then Inr (enda, drop (size_list enda) (t :: ts))
    else bindb (scan_upto enda ts) (fn (res, tsa) => Inr (t :: res, tsa)))
  | scan_upto enda [] =
    Inl ([#"d", #"i", #"d", #" ", #"n", #"o", #"t", #" ", #"f", #"i", #"n",
           #"d", #" ", #"e", #"n", #"d", #"-", #"m", #"a", #"r", #"k", #"e",
           #"r", #" "] @
          shows_quote (shows_prec_list show_char zero_nata enda) []);

fun trim x = dropWhile (membera equal_char [#" ", #"\n", #"\t", #"\r"]) x;

fun manya p (t :: ts) =
  (if p t then bindb (manya p ts) (fn (rs, tsa) => Inr (t :: rs, tsa))
    else Inr ([], t :: ts))
  | manya p [] = Inr ([], []);

fun parse_header ts =
  (if equal_lista equal_char (take (nat_of_integer (2 : IntInf.int)) (trim ts))
        [#"<", #"?"]
    then bindc (scan_upto [#"?", #">"])
           (fn h => bindc parse_header (fn hs => returna (h :: hs))) ts
    else bindc (bindc (manya (membera equal_char [#" ", #"\n", #"\t", #"\r"]))
                 (fn _ => returna ()))
           (fn _ => returna []) ts);

fun err_expecting A_ msg ts =
  Inl ([#"e", #"x", #"p", #"e", #"c", #"t", #"i", #"n", #"g", #" "] @
        msg @ [#",", #" ", #"b", #"u", #"t", #" ", #"f", #"o", #"u", #"n", #"d",
                #":", #" "] @
                shows_quote
                  (shows_prec_list A_ zero_nata
                    (take (nat_of_integer (30 : IntInf.int)) ts))
                  []);

fun eoi A_ [] = Inr ((), [])
  | eoi A_ (v :: va) =
    err_expecting A_
      [#"e", #"n", #"d", #" ", #"o", #"f", #" ", #"i", #"n", #"p", #"u", #"t"]
      (v :: va);

fun exactly_aux s i (x :: xs) (y :: ys) =
  (if ((x : char) = y) then exactly_aux s i xs ys
    else err_expecting show_char ([#"\""] @ s @ [#"\""]) i)
  | exactly_aux s i [] xs = Inr (s, trim xs)
  | exactly_aux s i (x :: xs) [] =
    err_expecting show_char ([#"\""] @ s @ [#"\""]) i;

fun exactly s x = exactly_aux s x s x;

fun parse_attribute_value x =
  bindc (exactly [#"\""])
    (fn _ =>
      bindc (manya (fn y => not ((#"\"" : char) = y)))
        (fn v => bindc (exactly [#"\""]) (fn _ => returna v)))
    x;

fun errora e = (fn _ => Inl e);

fun parse_name s =
  bindc (manya is_letter)
    (fn n =>
      bindc (bindc (manya (membera equal_char [#" ", #"\n", #"\t", #"\r"]))
              (fn _ => returna ()))
        (fn _ =>
          (if null n
            then errora
                   ([#"e", #"x", #"p", #"e", #"c", #"t", #"e", #"d", #" ", #"l",
                      #"e", #"t", #"t", #"e", #"r", #" "] @
                     letters @
                       [#" ", #"b", #"u", #"t", #" ", #"f", #"i", #"r", #"s",
                         #"t", #" ", #"s", #"y", #"m", #"b", #"o", #"l", #" ",
                         #"i", #"s", #" ", #"\""] @
                         take one_nata s @ [#"\""])
            else returna n)))
    s;

fun parse_attributes [] = Inr ([], [])
  | parse_attributes (c :: s) =
    (if membera equal_char [#"/", #">"] c then Inr ([], c :: s)
      else bindc parse_name
             (fn k =>
               bindc (exactly [#"="])
                 (fn _ =>
                   bindc parse_attribute_value
                     (fn v =>
                       bindc parse_attributes
                         (fn atts => returna ((k, v) :: atts)))))
             (c :: s));

fun oneof_closed (x :: xs) =
  (if ((x : char) = #">") then Inr ([#">"], trim xs)
    else (if ((x : char) = #"/") andalso
               (case xs of [] => false | y :: _ => ((y : char) = #">"))
           then Inr ([#"/", #">"], trim (tla xs))
           else err_expecting show_char
                  [#"o", #"n", #"e", #" ", #"o", #"f", #" ", #"[", #"/", #">",
                    #",", #" ", #">", #"]"]
                  (x :: xs)))
  | oneof_closed [] =
    err_expecting show_char
      [#"o", #"n", #"e", #" ", #"o", #"f", #" ", #"[", #"/", #">", #",", #" ",
        #">", #"]"]
      [];

fun parse_text x =
  bindc (manya (fn y => not ((#"<" : char) = y)))
    (fn ts =>
      let
        val text = trim ts;
      in
        (if null text then returna NONE
          else returna (SOME (rev (trim (rev text)))))
      end)
    x;

fun parse_nodes ts =
  (if null ts orelse
        equal_lista equal_char (take (nat_of_integer (2 : IntInf.int)) ts)
          [#"<", #"/"]
    then returna [] ts
    else (if not (((hda ts) : char) = #"<")
           then bindc parse_text
                  (fn t =>
                    bindc parse_nodes
                      (fn ns => returna (XML_text (the t) :: ns)))
                  ts
           else bindc (exactly [#"<"])
                  (fn _ =>
                    bindc parse_name
                      (fn n =>
                        bindc parse_attributes
                          (fn atts =>
                            bindc oneof_closed
                              (fn e =>
                                (if equal_lista equal_char e [#"/", #">"]
                                  then bindc parse_nodes
 (fn cs => returna (XML (n, atts, []) :: cs))
                                  else bindc parse_nodes
 (fn cs =>
   bindc (exactly [#"<", #"/"])
     (fn _ =>
       bindc (exactly n)
         (fn _ =>
           bindc (exactly [#">"])
             (fn _ =>
               bindc parse_nodes
                 (fn ns => returna (XML (n, atts, cs) :: ns)))))))))))
                  ts));

fun parse_node x =
  bindc (exactly [#"<"])
    (fn _ =>
      bindc parse_name
        (fn n =>
          bindc parse_attributes
            (fn atts =>
              bindc oneof_closed
                (fn e =>
                  (if equal_lista equal_char e [#"/", #">"]
                    then returna (XML (n, atts, []))
                    else bindc parse_nodes
                           (fn cs =>
                             bindc (exactly [#"<", #"/"])
                               (fn _ =>
                                 bindc (exactly n)
                                   (fn _ =>
                                     bindc (exactly [#">"])
                                       (fn _ =>
 returna (XML (n, atts, cs)))))))))))
    x;

fun parse_doc x =
  bindc (update_tokens remove_comments)
    (fn _ =>
      bindc parse_header
        (fn h =>
          bindc parse_node
            (fn xml =>
              bindc (eoi show_char) (fn _ => returna (XMLDOC (h, xml))))))
    x;

fun pick_up A_ rest key [] = NONE
  | pick_up A_ rest key ((l, r) :: s) =
    (if eq A_ key l then SOME (r, rest @ s)
      else pick_up A_ ((l, r) :: rest) key s);

fun nat_of_digit x =
  (if ((x : char) = #"0") then SOME zero_nata
    else (if ((x : char) = #"1") then SOME one_nata
           else (if ((x : char) = #"2")
                  then SOME (nat_of_integer (2 : IntInf.int))
                  else (if ((x : char) = #"3")
                         then SOME (nat_of_integer (3 : IntInf.int))
                         else (if ((x : char) = #"4")
                                then SOME (nat_of_integer (4 : IntInf.int))
                                else (if ((x : char) = #"5")
                                       then SOME
      (nat_of_integer (5 : IntInf.int))
                                       else (if ((x : char) = #"6")
      then SOME (nat_of_integer (6 : IntInf.int))
      else (if ((x : char) = #"7") then SOME (nat_of_integer (7 : IntInf.int))
             else (if ((x : char) = #"8")
                    then SOME (nat_of_integer (8 : IntInf.int))
                    else (if ((x : char) = #"9")
                           then SOME (nat_of_integer (9 : IntInf.int))
                           else NONE))))))))));

fun nat_of_string_aux n [] = SOME n
  | nat_of_string_aux n (d :: s) =
    bind (nat_of_digit d)
      (fn m =>
        nat_of_string_aux
          (plus_nata (times_nata (nat_of_integer (10 : IntInf.int)) n) m) s);

fun nat_of_string s =
  (case (if null s then NONE else nat_of_string_aux zero_nata s)
    of NONE =>
      Inl ([#"c", #"a", #"n", #"n", #"o", #"t", #" ", #"c", #"o", #"n", #"v",
             #"e", #"r", #"t", #" ", #"\""] @
            s @ [#"\"", #" ", #"t", #"o", #" ", #"a", #" ", #"n", #"u", #"m",
                  #"b", #"e", #"r"])
    | SOME a => Inr a);

fun safe_head [] = NONE
  | safe_head (x :: xs) = SOME x;

fun int_of_stringa s =
  (if equal_optiona equal_char (safe_head s) (SOME #"-")
    then bindb (nat_of_string (tla s))
           (fn n => Inr (uminus_inta (int_of_nat n)))
    else bindb (nat_of_string s) (fn n => Inr (int_of_nat n)));

fun xml_take_int p xs =
  (case xs
    of ([], _) =>
      xml_error (show_list (show_list show_char))
        [#"e", #"x", #"p", #"e", #"c", #"t", #"i", #"n", #"g", #" ", #"a", #"n",
          #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r"]
        xs
    | (XML (_, _, _) :: _, _) =>
      xml_error (show_list (show_list show_char))
        [#"e", #"x", #"p", #"e", #"c", #"t", #"i", #"n", #"g", #" ", #"a", #"n",
          #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r"]
        xs
    | (XML_text text :: xmls, s) =>
      (case int_of_stringa text
        of Inl x => xml_error (show_list (show_list show_char)) x xs
        | Inr n => p n (xmls, s)));

fun xml_return v x =
  (case x of ([], _) => Inr v
    | (_ :: _, _) =>
      xml_error (show_list (show_list show_char))
        [#"e", #"x", #"p", #"e", #"c", #"t", #"i", #"n", #"g", #" ", #"t", #"a",
          #"g", #" ", #"c", #"l", #"o", #"s", #"e"]
        x);

fun xml_int tag = xml_do tag (xml_take_int xml_return);

fun xml_take_nat p xs =
  (case xs
    of ([], _) =>
      xml_error (show_list (show_list show_char))
        [#"e", #"x", #"p", #"e", #"c", #"t", #"i", #"n", #"g", #" ", #"a", #" ",
          #"n", #"u", #"m", #"b", #"e", #"r"]
        xs
    | (XML (_, _, _) :: _, _) =>
      xml_error (show_list (show_list show_char))
        [#"e", #"x", #"p", #"e", #"c", #"t", #"i", #"n", #"g", #" ", #"a", #" ",
          #"n", #"u", #"m", #"b", #"e", #"r"]
        xs
    | (XML_text text :: xmls, s) =>
      (case nat_of_string text
        of Inl x => xml_error (show_list (show_list show_char)) x xs
        | Inr n => p n (xmls, s)));

fun xml_nat tag = xml_do tag (xml_take_nat xml_return);

val zero_enat : enat = Enat zero_nata;

fun minus_enat (Enat a) Infinity_enat = zero_enat
  | minus_enat Infinity_enat n = Infinity_enat
  | minus_enat (Enat a) (Enat b) = Enat (minus_nata a b);

fun equal_enat (Enat nat) Infinity_enat = false
  | equal_enat Infinity_enat (Enat nat) = false
  | equal_enat (Enat nata) (Enat nat) = equal_nata nata nat
  | equal_enat Infinity_enat Infinity_enat = true;

val one_enat : enat = Enat one_nata;

fun xml_take_many_sub acc minOccurs maxOccurs p1 p2 ([], (atts, (allow, rest)))
  = (if equal_nata minOccurs zero_nata
      then p2 (rev acc) ([], (atts, (allow, rest)))
      else (case p1 (XML ([], [], []), (atts, (false, rest))) of Inl a => Inl a
             | Inr _ =>
               Inl (Fatal
                     [#"u", #"n", #"e", #"x", #"p", #"e", #"c", #"t", #"e",
                       #"d"])))
  | xml_take_many_sub acc minOccurs maxOccurs p1 p2
    (xml :: xmls, (atts, (allow, (cands, rest)))) =
    (if equal_enat maxOccurs zero_enat
      then p2 (rev acc) (xml :: xmls, (atts, (allow, (cands, rest))))
      else (case p1 (xml, (atts,
                            (equal_nata minOccurs zero_nata, (cands, rest))))
             of Inl (TagMismatch _) =>
               p2 (rev acc) (xml :: xmls, (atts, (allow, (cands, rest))))
             | Inl (Fatal aa) => Inl (Fatal aa)
             | Inr a =>
               xml_take_many_sub (a :: acc) (minus_nata minOccurs one_nata)
                 (minus_enat maxOccurs one_enat) p1 p2
                 (xmls, (atts, (false, ([], rest))))));

fun position x =
  xml_do [#"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n"]
    (xml_take_nat (fn n => xml_return (minus_nata n one_nata))) x;

fun xml_change p f x =
  (case p x of Inl a => Inl a | Inr a => let
   val (_, rest) = x;
 in
   f a ([], rest)
 end);

fun xml_take p1 p2 x =
  (case x
    of ([], rest) =>
      (case p1 (XML ([], [], []), rest) of Inl a => Inl a
        | Inr _ =>
          Inl (Fatal
                [#"u", #"n", #"e", #"x", #"p", #"e", #"c", #"t", #"e", #"d"]))
    | (xa :: xs, rest) =>
      let
        val (atts, (flag, (cands, resta))) = rest;
      in
        (case p1 (xa, (atts, (flag, (cands, resta)))) of Inl a => Inl a
          | Inr a => p2 a (xs, (atts, (false, ([], resta)))))
      end);

fun afs A_ xml2name =
  xml_do
    [#"a", #"r", #"g", #"u", #"m", #"e", #"n", #"t", #"F", #"i", #"l", #"t",
      #"e", #"r"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"a", #"r", #"g", #"u", #"m", #"e", #"n", #"t", #"F", #"i", #"l", #"t",
          #"e", #"r", #"E", #"n", #"t", #"r", #"y"]
        (xml_take xml2name
          (fn name =>
            xml_take (xml_nat [#"a", #"r", #"i", #"t", #"y"])
              (fn arity =>
                xml_take
                  (xml_or
                    (xml_change
                      (xml_nat
                        [#"c", #"o", #"l", #"l", #"a", #"p", #"s", #"i", #"n",
                          #"g"])
                      (fn n => xml_return (Collapse (minus_nata n one_nata))))
                    (xml_do
                      [#"n", #"o", #"n", #"C", #"o", #"l", #"l", #"a", #"p",
                        #"s", #"i", #"n", #"g"]
                      (xml_take_many_sub [] zero_nata Infinity_enat position
                        (fn ls => xml_return (AFList ls)))))
                  (fn main => xml_return ((name, arity), main))))))
      xml_return);

fun scg_position x = xml_nat [#"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n"] x;

fun xml_take_default a p1 p2 xs =
  (case xs of ([], _) => p2 a xs
    | (xml :: xmls, (atts, (allow, (cands, rest)))) =>
      (case p1 (xml, (atts, (true, (cands, rest))))
        of Inl (TagMismatch cands1) =>
          p2 a (xml :: xmls, (atts, (allow, (cands1, rest))))
        | Inl (Fatal aa) => Inl (Fatal aa)
        | Inr aa => p2 aa (xmls, (atts, (false, ([], rest))))));

fun xml_take_text p xs =
  (case xs
    of ([], _) =>
      xml_error (show_list (show_list show_char))
        [#"e", #"x", #"p", #"e", #"c", #"t", #"i", #"n", #"g", #" ", #"a", #" ",
          #"t", #"e", #"x", #"t"]
        xs
    | (XML (_, _, _) :: _, _) =>
      xml_error (show_list (show_list show_char))
        [#"e", #"x", #"p", #"e", #"c", #"t", #"i", #"n", #"g", #" ", #"a", #" ",
          #"t", #"e", #"x", #"t"]
        xs
    | (XML_text text :: xmls, s) => p text (xmls, s));

fun xml_text tag = xml_do tag (xml_take_text xml_return);

fun plain_var x = xml_text [#"v", #"a", #"r"] x;

fun var x = xml_change plain_var (xml_return o Var) x;

fun term A_ xml2name x =
  xml_or var
    (xml_do [#"f", #"u", #"n", #"a", #"p", #"p"]
      (xml_take xml2name
        (fn name =>
          xml_take_many_sub [] zero_nata Infinity_enat
            (xml_or (term A_ xml2name)
              (xml_do [#"a", #"r", #"g"]
                (xml_take (term A_ xml2name) xml_return)))
            (fn args => xml_return (Fun (name, args))))))
    x;

fun conditions A_ xml2name tag =
  xml_do tag
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n"]
        (xml_take
          (xml_do [#"l", #"h", #"s"] (xml_take (term A_ xml2name) xml_return))
          (fn l =>
            xml_take
              (xml_do [#"r", #"h", #"s"]
                (xml_take (term A_ xml2name) xml_return))
              (fn r => xml_return (l, r)))))
      xml_return);

fun crule A_ xml2name tag =
  xml_do tag
    (xml_take
      (xml_do [#"l", #"h", #"s"] (xml_take (term A_ xml2name) xml_return))
      (fn l =>
        xml_take
          (xml_do [#"r", #"h", #"s"] (xml_take (term A_ xml2name) xml_return))
          (fn r =>
            xml_take_default []
              (conditions A_ xml2name
                [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s"])
              (fn conds => xml_return ((l, r), conds)))));

fun rule A_ xml2name =
  xml_change (crule A_ xml2name [#"r", #"u", #"l", #"e"])
    (fn (lr, conds) =>
      (if null conds then xml_return lr
        else xml_error (show_list (show_list show_char))
               [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a",
                 #"l", #" ", #"r", #"u", #"l", #"e", #" ", #"i", #"s", #" ",
                 #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o", #"w", #"e",
                 #"d", #" ", #"h", #"e", #"r", #"e"]));

fun bool_of_string s =
  (if equal_lista equal_char s [#"t", #"r", #"u", #"e"] then Inr true
    else (if equal_lista equal_char s [#"f", #"a", #"l", #"s", #"e"]
           then Inr false
           else Inl ([#"c", #"a", #"n", #"n", #"o", #"t", #" ", #"c", #"o",
                       #"n", #"v", #"e", #"r", #"t", #" ", #"\""] @
                      s @ [#"\"", #" ", #"i", #"n", #"t", #"o", #" ", #"B",
                            #"o", #"o", #"l", #"e", #"a", #"n"])));

fun xml_bool tag x =
  (case xml_text tag x of Inl a => Inl a
    | Inr str =>
      (case bool_of_string str
        of Inl err =>
          xml_error (show_list (show_list show_char)) err ([fst x], snd x)
        | Inr a => Inr a));

fun scg A_ xml2name =
  xml_do
    [#"s", #"i", #"z", #"e", #"C", #"h", #"a", #"n", #"g", #"e", #"G", #"r",
      #"a", #"p", #"h"]
    (xml_take (rule A_ xml2name)
      (fn lr =>
        xml_take_many_sub [] zero_nata Infinity_enat
          (xml_do [#"e", #"d", #"g", #"e"]
            (xml_take scg_position
              (fn p =>
                xml_take (xml_bool [#"s", #"t", #"r", #"i", #"c", #"t"])
                  (fn s =>
                    xml_take scg_position (fn q => xml_return (s, (p, q)))))))
          (fn edges =>
            xml_return
              (lr, (map_filter (fn x => (if fst x then SOME (snd x) else NONE))
                      edges,
                     map_filter
                       (fn x => (if not (fst x) then SOME (snd x) else NONE))
                       edges)))));

fun gt1 x = map (fn (s, t) => (root s, root t)) x;

fun map_term f1 f2 (Var x1) = Var (f2 x1)
  | map_term f1 f2 (Fun (x21, x22)) = Fun (f1 x21, map (map_term f1 f2) x22);

fun class_to_term_intern iv i (Fun (f, ts)) =
  let
    val (k, ss) =
      foldr (fn t => fn (j, ss) => let
                                     val (k, s) = class_to_term_intern iv j t;
                                   in
                                     (k, s :: ss)
                                   end)
        ts (i, []);
  in
    (k, Fun (f, ss))
  end
  | class_to_term_intern iv i (Var (Inl uu)) =
    (plus_nata i one_nata, Var (iv i))
  | class_to_term_intern iv i (Var (Inr x)) = (i, Var x);

fun class_to_term c t =
  snd (class_to_term_intern (fn i => c :: shows_prec_nat zero_nata i [])
        zero_nata t);

fun subst_apply_term (Var x) alpha = alpha x
  | subst_apply_term (Fun (f, ss)) alpha =
    Fun (f, map (fn s => subst_apply_term s alpha) ss);

fun subst_compose sigma tau = (fn x => subst_apply_term (sigma x) tau);

fun subst_of A_ ss =
  foldr (fn (x, t) => fn sigma => subst_compose sigma (subst A_ x t)) ss Var;

fun contains_var_term A_ x (Var y) = eq A_ x y
  | contains_var_term A_ x (Fun (uu, ts)) = list_ex (contains_var_term A_ x) ts;

fun subst_list sigma ys =
  map (fn p => (subst_apply_term (fst p) sigma, subst_apply_term (snd p) sigma))
    ys;

fun decompose A_ s t =
  (case (s, t) of (Var _, _) => NONE | (Fun (_, _), Var _) => NONE
    | (Fun (f, ss), Fun (g, ts)) =>
      (if eq A_ f g then zip_option ss ts else NONE));

fun unify A_ B_ [] bs = SOME bs
  | unify A_ B_ ((Fun (f, ss), Fun (g, ts)) :: e) bs =
    (case decompose A_ (Fun (f, ss)) (Fun (g, ts)) of NONE => NONE
      | SOME us => unify A_ B_ (us @ e) bs)
  | unify A_ B_ ((Var x, t) :: e) bs =
    (if equal_terma A_ B_ t (Var x) then unify A_ B_ e bs
      else (if contains_var_term B_ x t then NONE
             else unify A_ B_ (subst_list (subst B_ x t) e) ((x, t) :: bs)))
  | unify A_ B_ ((Fun (v, va), Var x) :: e) bs =
    (if contains_var_term B_ x (Fun (v, va)) then NONE
      else unify A_ B_ (subst_list (subst B_ x (Fun (v, va))) e)
             ((x, Fun (v, va)) :: bs));

fun mgu A_ B_ s t =
  (case unify A_ B_ [(s, t)] [] of NONE => NONE
    | SOME res => SOME (subst_of B_ res));

fun mgu_class A_ cs t =
  mgu A_ (equal_list equal_char) (class_to_term #"z" cs)
    (map_term (fn x => x) (fn a => #"y" :: a) t);

fun removeAll A_ x [] = []
  | removeAll A_ x (y :: xs) =
    (if eq A_ x y then removeAll A_ x xs else y :: removeAll A_ x xs);

fun match_term_list_code A_ (B1_, B2_) C_ ((Fun (f, ss), Var x) :: p) sigma =
  NONE
  | match_term_list_code A_ (B1_, B2_) C_ ((Fun (f, ss), Fun (g, ts)) :: p)
    sigma =
    (case decompose A_ (Fun (f, ss)) (Fun (g, ts)) of NONE => NONE
      | SOME us => match_term_list_code A_ (B1_, B2_) C_ (us @ p) sigma)
  | match_term_list_code A_ (B1_, B2_) C_ ((Var x, t) :: p) sigma =
    (if is_none (lookupb (B1_, B2_) sigma x) orelse
          equal_optiona (equal_term A_ C_) (lookupb (B1_, B2_) sigma x) (SOME t)
      then match_term_list_code A_ (B1_, B2_) C_ p
             (updateb (B1_, B2_) x t sigma)
      else NONE)
  | match_term_list_code A_ (B1_, B2_) C_ [] sigma = SOME sigma;

fun subst_of_map d sigma x = (case sigma x of NONE => d x | SOME t => t);

fun match_list (A1_, A2_, A3_) B_ C_ d p =
  map_option (subst_of_map d o lookupb (A1_, A2_))
    (match_term_list_code B_ (A1_, A2_) C_ p (emptyb (A1_, A3_)));

fun match A_ (B1_, B2_, B3_) t l =
  match_list (B1_, B2_, B3_) A_ B2_ Var [(l, t)];

fun dim_vec_impl xa = fst (rep_vec_impl xa);

fun dim_vec (Vec_impl v) = dim_vec_impl v;

fun map_mat f a = mat (dim_row a) (dim_col a) (fn ij => f (index_mat a ij));

fun one_mat (A1_, A2_) n =
  mat n n (fn (i, j) => (if equal_nata i j then onea A1_ else zerob A2_));

fun scalar_prod A_ v w =
  sum_list ((monoid_add_comm_monoid_add o comm_monoid_add_semiring_0) A_)
    (map (fn i =>
           times ((times_mult_zero o mult_zero_semiring_0) A_) (vec_index v i)
             (vec_index w i))
      (upt zero_nata (dim_vec w)));

fun times_mat A_ a b =
  mat (dim_row a) (dim_col b) (fn (i, j) => scalar_prod A_ (row a i) (col b j));

fun pow_mat A_ a k =
  (if equal_nata k zero_nata
    then one_mat
           ((one_numeral o numeral_semiring_numeral o
              semiring_numeral_semiring_1)
              A_,
             (zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1) A_)
           (dim_row a)
    else times_mat (semiring_0_semiring_1 A_)
           (pow_mat A_ a (minus_nata k one_nata)) a);

fun rBT_Impl_fold1 f (Branch (ca, Branch (c, l, ka, va, ra), k, v, r)) =
  folda (fn kb => fn _ => f kb) r
    (f k (rBT_Impl_fold1 f (Branch (c, l, ka, va, ra))))
  | rBT_Impl_fold1 f (Branch (c, Emptya, k, v, r)) =
    folda (fn ka => fn _ => f ka) r k
  | rBT_Impl_fold1 f Emptya = (raise Fail "undefined");

fun fold1 A_ x xc = rBT_Impl_fold1 x (impl_ofb A_ xc);

fun imagea (A1_, A2_) (B1_, B2_, B3_) (RBT_set rbt) c =
  (case ccompare A2_
    of NONE =>
      (raise Fail "Image RBT_set: ccompare1 = None")
        (fn _ => imagea (A1_, A2_) (B1_, B2_, B3_) (RBT_set rbt) c)
    | SOME _ =>
      (case ccompare B2_
        of NONE =>
          (raise Fail "Image RBT_set: ccompare2 = None")
            (fn _ => imagea (A1_, A2_) (B1_, B2_, B3_) (RBT_set rbt) c)
        | SOME _ =>
          foldb (ccompare_prod A2_ B2_)
            (fn (x, y) => fn acc =>
              (if member (A1_, A2_) x c then inserta (B1_, B2_) y acc else acc))
            rbt (bot_set (B1_, B2_, B3_))))
  | imagea (A1_, A2_) (B1_, B2_, B3_) (DList_set dxs) b =
    (case ceq A1_
      of NONE =>
        (raise Fail "Image DList_set: ceq1 = None")
          (fn _ => imagea (A1_, A2_) (B1_, B2_, B3_) (DList_set dxs) b)
      | SOME _ =>
        (case ceq B1_
          of NONE =>
            (raise Fail "Image DList_set: ceq2 = None")
              (fn _ => imagea (A1_, A2_) (B1_, B2_, B3_) (DList_set dxs) b)
          | SOME _ =>
            foldc (ceq_prod A1_ B1_)
              (fn (x, y) => fn acc =>
                (if member (A1_, A2_) x b then inserta (B1_, B2_) y acc
                  else acc))
              dxs (bot_set (B1_, B2_, B3_))))
  | imagea (A1_, A2_) (B1_, B2_, B3_) (Set_Monad rxs) a =
    Set_Monad
      (fold (fn (x, y) => fn rest =>
              (if member (A1_, A2_) x a then y :: rest else rest))
        rxs [])
  | imagea (A1_, A2_) (B1_, B2_, B3_) x y =
    image (ceq_prod A1_ B1_, ccompare_prod A2_ B2_) (B1_, B2_, B3_) snd
      (filter (ceq_prod A1_ B1_, ccompare_prod A2_ B2_)
        (fn (xa, _) => member (A1_, A2_) xa y) x);

fun zero
  (Partial_object_ext
    (carrier, Monoid_ext (mult, one, Ring_ext (zero, add, more))))
  = zero;

fun args (Var x1) = []
  | args (Fun (x21, x22)) = x22;

fun aarity sm f n = minus_nata (size_list (sm f n)) one_nata;

fun list2position [] = Empty
  | list2position (n :: ns) = PCons (n, list2position ns);

fun pos x =
  xml_do
    [#"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n", #"I", #"n", #"T", #"e",
      #"r", #"m"]
    (xml_take_many_sub [] zero_nata Infinity_enat position
      (fn lst => xml_return (list2position lst)))
    x;

fun many1_gen tag p1 p2 f (XML (name, atts, cs)) =
  (if equal_lista equal_char name tag andalso (null atts andalso not (null cs))
    then let
           val h :: t = cs;
         in
           binda (p1 h)
             (fn x => binda (map_sum_bot (p2 x) t) (fn xs => return (f x xs)))
         end
    else fail tag (XML (name, atts, cs)))
  | many1_gen tag p1 p2 f (XML_text v) = fail tag (XML_text v);

fun list1element [x] = SOME x
  | list1element [] = NONE
  | list1element (v :: vb :: vc) = NONE;

fun singleton tag p1 f xml =
  (case xml
    of XML (name, atts, cs) =>
      (if equal_lista equal_char name tag andalso null atts
        then (case list1element cs of NONE => fail tag xml
               | SOME cs1 => binda (p1 cs1) (return o f))
        else fail tag xml)
    | XML_text _ => fail tag xml);

fun xml_leaf tag ret = xml_do tag (xml_return ret);

fun ctxt A_ xml2name x =
  xml_or (xml_do [#"b", #"o", #"x"] (xml_return Hole))
    (xml_do [#"f", #"u", #"n", #"C", #"o", #"n", #"t", #"e", #"x", #"t"]
      (xml_take xml2name
        (fn name =>
          xml_take
            (xml_do [#"b", #"e", #"f", #"o", #"r", #"e"]
              (xml_take_many_sub [] zero_nata Infinity_enat (term A_ xml2name)
                xml_return))
            (fn left =>
              xml_take (ctxt A_ xml2name)
                (fn mid =>
                  xml_take
                    (xml_do [#"a", #"f", #"t", #"e", #"r"]
                      (xml_take_many_sub [] zero_nata Infinity_enat
                        (term A_ xml2name) xml_return))
                    (fn right =>
                      xml_return (More (name, left, mid, right))))))))
    x;

fun xml_take_optional p1 p2 xs =
  (case xs of ([], _) => p2 NONE xs
    | (xml :: xmls, (atts, (allow, (cands, rest)))) =>
      (case p1 (xml, (atts, (true, (cands, rest))))
        of Inl (TagMismatch cands1) =>
          p2 NONE (xml :: xmls, (atts, (allow, (cands1, rest))))
        | Inl (Fatal aa) => Inl (Fatal aa)
        | Inr a => p2 (SOME a) (xmls, (atts, (false, ([], rest))))));

fun relstep A_ xml2name =
  xml_do [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #"S", #"t", #"e", #"p"]
    (xml_take pos
      (fn p =>
        xml_take (rule A_ xml2name)
          (fn r =>
            xml_take_optional
              (xml_leaf [#"r", #"e", #"l", #"a", #"t", #"i", #"v", #"e"] ())
              (fn rel =>
                xml_take (term A_ xml2name)
                  (fn t => xml_return (p, (r, (is_none rel, t))))))));

fun relsteps A_ xml2name =
  xml_do
    [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #"S", #"e", #"q", #"u", #"e",
      #"n", #"c", #"e"]
    (xml_take
      (xml_do [#"s", #"t", #"a", #"r", #"t", #"T", #"e", #"r", #"m"]
        (xml_take (term A_ xml2name) (fn x => xml_return (id x))))
      (fn start =>
        xml_take_many_sub [] zero_nata Infinity_enat (relstep A_ xml2name)
          (fn steps => xml_return (start, steps))));

fun substa A_ xml2name =
  xml_do
    [#"s", #"u", #"b", #"s", #"t", #"i", #"t", #"u", #"t", #"i", #"o", #"n"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do [#"s", #"u", #"b", #"s", #"t", #"E", #"n", #"t", #"r", #"y"]
        (xml_take (xml_do [#"v", #"a", #"r"] (xml_take_text xml_return))
          (fn var =>
            xml_take (term A_ xml2name) (fn trm => xml_return (var, trm)))))
      xml_return);

fun loop A_ xml2name =
  xml_do [#"l", #"o", #"o", #"p"]
    (xml_take (relsteps A_ xml2name)
      (fn (s, rseq) =>
        xml_take (substa A_ xml2name)
          (fn sigma =>
            xml_take (ctxt A_ xml2name)
              (fn c => xml_return (s, (rseq, (sigma, c)))))));

fun proj A_ xml2name =
  xml_change (afs A_ xml2name)
    (fn afl =>
      xml_return
        (Projection
          (map (fn (fa, a) =>
                 (case a of Collapse aa => (fa, aa) | AFList _ => (fa, snd fa)))
            afl)));

fun catch_error (Sumbot a) f =
  (case a of Inl aa => f aa | Inr aa => Sumbot (Inr aa));

fun real x =
  catch_error (change rat ratreal x)
    (fn _ =>
      triple [#"a", #"l", #"g", #"e", #"b", #"r", #"a", #"i", #"c"] rat rat rat
        (fn a => fn b => fn c =>
          plus_reala (ratreal a) (times_reala (ratreal b) (sqrt (ratreal c))))
        x);

fun proj_term p (Var x) = Var x
  | proj_term p (Fun (f, ts)) =
    let
      val n = size_list ts;
      val i = p (f, n);
    in
      (if less_nat i n then nth ts i else Fun (f, ts))
    end;

fun start_term (A1_, A2_) xml2name t =
  xml_do [#"s", #"t", #"a", #"r", #"t", #"T", #"e", #"r", #"m"]
    (xml_take (term A2_ xml2name)
      (fn s =>
        (if equal_terma A1_ (equal_list equal_char) s t then xml_return t
          else xml_error (show_list (show_list show_char))
                 [#"<", #"s", #"t", #"a", #"r", #"t", #"T", #"e", #"r", #"m",
                   #">", #" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t",
                   #" ", #"m", #"a", #"t", #"c", #"h", #" ", #"l", #"h",
                   #"s"])));

fun rstep A_ xml2name =
  xml_do [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #"S", #"t", #"e", #"p"]
    (xml_take pos
      (fn p =>
        xml_take (rule A_ xml2name)
          (fn r =>
            xml_take (term A_ xml2name) (fn t => xml_return (p, (r, t))))));

fun rseq (A1_, A2_) xml2name pi r =
  xml_do
    [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #"S", #"e", #"q", #"u", #"e",
      #"n", #"c", #"e"]
    (xml_take (start_term (A1_, A2_) xml2name (proj_term pi (fst r)))
      (fn _ =>
        xml_take_many_sub [] zero_nata Infinity_enat (rstep A2_ xml2name)
          (fn rseq => xml_return (r, rseq))));

fun trivial_mute_fun A_ x y =
  (x, (y, onea ((one_numeral o numeral_neg_numeral o neg_numeral_ring_1 o
                  ring_1_comm_ring_1)
                 A_)));

fun fst_sel_fun x = fst (hda x);

fun prod_list A_ xs =
  foldr (times ((times_power o power_monoid_mult) A_)) xs
    (onea ((one_power o power_monoid_mult) A_));

fun find_non0 (A1_, A2_) sel_fun l a =
  let
    val is = upt (suc l) (dim_row a);
    val ais =
      filtera
        (fn (_, ail) =>
          not (eq A1_ ail
                (zerob
                  ((zero_mult_zero o mult_zero_semiring_0 o
                     semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                     comm_semiring_1_comm_semiring_1_cancel o
                     comm_semiring_1_cancel_semidom o semidom_idom o
                     idom_idom_divide)
                    A2_))))
        (map (fn i => (i, index_mat a (i, l))) is);
  in
    (case ais of [] => NONE | _ :: _ => SOME (sel_fun ais))
  end;

fun mat_addrow_gen_impl xd xe xf xh xi xj =
  Abs_mat_impl
    let
      val (nr, a) = rep_mat_impl xj;
      val (nc, aa) = a;
    in
      (if less_nat xi nr
        then let
               val ak = sub aa xh;
               val al = sub aa xi;
               val aka =
                 of_fun (fn i => xd (xe xf (sub al i)) (sub ak i))
                   (min ord_nat (length ak) (length al));
               val ab =
                 of_fun (fn i => (if equal_nata i xh then aka else sub aa i))
                   (length aa);
             in
               (nr, (nc, ab))
             end
        else (nr, (nc, aa)))
    end;

fun mat_addrow_gen ad mul aa k l (Mat_impl a) =
  (if less_nat l (dim_row_impl a)
    then Mat_impl (mat_addrow_gen_impl ad mul aa k l a)
    else (raise Fail "index out of bounds in mat_addrow")
           (fn _ => mat_addrow_gen ad mul aa k l (Mat_impl a)));

fun mute (A1_, A2_) mf a_ll k l (r, a) =
  let
    val p = index_mat a (k, l);
  in
    (if eq A1_ p
          (zerob
            ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
               semiring_1_comm_semiring_1 o
               comm_semiring_1_comm_semiring_1_cancel o
               comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
              A2_))
      then (r, a)
      else let
             val (q, (pa, _)) = mf a_ll p;
           in
             (times ((times_dvd o dvd_comm_monoid_mult o
                       comm_monoid_mult_comm_semiring_1 o
                       comm_semiring_1_comm_semiring_1_cancel o
                       comm_semiring_1_cancel_semidom o semidom_idom o
                       idom_idom_divide)
                      A2_)
                r q,
               mat_addrow_gen
                 (plus ((plus_semigroup_add o semigroup_add_numeral o
                          numeral_neg_numeral o neg_numeral_ring_1 o
                          ring_1_comm_ring_1 o comm_ring_1_idom o
                          idom_idom_divide)
                         A2_))
                 (times
                   ((times_dvd o dvd_comm_monoid_mult o
                      comm_monoid_mult_comm_semiring_1 o
                      comm_semiring_1_comm_semiring_1_cancel o
                      comm_semiring_1_cancel_semidom o semidom_idom o
                      idom_idom_divide)
                     A2_))
                 (uminus
                   ((uminus_group_add o group_add_neg_numeral o
                      neg_numeral_ring_1 o ring_1_comm_ring_1 o
                      comm_ring_1_idom o idom_idom_divide)
                     A2_)
                   pa)
                 k l (mat_multrow_gen
                       (times
                         ((times_dvd o dvd_comm_monoid_mult o
                            comm_monoid_mult_comm_semiring_1 o
                            comm_semiring_1_comm_semiring_1_cancel o
                            comm_semiring_1_cancel_semidom o semidom_idom o
                            idom_idom_divide)
                           A2_))
                       k q a))
           end)
  end;

fun sub1 (A1_, A2_) mf q k l rA =
  (if equal_nata k zero_nata then rA
    else mute (A1_, A2_) mf q (plus_nata l (suc (minus_nata k one_nata))) l
           (sub1 (A1_, A2_) mf q (minus_nata k one_nata) l rA));

fun sub2 (A1_, A2_) sel_fun mf d l (r, a) =
  (case find_non0 (A1_, A2_) sel_fun l a of NONE => (r, a)
    | SOME m =>
      let
        val aa = mat_swaprows m l a;
      in
        sub1 (A1_, A2_) mf (index_mat aa (l, l)) (minus_nata d (suc l)) l
          (uminus
             ((uminus_group_add o group_add_neg_numeral o neg_numeral_ring_1 o
                ring_1_comm_ring_1 o comm_ring_1_idom o idom_idom_divide)
               A2_)
             r,
            aa)
      end);

fun sub3 (A1_, A2_) sel_fun mf d l rA =
  (if equal_nata l zero_nata then rA
    else sub2 (A1_, A2_) sel_fun mf d (minus_nata l one_nata)
           (sub3 (A1_, A2_) sel_fun mf d (minus_nata l one_nata) rA));

fun triangulize (A1_, A2_) sel_fun mf a =
  sub3 (A1_, A2_) sel_fun mf (dim_row a) (dim_row a)
    (onea ((one_numeral o numeral_neg_numeral o neg_numeral_ring_1 o
             ring_1_comm_ring_1 o comm_ring_1_idom o idom_idom_divide)
            A2_),
      a);

fun diag_mat a = map (fn i => index_mat a (i, i)) (upt zero_nata (dim_row a));

fun det_code (A1_, A2_) sel_fun mf a =
  (if equal_nata (dim_row a) (dim_col a)
    then let
           val (m, aa) = triangulize (A1_, A2_) sel_fun mf a;
         in
           divide ((divide_semidom_divide o semidom_divide_idom_divide) A2_)
             (prod_list
               ((monoid_mult_semiring_numeral o semiring_numeral_semiring_1 o
                  semiring_1_comm_semiring_1 o
                  comm_semiring_1_comm_semiring_1_cancel o
                  comm_semiring_1_cancel_semidom o semidom_idom o
                  idom_idom_divide)
                 A2_)
               (diag_mat aa))
             m
         end
    else zerob ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
                  semiring_1_comm_semiring_1 o
                  comm_semiring_1_comm_semiring_1_cancel o
                  comm_semiring_1_cancel_semidom o semidom_idom o
                  idom_idom_divide)
                 A2_));

fun det (A1_, A2_) a =
  det_code (A1_, A2_) fst_sel_fun
    (trivial_mute_fun ((comm_ring_1_idom o idom_idom_divide) A2_)) a;

fun list_remdups equal (x :: xs) =
  (if list_member equal xs x then list_remdups equal xs
    else x :: list_remdups equal xs)
  | list_remdups equal [] = [];

fun lengtha A_ xa = size_list (list_of_dlist A_ xa);

fun card (A1_, A2_, A3_, A4_) (Complement a) =
  let
    val aa = carda A1_ a;
    val s = carda A1_ (top_set (A2_, A3_, A4_));
  in
    (if less_nat zero_nata s then minus_nata s aa
      else (if finitea (finite_UNIV_card_UNIV A1_) a then zero_nata
             else (raise Fail "card Complement: infinite")
                    (fn _ => carda A1_ (Complement a))))
  end
  | card (A1_, A2_, A3_, A4_) (Set_Monad xs) =
    (case ceq A2_
      of NONE =>
        (raise Fail "card Set_Monad: ceq = None")
          (fn _ => card (A1_, A2_, A3_, A4_) (Set_Monad xs))
      | SOME eq => size_list (list_remdups eq xs))
  | card (A1_, A2_, A3_, A4_) (RBT_set rbt) =
    (case ccompare A3_
      of NONE =>
        (raise Fail "card RBT_set: ccompare = None")
          (fn _ => card (A1_, A2_, A3_, A4_) (RBT_set rbt))
      | SOME _ => size_list (keysa A3_ rbt))
  | card (A1_, A2_, A3_, A4_) (DList_set dxs) =
    (case ceq A2_
      of NONE =>
        (raise Fail "card DList_set: ceq = None")
          (fn _ => card (A1_, A2_, A3_, A4_) (DList_set dxs))
      | SOME _ => lengtha A2_ dxs);

fun form_or (Disjunction []) psi = psi
  | form_or (Atom v) (Disjunction []) = Atom v
  | form_or (NegAtom v) (Disjunction []) = NegAtom v
  | form_or (Conjunction v) (Disjunction []) = Conjunction v
  | form_or (Disjunction (va :: vb)) (Disjunction []) = Disjunction (va :: vb)
  | form_or (Disjunction (v :: va)) (Disjunction (vb :: vc)) =
    Disjunction ((v :: va) @ vb :: vc)
  | form_or (Disjunction (v :: va)) (Atom vb) =
    Disjunction ((v :: va) @ [Atom vb])
  | form_or (Disjunction (v :: va)) (NegAtom vb) =
    Disjunction ((v :: va) @ [NegAtom vb])
  | form_or (Disjunction (v :: va)) (Conjunction vb) =
    Disjunction ((v :: va) @ [Conjunction vb])
  | form_or (Atom v) (Disjunction (va :: vb)) = Disjunction (Atom v :: va :: vb)
  | form_or (NegAtom v) (Disjunction (va :: vb)) =
    Disjunction (NegAtom v :: va :: vb)
  | form_or (Conjunction v) (Disjunction (va :: vb)) =
    Disjunction (Conjunction v :: va :: vb)
  | form_or (Atom v) (Atom va) = Disjunction [Atom v, Atom va]
  | form_or (Atom v) (NegAtom va) = Disjunction [Atom v, NegAtom va]
  | form_or (Atom v) (Conjunction va) = Disjunction [Atom v, Conjunction va]
  | form_or (NegAtom v) (Atom va) = Disjunction [NegAtom v, Atom va]
  | form_or (NegAtom v) (NegAtom va) = Disjunction [NegAtom v, NegAtom va]
  | form_or (NegAtom v) (Conjunction va) =
    Disjunction [NegAtom v, Conjunction va]
  | form_or (Conjunction v) (Atom va) = Disjunction [Conjunction v, Atom va]
  | form_or (Conjunction v) (NegAtom va) =
    Disjunction [Conjunction v, NegAtom va]
  | form_or (Conjunction v) (Conjunction va) =
    Disjunction [Conjunction v, Conjunction va];

fun cnf_form_or (Conjunction phi_s) (Conjunction psi_s) =
  Conjunction (maps (fn phi => map (form_or phi) psi_s) phi_s)
  | cnf_form_or (Atom v) psi = form_or (Atom v) psi
  | cnf_form_or (NegAtom v) psi = form_or (NegAtom v) psi
  | cnf_form_or (Disjunction v) psi = form_or (Disjunction v) psi
  | cnf_form_or phi (Atom v) = form_or phi (Atom v)
  | cnf_form_or phi (NegAtom v) = form_or phi (NegAtom v)
  | cnf_form_or phi (Disjunction v) = form_or phi (Disjunction v);

fun form_cnf_ex [] = Conjunction [Disjunction []]
  | form_cnf_ex (phi :: phi_s) = cnf_form_or phi (form_cnf_ex phi_s);

fun form_and (Conjunction []) psi = psi
  | form_and (Atom v) (Conjunction []) = Atom v
  | form_and (NegAtom v) (Conjunction []) = NegAtom v
  | form_and (Conjunction (va :: vb)) (Conjunction []) = Conjunction (va :: vb)
  | form_and (Disjunction v) (Conjunction []) = Disjunction v
  | form_and (Conjunction (v :: va)) (Conjunction (vb :: vc)) =
    Conjunction ((v :: va) @ vb :: vc)
  | form_and (Conjunction (v :: va)) (Atom vb) =
    Conjunction ((v :: va) @ [Atom vb])
  | form_and (Conjunction (v :: va)) (NegAtom vb) =
    Conjunction ((v :: va) @ [NegAtom vb])
  | form_and (Conjunction (v :: va)) (Disjunction vb) =
    Conjunction ((v :: va) @ [Disjunction vb])
  | form_and (Atom v) (Conjunction (va :: vb)) =
    Conjunction (Atom v :: va :: vb)
  | form_and (NegAtom v) (Conjunction (va :: vb)) =
    Conjunction (NegAtom v :: va :: vb)
  | form_and (Disjunction v) (Conjunction (va :: vb)) =
    Conjunction (Disjunction v :: va :: vb)
  | form_and (Atom v) (Atom va) = Conjunction [Atom v, Atom va]
  | form_and (Atom v) (NegAtom va) = Conjunction [Atom v, NegAtom va]
  | form_and (Atom v) (Disjunction va) = Conjunction [Atom v, Disjunction va]
  | form_and (NegAtom v) (Atom va) = Conjunction [NegAtom v, Atom va]
  | form_and (NegAtom v) (NegAtom va) = Conjunction [NegAtom v, NegAtom va]
  | form_and (NegAtom v) (Disjunction va) =
    Conjunction [NegAtom v, Disjunction va]
  | form_and (Disjunction v) (Atom va) = Conjunction [Disjunction v, Atom va]
  | form_and (Disjunction v) (NegAtom va) =
    Conjunction [Disjunction v, NegAtom va]
  | form_and (Disjunction v) (Disjunction va) =
    Conjunction [Disjunction v, Disjunction va];

fun form_all [] = Conjunction []
  | form_all (phi :: phi_s) = form_and phi (form_all phi_s);

fun flatten (Conjunction phi_s) = form_all (map flatten phi_s)
  | flatten (Disjunction phi_s) = form_cnf_ex (map flatten phi_s)
  | flatten (Atom v) = Conjunction [Disjunction [Atom v]]
  | flatten (NegAtom v) = Conjunction [Disjunction [NegAtom v]];

fun is_Atom (Atom uu) = true
  | is_Atom (NegAtom v) = false
  | is_Atom (Conjunction v) = false
  | is_Atom (Disjunction v) = false;

fun gen_set emp ins l = fold ins l emp;

fun initial (Lts_ext (initial, transition_rules, assertion, more)) = initial;

fun untrans_var (Pre x) = x
  | untrans_var (Post x) = x
  | untrans_var (Intermediate x) = x;

fun label f n (Inl l) = Lab (f, l)
  | label f n (Inr l) = FunLab (f, l);

fun unlab (Lab (f, l)) = f
  | unlab (FunLab (f, l)) = f
  | unlab (UnLab v) = UnLab v
  | unlab (Sharp v) = Sharp v;

fun plus_mat A_ a b =
  mat (dim_row b) (dim_col b)
    (fn ij => plus A_ (index_mat a ij) (index_mat b ij));

fun carrier_mat nr nc =
  Collect_set
    (fn a => equal_nata (dim_row a) nr andalso equal_nata (dim_col a) nc);

fun zero_mat A_ nr nc = mat nr nc (fn _ => zerob A_);

fun ring_mat A_ ty n b =
  Partial_object_ext
    (carrier_mat n n,
      Monoid_ext
        (times_mat (semiring_0_semiring_1 A_),
          one_mat
            ((one_numeral o numeral_semiring_numeral o
               semiring_numeral_semiring_1)
               A_,
              (zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1)
                A_)
            n,
          Ring_ext
            (zero_mat
               ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1)
                 A_)
               n n,
              plus_mat
                ((plus_semigroup_add o semigroup_add_numeral o
                   numeral_semiring_numeral o semiring_numeral_semiring_1)
                  A_),
              b)));

fun emptyd (B1_, B2_) xa = Abs_multimap (xa, (emptyb (B1_, B2_), []));

fun rm_iterateoi Emptya c f sigma = sigma
  | rm_iterateoi (Branch (col, l, k, v, r)) c f sigma =
    (if c sigma
      then let
             val sigmaa = rm_iterateoi l c f sigma;
           in
             (if c sigmaa then rm_iterateoi r c f (f (k, v) sigmaa) else sigmaa)
           end
      else sigma);

fun iteratei_bmap_op_list_it_rm_basic_ops A_ s = rm_iterateoi (impl_of A_ s);

fun g_to_list_rm_basic_ops A_ m =
  iteratei_bmap_op_list_it_rm_basic_ops A_ m (fn _ => true)
    (fn a => fn b => a :: b) [];

fun values A_ m = maps snd (g_to_list_rm_basic_ops A_ m);

fun vars_list lp =
  ordered_keys (ceq_nat, ccompare_nat, equal_nat, linorder_nat, set_impl_nat)
    (ceq_rat, ccompare_rat, set_impl_rat) (linear_poly_map lp);

fun valuate A_ lp vala =
  let
    val lpm = linear_poly_map lp;
  in
    sum_list
      ((monoid_add_group_add o group_add_ab_group_add o
         ab_group_add_rational_vector)
        A_)
      (map (fn x =>
             scaleRat (scaleRat_rational_vector A_)
               (the (fmlookup equal_nat lpm x)) (vala x))
        (vars_list lp))
  end;

fun delta_0 qd1 qd2 =
  let
    val c1 = qdfst qd1;
    val c2 = qdfst qd2;
    val k1 = qdsnd qd1;
    val k2 = qdsnd qd2;
  in
    (if less_rat c1 c2 andalso less_rat k2 k1
      then divide_rata (minus_rata c2 c1) (minus_rata k1 k2) else one_rata)
  end;

fun delta_0_val (LEQ_ns (lll, rrr)) vl =
  delta_0 (valuate rational_vector_QDelta lll vl) rrr
  | delta_0_val (GEQ_ns (lll, rrr)) vl =
    delta_0 rrr (valuate rational_vector_QDelta lll vl);

fun delta_0_val_min [] vl = one_rata
  | delta_0_val_min (h :: t) vl =
    min ord_rat (delta_0_val_min t vl) (delta_0_val h vl);

fun tabulate (A1_, A2_, A3_) xs f =
  fold (fn k => updateb (A1_, A2_) k (f k)) xs (emptyb (A1_, A3_));

fun map2fun A_ v =
  (fn x =>
    (case lookupb (ccompare_nat, equal_nat) v x of NONE => zerob A_
      | SOME y => y));

fun from_ns vl cs =
  let
    val delta = delta_0_val_min cs (map2fun zero_QDelta vl);
  in
    tabulate (ccompare_nat, equal_nat, mapping_impl_nat)
      (remdups equal_nat (maps vars_list (map poly cs)))
      (fn var => vala (map2fun zero_QDelta vl var) delta)
  end;

fun u_update ua (State_ext (t, b_l, b_u, v, u, more)) =
  State_ext (t, b_l, b_u, v, ua u, more);

fun uB_upd A_ (Direction_ext (lt, lb, ub, uB_upd, le, more)) = uB_upd;

fun lt A_ (Direction_ext (lt, lb, ub, uB_upd, le, more)) = lt;

fun ub A_ (Direction_ext (lt, lb, ub, uB_upd, le, more)) = ub;

fun lb A_ (Direction_ext (lt, lb, ub, uB_upd, le, more)) = lb;

fun v_update va (State_ext (t, b_l, b_u, v, u, more)) =
  State_ext (t, b_l, b_u, va v, u, more);

fun v (State_ext (t, b_l, b_u, v, u, more)) = v;

fun t (State_ext (t, b_l, b_u, v, u, more)) = t;

fun coeffa lp = get_var_coeff (linear_poly_map lp);

fun rhs_eq_val (A1_, A2_, A3_, A4_) v x_i c e =
  let
    val x_j = lhs e;
    val a_i_j = coeffa (rhs e) x_i;
  in
    plus A3_ (map2fun A4_ v x_j)
      (scaleRat A1_ a_i_j (minus A2_ c (map2fun A4_ v x_i)))
  end;

fun update_code A_ x c s =
  v_update
    (fn _ =>
      updateb (ccompare_nat, equal_nat) x c
        (foldl
          (fn va => fn e =>
            updateb (ccompare_nat, equal_nat) (lhs e)
              (rhs_eq_val
                ((scaleRat_rational_vector o
                   rational_vector_ordered_rational_vector o
                   ordered_rational_vector_linordered_rational_vector o
                   linordered_rational_vector_lrv)
                   A_,
                  (minus_group_add o group_add_ab_group_add o
                    ab_group_add_rational_vector o
                    rational_vector_ordered_rational_vector o
                    ordered_rational_vector_linordered_rational_vector o
                    linordered_rational_vector_lrv)
                    A_,
                  (plus_semigroup_add o semigroup_add_monoid_add o
                    monoid_add_group_add o group_add_ab_group_add o
                    ab_group_add_rational_vector o
                    rational_vector_ordered_rational_vector o
                    ordered_rational_vector_linordered_rational_vector o
                    linordered_rational_vector_lrv)
                    A_,
                  (zero_monoid_add o monoid_add_group_add o
                    group_add_ab_group_add o ab_group_add_rational_vector o
                    rational_vector_ordered_rational_vector o
                    ordered_rational_vector_linordered_rational_vector o
                    linordered_rational_vector_lrv)
                    A_)
                (v s) x c e)
              va)
          (v s) (t s)))
    s;

fun update_B A_ field_update x c s =
  field_update (fn b => fun_upd A_ b x (SOME c)) s;

fun assert_bound_codea (A1_, A2_) dir x c s =
  (if geub A2_
        (lt ((linorder_linordered_rational_vector o
               linordered_rational_vector_lrv)
              A1_)
          dir)
        c (ub ((linorder_linordered_rational_vector o
                 linordered_rational_vector_lrv)
                A1_)
            dir s x)
    then s
    else let
           val sa =
             update_B equal_nat
               (uB_upd
                 ((linorder_linordered_rational_vector o
                    linordered_rational_vector_lrv)
                   A1_)
                 dir)
               x c s;
         in
           (if ltlb (lt ((linorder_linordered_rational_vector o
                           linordered_rational_vector_lrv)
                          A1_)
                      dir)
                 c (lb ((linorder_linordered_rational_vector o
                          linordered_rational_vector_lrv)
                         A1_)
                     dir s x)
             then u_update (fn _ => true) sa
             else (if not (member (ceq_nat, ccompare_nat) x
                            (lvars (t sa))) andalso
                        lt ((linorder_linordered_rational_vector o
                              linordered_rational_vector_lrv)
                             A1_)
                          dir c
                          (map2fun
                            ((zero_monoid_add o monoid_add_group_add o
                               group_add_ab_group_add o
                               ab_group_add_rational_vector o
                               rational_vector_ordered_rational_vector o
                               ordered_rational_vector_linordered_rational_vector o
                               linordered_rational_vector_lrv)
                              A1_)
                            (v s) x)
                    then update_code A1_ x c sa else sa))
         end);

fun b_u_update b_ua (State_ext (t, b_l, b_u, v, u, more)) =
  State_ext (t, b_l, b_ua b_u, v, u, more);

fun b_u (State_ext (t, b_l, b_u, v, u, more)) = b_u;

fun b_l (State_ext (t, b_l, b_u, v, u, more)) = b_l;

fun positive A_ =
  Direction_ext
    (less ((ord_preorder o preorder_order o order_linorder) A_), b_l, b_u,
      b_u_update, (fn a => fn b => Leq (a, b)), ());

fun b_l_update b_la (State_ext (t, b_l, b_u, v, u, more)) =
  State_ext (t, b_la b_l, b_u, v, u, more);

fun negative A_ =
  Direction_ext
    ((fn x => fn y =>
       less ((ord_preorder o preorder_order o order_linorder) A_) y x),
      b_u, b_l, b_l_update, (fn a => fn b => Geq (a, b)), ());

fun assert_bound_code (A1_, A2_) (Leq (x, c)) s =
  assert_bound_codea (A1_, A2_)
    (positive
      ((linorder_linordered_rational_vector o linordered_rational_vector_lrv)
        A1_))
    x c s
  | assert_bound_code (A1_, A2_) (Geq (x, c)) s =
    assert_bound_codea (A1_, A2_)
      (negative
        ((linorder_linordered_rational_vector o linordered_rational_vector_lrv)
          A1_))
      x c s;

fun u (State_ext (t, b_l, b_u, v, u, more)) = u;

fun assert_bound_loop_code (A1_, A2_) ats s =
  foldl (fn sa => fn a =>
          (if u sa then sa else assert_bound_code (A1_, A2_) a sa))
    s ats;

fun init_state A_ t =
  State_ext
    (t, (fn _ => NONE), (fn _ => NONE),
      tabulate (ccompare_nat, equal_nat, mapping_impl_nat)
        (remdups equal_nat (map lhs t @ maps (vars_list o rhs) t))
        (fn _ => zerob A_),
      false, ());

fun min_satisfying A_ p l =
  let
    val xs = filtera p l;
  in
    (if null xs then NONE
      else SOME (foldl
                  (min ((ord_preorder o preorder_order o order_linorder) A_))
                  (hda xs) (tla xs)))
  end;

fun le_ubound (A1_, A2_) c b =
  leub A1_ (less ((ord_preorder o preorder_order o order_linorder) A2_)) c b;

fun ge_lbound (A1_, A2_) c b =
  gelb A1_ (less ((ord_preorder o preorder_order o order_linorder) A2_)) c b;

fun in_bounds (B1_, B2_) x v (lb, ub) =
  ge_lbound (B1_, B2_) (v x) (lb x) andalso le_ubound (B1_, B2_) (v x) (ub x);

fun min_lvar_not_in_bounds (A1_, A2_, A3_) s =
  min_satisfying linorder_nat
    (fn x => not (in_bounds (A2_, A3_) x (map2fun A1_ (v s)) (b_l s, b_u s)))
    (map lhs (t s));

fun vara x = LinearPoly (set_var_coeff x one_rata fmempty);

fun subst_var v lpa lp =
  minus_linear_poly
    (plus_linear_poly lp (scaleRat_linear_poly (coeffa lp v) lpa))
    (scaleRat_linear_poly (coeffa lp v) (vara v));

fun subst_var_eq_code v lp eq = (lhs eq, subst_var v lp (rhs eq));

fun eq_idx_for_lvar_aux [] x i = i
  | eq_idx_for_lvar_aux (eq :: t) x i =
    (if equal_nata (lhs eq) x then i
      else eq_idx_for_lvar_aux t x (plus_nata i one_nata));

fun eq_idx_for_lvar t x = eq_idx_for_lvar_aux t x zero_nata;

fun eq_for_lvar_code t v = nth t (eq_idx_for_lvar t v);

fun pivot_eq e y =
  let
    val cy = coeffa (rhs e) y;
  in
    (y, plus_linear_poly
          (scaleRat_linear_poly (divide_rata (uminus_rata one_rata) cy)
            (minus_linear_poly (rhs e) (scaleRat_linear_poly cy (vara y))))
          (scaleRat_linear_poly (divide_rata one_rata cy) (vara (lhs e))))
  end;

fun pivot_tableau_code x_i x_j t =
  let
    val eq = eq_for_lvar_code t x_i;
    val eqa = pivot_eq eq x_j;
  in
    map (fn e =>
          (if equal_nata (lhs e) (lhs eq) then eqa
            else subst_var_eq_code x_j (rhs eqa) e))
      t
  end;

fun t_update ta (State_ext (t, b_l, b_u, v, u, more)) =
  State_ext (ta t, b_l, b_u, v, u, more);

fun pivot_code A_ x_i x_j s =
  t_update (fn _ => pivot_tableau_code x_i x_j (t s)) s;

fun pivot_and_update_code A_ x_i x_j c s =
  update_code A_ x_i c (pivot_code A_ x_i x_j s);

fun min_rvar_incdec_eq A_ dir s eq =
  min_satisfying linorder_nat
    (fn x =>
      less_rat zero_rata (coeffa (rhs eq) x) andalso
        ltub (lt ((linorder_linordered_rational_vector o
                    linordered_rational_vector_lrv)
                   A_)
               dir)
          (map2fun
            ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add o
               ab_group_add_rational_vector o
               rational_vector_ordered_rational_vector o
               ordered_rational_vector_linordered_rational_vector o
               linordered_rational_vector_lrv)
              A_)
            (v s) x)
          (ub ((linorder_linordered_rational_vector o
                 linordered_rational_vector_lrv)
                A_)
            dir s x) orelse
        less_rat (coeffa (rhs eq) x) zero_rata andalso
          gtlb (lt ((linorder_linordered_rational_vector o
                      linordered_rational_vector_lrv)
                     A_)
                 dir)
            (map2fun
              ((zero_monoid_add o monoid_add_group_add o
                 group_add_ab_group_add o ab_group_add_rational_vector o
                 rational_vector_ordered_rational_vector o
                 ordered_rational_vector_linordered_rational_vector o
                 linordered_rational_vector_lrv)
                A_)
              (v s) x)
            (lb ((linorder_linordered_rational_vector o
                   linordered_rational_vector_lrv)
                  A_)
              dir s x))
    (vars_list (rhs eq));

fun check_codea A_ dir x_i s =
  let
    val l_i =
      the (lb ((linorder_linordered_rational_vector o
                 linordered_rational_vector_lrv)
                A_)
            dir s x_i);
  in
    (case min_rvar_incdec_eq A_ dir s (eq_for_lvar_code (t s) x_i)
      of NONE => u_update (fn _ => true) s
      | SOME x_j => pivot_and_update_code A_ x_i x_j l_i s)
  end;

fun lt_lbound A_ c b =
  ltlb (less ((ord_preorder o preorder_order o order_linorder) A_)) c b;

fun check_code (A1_, A2_) s =
  (if u s then s
    else (case min_lvar_not_in_bounds
                 ((zero_monoid_add o monoid_add_group_add o
                    group_add_ab_group_add o ab_group_add_rational_vector o
                    rational_vector_ordered_rational_vector o
                    ordered_rational_vector_linordered_rational_vector o
                    linordered_rational_vector_lrv)
                    A1_,
                   A2_,
                   (linorder_linordered_rational_vector o
                     linordered_rational_vector_lrv)
                     A1_)
                 s
           of NONE => s
           | SOME x_i =>
             let
               val dir =
                 (if lt_lbound
                       ((linorder_linordered_rational_vector o
                          linordered_rational_vector_lrv)
                         A1_)
                       (map2fun
                         ((zero_monoid_add o monoid_add_group_add o
                            group_add_ab_group_add o
                            ab_group_add_rational_vector o
                            rational_vector_ordered_rational_vector o
                            ordered_rational_vector_linordered_rational_vector o
                            linordered_rational_vector_lrv)
                           A1_)
                         (v s) x_i)
                       (b_l s x_i)
                   then positive
                          ((linorder_linordered_rational_vector o
                             linordered_rational_vector_lrv)
                            A1_)
                   else negative
                          ((linorder_linordered_rational_vector o
                             linordered_rational_vector_lrv)
                            A1_));
             in
               check_code (A1_, A2_) (check_codea A1_ dir x_i s)
             end));

fun assert_all_state_code (A1_, A2_) t ats =
  check_code (A1_, A2_)
    (assert_bound_loop_code (A1_, A2_) ats
      (init_state
        ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add o
           ab_group_add_rational_vector o
           rational_vector_ordered_rational_vector o
           ordered_rational_vector_linordered_rational_vector o
           linordered_rational_vector_lrv)
          A1_)
        t));

fun assert_all_code (A1_, A2_) t asa =
  let
    val s = assert_all_state_code (A1_, A2_) t asa;
  in
    (if u s then (false, NONE) else (true, SOME (v s)))
  end;

fun max_var lp =
  let
    val vl = vars_list lp;
  in
    (if null vl then zero_nata else foldl (max ord_nat) (hda vl) (tla vl))
  end;

fun start_fresh_variable [] = zero_nata
  | start_fresh_variable (h :: t) =
    max ord_nat (plus_nata (max_var (poly h)) one_nata)
      (start_fresh_variable t);

fun tableau (Istate_ext (firstFreshVariable, tableau, atoms, more)) = tableau;

fun atoms (Istate_ext (firstFreshVariable, tableau, atoms, more)) = atoms;

fun is_monom l = equal_nata (size_list (vars_list l)) one_nata;

fun monom_var l = max_var l;

fun monom_coeff l = coeffa l (monom_var l);

fun monom_to_atom (LEQ_ns (l, r)) =
  (if less_rat (monom_coeff l) zero_rata
    then Geq (monom_var l, scaleRat_QDeltaa (inverse_rata (monom_coeff l)) r)
    else Leq (monom_var l, scaleRat_QDeltaa (inverse_rata (monom_coeff l)) r))
  | monom_to_atom (GEQ_ns (l, r)) =
    (if less_rat (monom_coeff l) zero_rata
      then Leq (monom_var l, scaleRat_QDeltaa (inverse_rata (monom_coeff l)) r)
      else Geq (monom_var l,
                 scaleRat_QDeltaa (inverse_rata (monom_coeff l)) r));

fun qdelta_constraint_to_atom (LEQ_ns (l, r)) v =
  (if is_monom l then monom_to_atom (LEQ_ns (l, r)) else Leq (v, r))
  | qdelta_constraint_to_atom (GEQ_ns (l, r)) v =
    (if is_monom l then monom_to_atom (GEQ_ns (l, r)) else Geq (v, r));

fun firstFreshVariable (Istate_ext (firstFreshVariable, tableau, atoms, more)) =
  firstFreshVariable;

fun qdelta_constraint_to_eq (LEQ_ns (l, r)) v = (v, l)
  | qdelta_constraint_to_eq (GEQ_ns (l, r)) v = (v, l);

fun preprocessa [] v = Istate_ext (v, [], [], ())
  | preprocessa (h :: t) v =
    let
      val s = preprocessa t v;
      val va = firstFreshVariable s;
      val ta = tableau s;
      val a = atoms s;
    in
      Istate_ext
        ((if is_monom (poly h) then va else plus_nata va one_nata),
          (if is_monom (poly h) then ta
            else qdelta_constraint_to_eq h va :: ta),
          qdelta_constraint_to_atom h va :: a, ())
    end;

fun preprocess l = let
                     val start = start_fresh_variable l;
                     val is = preprocessa l start;
                   in
                     (tableau is, atoms is)
                   end;

fun solve_exec_ns_code s = let
                             val a = preprocess s;
                             val (aa, b) = a;
                           in
                             assert_all_code (lrv_QDelta, equal_QDelta) aa b
                           end;

fun solve_exec_code cs =
  let
    val csa = to_ns cs;
  in
    (case solve_exec_ns_code csa
      of (true, v) => (true, SOME (from_ns (the v) csa))
      | (false, _) => (false, NONE))
  end;

fun simplex cs = snd (solve_exec_code cs);

fun tcapI A_ B_ uu (Var uv) = GCHole
  | tcapI A_ B_ r (Fun (f, ts)) =
    let
      val h = GCFun (f, map (tcapI A_ B_ r) ts);
    in
      (if list_ex (fn ra => matchb A_ B_ h (fst ra)) r then GCHole else h)
    end;

fun sharp_term shp (Var x) = Var x
  | sharp_term shp (Fun (f, ss)) = Fun (shp f, ss);

fun hvf_top A_ a n (Fun (f, ts)) =
  (if eq A_ f a andalso equal_nata (size_list ts) n then not (is_Var (hda ts))
    else true)
  | hvf_top A_ a n (Var uu) = false;

fun status (Abs_status x) = x;

fun af_wpo pi sigma f =
  sup_seta (ceq_nat, ccompare_nat)
    (set (ceq_nat, ccompare_nat, set_impl_nat) (status sigma f)) (pi f);

fun lex_ext_unbounded f [] [] = (false, true)
  | lex_ext_unbounded f (uu :: uv) [] = (true, true)
  | lex_ext_unbounded f [] (uw :: ux) = (false, false)
  | lex_ext_unbounded f (a :: asa) (b :: bs) =
    (case f a b of (true, _) => (true, true)
      | (false, true) => lex_ext_unbounded f asa bs
      | (false, false) => (false, false));

fun wpo_ub B_ pr prl cS cNS sigma s t =
  (case s
    of Var x =>
      (false,
        (case t of Var a => eq B_ x a
          | Fun (g, ts) =>
            cNS s t andalso
              (null (status sigma (g, size_list ts)) andalso
                prl (g, size_list ts))))
    | Fun (f, ss) =>
      (if cS s t then (true, true)
        else let
               val ff = (f, size_list ss);
               val sf = status sigma ff;
             in
               (if cNS s t
                 then (if list_ex
                            (fn i =>
                              snd (wpo_ub B_ pr prl cS cNS sigma (nth ss i) t))
                            sf
                        then (true, true)
                        else (case t of Var _ => (false, false)
                               | Fun (g, ts) =>
                                 let
                                   val gg = (g, size_list ts);
                                   val sg = status sigma gg;
                                   val (prs, prns) = pr ff gg;
                                 in
                                   (if prns andalso
 list_all (fn j => fst (wpo_ub B_ pr prl cS cNS sigma s (nth ts j))) sg
                                     then (if prs then (true, true)
    else lex_ext_unbounded (wpo_ub B_ pr prl cS cNS sigma) (map (nth ss) sf)
           (map (nth ts) sg))
                                     else (false, false))
                                 end))
                 else (false, false))
             end));

fun parse_xml p xml =
  (case xml_take p xml_return ([xml], ([], (false, ([], []))))
    of Inl a => let
                  val Fatal aa = a;
                in
                  Inl aa
                end
    | Inr a => Inr a);

fun cstep (A1_, A2_) (B1_, B2_) xml2name x =
  xml_do
    [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a", #"l", #"R",
      #"e", #"w", #"r", #"i", #"t", #"e", #"S", #"t", #"e", #"p"]
    (xml_take (crule (show_lab A2_ B2_) xml2name [#"r", #"u", #"l", #"e"])
      (fn a =>
        xml_take pos
          (fn b =>
            xml_take (substa (show_lab A2_ B2_) xml2name)
              (fn c =>
                xml_take
                  (xml_do [#"s", #"o", #"u", #"r", #"c", #"e"]
                    (xml_take (term (show_lab A2_ B2_) xml2name)
                      (fn xa => xml_return (id xa))))
                  (fn d =>
                    xml_take
                      (xml_do [#"t", #"a", #"r", #"g", #"e", #"t"]
                        (xml_take (term (show_lab A2_ B2_) xml2name)
                          (fn xa => xml_return (id xa))))
                      (fn e =>
                        xml_take
                          (xml_do
                            [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o",
                              #"n", #"s"]
                            (xml_take_many_sub [] zero_nata Infinity_enat
                              (csteps (A1_, A2_) (B1_, B2_) xml2name)
                              (fn aa => xml_return (id aa))))
                          (fn f =>
                            xml_return
                              (Cstep_step
                                (a, b, mk_subst (equal_list equal_char) Var c,
                                  d, e, f)))))))))
    x
and csteps (A1_, A2_) (B1_, B2_) xml2name x =
  xml_do
    [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a", #"l", #"R",
      #"e", #"w", #"r", #"i", #"t", #"i", #"n", #"g", #"S", #"e", #"q", #"u",
      #"e", #"n", #"c", #"e"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (cstep (A1_, A2_) (B1_, B2_) xml2name) (fn a => xml_return (id a)))
    x;

fun estep A_ xml2name =
  xml_do
    [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"S", #"t", #"e", #"p"]
    (xml_take pos
      (fn p =>
        xml_take (rule A_ xml2name)
          (fn r =>
            xml_take
              (xml_or
                (xml_leaf [#"l", #"e", #"f", #"t", #"R", #"i", #"g", #"h", #"t"]
                  true)
                (xml_leaf [#"r", #"i", #"g", #"h", #"t", #"L", #"e", #"f", #"t"]
                  false))
              (fn b =>
                xml_take (term A_ xml2name)
                  (fn t => xml_return (p, (r, (b, t))))))));

fun state x = xml_text [#"s", #"t", #"a", #"t", #"e"] x;

fun case_sum_bot f g h (Sumbot p) = (case p of Inl a => g a | Inr a => h a);

fun xmlt2 xmlt x =
  let
    val (xml, (_, (_, (_, p)))) = x;
  in
    case_sum_bot (raise Fail "undefined")
      (fn err =>
        xml_error (show_list (show_list show_char)) err ([fst x], snd x))
      (fn v => xml_return v ([], ([], (false, ([], p))))) (xmlt xml)
  end;

fun isOK m = (case m of Inl _ => false | Inr _ => true);

fun mapM f [] = Inr []
  | mapM f (x :: xs) =
    bindb (f x) (fn y => bindb (mapM f xs) (fn ys => Inr (y :: ys)));

fun form_not (Atom a) = NegAtom a
  | form_not (NegAtom a) = Atom a
  | form_not (Conjunction phi_s) = Disjunction (map form_not phi_s)
  | form_not (Disjunction phi_s) = Conjunction (map form_not phi_s);

fun get_Atom (Atom a) = a
  | get_Atom (NegAtom a) = a;

fun simplify (Disjunction (phi :: phi_s)) =
  form_or (simplify phi) (simplify (Disjunction phi_s))
  | simplify (Conjunction [phi]) = simplify phi
  | simplify (Conjunction (phi :: v :: va)) =
    form_and (simplify phi) (simplify (Conjunction (v :: va)))
  | simplify (Atom v) = Atom v
  | simplify (NegAtom v) = NegAtom v
  | simplify (Conjunction []) = Conjunction []
  | simplify (Disjunction []) = Disjunction [];

fun gen_ball it m p = it m (fn x => x) (fn x => fn _ => p x) true;

fun gen_balla it s p = it s (fn x => x) (fn x => fn _ => p x) true;

fun gen_pick it s =
  the (it s (fn a => (case a of NONE => true | SOME _ => false))
         (fn x => fn _ => SOME x)
        NONE);

fun one (Partial_object_ext (carrier, Monoid_ext (mult, one, more))) = one;

fun base (f, h) = f;

fun lift h f = (f, h);

fun add_vars_term (Var x) xs = x :: xs
  | add_vars_term (Fun (uu, ts)) xs = foldr add_vars_term ts xs;

fun vars_term_list t = add_vars_term t [];

fun roof (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) (l, r) =
  let
    val xs = vars_term_list r;
  in
    (fn t =>
      let
        val xt = vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) t;
      in
        list_all (fn x => member (B3_, ccompare_cproper_interval B4_) x xt) xs
      end)
  end;

fun matches A_ B_ (C1_, C2_, C3_) t p =
  (case match_list (C1_, C2_, C3_) A_ B_ (fn _ => t) [(p, t)] of NONE => false
    | SOME _ => true);

fun smult_mat A_ aa a = map_mat (times A_ aa) a;

fun rep_multimap (Abs_multimap x) = x;

fun option_list_to_list NONE = []
  | option_list_to_list (SOME asa) = asa;

fun insertd (B1_, B2_) xb xc =
  Abs_multimap let
                 val (f, (m, all)) = rep_multimap xc;
                 val k = f xb;
                 val old = option_list_to_list (lookupb (B1_, B2_) m k);
                 val new = xb :: old;
               in
                 (f, (updateb (B1_, B2_) k new m, xb :: all))
               end;

fun lookupc (A1_, A2_) xa =
  let
    val (_, (m, _)) = rep_multimap xa;
  in
    (fn k => option_list_to_list (lookupb (A1_, A2_) m k))
  end;

fun valuesa xa = let
                   val (_, (_, all)) = rep_multimap xa;
                 in
                   all
                 end;

fun replicate_mset A_ n x = funpow n (add_mset A_ x) zero_multiseta;

fun minus_multiset _ _ _ = raise Fail
  "Multiset.minus_multiset_inst.minus_multiset";

fun inf_subset_mset A_ a b = minus_multiset A_ a (minus_multiset A_ a b);

fun fold_impl fna e ((a, n) :: ms) = fold_impl fna (fna a n e) ms
  | fold_impl fna e [] = e;

fun foldd f e al = fold_impl f e (impl_ofa al);

fun set_mset (A1_, A2_, A3_) (Bag ms) =
  foldd (fn a => fn n =>
          (if equal_nata n zero_nata then (fn m => m)
            else inserta (A1_, A2_) a))
    (bot_set (A1_, A2_, A3_)) ms;

fun multeqp (A1_, A2_, A3_, A4_) p n m =
  let
    val z = inf_subset_mset A3_ m n;
    val x = minus_multiset A3_ m z;
    val y = minus_multiset A3_ n z;
  in
    ball (A1_, A2_) (set_mset (A1_, A2_, A4_) y)
      (fn ya => bex (A1_, A2_) (set_mset (A1_, A2_, A4_) x) (p ya))
  end;

fun is_Inr (Inr uu) = true
  | is_Inr (Inl uv) = false;

fun one_monom A_ = Abs_monom [];

fun poly_split (A1_, A2_) B_ m p =
  (case extract (fn (n, _) => eq (equal_monom (A1_, A2_)) m n) p
    of NONE => (zerob B_, p) | SOME (p1, ((_, c), p2)) => (c, p1 @ p2));

fun max_v (A1_, A2_) v i fs =
  max A2_ v
    (foldr
      (fn f => fn m =>
        max A2_ m
          (fst (poly_split (equal_nat, linorder_nat) A1_
                 (one_monom linorder_nat) (i f))))
      fs (zerob A1_));

fun relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (Set_Monad xs6)
  (DList_set dxs4) =
  (case ceq B1_
    of NONE =>
      (raise Fail "relcomp Set_Monad DList_set: ceq1 = None")
        (fn _ =>
          relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (Set_Monad xs6)
            (DList_set dxs4))
    | SOME eq =>
      (case ceq C1_
        of NONE =>
          (raise Fail "relcomp Set_Monad DList_set: ceq2 = None")
            (fn _ =>
              relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (Set_Monad xs6)
                (DList_set dxs4))
        | SOME _ =>
          fold (fn (x, y) =>
                 foldc (ceq_prod B1_ C1_)
                   (fn (ya, z) => fn a =>
                     (if eq y ya
                       then inserta (ceq_prod A1_ C1_, ccompare_prod A2_ C2_)
                              (x, z) a
                       else a))
                   dxs4)
            xs6 (bot_set
                  (ceq_prod A1_ C1_, ccompare_prod A2_ C2_,
                    set_impl_prod A3_ C3_))))
  | relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (DList_set dxs3)
    (Set_Monad xs5) =
    (case ceq A1_
      of NONE =>
        (raise Fail "relcomp DList_set Set_Monad: ceq1 = None")
          (fn _ =>
            relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (DList_set dxs3)
              (Set_Monad xs5))
      | SOME _ =>
        (case ceq B1_
          of NONE =>
            (raise Fail "relcomp DList_set Set_Monad: ceq2 = None")
              (fn _ =>
                relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_)
                  (DList_set dxs3) (Set_Monad xs5))
          | SOME eq =>
            foldc (ceq_prod A1_ B1_)
              (fn (x, y) =>
                fold (fn (ya, z) => fn a =>
                       (if eq y ya
                         then inserta (ceq_prod A1_ C1_, ccompare_prod A2_ C2_)
                                (x, z) a
                         else a))
                  xs5)
              dxs3
              (bot_set
                (ceq_prod A1_ C1_, ccompare_prod A2_ C2_,
                  set_impl_prod A3_ C3_))))
  | relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (Set_Monad xs4)
    (RBT_set rbt5) =
    (case ccompare C2_
      of NONE =>
        (raise Fail "relcomp Set_Monad RBT_set: ccompare1 = None")
          (fn _ =>
            relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (Set_Monad xs4)
              (RBT_set rbt5))
      | SOME _ =>
        (case ccompare B2_
          of NONE =>
            (raise Fail "relcomp Set_Monad RBT_set: ccompare2 = None")
              (fn _ =>
                relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_)
                  (Set_Monad xs4) (RBT_set rbt5))
          | SOME c_b =>
            fold (fn (x, y) =>
                   foldb (ccompare_prod B2_ C2_)
                     (fn (ya, z) => fn a =>
                       (if not (equal_order (c_b y ya) Eq) then a
                         else inserta (ceq_prod A1_ C1_, ccompare_prod A2_ C2_)
                                (x, z) a))
                     rbt5)
              xs4 (bot_set
                    (ceq_prod A1_ C1_, ccompare_prod A2_ C2_,
                      set_impl_prod A3_ C3_))))
  | relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (RBT_set rbt1)
    (Set_Monad xs3) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "relcomp RBT_set Set_Monad: ccompare1 = None")
          (fn _ =>
            relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (RBT_set rbt1)
              (Set_Monad xs3))
      | SOME _ =>
        (case ccompare B2_
          of NONE =>
            (raise Fail "relcomp RBT_set Set_Monad: ccompare2 = None")
              (fn _ =>
                relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_)
                  (RBT_set rbt1) (Set_Monad xs3))
          | SOME c_b =>
            foldb (ccompare_prod A2_ B2_)
              (fn (x, y) =>
                fold (fn (ya, z) => fn a =>
                       (if not (equal_order (c_b y ya) Eq) then a
                         else inserta (ceq_prod A1_ C1_, ccompare_prod A2_ C2_)
                                (x, z) a))
                  xs3)
              rbt1
              (bot_set
                (ceq_prod A1_ C1_, ccompare_prod A2_ C2_,
                  set_impl_prod A3_ C3_))))
  | relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (Set_Monad xs1)
    (Set_Monad xs2) =
    (case ceq B1_
      of NONE =>
        (raise Fail "relcomp Set_Monad Set_Monad: ceq = None")
          (fn _ =>
            relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (Set_Monad xs1)
              (Set_Monad xs2))
      | SOME eq =>
        fold (fn (x, y) =>
               fold (fn (ya, z) => fn a =>
                      (if eq y ya
                        then inserta (ceq_prod A1_ C1_, ccompare_prod A2_ C2_)
                               (x, z) a
                        else a))
                 xs2)
          xs1 (bot_set
                (ceq_prod A1_ C1_, ccompare_prod A2_ C2_,
                  set_impl_prod A3_ C3_)))
  | relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (DList_set dxs3)
    (DList_set dxs4) =
    (case ceq A1_
      of NONE =>
        (raise Fail "relcomp DList_set DList_set: ceq1 = None")
          (fn _ =>
            relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (DList_set dxs3)
              (DList_set dxs4))
      | SOME _ =>
        (case ceq B1_
          of NONE =>
            (raise Fail "relcomp DList_set DList_set: ceq2 = None")
              (fn _ =>
                relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_)
                  (DList_set dxs3) (DList_set dxs4))
          | SOME eq =>
            (case ceq C1_
              of NONE =>
                (raise Fail "relcomp DList_set DList_set: ceq3 = None")
                  (fn _ =>
                    relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_)
                      (DList_set dxs3) (DList_set dxs4))
              | SOME _ =>
                foldc (ceq_prod A1_ B1_)
                  (fn (x, y) =>
                    foldc (ceq_prod B1_ C1_)
                      (fn (ya, z) => fn a =>
                        (if eq y ya
                          then inserta (ceq_prod A1_ C1_, ccompare_prod A2_ C2_)
                                 (x, z) a
                          else a))
                      dxs4)
                  dxs3
                  (bot_set
                    (ceq_prod A1_ C1_, ccompare_prod A2_ C2_,
                      set_impl_prod A3_ C3_)))))
  | relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (DList_set dxs2)
    (RBT_set rbt4) =
    (case ceq A1_
      of NONE =>
        (raise Fail "relcomp DList_set RBT_set: ceq1 = None")
          (fn _ =>
            relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (DList_set dxs2)
              (RBT_set rbt4))
      | SOME _ =>
        (case ccompare B2_
          of NONE =>
            (raise Fail "relcomp DList_set RBT_set: ceq2 = None")
              (fn _ =>
                relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_)
                  (DList_set dxs2) (RBT_set rbt4))
          | SOME _ =>
            (case ceq B1_
              of NONE =>
                (raise Fail "relcomp DList_set RBT_set: ccompare2 = None")
                  (fn _ =>
                    relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_)
                      (DList_set dxs2) (RBT_set rbt4))
              | SOME eq =>
                (case ccompare C2_
                  of NONE =>
                    (raise Fail "relcomp DList_set RBT_set: ccompare3 = None")
                      (fn _ =>
                        relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_)
                          (DList_set dxs2) (RBT_set rbt4))
                  | SOME _ =>
                    foldc (ceq_prod A1_ B1_)
                      (fn (x, y) =>
                        foldb (ccompare_prod B2_ C2_)
                          (fn (ya, z) => fn a =>
                            (if eq y ya
                              then inserta
                                     (ceq_prod A1_ C1_, ccompare_prod A2_ C2_)
                                     (x, z) a
                              else a))
                          rbt4)
                      dxs2
                      (bot_set
                        (ceq_prod A1_ C1_, ccompare_prod A2_ C2_,
                          set_impl_prod A3_ C3_))))))
  | relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (RBT_set rbt3)
    (DList_set dxs1) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "relcomp RBT_set DList_set: ccompare1 = None")
          (fn _ =>
            relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (RBT_set rbt3)
              (DList_set dxs1))
      | SOME _ =>
        (case ccompare B2_
          of NONE =>
            (raise Fail "relcomp RBT_set DList_set: ccompare2 = None")
              (fn _ =>
                relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_)
                  (RBT_set rbt3) (DList_set dxs1))
          | SOME _ =>
            (case ceq B1_
              of NONE =>
                (raise Fail "relcomp RBT_set DList_set: ceq2 = None")
                  (fn _ =>
                    relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_)
                      (RBT_set rbt3) (DList_set dxs1))
              | SOME eq =>
                (case ceq C1_
                  of NONE =>
                    (raise Fail "relcomp RBT_set DList_set: ceq3 = None")
                      (fn _ =>
                        relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_)
                          (RBT_set rbt3) (DList_set dxs1))
                  | SOME _ =>
                    foldb (ccompare_prod A2_ B2_)
                      (fn (x, y) =>
                        foldc (ceq_prod B1_ C1_)
                          (fn (ya, z) => fn a =>
                            (if eq y ya
                              then inserta
                                     (ceq_prod A1_ C1_, ccompare_prod A2_ C2_)
                                     (x, z) a
                              else a))
                          dxs1)
                      rbt3
                      (bot_set
                        (ceq_prod A1_ C1_, ccompare_prod A2_ C2_,
                          set_impl_prod A3_ C3_))))))
  | relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (RBT_set rbt1)
    (RBT_set rbt2) =
    (case ccompare A2_
      of NONE =>
        (raise Fail "relcomp RBT_set RBT_set: ccompare1 = None")
          (fn _ =>
            relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_) (RBT_set rbt1)
              (RBT_set rbt2))
      | SOME _ =>
        (case ccompare B2_
          of NONE =>
            (raise Fail "relcomp RBT_set RBT_set: ccompare2 = None")
              (fn _ =>
                relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_)
                  (RBT_set rbt1) (RBT_set rbt2))
          | SOME c_b =>
            (case ccompare C2_
              of NONE =>
                (raise Fail "relcomp RBT_set RBT_set: ccompare3 = None")
                  (fn _ =>
                    relcomp (A1_, A2_, A3_) (B1_, B2_) (C1_, C2_, C3_)
                      (RBT_set rbt1) (RBT_set rbt2))
              | SOME _ =>
                foldb (ccompare_prod A2_ B2_)
                  (fn (x, y) =>
                    foldb (ccompare_prod B2_ C2_)
                      (fn (ya, z) => fn a =>
                        (if not (equal_order (c_b y ya) Eq) then a
                          else inserta (ceq_prod A1_ C1_, ccompare_prod A2_ C2_)
                                 (x, z) a))
                      rbt2)
                  rbt1
                  (bot_set
                    (ceq_prod A1_ C1_, ccompare_prod A2_ C2_,
                      set_impl_prod A3_ C3_)))));

fun max_sls A_ =
  Abs_semilattice_set
    (max ((ord_preorder o preorder_order o order_linorder) A_));

fun shows_lines A_ = shows_sep (shows_prec A_ zero_nata) shows_nl;

fun lp_monom c x =
  LinearPoly
    (if equal_rata c zero_rata then fmempty else fmupd equal_nat x c fmempty);

fun tcapRM2 A_ B_ uu (Var uv) = GCHole
  | tcapRM2 A_ B_ rm (Fun (f, ts)) =
    let
      val h = GCFun (f, map (tcapRM2 A_ B_ rm) ts);
      val n = size_list ts;
    in
      (if list_ex (fn r => matchb A_ B_ h (fst r)) (rm (f, n)) then GCHole
        else h)
    end;

fun tcapRM A_ B_ nlv rm = (if nlv then tcapRM2 A_ B_ rm else (fn _ => GCHole));

fun linear_term_impl (A1_, A2_) xs (Var x) =
  (if member (A1_, A2_) x xs then NONE else SOME (inserta (A1_, A2_) x xs))
  | linear_term_impl (A1_, A2_) xs (Fun (uu, [])) = SOME xs
  | linear_term_impl (A1_, A2_) xs (Fun (f, t :: ts)) =
    (case linear_term_impl (A1_, A2_) xs t of NONE => NONE
      | SOME ys => linear_term_impl (A1_, A2_) ys (Fun (f, ts)));

fun linear_term (B1_, B2_, B3_) t =
  not (is_none (linear_term_impl (B1_, B2_) (bot_set (B1_, B2_, B3_)) t));

fun funposs_list (Var x) = []
  | funposs_list (Fun (f, ss)) =
    Empty ::
      maps (fn (i, a) => map (fn aa => PCons (i, aa)) a)
        (zip (upt zero_nata (size_list ss)) (map funposs_list ss));

fun ctxt_of_pos_term Empty t = Hole
  | ctxt_of_pos_term (PCons (i, ps)) (Fun (f, ts)) =
    More (f, take i ts, ctxt_of_pos_term ps (nth ts i), drop (suc i) ts);

fun ctxt_apply_term Hole s = s
  | ctxt_apply_term (More (f, ss1, c, ss2)) s =
    Fun (f, ss1 @ ctxt_apply_term c s :: ss2);

fun poss_list (Var x) = [Empty]
  | poss_list (Fun (f, ss)) =
    Empty ::
      maps (fn (i, a) => map (fn aa => PCons (i, aa)) a)
        (zip (upt zero_nata (size_list ss)) (map poss_list ss));

fun rewrite A_ (B1_, B2_, B3_) r s =
  maps (fn (l, ra) =>
         maps (fn p =>
                (case match A_ (B1_, B2_, B3_) (subt_at s p) l of NONE => []
                  | SOME sigma =>
                    [ctxt_apply_term (ctxt_of_pos_term p s)
                       (subst_apply_term ra sigma)]))
           (poss_list s))
    r;

fun hvf_term A_ a t =
  (case unapp A_ a t of (Var _, ts) => null ts
    | (Fun (_, us), ts) => list_all (hvf_term A_ a) (us @ ts));

fun max_list [] = zero_nata
  | max_list (x :: xs) = max ord_nat x (max_list xs);

fun rules A_ xml2name =
  xml_do [#"r", #"u", #"l", #"e", #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat (rule A_ xml2name)
      xml_return);

fun num_children (XML (uu, uv, cs)) = size_list cs
  | num_children (XML_text uw) = zero_nata;

fun string2xml str =
  (case bindc (update_tokens remove_comments)
          (fn _ =>
            bindc parse_node
              (fn xml => bindc (eoi show_char) (fn _ => returna xml)))
          str
    of Inl a => Inl a | Inr (xml, _) => Inr xml);

fun stringa (A1_, A2_) (B1_, B2_) xml2name =
  xml_do [#"s", #"t", #"r", #"i", #"n", #"g"]
    (xml_take_many_sub [] zero_nata Infinity_enat xml2name
      (fn a => xml_return (id a)));

fun oc_srs (A1_, A2_) (B1_, B2_) xml2name =
  xml_do
    [#"o", #"v", #"e", #"r", #"l", #"a", #"p", #"C", #"l", #"o", #"s", #"u",
      #"r", #"e", #"S", #"R", #"S"]
    (xml_take (stringa (A1_, A2_) (B1_, B2_) xml2name)
      (fn a =>
        xml_take (stringa (A1_, A2_) (B1_, B2_) xml2name)
          (fn b => xml_return (a, b))));

fun rsteps A_ xml2name =
  xml_do
    [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #"S", #"e", #"q", #"u", #"e",
      #"n", #"c", #"e"]
    (xml_take
      (xml_do [#"s", #"t", #"a", #"r", #"t", #"T", #"e", #"r", #"m"]
        (xml_take (term A_ xml2name) (fn x => xml_return (id x))))
      (fn start =>
        xml_take_many_sub [] zero_nata Infinity_enat (rstep A_ xml2name)
          (fn steps => xml_return (start, steps))));

fun check b e = (if b then Inr () else Inl e);

fun degree (Comp_Poly d) = d;

fun show_hint A_ Default = [#" ", #"a", #"u", #"t", #"o"]
  | show_hint A_ (Base raw) = [#" "] @ shows_prec A_ zero_nata raw []
  | show_hint A_ (Distribute (i, hints)) =
    [#" ", #"D", #"i", #"s", #"t", #"r", #"i", #"b", #"u", #"t", #"e", #" "] @
      shows_prec_nat zero_nata i [] @
        [#" ", #"["] @ maps (show_hint A_) hints @ [#" ", #"]"]
  | show_hint A_ (LexStrict hints) =
    [#" ", #"L", #"e", #"x", #"S", #"t", #"r", #"i", #"c", #"t", #"["] @
      maps (show_hint A_) hints @ [#" ", #"]"]
  | show_hint A_ (LexWeak hints) =
    [#" ", #"L", #"e", #"x", #"W", #"e", #"a", #"k", #"["] @
      maps (show_hint A_) hints @ [#" ", #"]"]
  | show_hint A_ (Erase (i, hint)) =
    [#" ", #"E", #"r", #"a", #"s", #"e", #" "] @
      shows_prec_nat zero_nata i [] @
        [#" ", #"["] @ show_hint A_ hint @ [#" ", #"]"];

fun gen_image it1 emp2 ins2 f s1 =
  it1 s1 (fn _ => true) (fn x => ins2 (f x)) emp2;

fun catch_errora m f = (case m of Inl a => f a | Inr a => Inr a);

fun check_no_edge ss g m n =
  check (not (g (m, n)))
    (shows_string [#"e", #"d", #"g", #"e", #" ", #"f", #"r", #"o", #"m", #" "] o
      (ss m o (shows_string [#" ", #"t", #"o", #" "] o ss n)));

fun forallM f [] = Inr ()
  | forallM f (x :: xs) =
    bindb (catch_errora (f x) (fn xa => Inl (x, xa))) (fn _ => forallM f xs);

fun check_edges ss g c d =
  catch_errora
    (forallM
      (fn n =>
        catch_errora (forallM (check_no_edge ss g n) d) (fn x => Inl (snd x)))
      c)
    (fn x => Inl (snd x));

fun mult (Partial_object_ext (carrier, Monoid_ext (mult, one, more))) = mult;

fun comp2eq cmp a b =
  (case cmp a b of LESS => false | EQUAL => true | GREATER => false);

fun prec_ext A_ prwm =
  (fn f => fn g =>
    (case prwm f of NONE => (false, eq A_ f g)
      | SOME pf =>
        (case prwm g of NONE => (true, true)
          | SOME pg =>
            (less_nat (fst pg) (fst pf), less_eq_nat (fst pg) (fst pf)))));

fun assertion (Lts_ext (initial, transition_rules, assertion, more)) =
  assertion;

fun map_of_total (A1_, A2_, A3_) err xys =
  let
    val m = of_alist (A1_, A2_, A3_) xys;
  in
    (fn x =>
      (case lookupb (A1_, A2_) m x
        of NONE => (raise Fail (String.implode (err x))) (fn _ => the NONE)
        | SOME y => y))
  end;

fun transition_of (E1_, E2_, E3_, E4_) pi =
  map_of_total (E1_, E2_, E3_)
    (fn a =>
      [#"a", #"c", #"c", #"e", #"s", #"s", #" ", #"t", #"o", #" ", #"n", #"o",
        #"n", #"-", #"e", #"x", #"i", #"s", #"t", #"i", #"n", #"g", #" ", #"t",
        #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n", #" "] @
        shows_prec E4_ zero_nata a [] @
          [#"\n", #"a", #"v", #"a", #"i", #"l", #"a", #"b", #"l", #"e", #" ",
            #"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n", #"s",
            #":", #"\n"] @
            shows_prec_list E4_ zero_nata (map fst (transitions_impl pi)) [])
    (transitions_impl pi);

fun matcha x = (fn _ => fn _ => true) x;

fun span p (x :: xs) = (if p x then let
                                      val a = span p xs;
                                      val (ys, aa) = a;
                                    in
                                      (x :: ys, aa)
                                    end
                         else ([], x :: xs))
  | span uu [] = ([], []);

fun fresh_strings_list name offset used n =
  take n
    (filtera
      (fn s =>
        not (membera (equal_list equal_char)
              (remdups (equal_list equal_char) used) s))
      (map (fn i => name @ shows_prec_nat zero_nata (plus_nata i offset) [])
        (upt zero_nata
          (plus_nata n (size_list (remdups (equal_list equal_char) used))))));

fun fresh_string pre =
  (fn s => hda (fresh_strings_list pre one_nata s one_nata));

fun mapMa f [] = SOME []
  | mapMa f (x :: xs) =
    bind (f x) (fn y => bind (mapMa f xs) (fn ys => SOME (y :: ys)));

fun equal_order_tag Lex Mul = false
  | equal_order_tag Mul Lex = false
  | equal_order_tag Mul Mul = true
  | equal_order_tag Lex Lex = true;

fun any_nstri_efficient_m f [] m = (false, m)
  | any_nstri_efficient_m f (a :: asa) m =
    let
      val aa = f a m;
      val (ab, b) = aa;
    in
      let
        val (_, ns) = ab;
      in
        (fn ma => (if ns then (true, ma) else any_nstri_efficient_m f asa ma))
      end
        b
    end;

fun all_stri_efficient_m f [] m = (true, m)
  | all_stri_efficient_m f (a :: asa) m =
    let
      val aa = f a m;
      val (ab, b) = aa;
    in
      let
        val (s, _) = ab;
      in
        (fn ma => (if s then all_stri_efficient_m f asa ma else (false, ma)))
      end
        b
    end;

fun filter_not_stri_efficient_m_aux f [] bs m = (bs, m)
  | filter_not_stri_efficient_m_aux f (a :: asa) bs m =
    let
      val b = f a m;
      val (ba, c) = b;
    in
      let
        val (s, _) = ba;
      in
        (fn ma =>
          (if s then filter_not_stri_efficient_m_aux f asa bs ma
            else filter_not_stri_efficient_m_aux f asa (a :: bs) ma))
      end
        c
    end;

fun filter_not_stri_efficient_m f asa m =
  let
    val a = filter_not_stri_efficient_m_aux f asa [] m;
    val (ys, aa) = a;
  in
    (rev ys, aa)
  end;

fun mul_ext_efficient_m f [] [] m = ((false, true), m)
  | mul_ext_efficient_m f [] (v :: va) m = ((false, false), m)
  | mul_ext_efficient_m f (v :: va) [] m = ((true, true), m)
  | mul_ext_efficient_m f (v :: va) (y :: ys) m =
    mul_ex_dom_efficient_m f (v :: va) [] y ys m
and mul_ex_dom_efficient_m f [] xs y ys m = ((false, false), m)
  | mul_ex_dom_efficient_m f (x :: xsa) xs y ys m =
    let
      val a = f x y m;
      val (aa, b) = a;
    in
      let
        val (s, ns) = aa;
      in
        (fn ma =>
          (if s then let
                       val (ysa, m2) = filter_not_stri_efficient_m (f x) ys ma;
                       val ab = mul_ext_efficient_m f (xsa @ xs) ysa m2;
                       val (ac, ba) = ab;
                     in
                       let
                         val (_, nsa) = ac;
                       in
                         (fn m3 =>
                           (if nsa then ((true, true), m3)
                             else mul_ex_dom_efficient_m f xsa (x :: xs) y ys
                                    m3))
                       end
                         ba
                     end
            else (if ns
                   then let
                          val ab = mul_ext_efficient_m f (xsa @ xs) ys ma;
                          val (ac, ba) = ab;
                        in
                          let
                            val (s2, ns2) = ac;
                          in
                            (fn m4 =>
                              (if s2 then ((true, true), m4)
                                else let
                                       val ad =
 mul_ex_dom_efficient_m f xsa (x :: xs) y ys m4;
                                       val (ae, bb) = ad;
                                     in
                                       let
 val (s3, ns3) = ae;
                                       in
 (fn m5 => (if s3 then ((true, true), m5) else ((false, ns2 orelse ns3), m5)))
                                       end
 bb
                                     end))
                          end
                            ba
                        end
                   else mul_ex_dom_efficient_m f xsa (x :: xs) y ys ma)))
      end
        b
    end;

fun lex_ext_efficient_m f [] [] m = ((false, true), m)
  | lex_ext_efficient_m f (uu :: uv) [] m = ((true, true), m)
  | lex_ext_efficient_m f [] (uw :: ux) m = ((false, false), m)
  | lex_ext_efficient_m f (a :: asa) (b :: bs) m =
    let
      val aa = f a b m;
      val (ab, ba) = aa;
    in
      let
        val (s, ns) = ab;
      in
        (fn ma =>
          (if s then ((true, true), ma)
            else (if ns then lex_ext_efficient_m f asa bs ma
                   else ((false, false), ma))))
      end
        ba
    end;

fun lookupe (Memory_ext (empty, lookup, store, more)) = lookup;

fun store (Memory_ext (empty, lookup, store, more)) = store;

fun diag_l (a, b) = ((a, a), b);

fun rpo_efficient_m C_ model pr tag s t m =
  (case lookupe model m (s, t)
    of NONE =>
      let
        val (res, res_m) =
          (case (s, t) of (Var x, Var y) => ((false, eq C_ x y), m)
            | (Var _, Fun (g, ts)) =>
              ((false, null ts andalso snd pr (g, zero_nata)), m)
            | (Fun (_, ss), Var y) =>
              diag_l
                (any_nstri_efficient_m
                  (fn sa => rpo_efficient_m C_ model pr tag sa (Var y)) ss m)
            | (Fun (f, ss), Fun (g, ts)) =>
              (case any_nstri_efficient_m
                      (fn sa =>
                        rpo_efficient_m C_ model pr tag sa (Fun (g, ts)))
                      ss m
                of (true, ma) => ((true, true), ma)
                | (false, ma) =>
                  let
                    val maa = size_list ss;
                    val n = size_list ts;
                  in
                    (case fst pr (f, maa) (g, n)
                      of (prs, true) =>
                        (case all_stri_efficient_m
                                (rpo_efficient_m C_ model pr tag (Fun (f, ss)))
                                ts ma
                          of (true, mb) =>
                            (if prs then ((true, true), mb)
                              else let
                                     val cf = tag (f, maa);
                                   in
                                     (if equal_order_tag cf (tag (g, n))
                                       then (if equal_order_tag cf Mul
      then mul_ext_efficient_m (rpo_efficient_m C_ model pr tag) ss ts mb
      else lex_ext_efficient_m (rpo_efficient_m C_ model pr tag) ss ts mb)
                                       else let
      val b = equal_nata n zero_nata;
    in
      ((not (equal_nata maa zero_nata) andalso b, b), mb)
    end)
                                   end)
                          | (false, mb) => ((false, false), mb))
                      | (_, false) => ((false, false), ma))
                  end));
      in
        (res, store model res_m ((s, t), res))
      end
    | SOME v => (v, m));

fun emptyf (Memory_ext (empty, lookup, store, more)) = empty;

fun efficient_rpo_2 A_ B_ pr tag p q =
  fst (rpo_efficient_m B_ (l2m (equal_term A_ B_) (equal_term A_ B_)) pr tag p q
        (emptyf (l2m (equal_term A_ B_) (equal_term A_ B_)) ()));

fun rpo_unbounded_impl A_ B_ = efficient_rpo_2 A_ B_;

fun rpo_unbounded A_ B_ = rpo_unbounded_impl A_ B_;

fun converse (A1_, A2_, A3_) (B1_, B2_, B3_) r =
  image (ceq_prod A1_ B1_, ccompare_prod A2_ B2_)
    (ceq_prod B1_ A1_, ccompare_prod B2_ A2_, set_impl_prod B3_ A3_)
    (fn (x, y) => (y, x)) r;

fun ctxt_compose Hole d = d
  | ctxt_compose (More (f, ss1, c, ss2)) d =
    More (f, ss1, ctxt_compose c d, ss2);

fun sum_mset A_ (Bag ms) =
  foldd (fn a => fn n =>
          funpow n
            (plus ((plus_semigroup_add o semigroup_add_monoid_add o
                     monoid_add_comm_monoid_add)
                    A_)
              a))
    (zerob ((zero_monoid_add o monoid_add_comm_monoid_add) A_)) ms;

fun funs_term_ms A_ (Var x) = zero_multiseta
  | funs_term_ms A_ (Fun (f, ts)) =
    plus_multiseta A_ (add_mset A_ f zero_multiseta)
      (sum_mset (comm_monoid_add_multiset A_)
        (mset (equal_multiset A_) (map (funs_term_ms A_) ts)));

fun subt_at_ctxt c Empty = c
  | subt_at_ctxt (More (f, bef, c, aft)) (PCons (i, p)) = subt_at_ctxt c p;

fun the_Var (Var x1) = x1;

fun vars_term_ms B_ (Var x) = add_mset B_ x zero_multiseta
  | vars_term_ms B_ (Fun (f, ts)) =
    sum_mset (comm_monoid_add_multiset B_)
      (mset (equal_multiset B_) (map (vars_term_ms B_) ts));

fun in_poss Empty uu = true
  | in_poss (PCons (i, p)) (Fun (f, ts)) =
    less_nat i (size_list ts) andalso in_poss p (nth ts i)
  | in_poss (PCons (i, p)) (Var uv) = false;

fun add_funs_term (Var uu) fs = fs
  | add_funs_term (Fun (f, ts)) fs = f :: foldr add_funs_term ts fs;

fun add_funs_rule r fs = add_funs_term (fst r) (add_funs_term (snd r) fs);

fun funs_trs_list trs = foldr add_funs_rule trs [];

fun instance_rule A_ B_ (C1_, C2_, C3_) lr st =
  not (is_none
        (match_list (C1_, C2_, C3_) A_ B_ (fn _ => fst lr)
          [(fst st, fst lr), (snd st, snd lr)]));

fun map_funs_rule fg lr =
  (map_term fg (fn x => x) (fst lr), map_term fg (fn x => x) (snd lr));

fun add_vars_rule r xs = add_vars_term (fst r) (add_vars_term (snd r) xs);

fun vars_trs_list trs = foldr add_vars_rule trs [];

fun elem_list_to_rm B_ key (d :: ds) =
  let
    val rm = elem_list_to_rm B_ key ds;
    val k = key d;
  in
    (case lookup B_ rm k of NONE => insert B_ k [d] rm
      | SOME data => insert B_ k (d :: data) rm)
  end
  | elem_list_to_rm B_ key [] = empty (linorder_compare_order B_);

fun fun_of_map m d a = (case m a of NONE => d | SOME b => b);

fun term_map A_ ts =
  fun_of_map
    (lookup (compare_order_prod (compare_order_key A_) compare_order_nat)
      (elem_list_to_rm
        (compare_order_prod (compare_order_key A_) compare_order_nat)
        (the o root) ts))
    [];

fun label_depth (UnLab uu) = zero_nata
  | label_depth (Lab (f, uv)) = suc (label_depth f)
  | label_depth (FunLab (f, uw)) = suc (label_depth f)
  | label_depth (Sharp f) = suc (label_depth f);

fun gen_label f n =
  (if equal_nata n zero_nata then f
    else FunLab (gen_label f (minus_nata n one_nata), []));

fun fmap A_ B_ a nn sml =
  let
    val m = suc (max_list (map label_depth (a :: maps snd sml)));
  in
    (fn f => fn n =>
      (if equal_proda (equal_lab A_ B_) equal_nat (f, n) (a, nn) then a
        else gen_label f m))
  end;

fun enum_vectors c [] = [[]]
  | enum_vectors c (x :: xs) =
    let
      val a = enum_vectors c xs;
    in
      maps (fn vec => map (fn ca => (x, ca) :: vec) c) a
    end;

fun replace_impl A_ a bs m =
  (if membera A_ m a then bs @ filtera (fn b => not (eq A_ b a)) m else m);

fun doc_of_string s = bindb (parse_doc s) (fn (doc, _) => Inr doc);

fun special_map x =
  map_of (equal_list equal_char)
    [([#"q", #"u", #"o", #"t"], [#"\""]), ([#"#", #"3", #"4"], [#"\""]),
      ([#"a", #"m", #"p"], [#"&"]), ([#"#", #"3", #"8"], [#"&"]),
      ([#"a", #"p", #"o", #"s"], [#"'"]), ([#"#", #"3", #"9"], [#"'"]),
      ([#"l", #"t"], [#"<"]), ([#"#", #"6", #"0"], [#"<"]),
      ([#"g", #"t"], [#">"]), ([#"#", #"6", #"2"], [#">"])]
    x;

fun pat_eqv_prf A_ xml2name =
  let
    val sub = substa A_ xml2name;
  in
    xml_do
      [#"p", #"a", #"t", #"t", #"e", #"r", #"n", #"E", #"q", #"u", #"i", #"v",
        #"a", #"l", #"e", #"n", #"c", #"e"]
      (xml_take
        (xml_or
          (xml_do
            [#"d", #"o", #"m", #"a", #"i", #"n", #"R", #"e", #"n", #"a", #"m",
              #"i", #"n", #"g"]
            (xml_take sub (fn n => xml_return (Pat_Dom_Renaming n))))
          (xml_or
            (xml_do [#"i", #"r", #"r", #"e", #"l", #"e", #"v", #"a", #"n", #"t"]
              (xml_take sub
                (fn n =>
                  xml_take sub (fn n2 => xml_return (Pat_Irrelevant (n, n2))))))
            (xml_do
              [#"s", #"i", #"m", #"p", #"l", #"i", #"f", #"i", #"c", #"a", #"t",
                #"i", #"o", #"n"]
              (xml_take sub
                (fn n =>
                  xml_take sub (fn n2 => xml_return (Pat_Simplify (n, n2))))))))
        (fn x => xml_return (id x)))
  end;

fun pat_term A_ xml2name =
  xml_do [#"p", #"a", #"t", #"t", #"e", #"r", #"n", #"T", #"e", #"r", #"m"]
    (xml_take (term A_ xml2name)
      (fn t =>
        xml_take (substa A_ xml2name)
          (fn s1 =>
            xml_take (substa A_ xml2name)
              (fn s2 => xml_return (t, (s1, s2))))));

fun pat_rule_prf A_ xml2name x =
  let
    val pat = pat_rule_prf A_ xml2name;
    val sub = substa A_ xml2name;
    val pt = pat_term A_ xml2name;
    val var = xml_text [#"v", #"a", #"r"];
  in
    xml_do [#"p", #"a", #"t", #"t", #"e", #"r", #"n", #"R", #"u", #"l", #"e"]
      (xml_take pt
        (fn _ =>
          xml_take pt
            (fn _ =>
              xml_take
                (xml_or
                  (xml_do
                    [#"o", #"r", #"i", #"g", #"i", #"n", #"a", #"l", #"R", #"u",
                      #"l", #"e"]
                    (xml_take (rule A_ xml2name)
                      (fn r =>
                        xml_take (xml_bool [#"i", #"s", #"P", #"a", #"i", #"r"])
                          (fn b => xml_return (Pat_OrigRule (r, b))))))
                  (xml_or
                    (xml_do
                      [#"i", #"n", #"i", #"t", #"i", #"a", #"l", #"P", #"u",
                        #"m", #"p", #"i", #"n", #"g"]
                      (xml_take pat
                        (fn a =>
                          xml_take sub
                            (fn b =>
                              xml_take sub
                                (fn c =>
                                  xml_return (Pat_InitPump (a, b, c)))))))
                    (xml_or
                      (xml_do
                        [#"i", #"n", #"i", #"t", #"i", #"a", #"l", #"P", #"u",
                          #"m", #"p", #"i", #"n", #"g", #"C", #"o", #"n", #"t",
                          #"e", #"x", #"t"]
                        (xml_take pat
                          (fn a =>
                            xml_take sub
                              (fn b =>
                                xml_take pos
                                  (fn c =>
                                    xml_take var
                                      (fn d =>
xml_return (Pat_InitPumpCtxt (a, b, c, d))))))))
                      (xml_or
                        (xml_do
                          [#"e", #"q", #"u", #"i", #"v", #"a", #"l", #"e", #"n",
                            #"c", #"e"]
                          (xml_take pat
                            (fn a =>
                              xml_take
                                (xml_or (xml_leaf [#"l", #"e", #"f", #"t"] true)
                                  (xml_leaf [#"r", #"i", #"g", #"h", #"t"]
                                    false))
                                (fn b =>
                                  xml_take (pat_eqv_prf A_ xml2name)
                                    (fn c =>
                                      xml_return (Pat_Equiv (a, b, c)))))))
                        (xml_or
                          (xml_do
                            [#"n", #"a", #"r", #"r", #"o", #"w", #"i", #"n",
                              #"g"]
                            (xml_take pat
                              (fn a =>
                                xml_take pat
                                  (fn b =>
                                    xml_take pos
                                      (fn c =>
xml_return (Pat_Narrow (a, b, c)))))))
                          (xml_or
                            (xml_do
                              [#"i", #"n", #"s", #"t", #"a", #"n", #"t", #"i",
                                #"a", #"t", #"i", #"o", #"n"]
                              (xml_take pat
                                (fn a =>
                                  xml_take sub
                                    (fn b =>
                                      xml_take
(xml_or (xml_leaf [#"b", #"a", #"s", #"e"] Pat_Base)
  (xml_or (xml_leaf [#"p", #"u", #"m", #"p", #"i", #"n", #"g"] Pat_Pump)
    (xml_leaf [#"c", #"l", #"o", #"s", #"i", #"n", #"g"] Pat_Close)))
(fn c => xml_return (Pat_Inst (a, b, c)))))))
                            (xml_or
                              (xml_do
                                [#"i", #"n", #"s", #"t", #"a", #"n", #"t", #"i",
                                  #"a", #"t", #"i", #"o", #"n", #"P", #"u",
                                  #"m", #"p", #"i", #"n", #"g"]
                                (xml_take pat
                                  (fn a =>
                                    xml_take
                                      (xml_nat [#"p", #"o", #"w", #"e", #"r"])
                                      (fn b =>
xml_return (Pat_Exp_Sigma (a, b))))))
                              (xml_do
                                [#"r", #"e", #"w", #"r", #"i", #"t", #"i", #"n",
                                  #"g"]
                                (xml_take pat
                                  (fn a =>
                                    xml_take (rsteps A_ xml2name)
                                      (fn b =>
xml_take
  (xml_or (xml_leaf [#"b", #"a", #"s", #"e"] (Pat_Base, []))
    (xml_or
      (xml_do [#"p", #"u", #"m", #"p", #"i", #"n", #"g"]
        (xml_take var (fn v => xml_return (Pat_Pump, v))))
      (xml_do [#"c", #"l", #"o", #"s", #"i", #"n", #"g"]
        (xml_take var (fn v => xml_return (Pat_Close, v))))))
  (fn (po, va) => xml_return (Pat_Rewr (a, b, po, va))))))))))))))
                xml_return)))
      x
  end;

fun nonloop (A1_, A2_) (B1_, B2_) xml2name =
  xml_do [#"n", #"o", #"n", #"L", #"o", #"o", #"p"]
    (xml_take (pat_rule_prf (show_lab A2_ B2_) xml2name)
      (fn a =>
        xml_take (substa (show_lab A2_ B2_) xml2name)
          (fn b =>
            xml_take (substa (show_lab A2_ B2_) xml2name)
              (fn c =>
                xml_take (xml_nat [#"n", #"a", #"t", #"u", #"r", #"a", #"l"])
                  (fn d =>
                    xml_take
                      (xml_nat [#"n", #"a", #"t", #"u", #"r", #"a", #"l"])
                      (fn e =>
                        xml_take pos
                          (fn f =>
                            xml_return (Non_loop_prf (a, b, c, d, e, f)))))))));

fun eq_set (A1_, A2_, A3_, A4_) = set_eq (A2_, A3_, A4_);

fun choice [] = Inl []
  | choice (x :: xs) =
    catch_errora x (fn e => catch_errora (choice xs) (fn xa => Inl (e :: xa)));

fun gen_filter it1 emp2 ins2 p s1 =
  it1 s1 (fn _ => true) (fn x => fn s => (if p x then ins2 x s else s)) emp2;

fun gt_term A_ C_ nlv ne gt_fun rm s t =
  ne andalso
    let
      val root1 = root s;
      val root2 = root t;
    in
      (is_Var s orelse
        (is_Var t orelse
          (gt_fun NONE NONE orelse
            (gt_fun root1 root2 orelse
              (gt_fun root1 NONE orelse gt_fun NONE root2))))) andalso
        (if nlv
          then (case root1 of NONE => true
                 | SOME fna =>
                   list_ex
                     (fn r => matchb A_ C_ (tcapRM A_ C_ nlv rm s) (fst r))
                     (rm fna))
          else true)
    end;

fun rd_impl A_ gt (Fun (f, ss), Fun (g, ts)) =
  (if eq A_ f g andalso
        (equal_nata (size_list ss) (size_list ts) andalso
          not (gt (Fun (f, ss)) (Fun (g, ts))))
    then maps (rd_impl A_ gt) (zip ss ts) else [(Fun (f, ss), Fun (g, ts))])
  | rd_impl A_ uu (Var v, t) = [(Var v, t)]
  | rd_impl A_ uu (s, Var v) = [(s, Var v)];

fun dflt_cmp le lt a b =
  (if lt a b then LESS else (if le a b then EQUAL else GREATER));

fun nodes_lts_impl D_ pi =
  remdups D_
    (map (source o snd) (transitions_impl pi) @
      map (target o snd) (transitions_impl pi));

fun rec_list f1 f2 [] = f1
  | rec_list f1 f2 (x21 :: x22) = f2 x21 x22 (rec_list f1 f2 x22);

fun product_lists [] = [[]]
  | product_lists (xs :: xss) =
    maps (fn x => map (fn a => x :: a) (product_lists xss)) xs;

fun height (f, h) = h;

fun mat_of_cols n cs =
  mat n (size_list cs) (fn (i, j) => vec_index (nth cs j) i);

fun vec_of_list_impl xa = Abs_vec_impl (size_list xa, Vector.fromList xa);

fun vec_of_list v = Vec_impl (vec_of_list_impl v);

fun shows_monom_list (A1_, A2_) [(x, p)] =
  (if equal_nata p one_nata then shows_prec A2_ zero_nata x
    else shows_prec A2_ zero_nata x o
           (shows_string [#"^"] o shows_prec_nat zero_nata p))
  | shows_monom_list (A1_, A2_) ((x, p) :: v :: va) =
    (if equal_nata p one_nata then shows_prec A2_ zero_nata x
      else shows_prec A2_ zero_nata x o
             (shows_string [#"^"] o shows_prec_nat zero_nata p)) o
      (shows_string [#"*"] o shows_monom_list (A1_, A2_) (v :: va))
  | shows_monom_list (A1_, A2_) [] = shows_string [#"1"];

fun shows_prec_monom (A1_, A2_) x xc =
  shows_monom_list (A1_, A2_) (rep_monom A1_ xc);

fun shows_poly (A1_, A2_, A3_) (B1_, B2_, B3_) [] = shows_string [#"0"]
  | shows_poly (A1_, A2_, A3_) (B1_, B2_, B3_) ((m, c) :: p) =
    (if eq B2_ c (onea B1_) then shows_prec_monom (A2_, A3_) zero_nata m
      else (if eq (equal_monom (A1_, A2_)) m (one_monom A2_)
             then shows_prec B3_ zero_nata c
             else shows_prec B3_ zero_nata c o
                    (shows_string [#"*"] o
                      shows_prec_monom (A2_, A3_) zero_nata m))) o
      (if null p then shows_string []
        else shows_string [#" ", #"+", #" "] o
               shows_poly (A1_, A2_, A3_) (B1_, B2_, B3_) p);

fun check_poly_ge (A1_, A2_) B_ [] q =
  list_all
    (fn (_, d) =>
      less_eq
        ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
           ordered_ab_semigroup_ordered_semiring_0)
          B_)
        d (zerob
            ((zero_mult_zero o mult_zero_semiring_0 o
               semiring_0_ordered_semiring_0a)
              B_)))
    q
  | check_poly_ge (A1_, A2_) B_ ((m, c) :: p) q =
    (case extract (fn nd => eq (equal_monom (A1_, A2_)) (fst nd) m) q
      of NONE =>
        less_eq
          ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
             ordered_ab_semigroup_ordered_semiring_0)
            B_)
          (zerob
            ((zero_mult_zero o mult_zero_semiring_0 o
               semiring_0_ordered_semiring_0a)
              B_))
          c andalso
          check_poly_ge (A1_, A2_) B_ p q
      | SOME (q1, ((_, d), q2)) =>
        less_eq
          ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
             ordered_ab_semigroup_ordered_semiring_0)
            B_)
          d c andalso
          check_poly_ge (A1_, A2_) B_ p (q1 @ q2));

fun check_poly_gt A_ (B1_, B2_) gt p q =
  let
    val (a1, p1) =
      poly_split (B1_, B2_)
        ((zero_mult_zero o mult_zero_semiring_0 o
           semiring_0_ordered_semiring_0a)
          A_)
        (one_monom B2_) p;
    val (b1, q1) =
      poly_split (B1_, B2_)
        ((zero_mult_zero o mult_zero_semiring_0 o
           semiring_0_ordered_semiring_0a)
          A_)
        (one_monom B2_) q;
  in
    gt a1 b1 andalso check_poly_ge (B1_, B2_) A_ p1 q1
  end;

fun monom_mult_list (A1_, A2_) [] n = n
  | monom_mult_list (A1_, A2_) ((x, p) :: m) n =
    (case n of [] => (x, p) :: m
      | (y, q) :: na =>
        (if eq A1_ x y
          then (x, plus_nata p q) :: monom_mult_list (A1_, A2_) m na
          else (if less ((ord_preorder o preorder_order o order_linorder) A2_) x
                     y
                 then (x, p) :: monom_mult_list (A1_, A2_) m n
                 else (y, q) :: monom_mult_list (A1_, A2_) ((x, p) :: m) na)));

fun times_monom (A1_, A2_) xb xc =
  Abs_monom (monom_mult_list (A1_, A2_) (rep_monom A2_ xb) (rep_monom A2_ xc));

fun monom_mult_poly (A1_, A2_) (B1_, B2_) uu [] = []
  | monom_mult_poly (A1_, A2_) (B1_, B2_) (ma, c) ((m, d) :: p) =
    (if eq B1_ (times ((times_mult_zero o mult_zero_semiring_0) B2_) c d)
          (zerob ((zero_mult_zero o mult_zero_semiring_0) B2_))
      then monom_mult_poly (A1_, A2_) (B1_, B2_) (ma, c) p
      else (times_monom (A1_, A2_) ma m,
             times ((times_mult_zero o mult_zero_semiring_0) B2_) c d) ::
             monom_mult_poly (A1_, A2_) (B1_, B2_) (ma, c) p);

fun poly_add (A1_, A2_) (B1_, B2_) [] q = q
  | poly_add (A1_, A2_) (B1_, B2_) ((m, c) :: p) q =
    (case extract (fn mc => eq (equal_monom (A1_, A2_)) (fst mc) m) q
      of NONE => (m, c) :: poly_add (A1_, A2_) (B1_, B2_) p q
      | SOME (q1, ((_, d), q2)) =>
        (if eq B1_
              (plus ((plus_semigroup_add o semigroup_add_monoid_add o
                       monoid_add_comm_monoid_add o comm_monoid_add_semiring_0)
                      B2_)
                c d)
              (zerob ((zero_mult_zero o mult_zero_semiring_0) B2_))
          then poly_add (A1_, A2_) (B1_, B2_) p (q1 @ q2)
          else (m, plus ((plus_semigroup_add o semigroup_add_monoid_add o
                           monoid_add_comm_monoid_add o
                           comm_monoid_add_semiring_0)
                          B2_)
                     c d) ::
                 poly_add (A1_, A2_) (B1_, B2_) p (q1 @ q2)));

fun poly_mult (A1_, A2_) (B1_, B2_) [] q = []
  | poly_mult (A1_, A2_) (B1_, B2_) (mc :: p) q =
    poly_add (A1_, A2_) (B1_, B2_) (monom_mult_poly (A1_, A2_) (B1_, B2_) mc q)
      (poly_mult (A1_, A2_) (B1_, B2_) p q);

fun one_polya A_ B_ =
  [(one_monom A_,
     onea ((one_numeral o numeral_semiring_numeral o
             semiring_numeral_semiring_1)
            B_))];

fun poly_power (A1_, A2_) (B1_, B2_) uu n =
  (if equal_nata n zero_nata then one_polya A2_ (semiring_1_comm_semiring_1 B2_)
    else poly_mult (A1_, A2_)
           (B1_, (semiring_0_semiring_1 o semiring_1_comm_semiring_1) B2_) uu
           (poly_power (A1_, A2_) (B1_, B2_) uu (minus_nata n one_nata)));

fun monom_list_subst (B1_, B2_) (C1_, C2_) sigma [] =
  one_polya B2_ (semiring_1_comm_semiring_1 C2_)
  | monom_list_subst (B1_, B2_) (C1_, C2_) sigma ((x, p) :: m) =
    poly_mult (B1_, B2_)
      (C1_, (semiring_0_semiring_1 o semiring_1_comm_semiring_1) C2_)
      (poly_power (B1_, B2_) (C1_, C2_) (sigma x) p)
      (monom_list_subst (B1_, B2_) (C1_, C2_) sigma m);

fun monom_list A_ x = rep_monom A_ x;

fun monom_subst A_ (B1_, B2_) (C1_, C2_) sigma m =
  monom_list_subst (B1_, B2_) (C1_, C2_) sigma (monom_list A_ m);

val zero_polya : ('a monom * 'b) list = [];

fun poly_subst A_ (B1_, B2_) (C1_, C2_) sigma [] = zero_polya
  | poly_subst A_ (B1_, B2_) (C1_, C2_) sigma ((m, c) :: p) =
    poly_add (B1_, B2_)
      (C1_, (semiring_0_semiring_1 o semiring_1_comm_semiring_1) C2_)
      (poly_mult (B1_, B2_)
        (C1_, (semiring_0_semiring_1 o semiring_1_comm_semiring_1) C2_)
        [(one_monom B2_, c)] (monom_subst A_ (B1_, B2_) (C1_, C2_) sigma m))
      (poly_subst A_ (B1_, B2_) (C1_, C2_) sigma p);

fun var_monom A_ xa = Abs_monom [(xa, one_nata)];

fun eval_term (B1_, B2_) (C1_, C2_) uu (Var x) =
  [(var_monom C2_ x,
     onea ((one_numeral o numeral_semiring_numeral o
             semiring_numeral_semiring_1 o semiring_1_comm_semiring_1 o
             comm_semiring_1_poly_carrier)
            B2_))]
  | eval_term (B1_, B2_) (C1_, C2_) i (Fun (f, ts)) =
    let
      val ps = map (eval_term (B1_, B2_) (C1_, C2_) i) ts;
      val n = size_list ts;
    in
      poly_subst linorder_nat (C1_, C2_) (B1_, comm_semiring_1_poly_carrier B2_)
        (fn ia => (if less_nat ia n then nth ps ia else zero_polya)) (i (f, n))
    end;

fun check_s (A1_, A2_, A3_) B_ (C1_, C2_, C3_) gt i =
  (fn (s, t) =>
    let
      val p = eval_term (A1_, A2_) (C1_, C2_) i s;
      val q = eval_term (A1_, A2_) (C1_, C2_) i t;
    in
      check (check_poly_gt
              ((ordered_semiring_0_ordered_semiring_1 o
                 ordered_semiring_1_poly_carrier)
                A2_)
              (C1_, C2_) gt p q)
        (shows_string
           [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"e",
             #"n", #"s", #"u", #"r", #"e", #" "] o
          (shows_prec_term B_ C3_ zero_nata s o
            (shows_string [#" ", #">", #" "] o
              (shows_prec_term B_ C3_ zero_nata t o
                (shows_string
                   [#" ", #"s", #"i", #"n", #"c", #"e", #" ", #"w", #"e",
                     #" "] o
                  (shows_nl o
                    (shows_string
                       [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                         #" ", #"e", #"n", #"s", #"u", #"r", #"e", #" "] o
                      (shows_poly (C1_, C2_, C3_)
                         ((one_numeral o numeral_semiring_numeral o
                            semiring_numeral_semiring_1 o
                            semiring_1_comm_semiring_1 o
                            comm_semiring_1_poly_carrier)
                            A2_,
                           A1_, A3_)
                         p o
                        (shows_string [#" ", #">", #" "] o
                          shows_poly (C1_, C2_, C3_)
                            ((one_numeral o numeral_semiring_numeral o
                               semiring_numeral_semiring_1 o
                               semiring_1_comm_semiring_1 o
                               comm_semiring_1_poly_carrier)
                               A2_,
                              A1_, A3_)
                            q)))))))))
    end);

fun curry f a b = f (a, b);

fun shows_rpo_repr A_ prs =
  shows_prec_list show_char zero_nata
    [#"R", #"P", #"O", #" ", #"w", #"i", #"t", #"h", #" ", #"t", #"h", #"e",
      #" ", #"f", #"o", #"l", #"l", #"o", #"w", #"i", #"n", #"g", #" ", #"p",
      #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c", #"e"] o
    shows_nl o
    foldr (fn (a, b) =>
            let
              val (f, n) = a;
            in
              (fn (pr, _) =>
                shows_prec_list show_char zero_nata
                  [#"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c", #"e",
                    #"("] o
                  shows_prec A_ zero_nata f o
                  shows_prec_list show_char zero_nata [#"["] o
                  shows_prec_nat zero_nata n o
                  shows_prec_list show_char zero_nata
                    [#"]", #")", #" ", #"=", #" "] o
                  shows_prec_nat zero_nata pr o
                  shows_nl)
            end
              b)
      prs o
    shows_nl o
    shows_prec_list show_char zero_nata
      [#"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c", #"e", #"(", #"_",
        #")", #" ", #"=", #" ", #"0"] o
    shows_nl o
    shows_prec_list show_char zero_nata
      [#"a", #"n", #"d", #" ", #"t", #"h", #"e", #" ", #"f", #"o", #"l", #"l",
        #"o", #"w", #"i", #"n", #"g", #" ", #"s", #"t", #"a", #"t", #"u",
        #"s"] o
    shows_nl o
    foldr (fn (a, b) =>
            let
              val (f, n) = a;
            in
              (fn (_, s) =>
                shows_prec_list show_char zero_nata
                  [#"s", #"t", #"a", #"t", #"u", #"s", #"("] o
                  shows_prec A_ zero_nata f o
                  shows_prec_list show_char zero_nata [#"["] o
                  shows_prec_nat zero_nata n o
                  shows_prec_list show_char zero_nata
                    [#"]", #")", #" ", #"=", #" "] o
                  shows_prec_list show_char zero_nata
                    (case s of Lex => [#"l", #"e", #"x"]
                      | Mul => [#"m", #"u", #"l"]) o
                  shows_nl)
            end
              b)
      prs o
    shows_nl o
    shows_prec_list show_char zero_nata
      [#"s", #"t", #"a", #"t", #"u", #"s", #"(", #"_", #")", #" ", #"=", #" ",
        #"l", #"e", #"x"] o
    shows_nl;

fun scnp_af_to_af pia pi =
  (fn (f, n) =>
    let
      val is = map fst (pia (f, n));
    in
      (if list_ex (less_eq_nat n) is
        then sup_seta (ceq_nat, ccompare_nat) (pi (f, n))
               (set (ceq_nat, ccompare_nat, set_impl_nat) is)
        else set (ceq_nat, ccompare_nat, set_impl_nat) is)
    end);

fun semilattice_set_apply (Abs_semilattice_set x) = x;

fun set_fold1 (A1_, A2_, A3_) f (RBT_set rbt) =
  (case ccompare A2_
    of NONE =>
      (raise Fail "set_fold1 RBT_set: ccompare = None")
        (fn _ => set_fold1 (A1_, A2_, A3_) f (RBT_set rbt))
    | SOME _ =>
      (if is_emptya A2_ rbt
        then (raise Fail "set_fold1 RBT_set: empty set")
               (fn _ => set_fold1 (A1_, A2_, A3_) f (RBT_set rbt))
        else fold1 A2_ (semilattice_set_apply f) rbt))
  | set_fold1 (A1_, A2_, A3_) f (DList_set dxs) =
    (case ceq A1_
      of NONE =>
        (raise Fail "set_fold1 DList_set: ceq = None")
          (fn _ => set_fold1 (A1_, A2_, A3_) f (DList_set dxs))
      | SOME _ =>
        (if nulla A1_ dxs
          then (raise Fail "set_fold1 DList_set: empty set")
                 (fn _ => set_fold1 (A1_, A2_, A3_) f (DList_set dxs))
          else foldc A1_ (semilattice_set_apply f) (tl A1_ dxs) (hd A1_ dxs)))
  | set_fold1 (A1_, A2_, A3_) f (Set_Monad (x :: xs)) =
    fold (semilattice_set_apply f) xs x
  | set_fold1 (A1_, A2_, A3_) f (Collect_set p) =
    (raise Fail "set_fold1: Collect_set")
      (fn _ => set_fold1 (A1_, A2_, A3_) f (Collect_set p))
  | set_fold1 (A1_, A2_, A3_) f (Complement a) =
    (raise Fail "set_fold1: Complement")
      (fn _ => set_fold1 (A1_, A2_, A3_) f (Complement a));

fun projr (Inr x2) = x2;

fun rec_term f1 f2 (Var x1) = f1 x1
  | rec_term f1 f2 (Fun (x21, x22)) =
    f2 x21 (map (fn term => (term, rec_term f1 f2 term)) x22);

fun mk_subst_domain A_ B_ sigma =
  let
    val tau = mk_subst A_ Var sigma;
  in
    filtera (fn (x, t) => not (equal_terma B_ A_ (Var x) t))
      (map (fn x => (x, tau x)) (remdups A_ (map fst sigma)))
  end;

fun subst_eq (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) sigma tau =
  let
    val sigmaa = mk_subst_domain A5_ B2_ sigma;
    val taua = mk_subst_domain A5_ B2_ tau;
  in
    set_eq
      (cenum_prod A1_ cenum_term, ceq_prod A2_ (ceq_term B2_ A5_),
        ccompare_prod A3_ (ccompare_term B1_ A4_))
      (set (ceq_prod A2_ (ceq_term B2_ A5_),
             ccompare_prod A3_ (ccompare_term B1_ A4_),
             set_impl_prod A6_ set_impl_term)
        sigmaa)
      (set (ceq_prod A2_ (ceq_term B2_ A5_),
             ccompare_prod A3_ (ccompare_term B1_ A4_),
             set_impl_prod A6_ set_impl_term)
        taua)
  end;

fun full_af fna =
  set (ceq_nat, ccompare_nat, set_impl_nat) (upt zero_nata (snd fna));

fun add_funas_term (Var uu) fs = fs
  | add_funas_term (Fun (f, ts)) fs =
    (f, size_list ts) :: foldr add_funas_term ts fs;

fun add_funas_rule r fs = add_funas_term (fst r) (add_funas_term (snd r) fs);

fun funas_trs_list trs = foldr add_funas_rule trs [];

fun funs_rule_list r = add_funs_rule r [];

fun vars_rule_list r = add_vars_rule r [];

fun supteq_list (Var x) = [Var x]
  | supteq_list (Fun (f, ts)) = Fun (f, ts) :: maps supteq_list ts;

fun is_NF_main (A1_, A2_) (B1_, B2_, B3_) var_cond r_empty m =
  (if var_cond then (fn _ => false)
    else (if r_empty then (fn _ => true)
           else (fn t =>
                  list_all
                    (fn u =>
                      (if not (is_Var u)
                        then list_all
                               (fn l =>
                                 not (matches A1_ B2_ (B1_, B2_, B3_) u l))
                               (m (the (root u)))
                        else true))
                    (supteq_list t))));

fun is_NF_trs (A1_, A2_) (B1_, B2_, B3_) r =
  is_NF_main (A1_, A2_) (B1_, B2_, B3_) (list_ex (fn ra => is_Var (fst ra)) r)
    (null r) (term_map A2_ (map fst r));

fun apply_args a t [] = t
  | apply_args a t (s :: ss) = apply_args a (Fun (a, [t, s])) ss;

fun get_symbol sm f n i = nth (sm f n) i;

fun strategy_of_string str =
  (if equal_lista equal_char str [#"F", #"U", #"L", #"L"]
    then xml_return (Inl No_Strategy)
    else (if equal_lista equal_char str
               [#"I", #"N", #"N", #"E", #"R", #"M", #"O", #"S", #"T"]
           then xml_return (Inl Innermost)
           else (if equal_lista equal_char str
                      [#"O", #"U", #"T", #"E", #"R", #"M", #"O", #"S", #"T"]
                  then xml_return (Inr Outermost)
                  else xml_error (show_list (show_list show_char))
                         ([#"u", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"s",
                            #"t", #"r", #"a", #"t", #"e", #"g", #"y", #" ",
                            #"\""] @
                           str @ [#"\""]))));

fun signature_to_AC A_ asa cs [] = (asa, cs)
  | signature_to_AC A_ asa cs (fnac :: siga) =
    let
      val (f, a) = fnac;
      val (_, aa) = a;
      val (ab, c) = aa;
    in
      signature_to_AC A_ (if ab then f :: asa else asa)
        (if c then f :: cs else cs) siga
    end;

fun xml_take_attribute att p xs =
  let
    val (xmls, (atts, (allow, (cands, pos)))) = xs;
  in
    (case pick_up (equal_list equal_char) [] att atts
      of NONE =>
        xml_error (show_list (show_list show_char))
          ([#"a", #"t", #"t", #"r", #"i", #"b", #"u", #"t", #"e", #" ", #"\""] @
            att @ [#"\"", #" ", #"n", #"o", #"t", #" ", #"f", #"o", #"u", #"n",
                    #"d"])
          xs
      | SOME (v, rest) => p v (xmls, (rest, (allow, (cands, pos)))))
  end;

fun signaturea A_ xml2name =
  xml_do [#"s", #"i", #"g", #"n", #"a", #"t", #"u", #"r", #"e"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do [#"f", #"u", #"n", #"c", #"s", #"y", #"m"]
        (xml_take xml2name
          (fn name =>
            xml_take (xml_nat [#"a", #"r", #"i", #"t", #"y"])
              (fn arity =>
                xml_take_optional
                  (xml_text [#"t", #"h", #"e", #"o", #"r", #"y"])
                  (fn a =>
                    (case a
                      of NONE => xml_return (name, (arity, (false, false)))
                      | SOME th =>
                        (if equal_lista equal_char th [#"A"]
                          then (if equal_nata arity
                                     (nat_of_integer (2 : IntInf.int))
                                 then xml_return (name, (arity, (true, false)))
                                 else xml_error
(show_list (show_list show_char))
([#"w", #"r", #"o", #"n", #"g", #" ", #"a", #"r", #"i", #"t", #"y", #" "] @
  shows_prec_nat zero_nata arity [] @
    [#" ", #"f", #"o", #"r", #" ", #"a", #"s", #"s", #"o", #"c", #"i", #"a",
      #"t", #"i", #"v", #"e", #" ", #"s", #"y", #"m", #"b", #"o", #"l", #" ",
      #"\""] @
      shows_prec A_ zero_nata name [] @ [#"\""]))
                          else (if equal_lista equal_char th [#"A", #"C"]
                                 then (if equal_nata arity
    (nat_of_integer (2 : IntInf.int))
then xml_return (name, (arity, (true, true)))
else xml_error (show_list (show_list show_char))
       ([#"w", #"r", #"o", #"n", #"g", #" ", #"a", #"r", #"i", #"t", #"y",
          #" "] @
         shows_prec_nat zero_nata arity [] @
           [#" ", #"f", #"o", #"r", #" ", #"A", #"C", #" ", #"s", #"y", #"m",
             #"b", #"o", #"l", #" ", #"\""] @
             shows_prec A_ zero_nata name [] @ [#"\""]))
                                 else (if equal_lista equal_char th [#"C"]
then (if equal_nata arity (nat_of_integer (2 : IntInf.int))
       then xml_return (name, (arity, (false, true)))
       else xml_error (show_list (show_list show_char))
              ([#"w", #"r", #"o", #"n", #"g", #" ", #"a", #"r", #"i", #"t",
                 #"y", #" "] @
                shows_prec_nat zero_nata arity [] @
                  [#" ", #"f", #"o", #"r", #" ", #"c", #"o", #"m", #"m", #"u",
                    #"t", #"a", #"t", #"i", #"v", #"e", #" ", #"s", #"y", #"m",
                    #"b", #"o", #"l", #" ", #"\""] @
                    shows_prec A_ zero_nata name [] @ [#"\""]))
else xml_error (show_list (show_list show_char))
       ([#"u", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"t", #"h", #"e", #"o",
          #"r", #"y", #" ", #"\""] @
         th @ [#"\""]))))))))))
      xml_return);

fun problem A_ xml2name =
  xml_do [#"p", #"r", #"o", #"b", #"l", #"e", #"m"]
    (xml_take_attribute [#"t", #"y", #"p", #"e"]
      (fn _ =>
        xml_take
          (xml_do [#"t", #"r", #"s"]
            (xml_take
              (xml_do [#"r", #"u", #"l", #"e", #"s"]
                (xml_take_many_sub [] zero_nata Infinity_enat
                  (crule A_ xml2name [#"r", #"u", #"l", #"e"])
                  (fn crules =>
                    xml_take_default []
                      (xml_do [#"r", #"e", #"l", #"r", #"u", #"l", #"e", #"s"]
                        (xml_take_many_sub [] zero_nata Infinity_enat
                          (rule A_ xml2name) xml_return))
                      (fn rel => xml_return (crules, rel)))))
              (fn (crules, rel) =>
                xml_take (signaturea A_ xml2name)
                  (fn siga =>
                    let
                      val a = signature_to_AC A_ [] [] siga;
                      val (aa, c) = a;
                    in
                      xml_take_optional
                        (xml_do [#"c", #"o", #"m", #"m", #"e", #"n", #"t"]
                          (xml_take_many_sub [] zero_nata Infinity_enat
                            (fn x => Inr (fst x)) (fn _ => xml_return ())))
                        (fn _ =>
                          xml_take_optional
                            (xml_do
                              [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o",
                                #"n", #"t", #"y", #"p", #"e"]
                              (xml_take_many_sub [] zero_nata Infinity_enat
                                (fn x => Inr (fst x)) (fn _ => xml_return ())))
                            (fn _ => xml_return (crules, (rel, (aa, c)))))
                    end))))
          (fn (crules, a) =>
            let
              val (rel, aa) = a;
              val (ab, c) = aa;
            in
              xml_take
                (xml_change
                  (xml_text [#"s", #"t", #"r", #"a", #"t", #"e", #"g", #"y"])
                  strategy_of_string)
                (fn strat =>
                  xml_take_default Full
                    (xml_do
                      [#"s", #"t", #"a", #"r", #"t", #"t", #"e", #"r", #"m"]
                      (xml_take
                        (xml_or
                          (xml_do
                            [#"c", #"o", #"n", #"s", #"t", #"r", #"u", #"c",
                              #"t", #"o", #"r", #"-", #"b", #"a", #"s", #"e",
                              #"d"]
                            (xml_return Constructor_Based))
                          (xml_do [#"f", #"u", #"l", #"l"] (xml_return Full)))
                        xml_return))
                    (fn start =>
                      xml_take_optional
                        (xml_do [#"s", #"t", #"a", #"t", #"u", #"s"]
                          (xml_take_many_sub [] zero_nata Infinity_enat
                            (fn x => Inr (fst x)) (fn _ => xml_return ())))
                        (fn _ =>
                          xml_take_optional
                            (xml_do
                              [#"m", #"e", #"t", #"a", #"i", #"n", #"f", #"o",
                                #"r", #"m", #"a", #"t", #"i", #"o", #"n"]
                              (xml_take_many_sub [] zero_nata Infinity_enat
                                (fn x => Inr (fst x)) (fn _ => xml_return ())))
                            (fn _ =>
                              let
                                val relative = not (null rel);
                                val (conditional, r) =
                                  (if list_all (fn (_, ac) => null ac) crules
                                    then (false, map fst crules)
                                    else (true, []));
                                val equational =
                                  not (null ab) orelse not (null c);
                              in
                                (case (conditional,
(equational, (relative, (strat, start))))
                                  of (true, (true, _)) =>
                                    xml_error (show_list (show_list show_char))
                                      [#"e", #"q", #"u", #"a", #"t", #"i", #"o",
#"n", #"a", #"l", #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
#"a", #"l", #" ", #"s", #"y", #"s", #"t", #"e", #"m"]
                                  | (true, (false, (true, _))) =>
                                    xml_error (show_list (show_list show_char))
                                      [#"r", #"e", #"l", #"a", #"t", #"i", #"v",
#"e", #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a", #"l",
#" ", #"s", #"y", #"s", #"t", #"e", #"m"]
                                  | (true,
                                      (false, (false, (Inl No_Strategy, Full))))
                                    => xml_return (CTRS_input crules)
                                  | (true,
                                      (false,
(false, (Inl No_Strategy, Constructor_Based))))
                                    => xml_error
 (show_list (show_list show_char))
 [#"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d", #" ", #"c",
   #"o", #"m", #"b", #"i", #"n", #"a", #"t", #"i", #"o", #"n"]
                                  | (true, (false, (false, (Inl Innermost, _))))
                                    => xml_error
 (show_list (show_list show_char))
 [#"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d", #" ", #"c",
   #"o", #"m", #"b", #"i", #"n", #"a", #"t", #"i", #"o", #"n"]
                                  | (true,
                                      (false,
(false, (Inl (Innermost_Q _), _))))
                                    => xml_error
 (show_list (show_list show_char))
 [#"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d", #" ", #"c",
   #"o", #"m", #"b", #"i", #"n", #"a", #"t", #"i", #"o", #"n"]
                                  | (true, (false, (false, (Inr _, _)))) =>
                                    xml_error (show_list (show_list show_char))
                                      [#"u", #"n", #"s", #"u", #"p", #"p", #"o",
#"r", #"t", #"e", #"d", #" ", #"c", #"o", #"m", #"b", #"i", #"n", #"a", #"t",
#"i", #"o", #"n"]
                                  | (false, (true, (true, _))) =>
                                    xml_error (show_list (show_list show_char))
                                      [#"r", #"e", #"l", #"a", #"t", #"i", #"v",
#"e", #" ", #"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #" ",
#"s", #"y", #"s", #"t", #"e", #"m"]
                                  | (false,
                                      (true, (false, (Inl No_Strategy, Full))))
                                    => xml_return (AC_input (r, ab, c))
                                  | (false,
                                      (true,
(false, (Inl No_Strategy, Constructor_Based))))
                                    => xml_error
 (show_list (show_list show_char))
 [#"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d", #" ", #"c",
   #"o", #"m", #"b", #"i", #"n", #"a", #"t", #"i", #"o", #"n"]
                                  | (false, (true, (false, (Inl Innermost, _))))
                                    => xml_error
 (show_list (show_list show_char))
 [#"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d", #" ", #"c",
   #"o", #"m", #"b", #"i", #"n", #"a", #"t", #"i", #"o", #"n"]
                                  | (false,
                                      (true, (false, (Inl (Innermost_Q _), _))))
                                    => xml_error
 (show_list (show_list show_char))
 [#"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d", #" ", #"c",
   #"o", #"m", #"b", #"i", #"n", #"a", #"t", #"i", #"o", #"n"]
                                  | (false, (true, (false, (Inr _, _)))) =>
                                    xml_error (show_list (show_list show_char))
                                      [#"u", #"n", #"s", #"u", #"p", #"p", #"o",
#"r", #"t", #"e", #"d", #" ", #"c", #"o", #"m", #"b", #"i", #"n", #"a", #"t",
#"i", #"o", #"n"]
                                  | (false, (false, (true, (Inl istrat, _)))) =>
                                    xml_return
                                      (Inn_TRS_input (istrat, r, rel, start))
                                  | (false, (false, (true, (Inr _, _)))) =>
                                    xml_error (show_list (show_list show_char))
                                      [#"u", #"n", #"s", #"u", #"p", #"p", #"o",
#"r", #"t", #"e", #"d", #" ", #"c", #"o", #"m", #"b", #"i", #"n", #"a", #"t",
#"i", #"o", #"n"]
                                  | (false, (false, (false, (Inl istrat, _))))
                                    => xml_return
 (Inn_TRS_input (istrat, r, rel, start))
                                  | (false,
                                      (false, (false, (Inr fpstrat, Full))))
                                    => xml_return (FP_TRS_input (fpstrat, r))
                                  | (false,
                                      (false,
(false, (Inr _, Constructor_Based))))
                                    => xml_error
 (show_list (show_list show_char))
 [#"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d", #" ", #"c",
   #"o", #"m", #"b", #"i", #"n", #"a", #"t", #"i", #"o", #"n"])
                              end))))
            end)));

fun symbols A_ xml2name tagname =
  xml_do tagname
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do [#"s", #"y", #"m", #"b", #"o", #"l"]
        (xml_take xml2name
          (fn a =>
            xml_take (xml_nat [#"a", #"r", #"i", #"t", #"y"])
              (fn b => xml_return (a, b)))))
      xml_return);

fun map_xml_text f (XML (t, asa, cs)) = XML (t, asa, map (map_xml_text f) cs)
  | map_xml_text f (XML_text txt) = XML_text (f txt);

fun orig_term m (Var x) = Var x
  | orig_term m (Fun (f, [])) =
    (case m f of NONE => Fun (f, []) | SOME a => Var a)
  | orig_term m (Fun (f, v :: va)) = Fun (f, map (orig_term m) (v :: va));

fun rep_afs (Abs_afs x) = x;

fun afsa xa = fst (rep_afs xa);

fun sum_lpoly c [] ys = ys
  | sum_lpoly c (v :: va) [] = v :: va
  | sum_lpoly c (x :: xs) (y :: ys) = add c x y :: sum_lpoly c xs ys;

fun lpoly_of A_ c (PNum i) = return (i, [])
  | lpoly_of A_ c (PVar x) = return (zero c, replicate x (zero c) @ [one c])
  | lpoly_of A_ c (PSum []) = return (zero c, [])
  | lpoly_of A_ c (PSum (p :: ps)) =
    binda (lpoly_of A_ c p)
      (fn (cp, ncp) =>
        binda (lpoly_of A_ c (PSum ps))
          (fn (cq, ncq) => return (add c cp cq, sum_lpoly c ncp ncq)))
  | lpoly_of A_ c (PMult []) = return (one c, [])
  | lpoly_of A_ c (PMult (p :: ps)) =
    binda (lpoly_of A_ c p)
      (fn (cp, ncp) =>
        binda (lpoly_of A_ c (PMult ps))
          (fn (cq, ncq) =>
            (if list_all (eq A_ (zero c)) ncp
              then return (mult c cp cq, map (mult c cp) ncq)
              else (if list_all (eq A_ (zero c)) ncq
                     then return (mult c cp cq, map (fn x => mult c x cq) ncp)
                     else error [#"c", #"a", #"n", #"n", #"o", #"t", #" ", #"t",
                                  #"r", #"a", #"n", #"s", #"f", #"o", #"r",
                                  #"m", #" ", #"n", #"o", #"n", #"-", #"l",
                                  #"i", #"n", #"e", #"a", #"r", #" ", #"p",
                                  #"o", #"l", #"y", #"n", #"o", #"m", #"i",
                                  #"a", #"l", #" ", #"t", #"o", #" ", #"l",
                                  #"i", #"n", #"e", #"a", #"r", #" ", #"p",
                                  #"o", #"l", #"y", #"n", #"o", #"m", #"i",
                                  #"a", #"l"]))));

fun renaming A_ xml2name =
  xml_do [#"r", #"e", #"n", #"a", #"m", #"i", #"n", #"g"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"r", #"e", #"n", #"a", #"m", #"i", #"n", #"g", #"E", #"n", #"t", #"r",
          #"y"]
        (xml_take xml2name
          (fn a => xml_take xml2name (fn b => xml_return (a, b)))))
      xml_return);

fun subset (A1_, A2_, A3_, A4_) = subset_eq (A2_, A3_, A4_);

fun char_poly_matrix (A1_, A2_, A3_) a =
  plus_mat
    (plus_poly
      ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
         semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
         comm_semiring_1_cancel_comm_ring_1)
         A2_,
        A1_))
    (smult_mat
      (times_poly
        (A1_, (comm_semiring_0_comm_semiring_1 o
                comm_semiring_1_comm_semiring_1_cancel o
                comm_semiring_1_cancel_comm_ring_1)
                A2_,
          A3_))
      (pCons
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_comm_ring_1)
           A2_,
          A1_)
        (zerob
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_comm_semiring_1 o
             comm_semiring_1_comm_semiring_1_cancel o
             comm_semiring_1_cancel_comm_ring_1)
            A2_))
        (pCons
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_comm_semiring_1 o
             comm_semiring_1_comm_semiring_1_cancel o
             comm_semiring_1_cancel_comm_ring_1)
             A2_,
            A1_)
          (onea ((one_numeral o numeral_neg_numeral o neg_numeral_ring_1 o
                   ring_1_comm_ring_1)
                  A2_))
          (zero_polyb
            ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
               semiring_1_comm_semiring_1 o
               comm_semiring_1_comm_semiring_1_cancel o
               comm_semiring_1_cancel_comm_ring_1)
              A2_))))
      (one_mat
        (one_poly
           ((comm_semiring_1_comm_semiring_1_cancel o
              comm_semiring_1_cancel_comm_ring_1)
             A2_),
          zero_poly
            ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
               semiring_1_comm_semiring_1 o
               comm_semiring_1_comm_semiring_1_cancel o
               comm_semiring_1_cancel_comm_ring_1)
              A2_))
        (dim_row a)))
    (map_mat
      (fn aa =>
        pCons ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
                 semiring_1_comm_semiring_1 o
                 comm_semiring_1_comm_semiring_1_cancel o
                 comm_semiring_1_cancel_comm_ring_1)
                 A2_,
                A1_)
          (uminus
            ((uminus_group_add o group_add_neg_numeral o neg_numeral_ring_1 o
               ring_1_comm_ring_1)
              A2_)
            aa)
          (zero_polyb
            ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
               semiring_1_comm_semiring_1 o
               comm_semiring_1_comm_semiring_1_cancel o
               comm_semiring_1_cancel_comm_ring_1)
              A2_)))
      a);

fun char_poly (A1_, A2_) a =
  det (equal_poly
         ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
            semiring_1_comm_semiring_1 o
            comm_semiring_1_comm_semiring_1_cancel o
            comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide)
            A2_,
           A1_),
        idom_divide_poly (A1_, A2_))
    (char_poly_matrix
      (A1_, (comm_ring_1_idom o idom_idom_divide) A2_,
        (semiring_no_zero_divisors_semiring_1_no_zero_divisors o
          semiring_1_no_zero_divisors_semidom o semidom_idom o idom_idom_divide)
          A2_)
      a);

fun existsM f [] = Inl []
  | existsM f (x :: xs) =
    catch_errora (f x)
      (fn e => catch_errora (existsM f xs) (fn xa => Inl (e :: xa)));

fun is_neg_atom (NegAtom uu) = true
  | is_neg_atom (Atom v) = false
  | is_neg_atom (Conjunction v) = false
  | is_neg_atom (Disjunction v) = false;

fun gen_isEmpty ball m = ball m (fn _ => false);

fun gen_isEmptya ball s = ball s (fn _ => false);

fun nonreach A_ gt s t =
  (case (s, t) of (Var _, _) => false | (Fun (_, _), Var _) => false
    | (Fun (f, ss), Fun (g, ts)) =>
      not (equal_proda A_ equal_nat (f, size_list ss) (g, size_list ts)) andalso
        not (gt s t));

fun weight w w0 scf (Fun (f, ts)) =
  let
    val n = size_list ts;
    val scff = scf (f, n);
  in
    plus_nata (w (f, n))
      (sum_list monoid_add_nat
        (map (fn (ti, i) => times_nata (weight w w0 scf ti) (scff i))
          (zip ts (upt zero_nata n))))
  end
  | weight w w0 scf (Var x) = w0;

fun kbo_impl B_ w w0 prc least scf s t =
  let
    val wt = weight w w0 scf t;
    val ws = weight w w0 scf s;
  in
    (if subseteq_mset B_ (vars_term_ms B_ (scf_term scf t))
          (vars_term_ms B_ (scf_term scf s)) andalso
          less_eq_nat wt ws
      then (if less_nat wt ws then (true, true)
             else (case s
                    of Var _ =>
                      (false,
                        (case t of Var _ => true
                          | Fun (g, ts) => null ts andalso least g))
                    | Fun (f, ss) =>
                      (case t of Var _ => (true, true)
                        | Fun (g, ts) =>
                          let
                            val p = prc (f, size_list ss) (g, size_list ts);
                          in
                            (if fst p then (true, true)
                              else (if snd p
                                     then lex_ext_unbounded
    (kbo_impl B_ w w0 prc least scf) ss ts
                                     else (false, false)))
                          end)))
      else (false, false))
  end;

fun kbo_strict A_ (B1_, B2_) pr w w0 least scf =
  (fn (s, t) =>
    check (fst (kbo_impl B1_ w w0 pr least scf s t))
      (shows_string
         [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"o",
           #"r", #"i", #"e", #"n", #"t", #" "] o
        (shows_prec_term A_ B2_ zero_nata s o
          (shows_string [#" ", #">", #"K", #"B", #"O", #" "] o
            (shows_prec_term A_ B2_ zero_nata t o shows_nl)))));

fun trans_id trans_id_parser =
  trans_id_parser
    [#"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n", #"I", #"d"];

val zeroa : (nat, rat) fmap = fmempty;

fun list_all2 p (x :: xs) (y :: ys) = p x y andalso list_all2 p xs ys
  | list_all2 p xs [] = null xs
  | list_all2 p [] ys = null ys;

fun elements_mat (A1_, A2_, A3_) a =
  set (A1_, A2_, A3_)
    (maps (fn i => map (fn j => index_mat a (i, j)) (upt zero_nata (dim_col a)))
      (upt zero_nata (dim_row a)));

fun single_alist_entry xb xc = Alist [(xb, xc)];

fun image_mset B_ f (Bag ms) =
  foldd (fn a => fn n => plus_multiseta B_ (Bag (single_alist_entry (f a) n)))
    zero_multiseta ms;

fun eval i alpha (Var x) = alpha x
  | eval i alpha (Fun (f, ts)) = i f (map (eval i alpha) ts);

fun monom_vars_list A_ xa = map fst (rep_monom A_ xa);

fun poly_vars_list (A1_, A2_) p =
  remdups A1_ (maps (monom_vars_list A2_ o fst) p);

fun concat_lists [] = [[]]
  | concat_lists (asa :: xs) =
    maps (fn vec => map (fn a => a :: vec) asa) (concat_lists xs);

fun poly_of (A1_, A2_) (B1_, B2_) (PNum i) =
  (if eq B1_ i
        (zerob
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_comm_semiring_1)
            B2_))
    then [] else [(one_monom A2_, i)])
  | poly_of (A1_, A2_) (B1_, B2_) (PVar x) =
    [(var_monom A2_ x,
       onea ((one_numeral o numeral_semiring_numeral o
               semiring_numeral_semiring_1 o semiring_1_comm_semiring_1)
              B2_))]
  | poly_of (A1_, A2_) (B1_, B2_) (PSum []) = zero_polya
  | poly_of (A1_, A2_) (B1_, B2_) (PSum (p :: ps)) =
    poly_add (A1_, A2_)
      (B1_, (semiring_0_semiring_1 o semiring_1_comm_semiring_1) B2_)
      (poly_of (A1_, A2_) (B1_, B2_) p)
      (poly_of (A1_, A2_) (B1_, B2_) (PSum ps))
  | poly_of (A1_, A2_) (B1_, B2_) (PMult []) =
    one_polya A2_ (semiring_1_comm_semiring_1 B2_)
  | poly_of (A1_, A2_) (B1_, B2_) (PMult (p :: ps)) =
    poly_mult (A1_, A2_)
      (B1_, (semiring_0_semiring_1 o semiring_1_comm_semiring_1) B2_)
      (poly_of (A1_, A2_) (B1_, B2_) p)
      (poly_of (A1_, A2_) (B1_, B2_) (PMult ps));

fun square_possibilities (A1_, A2_) (B1_, B2_) sqrt p =
  let
    val roots =
      map (fn x =>
            map (fn a => (x, a))
              (sqrt (fst (poly_split (B1_, B2_)
                           ((zero_mult_zero o mult_zero_semiring_0 o
                              semiring_0_semiring_1 o
                              semiring_1_comm_semiring_1 o
                              comm_semiring_1_poly_carrier)
                             A2_)
                           (times_monom (B1_, B2_) (var_monom B2_ x)
                             (var_monom B2_ x))
                           p))))
        (poly_vars_list (B1_, B2_) p);
    val choices =
      (if membera (equal_list (equal_prod B1_ A1_)) roots [] then []
        else concat_lists roots);
    val polys =
      map (fn xas =>
            poly_of (B1_, B2_) (A1_, comm_semiring_1_poly_carrier A2_)
              (PSum (map (fn (x, a) => PMult [PVar x, PNum a]) xas)))
        choices;
  in
    polys
  end;

fun check_poly_eq (A1_, A2_) (B1_, B2_) [] q = null q
  | check_poly_eq (A1_, A2_) (B1_, B2_) ((m, c) :: p) q =
    (case extract (fn nd => eq (equal_monom (A1_, A2_)) (fst nd) m) q
      of NONE => false
      | SOME (q1, ((_, d), q2)) =>
        eq B1_ c d andalso check_poly_eq (A1_, A2_) (B1_, B2_) p (q1 @ q2));

fun monom_list_degree xps = sum_list monoid_add_nat (map snd xps);

fun monom_degree A_ xa = monom_list_degree (rep_monom A_ xa);

fun poly_degree A_ p = max_list (map (fn (m, _) => monom_degree A_ m) p);

fun check_quadratic (A1_, A2_) sqrt p =
  bindb (check
          (equal_nata (poly_degree linorder_nat p)
            (nat_of_integer (2 : IntInf.int)))
          (shows_prec_list show_char zero_nata
            [#"n", #"o", #"t", #" ", #"q", #"u", #"a", #"d", #"r", #"a", #"t",
              #"i", #"c"]))
    (fn _ =>
      let
        val polys =
          square_possibilities (A1_, A2_) (equal_nat, linorder_nat) sqrt p;
      in
        check (list_ex
                (fn q =>
                  check_poly_eq (equal_nat, linorder_nat)
                    (A1_, (semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                            comm_semiring_1_poly_carrier)
                            A2_)
                    (poly_mult (equal_nat, linorder_nat)
                      (A1_, (semiring_0_semiring_1 o
                              semiring_1_comm_semiring_1 o
                              comm_semiring_1_poly_carrier)
                              A2_)
                      q q)
                    p)
                polys)
          (shows_prec_list show_char zero_nata
            [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"f",
              #"i", #"n", #"d", #" ", #"q", #"u", #"a", #"d", #"r", #"a", #"t",
              #"i", #"c", #" ", #"p", #"o", #"l", #"y", #"n", #"o", #"m", #"i",
              #"a", #"l"])
      end);

fun check_quadratic_ge_const (A1_, A2_) (C1_, C2_) sq i st =
  let
    val (s, t) = st;
  in
    bindb (check (not (is_Var s))
            (shows_prec_list show_char zero_nata
              [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"n", #"o", #"n",
                #"-", #"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #"s",
                #" ", #"a", #"s", #" ", #"a", #"r", #"g", #"u", #"m", #"e",
                #"n", #"t", #"s"]))
      (fn _ =>
        let
          val pt = eval_term (A1_, A2_) (C1_, C2_) i t;
          val (c, p0) =
            poly_split (C1_, C2_)
              ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
                 semiring_1_comm_semiring_1 o comm_semiring_1_poly_carrier)
                A2_)
              (one_monom C2_) pt;
        in
          bindb (check
                  (equal_lista (equal_prod (equal_monom (C1_, C2_)) A1_) p0
                    zero_polya)
                  (shows_prec_list show_char zero_nata
                    [#"r", #"h", #"s", #" ", #"m", #"u", #"s", #"t", #" ", #"e",
                      #"v", #"a", #"l", #"u", #"a", #"t", #"e", #" ", #"t",
                      #"o", #" ", #"c", #"o", #"n", #"s", #"t", #"a", #"n",
                      #"t"]))
            (fn _ =>
              let
                val ps = i (the (root s));
                val (d, psx) =
                  poly_split (equal_nat, linorder_nat)
                    ((zero_mult_zero o mult_zero_semiring_0 o
                       semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                       comm_semiring_1_poly_carrier)
                      A2_)
                    (one_monom linorder_nat) ps;
              in
                bindb (check
                        (less_eq
                          ((ord_non_strict_order o
                             non_strict_order_ordered_ab_semigroup o
                             ordered_ab_semigroup_ordered_semiring_0 o
                             ordered_semiring_0_ordered_semiring_1 o
                             ordered_semiring_1_poly_carrier)
                            A2_)
                          c d)
                        (shows_prec_list show_char zero_nata
                          [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i",
                            #"n", #" ", #"c", #"o", #"m", #"p", #"a", #"r",
                            #"i", #"n", #"g", #" ", #"c", #"o", #"n", #"s",
                            #"t", #"a", #"n", #"t", #"s"]))
                  (fn _ => check_quadratic (A1_, A2_) sq psx)
              end)
        end)
  end;

fun check_ns A_ (B1_, B2_, B3_) (C1_, C2_, C3_) i =
  (fn (s, t) =>
    let
      val p = eval_term (B1_, B2_) (C1_, C2_) i s;
      val q = eval_term (B1_, B2_) (C1_, C2_) i t;
    in
      check (check_poly_ge (C1_, C2_)
              ((ordered_semiring_0_ordered_semiring_1 o
                 ordered_semiring_1_poly_carrier)
                B2_)
              p q)
        (shows_string
           [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"e",
             #"n", #"s", #"u", #"r", #"e", #" "] o
          (shows_prec_term A_ C3_ zero_nata s o
            (shows_string [#" ", #">", #"=", #" "] o
              (shows_prec_term A_ C3_ zero_nata t o
                (shows_string
                   [#" ", #"s", #"i", #"n", #"c", #"e", #" ", #"w", #"e",
                     #" "] o
                  (shows_nl o
                    (shows_string
                       [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                         #" ", #"e", #"n", #"s", #"u", #"r", #"e", #" "] o
                      (shows_poly (C1_, C2_, C3_)
                         ((one_numeral o numeral_semiring_numeral o
                            semiring_numeral_semiring_1 o
                            semiring_1_comm_semiring_1 o
                            comm_semiring_1_poly_carrier)
                            B2_,
                           B1_, B3_)
                         p o
                        (shows_string [#" ", #">", #"=", #" "] o
                          shows_poly (C1_, C2_, C3_)
                            ((one_numeral o numeral_semiring_numeral o
                               semiring_numeral_semiring_1 o
                               semiring_1_comm_semiring_1 o
                               comm_semiring_1_poly_carrier)
                               B2_,
                              B1_, B3_)
                            q)))))))))
    end);

fun check_cc (A1_, A2_, A3_) B_ (C1_, C2_, C3_) sq gt i
  (Unconditional_C (false, st)) =
  (if isOK (check_quadratic_ge_const (A1_, A2_) (C1_, C2_) sq i st) then Inr ()
    else check_ns B_ (A1_, A2_, A3_) (C1_, C2_, C3_) i st)
  | check_cc (A1_, A2_, A3_) B_ (C1_, C2_, C3_) sq gt i
    (Unconditional_C (true, st)) =
    check_s (A1_, A2_, A3_) B_ (C1_, C2_, C3_) gt i st
  | check_cc (A1_, A2_, A3_) B_ (C1_, C2_, C3_) sq gt i
    (Conditional_C (true, (u, v), (s, t))) =
    let
      val ss = eval_term (A1_, A2_) (C1_, C2_) i s;
      val tt = eval_term (A1_, A2_) (C1_, C2_) i t;
      val uu = eval_term (A1_, A2_) (C1_, C2_) i u;
      val vv = eval_term (A1_, A2_) (C1_, C2_) i v;
    in
      (if check_poly_gt
            ((ordered_semiring_0_ordered_semiring_1 o
               ordered_semiring_1_poly_carrier)
              A2_)
            (C1_, C2_) gt ss tt
        then Inr ()
        else check (check_poly_ge (C1_, C2_)
                     ((ordered_semiring_0_ordered_semiring_1 o
                        ordered_semiring_1_poly_carrier)
                       A2_)
                     (poly_add (C1_, C2_)
                       (A1_, (semiring_0_semiring_1 o
                               semiring_1_comm_semiring_1 o
                               comm_semiring_1_poly_carrier)
                               A2_)
                       ss vv)
                     (poly_add (C1_, C2_)
                       (A1_, (semiring_0_semiring_1 o
                               semiring_1_comm_semiring_1 o
                               comm_semiring_1_poly_carrier)
                               A2_)
                       tt uu))
               (shows_string
                  [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                    #"e", #"n", #"s", #"u", #"r", #"e", #" "] o
                 (shows_prec_term B_ C3_ zero_nata u o
                   (shows_string [#" ", #">", #" "] o
                     (shows_prec_term B_ C3_ zero_nata v o
                       (shows_string [#" ", #"=", #"=", #">", #" "] o
                         (shows_prec_term B_ C3_ zero_nata s o
                           (shows_string [#" ", #">", #" "] o
                             shows_prec_term B_ C3_ zero_nata t))))))))
    end
  | check_cc (A1_, A2_, A3_) B_ (C1_, C2_, C3_) sq gt i
    (Conditional_C (false, (u, v), (s, t))) =
    (if isOK (check_quadratic_ge_const (A1_, A2_) (C1_, C2_) sq i (s, t))
      then Inr ()
      else let
             val ss = eval_term (A1_, A2_) (C1_, C2_) i s;
             val tt = eval_term (A1_, A2_) (C1_, C2_) i t;
             val uu = eval_term (A1_, A2_) (C1_, C2_) i u;
             val vv = eval_term (A1_, A2_) (C1_, C2_) i v;
           in
             (if check_poly_ge (C1_, C2_)
                   ((ordered_semiring_0_ordered_semiring_1 o
                      ordered_semiring_1_poly_carrier)
                     A2_)
                   ss tt
               then Inr ()
               else check (check_poly_ge (C1_, C2_)
                            ((ordered_semiring_0_ordered_semiring_1 o
                               ordered_semiring_1_poly_carrier)
                              A2_)
                            (poly_add (C1_, C2_)
                              (A1_, (semiring_0_semiring_1 o
                                      semiring_1_comm_semiring_1 o
                                      comm_semiring_1_poly_carrier)
                                      A2_)
                              ss vv)
                            (poly_add (C1_, C2_)
                              (A1_, (semiring_0_semiring_1 o
                                      semiring_1_comm_semiring_1 o
                                      comm_semiring_1_poly_carrier)
                                      A2_)
                              tt uu))
                      (shows_string
                         [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                           #" ", #"e", #"n", #"s", #"u", #"r", #"e", #" "] o
                        (shows_prec_term B_ C3_ zero_nata u o
                          (shows_string [#" ", #">", #"=", #" "] o
                            (shows_prec_term B_ C3_ zero_nata v o
                              (shows_string [#" ", #"=", #"=", #">", #" "] o
                                (shows_prec_term B_ C3_ zero_nata s o
                                  (shows_string [#" ", #">", #"=", #" "] o
                                    shows_prec_term B_ C3_ zero_nata t))))))))
           end);

fun is_left_of Empty q = false
  | is_left_of (PCons (i, p)) q =
    (case q of Empty => false
      | PCons (j, qa) =>
        (if less_nat i j then true
          else (if less_nat j i then false else is_left_of p qa)));

fun pos_prefix Empty q = SOME q
  | pos_prefix (PCons (i, p)) q =
    (case q of Empty => NONE
      | PCons (j, qa) => (if equal_nata i j then pos_prefix p qa else NONE));

fun pos_suffix p q =
  (case pos_prefix (reva p) (reva q) of NONE => NONE
    | SOME qa => SOME (reva qa));

fun rules_with B_ p m =
  map_filter (fn x => (if (p o fst) x then SOME (snd x) else NONE))
    (values (linorder_prod B_ linorder_nat) m);

fun scnp_desc A_ af mu =
  shows_prec_list show_char zero_nata
    [#"S", #"C", #"N", #"P", #"-", #"v", #"e", #"r", #"s", #"i", #"o", #"n",
      #" ", #"w", #"i", #"t", #"h", #" ", #"m", #"u", #" ", #"=", #" "] o
    shows_prec_list show_char zero_nata mu o
    shows_prec_list show_char zero_nata
      [#" ", #"a", #"n", #"d", #" ", #"t", #"h", #"e", #" ", #"l", #"e", #"v",
        #"e", #"l", #" ", #"m", #"a", #"p", #"p", #"i", #"n", #"g", #" ", #"d",
        #"e", #"f", #"i", #"n", #"e", #"d", #" ", #"b", #"y", #" "] o
    shows_nl o
    shows_sep
      (fn (a, b) =>
        let
          val (f, n) = a;
        in
          (fn asa =>
            shows_prec_list show_char zero_nata [#"p", #"i", #"("] o
              shows_prec A_ zero_nata f o
              shows_prec_list show_char zero_nata [#")", #" ", #"=", #" "] o
              showsp_list
                (fn _ => fn (p, l) =>
                  shows_prec_list show_char zero_nata [#"("] o
                    (if less_nat p n then shows_prec_nat zero_nata (suc p)
                      else shows_prec_list show_char zero_nata
                             [#"e", #"p", #"s", #"i", #"l", #"o", #"n"]) o
                    shows_prec_list show_char zero_nata [#","] o
                    shows_prec_nat zero_nata l o
                    shows_prec_list show_char zero_nata [#")"])
                zero_nata asa)
        end
          b)
      shows_nl af o
    shows_nl;

fun split_rulesb
  (Tp_ops_ext
    (qreltrs, q, r, rw, rules, q_empty, is_QNF, nFQ_subset_NF_rules, rules_map,
      delete_R_Rw, split_rules, mk, nfs, more))
  = split_rules;

fun delete_R_Rwb
  (Tp_ops_ext
    (qreltrs, q, r, rw, rules, q_empty, is_QNF, nFQ_subset_NF_rules, rules_map,
      delete_R_Rw, split_rules, mk, nfs, more))
  = delete_R_Rw;

fun nfsb
  (Tp_ops_ext
    (qreltrs, q, r, rw, rules, q_empty, is_QNF, nFQ_subset_NF_rules, rules_map,
      delete_R_Rw, split_rules, mk, nfs, more))
  = nfs;

fun mkc
  (Tp_ops_ext
    (qreltrs, q, r, rw, rules, q_empty, is_QNF, nFQ_subset_NF_rules, rules_map,
      delete_R_Rw, split_rules, mk, nfs, more))
  = mk;

fun qb
  (Tp_ops_ext
    (qreltrs, q, r, rw, rules, q_empty, is_QNF, nFQ_subset_NF_rules, rules_map,
      delete_R_Rw, split_rules, mk, nfs, more))
  = q;

fun split_tt B_ C_ i tp r_remove =
  let
    val (r, rw) = split_rulesb i tp r_remove;
    val tp1 = mkc i (nfsb i tp) (qb i tp) r rw;
    val a = delete_R_Rwb i tp r_remove r_remove;
  in
    (tp1, a)
  end;

fun sturm_aux p q =
  (if equal_nata (degreea zero_real q) zero_nata then [p, q]
    else p :: sturm_aux q
                (uminus_polya ab_group_add_real
                  (modulo_polya (field_real, equal_real) p q)));

fun sturm p =
  sturm_aux p
    (pderiv (equal_real, comm_semiring_1_real, semiring_no_zero_divisors_real)
      p);

fun funs_term_list t = add_funs_term t [];

fun supt_impl A_ B_ (Var x) t = false
  | supt_impl A_ B_ (Fun (f, ss)) t =
    membera (equal_term A_ B_) ss t orelse
      list_ex (fn s => supt_impl A_ B_ s t) ss;

fun supt_list (Var x) = []
  | supt_list (Fun (f, ts)) = maps supteq_list ts;

fun af_inter pi mu f = inf_seta (ceq_nat, ccompare_nat) (pi f) (mu f);

fun empty_af fna = set_empty (ceq_nat, ccompare_nat) (of_phantom set_impl_nata);

fun r_sym (TA_rule (f, qs, q)) = (f, size_list qs);

fun shows_rule funa var arr (l, r) =
  shows_term funa var l o shows_prec_list show_char zero_nata arr o
    shows_term funa var r;

fun shows_rules funa var arr trs =
  shows_list_gen (shows_rule funa var arr) [] [] [#"\n"] [] trs o shows_nl;

fun shows_trs funa var name arr r =
  shows_prec_list show_char zero_nata name o shows_nl o shows_nl o
    shows_rules funa var arr r;

fun aarity_term A_ a sm t =
  (case unapp A_ a t of (Var _, _) => NONE
    | (Fun (f, ss), ts) =>
      SOME (minus_nata (aarity sm f (size_list ss)) (size_list ts)));

fun map_funs_term_wa fg (Var x) = Var x
  | map_funs_term_wa fg (Fun (f, ts)) =
    Fun (fg (f, size_list ts), map (map_funs_term_wa fg) ts);

fun uncurry_top A_ a n sm (Fun (f, ts)) =
  let
    val mt =
      map (map_funs_term_wa (fn (fa, na) => get_symbol sm fa na zero_nata));
    val t = hda ts;
  in
    (if eq A_ f a andalso
          (equal_nata (size_list ts) n andalso
            (not (is_Var t) andalso
              let
                val (h, m) = the (root t);
              in
                not (equal_nata (aarity sm h m) zero_nata)
              end))
      then let
             val Fun (g, ss) = t;
           in
             Fun (get_symbol sm g (size_list ss) one_nata, mt (ss @ tla ts))
           end
      else Fun (let
                  val (fa, na) = (f, size_list ts);
                in
                  get_symbol sm fa na zero_nata
                end,
                 mt ts))
  end
  | uncurry_top A_ a n sm (Var x) = Var x;

fun innermostLhss A_ xml2name =
  xml_do
    [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #"L", #"h", #"s",
      #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat (term A_ xml2name)
      xml_return);

fun strategy A_ xml2name =
  xml_do [#"s", #"t", #"r", #"a", #"t", #"e", #"g", #"y"]
    (xml_take
      (xml_or
        (xml_leaf [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t"]
          Innermost)
        (xml_change (innermostLhss A_ xml2name) (xml_return o Innermost_Q)))
      xml_return);

fun extract_special acc [] = NONE
  | extract_special acc (x :: xs) =
    (if ((x : char) = #";")
      then map_option (fn s => (s, xs)) (special_map (rev acc))
      else extract_special (x :: acc) xs);

fun normalize_special [] = []
  | normalize_special (x :: xs) =
    (if ((x : char) = #"&")
      then (case extract_special [] xs of NONE => [#"&"] @ normalize_special xs
             | SOME (spec, ys) => spec @ normalize_special ys)
      else x :: normalize_special xs);

fun parse_xmlfile p str =
  (case doc_of_string str of Inl a => Inl a
    | Inr (XMLDOC (_, xml)) =>
      parse_xml p (map_xml_text normalize_special xml));

fun right x = Sumbot (Inr x);

fun left x = Sumbot (Inl x);

fun xmlt_of_xmlt2 p xml =
  (case xml_take p xml_return ([xml], ([], (false, ([], [[#"?", #"?"]]))))
    of Inl a => let
                  val Fatal aa = a;
                in
                  left aa
                end
    | Inr a => right a);

fun aABin A_ f (AFun (g, [s, t])) u =
  (if eq A_ f g then AFun (f, [s, aABin A_ f t u])
    else AFun (f, [AFun (g, [s, t]), u]))
  | aABin A_ f (AVar v) t = AFun (f, [AVar v, t])
  | aABin A_ f (AFun (v, [])) t = AFun (f, [AFun (v, []), t])
  | aABin A_ f (AFun (v, [vb])) t = AFun (f, [AFun (v, [vb]), t])
  | aABin A_ f (AFun (v, vb :: vd :: vf :: vg)) t =
    AFun (f, [AFun (v, vb :: vd :: vf :: vg), t])
  | aABin A_ f (AAC (v, va)) t = AFun (f, [AAC (v, va), t]);

fun actop A_ B_ f (Fun (g, [s, t])) =
  (if eq A_ f g
    then plus_multiseta (equal_term A_ B_) (actop A_ B_ f s) (actop A_ B_ f t)
    else add_mset (equal_term A_ B_) (Fun (g, [s, t])) zero_multiseta)
  | actop A_ B_ f (Var v) = add_mset (equal_term A_ B_) (Var v) zero_multiseta
  | actop A_ B_ f (Fun (v, [])) =
    add_mset (equal_term A_ B_) (Fun (v, [])) zero_multiseta
  | actop A_ B_ f (Fun (v, [vb])) =
    add_mset (equal_term A_ B_) (Fun (v, [vb])) zero_multiseta
  | actop A_ B_ f (Fun (v, vb :: vd :: vf :: vg)) =
    add_mset (equal_term A_ B_) (Fun (v, vb :: vd :: vf :: vg)) zero_multiseta;

fun aocnf (A1_, A2_, A3_) B_ f_A f_C (Fun (f, s :: t :: u :: us)) =
  AFun (f, aocnf (A1_, A2_, A3_) B_ f_A f_C s ::
             aocnf (A1_, A2_, A3_) B_ f_A f_C t ::
               aocnf (A1_, A2_, A3_) B_ f_A f_C u ::
                 map (aocnf (A1_, A2_, A3_) B_ f_A f_C) us)
  | aocnf (A1_, A2_, A3_) B_ f_A f_C (Fun (f, [t])) =
    AFun (f, [aocnf (A1_, A2_, A3_) B_ f_A f_C t])
  | aocnf (A1_, A2_, A3_) B_ f_A f_C (Fun (f, [])) = AFun (f, [])
  | aocnf (A1_, A2_, A3_) B_ f_A f_C (Fun (f, [s, t])) =
    let
      val a = member (A1_, A2_) f f_A;
      val c = member (A1_, A2_) f f_C;
    in
      (if a andalso c
        then AAC (f, image_mset (equal_acterm A3_ B_)
                       (aocnf (A1_, A2_, A3_) B_ f_A f_C)
                       (actop A3_ B_ f (Fun (f, [s, t]))))
        else (if a then aABin A3_ f (aocnf (A1_, A2_, A3_) B_ f_A f_C s)
                          (aocnf (A1_, A2_, A3_) B_ f_A f_C t)
               else (if c then AAC (f, add_mset (equal_acterm A3_ B_)
 (aocnf (A1_, A2_, A3_) B_ f_A f_C s)
 (add_mset (equal_acterm A3_ B_) (aocnf (A1_, A2_, A3_) B_ f_A f_C t)
   zero_multiseta))
                      else AFun (f, [aocnf (A1_, A2_, A3_) B_ f_A f_C s,
                                      aocnf (A1_, A2_, A3_) B_ f_A f_C t]))))
    end
  | aocnf (A1_, A2_, A3_) B_ f_A f_C (Var x) = AVar x;

fun cstep_trg (Cstep_step (x1, x2, x3, x4, x5, x6)) = x5;

fun cstep_src (Cstep_step (x1, x2, x3, x4, x5, x6)) = x4;

fun shows_eq funa var = shows_rule funa var [#" ", #"-", #">", #"*", #" "];

fun shows_conditions funa var =
  shows_sep (shows_eq funa var)
    (shows_prec_list show_char zero_nata [#",", #" "]);

fun shows_crule funa var cr =
  shows_rule funa var [#" ", #"-", #">", #" "] (fst cr) o
    (if null (snd cr) then id
      else shows_prec_list show_char zero_nata [#" ", #"|", #" "]) o
    shows_conditions funa var (snd cr);

fun match_rules A_ (B1_, B2_, B3_) rs_1 rs_2 =
  bind (zip_option (map fst rs_2 @ map snd rs_2) (map fst rs_1 @ map snd rs_1))
    (match_list (B1_, B2_, B3_) A_ B2_ Var);

fun check_crule_variants (A1_, A2_) (B1_, B2_, B3_, B4_) ra r =
  let
    val rs = fst ra :: snd ra;
    val rsa = fst r :: snd r;
  in
    check (not (is_none (match_rules A1_ (B1_, B2_, B3_) rs rsa)) andalso
            not (is_none (match_rules A1_ (B1_, B2_, B3_) rsa rs)))
      (shows_crule (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata) ra o
         shows_prec_list show_char zero_nata [#" ", #"a", #"n", #"d", #" "] o
         shows_crule (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata) r o
         shows_prec_list show_char zero_nata
           [#" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ", #"v", #"a",
             #"r", #"i", #"a", #"n", #"t", #"s", #" ", #"o", #"f", #" ", #"e",
             #"a", #"c", #"h", #" ", #"o", #"t", #"h", #"e", #"r"] o
        shows_nl)
  end;

fun shows_crules funa var ctrs =
  shows_list_gen (shows_crule funa var) [] [] [#"\n"] [] ctrs o shows_nl;

fun shows_ctrs funa var r =
  shows_prec_list show_char zero_nata [#"C", #"T", #"R", #"S", #":"] o
    shows_nl o
    shows_nl o
    shows_crules funa var r;

fun check_variant_in_ctrs (A1_, A2_) (B1_, B2_, B3_, B4_) ra r =
  catch_errora
    (catch_errora
      (existsM (check_crule_variants (A1_, A2_) (B1_, B2_, B3_, B4_) r) ra)
      (fn x => Inl (shows_sep id id x)))
    (fn _ =>
      Inl (shows_prec_list show_char zero_nata [#"r", #"u", #"l", #"e", #" "] o
             shows_crule (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
               r o
             shows_prec_list show_char zero_nata
               [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ",
                 #"v", #"a", #"r", #"i", #"a", #"n", #"t", #" ", #"o", #"f",
                 #" ", #"a", #"n", #"y", #" ", #"r", #"u", #"l", #"e", #" ",
                 #"i", #"n", #":"] o
             shows_nl o
            shows_ctrs (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
              ra));

fun check_csteps (A1_, A2_) (B1_, B2_, B3_, B4_) r s t [] =
  check (equal_terma A1_ B2_ s t)
    (shows_prec_list show_char zero_nata
       [#"e", #"m", #"p", #"t", #"y", #" ", #"r", #"e", #"w", #"r", #"i", #"t",
         #"e", #" ", #"s", #"e", #"q", #"u", #"e", #"n", #"c", #"e", #" ", #"b",
         #"u", #"t", #" ", #"s", #"o", #"u", #"r", #"c", #"e", #" "] o
       shows_prec_term A2_ B4_ zero_nata s o
       shows_prec_list show_char zero_nata
         [#" ", #"a", #"n", #"d", #" ", #"t", #"a", #"r", #"g", #"e", #"t",
           #" "] o
       shows_prec_term A2_ B4_ zero_nata t o
      shows_prec_list show_char zero_nata
        [#" ", #"d", #"i", #"f", #"f", #"e", #"r"])
  | check_csteps (A1_, A2_) (B1_, B2_, B3_, B4_) r s t [p] =
    bindb (check (equal_terma A1_ B2_ (cstep_src p) s)
            (shows_prec_term A2_ B4_ zero_nata (cstep_src p) o
               shows_prec_list show_char zero_nata
                 [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ",
                   #"m", #"a", #"t", #"c", #"h", #" ", #"t", #"h", #"e", #" ",
                   #"s", #"o", #"u", #"r", #"c", #"e", #" "] o
              shows_prec_term A2_ B4_ zero_nata s))
      (fn _ =>
        bindb (check (equal_terma A1_ B2_ (cstep_trg p) t)
                (shows_prec_term A2_ B4_ zero_nata (cstep_trg p) o
                   shows_prec_list show_char zero_nata
                     [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t",
                       #" ", #"m", #"a", #"t", #"c", #"h", #" ", #"t", #"h",
                       #"e", #" ", #"t", #"a", #"r", #"g", #"e", #"t", #" "] o
                  shows_prec_term A2_ B4_ zero_nata t))
          (fn _ => check_cstep (A1_, A2_) (B1_, B2_, B3_, B4_) r p))
  | check_csteps (A1_, A2_) (B1_, B2_, B3_, B4_) r s t (p :: v :: va) =
    bindb (check (equal_terma A1_ B2_ (cstep_src p) s)
            (shows_prec_term A2_ B4_ zero_nata (cstep_src p) o
               shows_prec_list show_char zero_nata
                 [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ",
                   #"m", #"a", #"t", #"c", #"h", #" ", #"t", #"h", #"e", #" ",
                   #"s", #"o", #"u", #"r", #"c", #"e", #" "] o
              shows_prec_term A2_ B4_ zero_nata s))
      (fn _ =>
        bindb (check_cstep (A1_, A2_) (B1_, B2_, B3_, B4_) r p)
          (fn _ =>
            check_csteps (A1_, A2_) (B1_, B2_, B3_, B4_) r (cstep_trg p) t
              (v :: va)))
and check_cstep (A1_, A2_) (B1_, B2_, B3_, B4_) ra
  (Cstep_step (((l, r), cs), p, sigma, s, t, pss)) =
  bindb (check_variant_in_ctrs (A1_, A2_) (B1_, B2_, B3_, B4_) ra ((l, r), cs))
    (fn _ =>
      bindb (check (equal_nata (size_list pss) (size_list cs))
              (shows_prec_list show_char zero_nata
                [#"m", #"i", #"s", #"m", #"a", #"t", #"c", #"h", #" ", #"b",
                  #"e", #"t", #"w", #"e", #"e", #"n", #" ", #"n", #"u", #"m",
                  #"b", #"e", #"r", #" ", #"o", #"f", #" ", #"c", #"o", #"n",
                  #"d", #"i", #"t", #"i", #"o", #"n", #"s", #" ", #"a", #"n",
                  #"d", #" ", #"n", #"u", #"m", #"b", #"e", #"r", #" ", #"o",
                  #"f", #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                  #"s", #"e", #"q", #"u", #"e", #"n", #"c", #"e", #"s"]))
        (fn _ =>
          bindb (check
                  (equal_terma A1_ B2_ s
                    (ctxt_apply_term (ctxt_of_pos_term p s)
                      (subst_apply_term l sigma)))
                  (shows_prec_term A2_ B4_ zero_nata s o
                     shows_prec_list show_char zero_nata
                       [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t",
                         #" ", #"c", #"o", #"n", #"t", #"a", #"i", #"n", #" ",
                         #"a", #"n", #" ", #"i", #"n", #"s", #"t", #"a", #"n",
                         #"c", #"e", #" ", #"o", #"f", #" "] o
                    shows_prec_term A2_ B4_ zero_nata l))
            (fn _ =>
              bindb (check
                      (equal_terma A1_ B2_ t
                        (ctxt_apply_term (ctxt_of_pos_term p s)
                          (subst_apply_term r sigma)))
                      (shows_prec_term A2_ B4_ zero_nata t o
                         shows_prec_list show_char zero_nata
                           [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o",
                             #"t", #" ", #"c", #"o", #"n", #"t", #"a", #"i",
                             #"n", #" ", #"a", #"n", #" ", #"i", #"n", #"s",
                             #"t", #"a", #"n", #"c", #"e", #" ", #"o", #"f",
                             #" "] o
                        shows_prec_term A2_ B4_ zero_nata r))
                (fn _ =>
                  catch_errora
                    (forallM
                      (fn i =>
                        check_csteps (A1_, A2_) (B1_, B2_, B3_, B4_) ra
                          (subst_apply_term (fst (nth cs i)) sigma)
                          (subst_apply_term (snd (nth cs i)) sigma) (nth pss i))
                      (upt zero_nata (size_list cs)))
                    (fn x => Inl (snd x))))));

fun map_funs_crule f r =
  ((map_term f (fn x => x) (fst (fst r)), map_term f (fn x => x) (snd (fst r))),
    map (map_funs_rule f) (snd r));

fun skol_crule (A1_, A2_) (B1_, B2_, B3_, B4_) ra v r =
  (if member
        (ceq_prod (ceq_prod (ceq_term A2_ B4_) (ceq_term A2_ B4_))
           (ceq_list (ceq_prod (ceq_term A2_ B4_) (ceq_term A2_ B4_))),
          ccompare_prod
            (ccompare_prod (ccompare_term A1_ B3_) (ccompare_term A1_ B3_))
            (ccompare_list
              (ccompare_prod (ccompare_term A1_ B3_) (ccompare_term A1_ B3_))))
        r ra
    then map_funs_crule Inl r
    else ((skol (B1_, B2_) v (fst (fst r)), skol (B1_, B2_) v (snd (fst r))),
           map (fn (s, t) => (skol (B1_, B2_) v s, skol (B1_, B2_) v t))
             (snd r)));

fun skol_cstep_proof (A1_, A2_) (B1_, B2_, B3_, B4_) r v
  (Cstep_step (rho, p, sigma, s, t, pss)) =
  Cstep_step
    (skol_crule (A1_, A2_) (B1_, B2_, B3_, B4_) r v rho, p,
      skol (B1_, B2_) v o sigma, skol (B1_, B2_) v s, skol (B1_, B2_) v t,
      map (map (skol_cstep_proof (A1_, A2_) (B1_, B2_, B3_, B4_) r v)) pss);

fun map_funs_crules f r = map (map_funs_crule f) r;

fun rules2crules rs = map (fn r => (r, [])) rs;

fun skol_rules (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) cs =
  let
    val v =
      vars_trs (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
        (set (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_),
               ccompare_prod (ccompare_term A1_ B5_) (ccompare_term A1_ B5_),
               set_impl_prod set_impl_term set_impl_term)
          cs);
  in
    map (fn (l, r) =>
          (skol (B3_, ccompare_cproper_interval B4_) v l,
            skol (B3_, ccompare_cproper_interval B4_) v r))
      cs
  end;

fun check_context_joinablea (A1_, A2_, A3_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) (Contextual_Join (u, ps, qs)) r
  s t cs =
  catch_errora
    let
      val c = skol_rules (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B8_) cs;
      val v =
        vars_trs (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B8_)
          (set (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_),
                 ccompare_prod (ccompare_term A1_ B5_) (ccompare_term A1_ B5_),
                 set_impl_prod set_impl_term set_impl_term)
            cs);
      val sa = skol (B3_, ccompare_cproper_interval B4_) v s;
      val ta = skol (B3_, ccompare_cproper_interval B4_) v t;
      val ua = skol (B3_, ccompare_cproper_interval B4_) v u;
      val psa =
        map (skol_cstep_proof (A1_, A2_)
              (B3_, ccompare_cproper_interval B4_, B5_, B6_)
              (set (ceq_prod (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_))
                      (ceq_list
                        (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_))),
                     ccompare_prod
                       (ccompare_prod (ccompare_term A1_ B5_)
                         (ccompare_term A1_ B5_))
                       (ccompare_list
                         (ccompare_prod (ccompare_term A1_ B5_)
                           (ccompare_term A1_ B5_))),
                     set_impl_prod (set_impl_prod set_impl_term set_impl_term)
                       set_impl_list)
                r)
              v)
          ps;
      val qsa =
        map (skol_cstep_proof (A1_, A2_)
              (B3_, ccompare_cproper_interval B4_, B5_, B6_)
              (set (ceq_prod (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_))
                      (ceq_list
                        (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_))),
                     ccompare_prod
                       (ccompare_prod (ccompare_term A1_ B5_)
                         (ccompare_term A1_ B5_))
                       (ccompare_list
                         (ccompare_prod (ccompare_term A1_ B5_)
                           (ccompare_term A1_ B5_))),
                     set_impl_prod (set_impl_prod set_impl_term set_impl_term)
                       set_impl_list)
                r)
              v)
          qs;
      val ra = map_funs_crules Inl r @ rules2crules c;
    in
      bindb (check_csteps (equal_sum A2_ B6_, show_sum A3_ B9_)
              (ccompare_cproper_interval B4_, B6_, B7_, B9_) ra sa ua psa)
        (fn _ =>
          check_csteps (equal_sum A2_ B6_, show_sum A3_ B9_)
            (ccompare_cproper_interval B4_, B6_, B7_, B9_) ra ta ua qsa)
    end
    (fn x =>
      Inl (shows_term (shows_prec A3_ zero_nata) (shows_prec B9_ zero_nata) s o
             shows_prec_list show_char zero_nata
               [#" ", #"a", #"n", #"d", #" "] o
             shows_term (shows_prec A3_ zero_nata) (shows_prec B9_ zero_nata)
               t o
             shows_prec_list show_char zero_nata
               [#" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ", #"c",
                 #"o", #"n", #"t", #"e", #"x", #"t", #"-", #"j", #"o", #"i",
                 #"n", #"a", #"b", #"l", #"e"] o
             shows_nl o
            x));

fun check_context_joinable (A1_, A2_, A3_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_, B10_) cj r s t cs =
  catch_errora
    (existsM
      (fn (sa, (ta, (csa, p))) =>
        bindb (check
                (not (is_none
                       (match_rules A1_
                         (ccompare_cproper_interval B4_, B6_, B7_)
                         ((s, t) :: cs) ((sa, ta) :: csa))))
                id)
          (fn _ =>
            bindb (check
                    (not (is_none
                           (match_rules A1_
                             (ccompare_cproper_interval B4_, B6_, B7_)
                             ((sa, ta) :: csa) ((s, t) :: cs))))
                    id)
              (fn _ =>
                check_context_joinablea
                  ((compare_compare_order o compare_order_key) A2_, A1_, A3_)
                  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B9_, B10_) p r sa ta
                  csa)))
      cj)
    (fn x => Inl (shows_sep id shows_nl x));

fun shows_coverlap A_ B_ C_ D_ E_ rho_1 rho_2 p =
  shows_prec_list show_char zero_nata
    [#"o", #"v", #"e", #"r", #"l", #"a", #"p", #" ", #"o", #"f", #" ", #"c",
      #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a", #"l", #" ", #"r",
      #"u", #"l", #"e", #"s", #" "] o
    shows_crule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata) rho_1 o
    shows_prec_list show_char zero_nata [#" ", #"a", #"n", #"d", #" "] o
    shows_crule (shows_prec C_ zero_nata) (shows_prec D_ zero_nata) rho_2 o
    shows_prec_list show_char zero_nata
      [#" ", #"a", #"t", #" ", #"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n",
        #" "] o
    shows_prec E_ zero_nata p;

fun mgu_var_disjoint_generic B_ D_ vu wu s t =
  (case mgu D_ B_ (map_term (fn x => x) vu s) (map_term (fn x => x) wu t)
    of NONE => NONE | SOME gamma => SOME (gamma o vu, gamma o wu));

fun check_overlap (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) xvar yvar
  check_context_joinable check_infeasible check_unfeasible r rho_1 rho_2 p =
  catch_errora
    (case mgu_var_disjoint_generic A2_ B1_ xvar yvar
            (subt_at (fst (fst rho_1)) p) (fst (fst rho_2))
      of NONE => Inr ()
      | SOME (sigma_1, sigma_2) =>
        let
          val cs =
            subst_list sigma_1 (snd rho_1) @ subst_list sigma_2 (snd rho_2);
          val s = subst_apply_term (snd (fst rho_1)) sigma_1;
          val t =
            ctxt_apply_term
              (ctxt_of_pos_term p (subst_apply_term (fst (fst rho_1)) sigma_1))
              (subst_apply_term (snd (fst rho_2)) sigma_2);
        in
          catch_errora
            (choice
              [catch_errora
                 (bindb (check (equal_posa p Empty) id)
                   (fn _ =>
                     check_crule_variants (B1_, B2_) (A1_, A2_, A3_, A5_) rho_1
                       rho_2))
                 (fn x =>
                   Inl (shows_prec_list show_char zero_nata
                          [#"t", #"h", #"e", #" ", #"o", #"v", #"e", #"r", #"l",
                            #"a", #"p", #" ", #"i", #"s", #" ", #"c", #"r",
                            #"i", #"t", #"i", #"c", #"a", #"l"] o
                          shows_nl o
                         x)),
                catch_errora (check_context_joinable r s t cs)
                  (fn x =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
                             #"t", #" ", #"b", #"e", #" ", #"s", #"h", #"o",
                             #"w", #"n", #" ", #"t", #"o", #" ", #"b", #"e",
                             #" ", #"c", #"o", #"n", #"t", #"e", #"x", #"t",
                             #"-", #"j", #"o", #"i", #"n", #"a", #"b", #"l",
                             #"e"] o
                           shows_nl o
                          x)),
                catch_errora (check_infeasible r cs)
                  (fn x =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
                             #"t", #" ", #"b", #"e", #" ", #"s", #"h", #"o",
                             #"w", #"n", #" ", #"t", #"o", #" ", #"b", #"e",
                             #" ", #"i", #"n", #"f", #"e", #"a", #"s", #"i",
                             #"b", #"l", #"e"] o
                           shows_nl o
                          x)),
                catch_errora (check_unfeasible r (fst (fst rho_1)) sigma_1 cs)
                  (fn x =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
                             #"t", #" ", #"b", #"e", #" ", #"s", #"h", #"o",
                             #"w", #"n", #" ", #"t", #"o", #" ", #"b", #"e",
                             #" ", #"u", #"n", #"f", #"e", #"a", #"s", #"i",
                             #"b", #"l", #"e"] o
                           shows_nl o
                          x))])
            (fn x => Inl (shows_sep id shows_nl x))
        end)
    (fn x =>
      Inl (shows_coverlap B2_ A5_ B2_ A5_ show_pos rho_1 rho_2 p o
             shows_prec_list show_char zero_nata [#":"] o
             shows_nl o
             shows_nl o
            x));

fun rule2 (UnfeasibleOverlap (x1, x2, x3, x4, x5, x6, x7)) = x7;

fun rule1 (UnfeasibleOverlap (x1, x2, x3, x4, x5, x6, x7)) = x6;

fun check_airr (A1_, A2_) r t =
  catch_errora
    (catch_errora
      (forallM
        (fn cr =>
          catch_errora
            (forallM
              (fn p =>
                check (is_none
                        (mgu_var_disjoint_generic (equal_list equal_char) A1_
                          (fn a => #"x" :: a) (fn a => #"y" :: a) (subt_at t p)
                          (fst (fst cr))))
                  (shows_prec_list show_char zero_nata
                     [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #" "] o
                     shows_term (shows_prec A2_ zero_nata)
                       (shows_prec_list show_char zero_nata) t o
                     shows_prec_list show_char zero_nata
                       [#" ", #"i", #"s", #" ", #"u", #"n", #"i", #"f", #"i",
                         #"a", #"b", #"l", #"e", #" ", #"w", #"i", #"t", #"h",
                         #" ", #"t", #"h", #"e", #" ", #"l", #"e", #"f", #"t",
                         #"-", #"h", #"a", #"n", #"d", #" ", #"s", #"i", #"d",
                         #"e", #" ", #"o", #"f", #" ", #"r", #"u", #"l", #"e",
                         #" "] o
                     shows_crule (shows_prec A2_ zero_nata)
                       (shows_prec_list show_char zero_nata) cr o
                     shows_prec_list show_char zero_nata
                       [#" ", #"a", #"t", #" ", #"p", #"o", #"s", #"i", #"t",
                         #"i", #"o", #"n", #" "] o
                    shows_pos p))
              (funposs_list t))
            (fn x => Inl (snd x)))
        r)
      (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #" "] o
             shows_term (shows_prec A2_ zero_nata)
               (shows_prec_list show_char zero_nata) t o
             shows_prec_list show_char zero_nata
               [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"b",
                 #"s", #"o", #"l", #"u", #"t", #"e", #"l", #"y", #" ", #"i",
                 #"r", #"r", #"e", #"d", #"u", #"c", #"i", #"b", #"l", #"e"] o
             shows_nl o
            x));

fun check_unfeasiblea (A1_, A2_, A3_)
  (UnfeasibleOverlap (t, u, v, ps, qs, rho_1, rho_2)) r l mu cs =
  catch_errora
    let
      val c =
        skol_rules (A1_, A2_)
          (finite_UNIV_list, cenum_list, ceq_list ceq_char,
            cproper_interval_list ccompare_char, compare_list compare_char,
            equal_list equal_char, set_impl_list)
          cs;
      val va =
        vars_trs (A1_, A2_)
          (finite_UNIV_list, cenum_list, ceq_list ceq_char,
            cproper_interval_list ccompare_char, compare_list compare_char,
            equal_list equal_char, set_impl_list)
          (set (ceq_prod (ceq_term A2_ (equal_list equal_char))
                  (ceq_term A2_ (equal_list equal_char)),
                 ccompare_prod (ccompare_term A1_ (compare_list compare_char))
                   (ccompare_term A1_ (compare_list compare_char)),
                 set_impl_prod set_impl_term set_impl_term)
            cs);
      val ta = skol (ceq_list ceq_char, ccompare_list ccompare_char) va t;
      val ua = skol (ceq_list ceq_char, ccompare_list ccompare_char) va u;
      val vb = skol (ceq_list ceq_char, ccompare_list ccompare_char) va v;
      val psa =
        map (skol_cstep_proof (A1_, A2_)
              (ceq_list ceq_char, ccompare_list ccompare_char,
                compare_list compare_char, equal_list equal_char)
              (set (ceq_prod
                      (ceq_prod (ceq_term A2_ (equal_list equal_char))
                        (ceq_term A2_ (equal_list equal_char)))
                      (ceq_list
                        (ceq_prod (ceq_term A2_ (equal_list equal_char))
                          (ceq_term A2_ (equal_list equal_char)))),
                     ccompare_prod
                       (ccompare_prod
                         (ccompare_term A1_ (compare_list compare_char))
                         (ccompare_term A1_ (compare_list compare_char)))
                       (ccompare_list
                         (ccompare_prod
                           (ccompare_term A1_ (compare_list compare_char))
                           (ccompare_term A1_ (compare_list compare_char)))),
                     set_impl_prod (set_impl_prod set_impl_term set_impl_term)
                       set_impl_list)
                r)
              va)
          ps;
      val qsa =
        map (skol_cstep_proof (A1_, A2_)
              (ceq_list ceq_char, ccompare_list ccompare_char,
                compare_list compare_char, equal_list equal_char)
              (set (ceq_prod
                      (ceq_prod (ceq_term A2_ (equal_list equal_char))
                        (ceq_term A2_ (equal_list equal_char)))
                      (ceq_list
                        (ceq_prod (ceq_term A2_ (equal_list equal_char))
                          (ceq_term A2_ (equal_list equal_char)))),
                     ccompare_prod
                       (ccompare_prod
                         (ccompare_term A1_ (compare_list compare_char))
                         (ccompare_term A1_ (compare_list compare_char)))
                       (ccompare_list
                         (ccompare_prod
                           (ccompare_term A1_ (compare_list compare_char))
                           (ccompare_term A1_ (compare_list compare_char)))),
                     set_impl_prod (set_impl_prod set_impl_term set_impl_term)
                       set_impl_list)
                r)
              va)
          qs;
      val ra = map_funs_crules Inl r @ rules2crules c;
    in
      bindb (check (equal_terma A2_ (equal_list equal_char) l (fst (fst rho_1)))
              id)
        (fn _ =>
          bindb (check (list_all (fn (a, b) => let
         val (la, _) = a;
       in
         (fn _ => not (is_Var la))
       end
         b)
                         r)
                  (shows_prec_list show_char zero_nata
                    [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #" ", #"l",
                      #"e", #"f", #"t", #"-", #"h", #"a", #"n", #"d", #" ",
                      #"s", #"i", #"d", #"e"]))
            (fn _ =>
              bindb (check_variant_in_ctrs (A2_, A3_)
                      (ccompare_list ccompare_char, equal_list equal_char,
                        mapping_impl_list, show_list show_char)
                      r rho_1)
                (fn _ =>
                  bindb (check_variant_in_ctrs (A2_, A3_)
                          (ccompare_list ccompare_char, equal_list equal_char,
                            mapping_impl_list, show_list show_char)
                          r rho_2)
                    (fn _ =>
                      bindb (check
                              (equal_terma A2_ (equal_list equal_char)
                                 (subst_apply_term l mu)
                                 (subst_apply_term (fst (fst rho_2)) mu) orelse
                                supt_impl A2_ (equal_list equal_char)
                                  (subst_apply_term l mu)
                                  (subst_apply_term (fst (fst rho_2)) mu))
                              id)
                        (fn _ =>
                          bindb (check
                                  (member
                                    (ceq_term A2_ (equal_list equal_char),
                                      ccompare_term A1_
(compare_list compare_char))
                                    t (image
(ceq_prod (ceq_term A2_ (equal_list equal_char))
   (ceq_term A2_ (equal_list equal_char)),
  ccompare_prod (ccompare_term A1_ (compare_list compare_char))
    (ccompare_term A1_ (compare_list compare_char)))
(ceq_term A2_ (equal_list equal_char),
  ccompare_term A1_ (compare_list compare_char), set_impl_term)
fst (set (ceq_prod (ceq_term A2_ (equal_list equal_char))
            (ceq_term A2_ (equal_list equal_char)),
           ccompare_prod (ccompare_term A1_ (compare_list compare_char))
             (ccompare_term A1_ (compare_list compare_char)),
           set_impl_prod set_impl_term set_impl_term)
      cs)))
                                  id)
                            (fn _ =>
                              bindb (check
                                      (equal_lista
(equal_prod (equal_term A2_ (equal_list equal_char))
  (equal_term A2_ (equal_list equal_char)))
cs (subst_list mu (snd rho_1 @ snd rho_2)))
                                      id)
                                (fn _ =>
                                  bindb (check_csteps
  (equal_sum A2_ (equal_list equal_char), show_sum A3_ (show_list show_char))
  (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list,
    show_list show_char)
  ra ta ua psa)
                                    (fn _ =>
                                      bindb
(check_csteps
  (equal_sum A2_ (equal_list equal_char), show_sum A3_ (show_list show_char))
  (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list,
    show_list show_char)
  ra ta vb qsa)
(fn _ =>
  bindb (check_airr (A2_, A3_) r u)
    (fn _ =>
      bindb (check_airr (A2_, A3_) r v)
        (fn _ =>
          check (is_none (mgu A2_ (equal_list equal_char) u v))
            (shows_term (shows_prec A3_ zero_nata)
               (shows_prec_list show_char zero_nata) u o
               shows_prec_list show_char zero_nata
                 [#" ", #"a", #"n", #"d", #" "] o
               shows_term (shows_prec A3_ zero_nata)
                 (shows_prec_list show_char zero_nata) v o
              shows_prec_list show_char zero_nata
                [#" ", #"a", #"r", #"e", #" ", #"u", #"n", #"i", #"f", #"i",
                  #"a", #"b", #"l", #"e"]))))))))))))
    end
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s",
               #" "] o
             shows_conditions (shows_prec A3_ zero_nata)
               (shows_prec_list show_char zero_nata) cs o
             shows_prec_list show_char zero_nata
               [#" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ", #"u",
                 #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e"] o
             shows_nl o
            x));

fun check_unfeasible (A1_, A2_, A3_) css r l mu cs =
  catch_errora
    (existsM
      (fn (mua, uo) =>
        let
          val cs_1 = snd (rule1 uo);
          val cs_2 = snd (rule2 uo);
          val csa = subst_list mua (cs_1 @ cs_2);
          val la = fst (fst (rule1 uo));
        in
          bindb (check (equal_nata (size_list csa) (size_list cs))
                  (shows_prec_list show_char zero_nata
                    [#"l", #"e", #"n", #"g", #"t", #"h", #"s", #" ", #"d", #"i",
                      #"f", #"f", #"e", #"r"]))
            (fn _ =>
              bindb (check
                      (not (is_none
                             (match_rules A1_
                               (ccompare_list ccompare_char,
                                 equal_list equal_char, mapping_impl_list)
                               ((subst_apply_term l mu,
                                  subst_apply_term l mu) ::
                                 cs)
                               ((subst_apply_term la mua,
                                  subst_apply_term la mua) ::
                                 csa))) andalso
                        not (is_none
                              (match_rules A1_
                                (ccompare_list ccompare_char,
                                  equal_list equal_char, mapping_impl_list)
                                ((subst_apply_term la mua,
                                   subst_apply_term la mua) ::
                                  csa)
                                ((subst_apply_term l mu,
                                   subst_apply_term l mu) ::
                                  cs))))
                      id)
                (fn _ =>
                  check_unfeasiblea
                    ((compare_compare_order o compare_order_key) A2_, A1_, A3_)
                    uo r la mua csa))
        end)
      css)
    (fn x => Inl (shows_sep id shows_nl x));

fun ta_rules_implb (Tree_Automaton (x1, x2, x3)) = x2;

fun check_subseteq A_ xs ys =
  catch_errora
    (forallM (fn x => (if membera A_ ys x then Inr () else Inl x)) xs)
    (fn x => Inl (snd x));

fun check_rules_subseteq (A1_, A2_) (B1_, B2_) rs a =
  catch_errora (check_subseteq (equal_ta_rule A1_ B1_) rs (ta_rules_implb a))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata [#"r", #"u", #"l", #"e", #" "] o
             shows_prec_ta_rule A2_ B2_ zero_nata x o
            shows_prec_list show_char zero_nata
              [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n",
                #"g"]));

fun ta_rules (Ta_ext (ta_final, ta_rules, ta_eps, more)) = ta_rules;

fun ta_final (Ta_ext (ta_final, ta_rules, ta_eps, more)) = ta_final;

fun ta_syms (A1_, A2_) (B1_, B2_, B3_, B4_) ta =
  image (ceq_ta_rule A2_ B3_, ccompare_ta_rule A1_ B2_)
    (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat,
      set_impl_prod B4_ set_impl_nat)
    r_sym (ta_rules ta);

fun ta_inter_eps_empty (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_)
  (C1_, C2_, C3_, C4_) ta t =
  Ta_ext
    (productc (A1_, A2_, A4_) (C1_, C2_, C4_) (ta_final ta) (ta_final t),
      image (ceq_prod (ceq_ta_rule A3_ B3_) (ceq_ta_rule C3_ B3_),
              ccompare_prod (ccompare_ta_rule A2_ B2_)
                (ccompare_ta_rule C2_ B2_))
        (ceq_ta_rule (equal_prod A3_ C3_) B3_,
          ccompare_ta_rule (ccompare_prod A2_ C2_) B2_, set_impl_ta_rule)
        (fn (TA_rule (f, ps, p), TA_rule (_, qs, q)) =>
          TA_rule (f, zip ps qs, (p, q)))
        (sup_setb
          (finite_UNIV_prod finite_UNIV_ta_rule finite_UNIV_ta_rule,
            cenum_prod cenum_ta_rule cenum_ta_rule,
            ceq_prod (ceq_ta_rule A3_ B3_) (ceq_ta_rule C3_ B3_),
            cproper_interval_prod (cproper_interval_ta_rule A2_ B2_)
              (cproper_interval_ta_rule C2_ B2_),
            set_impl_prod set_impl_ta_rule set_impl_ta_rule)
          (image (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat)
            (ceq_set
               (cenum_prod cenum_ta_rule cenum_ta_rule,
                 ceq_prod (ceq_ta_rule A3_ B3_) (ceq_ta_rule C3_ B3_),
                 ccompare_cproper_interval
                   (cproper_interval_prod (cproper_interval_ta_rule A2_ B2_)
                     (cproper_interval_ta_rule C2_ B2_))),
              ccompare_set
                (finite_UNIV_prod finite_UNIV_ta_rule finite_UNIV_ta_rule,
                  ceq_prod (ceq_ta_rule A3_ B3_) (ceq_ta_rule C3_ B3_),
                  cproper_interval_prod (cproper_interval_ta_rule A2_ B2_)
                    (cproper_interval_ta_rule C2_ B2_),
                  set_impl_prod set_impl_ta_rule set_impl_ta_rule),
              set_impl_set)
            (fn f =>
              productc
                (ceq_ta_rule A3_ B3_, ccompare_ta_rule A2_ B2_,
                  set_impl_ta_rule)
                (ceq_ta_rule C3_ B3_, ccompare_ta_rule C2_ B2_,
                  set_impl_ta_rule)
                (filter (ceq_ta_rule A3_ B3_, ccompare_ta_rule A2_ B2_)
                  (fn r => equal_proda B3_ equal_nat (r_sym r) f) (ta_rules ta))
                (filter (ceq_ta_rule C3_ B3_, ccompare_ta_rule C2_ B2_)
                  (fn r => equal_proda B3_ equal_nat (r_sym r) f) (ta_rules t)))
            (ta_syms (A2_, A3_) (B1_, B2_, B3_, B4_) ta))),
      bot_set
        (ceq_prod (ceq_prod A1_ C1_) (ceq_prod A1_ C1_),
          ccompare_prod (ccompare_prod A2_ C2_) (ccompare_prod A2_ C2_),
          set_impl_prod (set_impl_prod A4_ C4_) (set_impl_prod A4_ C4_)),
      ());

fun add_rule_states A_ rs ss =
  fold (fn r => fn ssa => let
                            val TA_rule (_, qs, q) = r;
                          in
                            insertb A_ q (fold (insertb A_) qs ssa)
                          end)
    rs ss;

fun sig_rules (A1_, A2_, A3_) (B1_, B2_) f c =
  image (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat)
    (ceq_ta_rule B2_ A3_, ccompare_ta_rule B1_ A2_, set_impl_ta_rule)
    (fn (fa, n) => TA_rule (fa, replicate n c, c)) f;

fun star c (Var x) = Fun (c, [])
  | star c (Fun (f, ts)) = Fun (f, map (star c) ts);

fun ground_instances_rules (A1_, A2_, A3_, A4_) (B1_, B2_) f c (Var x) =
  sig_rules (A1_, A2_, A4_) (ccompare_term A3_ B1_, equal_term A4_ B2_) f
    (Fun (c, []))
  | ground_instances_rules (A1_, A2_, A3_, A4_) (B1_, B2_) fa c (Fun (f, ts)) =
    sup_seta
      (ceq_ta_rule (equal_term A4_ B2_) A4_,
        ccompare_ta_rule (ccompare_term A3_ B1_) A2_)
      (inserta
        (ceq_ta_rule (equal_term A4_ B2_) A4_,
          ccompare_ta_rule (ccompare_term A3_ B1_) A2_)
        (TA_rule (f, map (star c) ts, star c (Fun (f, ts))))
        (set_empty
          (ceq_ta_rule (equal_term A4_ B2_) A4_,
            ccompare_ta_rule (ccompare_term A3_ B1_) A2_)
          (of_phantom set_impl_ta_rulea)))
      (sup_setb
        (finite_UNIV_ta_rule, cenum_ta_rule,
          ceq_ta_rule (equal_term A4_ B2_) A4_,
          cproper_interval_ta_rule (ccompare_term A3_ B1_) A2_,
          set_impl_ta_rule)
        (image (ceq_term A4_ B2_, ccompare_term A3_ B1_)
          (ceq_set
             (cenum_ta_rule, ceq_ta_rule (equal_term A4_ B2_) A4_,
               ccompare_cproper_interval
                 (cproper_interval_ta_rule (ccompare_term A3_ B1_) A2_)),
            ccompare_set
              (finite_UNIV_ta_rule, ceq_ta_rule (equal_term A4_ B2_) A4_,
                cproper_interval_ta_rule (ccompare_term A3_ B1_) A2_,
                set_impl_ta_rule),
            set_impl_set)
          (ground_instances_rules (A1_, A2_, A3_, A4_) (B1_, B2_) fa c)
          (set (ceq_term A4_ B2_, ccompare_term A3_ B1_, set_impl_term) ts)));

fun ground_instances_ta (A1_, A2_, A3_, A4_) (B1_, B2_) f c t =
  Ta_ext
    (inserta (ceq_term A4_ B2_, ccompare_term A3_ B1_) (star c t)
       (set_empty (ceq_term A4_ B2_, ccompare_term A3_ B1_)
         (of_phantom set_impl_terma)),
      ground_instances_rules (A1_, A2_, A3_, A4_) (B1_, B2_) f c t,
      set_empty
        (ceq_prod (ceq_term A4_ B2_) (ceq_term A4_ B2_),
          ccompare_prod (ccompare_term A3_ B1_) (ccompare_term A3_ B1_))
        (of_phantom (set_impl_proda set_impl_term set_impl_term)),
      ());

fun sig_rules_list f c = map (fn (fa, n) => TA_rule (fa, replicate n c, c)) f;

fun gi_rules_list f c (Var x) = sig_rules_list f (Fun (c, []))
  | gi_rules_list fa c (Fun (f, ts)) =
    TA_rule (f, map (star c) ts, star c (Fun (f, ts))) ::
      maps (gi_rules_list fa c) ts;

fun size_pos Empty = zero_nata
  | size_pos (PCons (x21, x22)) = plus_nata (size_pos x22) (suc zero_nata);

fun growing_rule (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) (l, r) =
  ball (B3_, ccompare_cproper_interval B4_)
    (vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) r)
    (fn x =>
      ball (ceq_pos, ccompare_pos) (varposs l)
        (fn p =>
          (if equal_terma A2_ B6_ (Var x) (subt_at l p)
            then less_eq_nat (size_pos p) one_nata else true)));

fun growing (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) r =
  ball (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_),
         ccompare_prod (ccompare_term A1_ B5_) (ccompare_term A1_ B5_))
    r (growing_rule (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_));

fun check_growing (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) r =
  check (growing (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
          (set (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_),
                 ccompare_prod (ccompare_term A1_ B5_) (ccompare_term A1_ B5_),
                 set_impl_prod set_impl_term set_impl_term)
            r))
    (shows_prec_list show_char zero_nata
      [#"T", #"R", #"S", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"g",
        #"r", #"o", #"w", #"i", #"n", #"g"]);

fun combs [] ys = [[]]
  | combs (x :: xs) ys =
    maps (fn l => map (fn y => (x, y) :: l) ys) (combs xs ys);

fun state_substs v q = combs v q;

fun lhss_impl A_ r = remdups A_ (map fst r);

fun mp_ta_rules A_ B_ r f c =
  maps (gi_rules_list f c) (lhss_impl (equal_term A_ B_) r);

fun r_lhs_states (TA_rule (x1, x2, x3)) = x2;

fun r_root (TA_rule (x1, x2, x3)) = x1;

fun r_rhs (TA_rule (x1, x2, x3)) = x3;

fun reachable_states (A1_, A2_, A3_, A4_) (B1_, B2_) delta (Fun (Inr q, [])) =
  inserta (A1_, A2_) q (bot_set (A1_, A2_, A4_))
  | reachable_states (A1_, A2_, A3_, A4_) (B1_, B2_) delta (Fun (Inl f, ts)) =
    image (ceq_ta_rule A3_ B2_, ccompare_ta_rule A2_ B1_) (A1_, A2_, A4_) r_rhs
      (filter (ceq_ta_rule A3_ B2_, ccompare_ta_rule A2_ B1_)
        (fn r =>
          eq B2_ (r_root r) f andalso
            (equal_nata (size_list (r_lhs_states r)) (size_list ts) andalso
              all_interval_nat
                (fn i =>
                  member (A1_, A2_) (nth (r_lhs_states r) i)
                    (reachable_states (A1_, A2_, A3_, A4_) (B1_, B2_) delta
                      (nth ts i)))
                zero_nata (size_list ts)))
        delta)
  | reachable_states (A1_, A2_, A3_, A4_) (B1_, B2_) delta (Var v) =
    bot_set (A1_, A2_, A4_)
  | reachable_states (A1_, A2_, A3_, A4_) (B1_, B2_) delta
    (Fun (Inr va, vb :: vc)) = bot_set (A1_, A2_, A4_);

fun qi B_ c t g (Var x) =
  (if contains_var_term B_ x t then g x else star c (Var x))
  | qi B_ c t g (Fun (f, ts)) = star c (Fun (f, ts));

fun inf_step (A1_, A2_, A3_) (B1_, B2_) c r s delta =
  foldr (sup_seta
           (ceq_ta_rule (equal_term A3_ B2_) A3_,
             ccompare_ta_rule (ccompare_term A2_ B1_) A1_) o
          (fn (a, b) =>
            let
              val (l, ra) = a;
            in
              (fn theta =>
                let
                  val Fun (f, ls) = l;
                in
                  image (ceq_term A3_ B2_, ccompare_term A2_ B1_)
                    (ceq_ta_rule (equal_term A3_ B2_) A3_,
                      ccompare_ta_rule (ccompare_term A2_ B1_) A1_,
                      set_impl_ta_rule)
                    (fn aa =>
                      TA_rule (f, map (qi B2_ c ra (fun_of B2_ theta)) ls, aa))
                    (reachable_states
                      (ceq_term A3_ B2_, ccompare_term A2_ B1_,
                        equal_term A3_ B2_, set_impl_term)
                      (A1_, A3_) delta
                      (subst_apply_term (map_term Inl (fn x => x) ra)
                        ((fn fa => Fun (Inr fa, [])) o fun_of B2_ theta)))
                end)
            end
              b))
    (product r s)
    (set_empty
      (ceq_ta_rule (equal_term A3_ B2_) A3_,
        ccompare_ta_rule (ccompare_term A2_ B1_) A1_)
      (of_phantom set_impl_ta_rulea));

fun funas_ta_rule (B1_, B2_, B3_) r =
  inserta (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat)
    (r_root r, size_list (r_lhs_states r))
    (bot_set
      (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat,
        set_impl_prod B3_ set_impl_nat));

fun funas_ta (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_) a =
  sup_setb
    (finite_UNIV_prod B1_ finite_UNIV_nat, cenum_prod B2_ cenum_nat,
      ceq_prod B3_ ceq_nat, cproper_interval_prod B4_ cproper_interval_nat,
      set_impl_prod B6_ set_impl_nat)
    (image
      (ceq_ta_rule A2_ B5_,
        ccompare_ta_rule A1_ (ccompare_cproper_interval B4_))
      (ceq_set
         (cenum_prod B2_ cenum_nat, ceq_prod B3_ ceq_nat,
           ccompare_cproper_interval
             (cproper_interval_prod B4_ cproper_interval_nat)),
        ccompare_set
          (finite_UNIV_prod B1_ finite_UNIV_nat, ceq_prod B3_ ceq_nat,
            cproper_interval_prod B4_ cproper_interval_nat,
            set_impl_prod B6_ set_impl_nat),
        set_impl_set)
      (funas_ta_rule (B3_, ccompare_cproper_interval B4_, B6_)) (ta_rules a));

fun check_varcond_no_Var_lhs A_ B_ =
  (fn xs =>
    catch_errora
      (forallM
        (fn rule =>
          check (not (is_Var (fst rule)))
            (shows_prec_list show_char zero_nata
               [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #" ", #"l",
                 #"e", #"f", #"t", #"-", #"h", #"a", #"n", #"d", #" ", #"s",
                 #"i", #"d", #"e", #" ", #"i", #"n", #" ", #"r", #"u", #"l",
                 #"e", #" "] o
               shows_rule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata)
                 [#" ", #"-", #">", #" "] rule o
              shows_nl))
        xs)
      (fn x => Inl (snd x)));

fun ta_of_ta (A1_, A2_, A3_, A4_) (B1_, B2_) (Tree_Automaton (fin, rules, eps))
  = Ta_ext
      (set (A1_, A2_, A4_) fin,
        set (ceq_ta_rule A3_ B2_, ccompare_ta_rule A2_ B1_, set_impl_ta_rule)
          rules,
        set (ceq_prod A1_ A1_, ccompare_prod A2_ A2_, set_impl_prod A4_ A4_)
          eps,
        ());

fun insert_funas_term A_ (Var x) fs = fs
  | insert_funas_term A_ (Fun (f, ts)) fs =
    insertb (equal_prod A_ equal_nat) (f, size_list ts)
      (foldr (insert_funas_term A_) ts fs);

fun insert_funas_rule A_ r fs =
  insert_funas_term A_ (fst r) (insert_funas_term A_ (snd r) fs);

fun insert_funas_trs A_ trs = foldr (insert_funas_rule A_) trs;

fun check_linear_trs A_ (B1_, B2_, B3_, B4_) r =
  catch_errora
    (catch_errora
      (forallM
        (fn x =>
          (if let
                val (l, ra) = x;
              in
                linear_term (B1_, B2_, B3_) l andalso
                  linear_term (B1_, B2_, B3_) ra
              end
            then Inr () else Inl x))
        r)
      (fn x => Inl (snd x)))
    (fn _ =>
      Inl (shows_prec_list (show_prod (show_term A_ B4_) (show_term A_ B4_))
             zero_nata r o
             shows_nl o
             shows_prec_list show_char zero_nata
               [#"i", #"s", #" ", #"n", #"o", #"t", #" ", #"l", #"i", #"n",
                 #"e", #"a", #"r"] o
            shows_nl));

fun ta_eps (Ta_ext (ta_final, ta_rules, ta_eps, more)) = ta_eps;

fun reduced_TA (A1_, A2_) (B1_, B2_, B3_, B4_) f ta q =
  Ta_ext
    (bot_set (B1_, B2_, B4_),
      sup_seta (ceq_ta_rule B3_ A2_, ccompare_ta_rule B2_ A1_)
        (image (ceq_ta_rule B3_ A2_, ccompare_ta_rule B2_ A1_)
          (ceq_ta_rule B3_ A2_, ccompare_ta_rule B2_ A1_, set_impl_ta_rule)
          (fn TA_rule (fa, qs, a) =>
            TA_rule (fa, filtera (fn qa => not (member (B1_, B2_) qa q)) qs, a))
          (filter (ceq_ta_rule B3_ A2_, ccompare_ta_rule B2_ A1_)
            (fn r => not (member (B1_, B2_) (r_rhs r) q)) (ta_rules ta)))
        (image (ceq_prod B1_ B1_, ccompare_prod B2_ B2_)
          (ceq_ta_rule B3_ A2_, ccompare_ta_rule B2_ A1_, set_impl_ta_rule)
          (fn p => TA_rule (f, [], snd p))
          (filter (ceq_prod B1_ B1_, ccompare_prod B2_ B2_)
            (fn p =>
              member (B1_, B2_) (fst p) q andalso
                not (member (B1_, B2_) (snd p) q))
            (ta_eps ta))),
      filter (ceq_prod B1_ B1_, ccompare_prod B2_ B2_)
        (fn p =>
          not (member (B1_, B2_) (fst p) q) andalso
            not (member (B1_, B2_) (snd p) q))
        (ta_eps ta),
      ());

fun new_reach (A1_, A2_, A3_, A4_) (B1_, B2_) ta =
  image (ceq_ta_rule A3_ B2_, ccompare_ta_rule A2_ B1_) (A1_, A2_, A4_) r_rhs
    (filter (ceq_ta_rule A3_ B2_, ccompare_ta_rule A2_ B1_)
      (fn r => null (r_lhs_states r)) (ta_rules ta));

fun ta_reachable (A1_, A2_, A3_, A4_, A5_) (B1_, B2_, B3_) ta =
  let
    val q = new_reach (A2_, A3_, A4_, A5_) (B1_, B3_) ta;
  in
    (if less_eq_set (A1_, A2_, A3_) q (bot_set (A2_, A3_, A5_))
      then bot_set (A2_, A3_, A5_)
      else sup_seta (A2_, A3_) q
             (ta_reachable (A1_, A2_, A3_, A4_, A5_) (B1_, B2_, B3_)
               (reduced_TA (B1_, B3_) (A2_, A3_, A4_, A5_) (default B2_) ta q)))
  end;

fun ta_empty (A1_, A2_, A3_, A4_, A5_) (B1_, B2_, B3_) ta =
  less_eq_set (A1_, A2_, A3_)
    (inf_seta (A2_, A3_)
      (ta_reachable (A1_, A2_, A3_, A4_, A5_) (B1_, B2_, B3_) ta) (ta_final ta))
    (bot_set (A2_, A3_, A5_));

fun check_etac_nonreachable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) f aa c a r s t =
  let
    val fa =
      set (ceq_prod A3_ ceq_nat,
            ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat,
            set_impl_prod A8_ set_impl_nat)
        f;
  in
    bindb (check
            (member
              (ceq_prod A3_ ceq_nat,
                ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat)
              (aa, zero_nata) fa)
            (shows_prec_list show_char zero_nata
               [#"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t", #" "] o
               shows_prec A9_ zero_nata aa o
              shows_prec_list show_char zero_nata
                [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"i", #"n",
                  #" ", #"s", #"i", #"g", #"n", #"a", #"t", #"u", #"r", #"e"]))
      (fn _ =>
        bindb (check
                (not (member
                       (ceq_prod A3_ ceq_nat,
                         ccompare_prod (ccompare_cproper_interval A4_)
                           ccompare_nat)
                       (c, zero_nata) fa))
                (shows_prec_list show_char zero_nata
                  [#"s", #"t", #"a", #"r", #"-", #"s", #"y", #"m", #"b", #"o",
                    #"l", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"f",
                    #"r", #"e", #"s", #"h", #" ", #"w", #".", #"r", #".", #"t",
                    #".", #" ", #"s", #"i", #"g", #"n", #"a", #"t", #"u", #"r",
                    #"e"]))
          (fn _ =>
            bindb (catch_errora
                    (check_subseteq (equal_prod A7_ equal_nat)
                      (insert_funas_term A7_ s []) f)
                    (fn _ =>
                      Inl (shows_prec_list show_char zero_nata
                            [#"l", #"h", #"s", #" ", #"v", #"i", #"o", #"l",
                              #"a", #"t", #"e", #"s", #" ", #"s", #"i", #"g",
                              #"n", #"a", #"t", #"u", #"r", #"e"])))
              (fn _ =>
                bindb (catch_errora
                        (check_subseteq (equal_prod A7_ equal_nat)
                          (insert_funas_term A7_ t []) f)
                        (fn _ =>
                          Inl (shows_prec_list show_char zero_nata
                                [#"r", #"h", #"s", #" ", #"v", #"i", #"o", #"l",
                                  #"a", #"t", #"e", #"s", #" ", #"s", #"i",
                                  #"g", #"n", #"a", #"t", #"u", #"r", #"e"])))
                  (fn _ =>
                    let
                      val fs = insert_funas_trs A7_ r [];
                    in
                      bindb (catch_errora
                              (check_subseteq (equal_prod A7_ equal_nat) fs f)
                              (fn _ =>
                                Inl (shows_prec_list show_char zero_nata
                                      [#"T", #"R", #"S", #" ", #"v", #"i", #"o",
#"l", #"a", #"t", #"e", #"s", #" ", #"s", #"i", #"g", #"n", #"a", #"t", #"u",
#"r", #"e"])))
                        (fn _ =>
                          bindb (check_varcond_no_Var_lhs A9_ B8_ r)
                            (fn _ =>
                              bindb (check_linear_trs A9_
                                      (B3_, ccompare_cproper_interval B4_, B7_,
B8_)
                                      r)
                                (fn _ =>
                                  bindb (check_growing (A5_, A7_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_) r)
                                    (fn _ =>
                                      let
val aaa =
  ta_of_ta
    (ceq_term A7_ B6_, ccompare_term A5_ B5_, equal_term A7_ B6_, set_impl_term)
    (ccompare_cproper_interval A4_, A7_) a;
                                      in
bindb (check
        (set_eq
          (cenum_prod cenum_term cenum_term,
            ceq_prod (ceq_term A7_ B6_) (ceq_term A7_ B6_),
            ccompare_prod (ccompare_term A5_ B5_) (ccompare_term A5_ B5_))
          (ta_eps aaa)
          (set_empty
            (ceq_prod (ceq_term A7_ B6_) (ceq_term A7_ B6_),
              ccompare_prod (ccompare_term A5_ B5_) (ccompare_term A5_ B5_))
            (of_phantom (set_impl_proda set_impl_term set_impl_term))))
        (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"e", #"p", #"s", #"i", #"l", #"o", #"n", #" ",
            #"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n", #"s",
            #" ", #"a", #"l", #"l", #"o", #"w", #"e", #"d"]))
  (fn _ =>
    bindb (check
            (member (ceq_term A7_ B6_, ccompare_term A5_ B5_) (star c t)
              (ta_final aaa))
            (shows_prec_list show_char zero_nata
               [#"f", #"i", #"n", #"a", #"l", #" ", #"s", #"t", #"a", #"t",
                 #"e", #" ", #"f", #"o", #"r", #" "] o
               shows_prec_term A9_ B8_ zero_nata t o
              shows_prec_list show_char zero_nata
                [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n",
                  #"g"]))
      (fn _ =>
        bindb (check
                (less_eq_set
                  (cenum_prod A2_ cenum_nat, ceq_prod A3_ ceq_nat,
                    ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat)
                  (funas_ta (ccompare_term A5_ B5_, equal_term A7_ B6_)
                    (A1_, A2_, A3_, A4_, A7_, A8_) aaa)
                  fa)
                (shows_prec_list show_char zero_nata
                  [#"t", #"h", #"e", #" ", #"g", #"i", #"v", #"e", #"n", #" ",
                    #"a", #"u", #"t", #"o", #"m", #"a", #"t", #"o", #"n", #" ",
                    #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"r",
                    #"e", #"s", #"p", #"e", #"c", #"t", #" ", #"t", #"h", #"e",
                    #" ", #"s", #"i", #"g", #"n", #"a", #"t", #"u", #"r",
                    #"e"]))
          (fn _ =>
            let
              val ts = gi_rules_list f c t;
              val ms = mp_ta_rules A7_ B6_ r f c;
            in
              bindb (check_rules_subseteq
                      (equal_term A7_ B6_, show_term A9_ B8_) (A7_, A9_) ts a)
                (fn _ =>
                  bindb (check_rules_subseteq
                          (equal_term A7_ B6_, show_term A9_ B8_) (A7_, A9_) ms
                          a)
                    (fn _ =>
                      let
                        val q =
                          add_rule_states (equal_term A7_ B6_) ts
                            (add_rule_states (equal_term A7_ B6_) ms []);
                        val ss =
                          state_substs
                            (remdups B6_ (maps (vars_term_list o snd) r)) q;
                        val d =
                          set (ceq_ta_rule (equal_term A7_ B6_) A7_,
                                ccompare_ta_rule (ccompare_term A5_ B5_)
                                  (ccompare_cproper_interval A4_),
                                set_impl_ta_rule)
                            (ta_rules_implb a);
                        val da =
                          inf_step (ccompare_cproper_interval A4_, A5_, A7_)
                            (B5_, B6_) c r ss d;
                      in
                        bindb (check
                                (less_eq_set
                                  (cenum_ta_rule,
                                    ceq_ta_rule (equal_term A7_ B6_) A7_,
                                    ccompare_ta_rule (ccompare_term A5_ B5_)
                                      (ccompare_cproper_interval A4_))
                                  da d)
                                (shows_prec_list show_char zero_nata
                                  [#"t", #"h", #"e", #" ", #"g", #"i", #"v",
                                    #"e", #"n", #" ", #"t", #"r", #"e", #"e",
                                    #" ", #"a", #"u", #"t", #"o", #"m", #"a",
                                    #"t", #"o", #"n", #" ", #"i", #"s", #" ",
                                    #"n", #"o", #"t", #" ", #"c", #"l", #"o",
                                    #"s", #"e", #"d", #" ", #"u", #"n", #"d",
                                    #"e", #"r", #" ", #"c", #"o", #"m", #"p",
                                    #"l", #"e", #"t", #"i", #"o", #"n", #" ",
                                    #"r", #"u", #"l", #"e", #"s"]))
                          (fn _ =>
                            check (ta_empty
                                    (cenum_prod cenum_term cenum_term,
                                      ceq_prod (ceq_term A7_ B6_)
(ceq_term A7_ B6_),
                                      ccompare_prod (ccompare_term A5_ B5_)
(ccompare_term A5_ B5_),
                                      equal_prod (equal_term A7_ B6_)
(equal_term A7_ B6_),
                                      set_impl_prod set_impl_term set_impl_term)
                                    (ccompare_cproper_interval A4_, A6_, A7_)
                                    (ta_inter_eps_empty
                                      (ceq_term A7_ B6_, ccompare_term A5_ B5_,
equal_term A7_ B6_, set_impl_term)
                                      (A3_, ccompare_cproper_interval A4_, A7_,
A8_)
                                      (ceq_term A7_ B6_, ccompare_term A5_ B5_,
equal_term A7_ B6_, set_impl_term)
                                      aaa (ground_instances_ta
    (A3_, ccompare_cproper_interval A4_, A5_, A7_) (B5_, B6_) fa c s)))
                              (shows_prec_list show_char zero_nata
                                [#"t", #"h", #"e", #" ", #"g", #"i", #"v", #"e",
                                  #"n", #" ", #"t", #"r", #"e", #"e", #" ",
                                  #"a", #"u", #"t", #"o", #"m", #"a", #"t",
                                  #"o", #"n", #" ", #"d", #"o", #"e", #"s",
                                  #" ", #"n", #"o", #"t", #" ", #"c", #"e",
                                  #"r", #"t", #"i", #"f", #"y", #" ", #"n",
                                  #"o", #"n", #"-", #"r", #"e", #"a", #"c",
                                  #"h", #"a", #"b", #"i", #"l", #"i", #"t",
                                  #"y"]))
                      end))
            end)))
                                      end))))
                    end))))
  end;

fun is_instance_rule A_ (B1_, B2_, B3_) ra r =
  (case match_list (B1_, B2_, B3_) A_ B2_ Var [(fst r, fst ra), (snd r, snd ra)]
    of NONE => false | SOME _ => true);

fun check_subst_overapproximation (A1_, A2_) (B1_, B2_, B3_, B4_) ra r =
  catch_errora
    (catch_errora
      (forallM
        (fn raa =>
          catch_errora
            (existsM
              (fn rb => check (is_instance_rule A1_ (B1_, B2_, B3_) raa rb) id)
              r)
            (fn _ =>
              Inl (shows_prec_list show_char zero_nata
                     [#"g", #"r", #"o", #"w", #"i", #"n", #"g", #" ", #"r",
                       #"u", #"l", #"e", #" ", #"f", #"o", #"r", #" "] o
                     shows_rule (shows_prec A2_ zero_nata)
                       (shows_prec B4_ zero_nata) [#" ", #"-", #">", #" "] raa o
                     shows_prec_list show_char zero_nata
                       [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i",
                         #"n", #"g"] o
                    shows_nl)))
        ra)
      (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_prec_list (show_prod (show_term A2_ B4_) (show_term A2_ B4_))
             zero_nata r o
             shows_nl o
             shows_prec_list show_char zero_nata
               [#"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"n", #" ",
                 #"o", #"v", #"e", #"r", #"a", #"p", #"p", #"r", #"o", #"x",
                 #"i", #"m", #"a", #"t", #"i", #"o", #"n", #" ", #"o", #"f"] o
             shows_nl o
             shows_prec_list (show_prod (show_term A2_ B4_) (show_term A2_ B4_))
               zero_nata ra o
             shows_nl o
            x));

fun group_key B_ f [] = []
  | group_key B_ f (x :: xs) =
    (x :: takeWhile (fn y => eq B_ (f x) (f y)) xs) ::
      group_key B_ f (dropWhile (fn y => eq B_ (f x) (f y)) xs);

fun nonlinear_var_nonreach (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) (C1_, C2_) f
  gt_fun xs =
  let
    val xs1 = filtera (is_Var o fst) xs;
    val xs2 = sort_key (linorder_term B1_ C1_) fst xs1;
    val a = group_key (equal_term B2_ C2_) fst xs2;
  in
    list_ex
      (fn xts =>
        less_nat one_nata (size_list xts) andalso
          list_all
            (fn fa =>
              not (gt_fun (SOME fa) NONE) andalso
                list_ex
                  (fn (_, v) =>
                    not (is_Var v) andalso
                      (less_eq_set
                         (cenum_prod A1_ cenum_nat, ceq_prod A2_ ceq_nat,
                           ccompare_prod A3_ ccompare_nat)
                         (funas_term (A2_, A3_, A5_) v)
                         (set (ceq_prod A2_ ceq_nat,
                                ccompare_prod A3_ ccompare_nat,
                                set_impl_prod A5_ set_impl_nat)
                           f) andalso
                        (not (equal_optiona (equal_prod A4_ equal_nat) (root v)
                               (SOME fa)) andalso
                          not (gt_fun (SOME fa) (root v)))))
                  xts)
            f)
      a
  end;

fun nonreachable_gtcapRM (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) fs nlv ne
  gt_fun rm s t =
  let
    val gt = gt_term A5_ B2_ nlv ne gt_fun rm;
    val rs = rd_impl A5_ gt (s, t);
  in
    list_ex (fn (a, b) => nonreach A5_ gt a b) rs orelse
      nlv andalso
        (ne andalso
          nonlinear_var_nonreach (A1_, A2_, A3_, A5_, A6_) (A4_, A5_) (B1_, B2_)
            fs gt_fun rs)
  end;

fun insert_value A_ B_ key v m =
  (case key v of NONE => m
    | SOME k =>
      (case lookup B_ m k of NONE => insert B_ k [v] m
        | SOME vs => insert B_ k (insertb A_ v vs) m));

fun insert_values A_ B_ uu [] m = m
  | insert_values A_ B_ key (v :: vs) m =
    insert_value A_ B_ key v (insert_values A_ B_ key vs m);

fun insert_rules A_ (B1_, B2_) C_ a rs =
  insert_values
    (equal_prod A_ (equal_prod (equal_term B2_ C_) (equal_term B2_ C_)))
    (compare_order_prod B1_ compare_order_nat) key (map (fn b => (a, b)) rs);

fun rule_map (A1_, A2_) B_ r fna =
  (case lookup (compare_order_prod A1_ compare_order_nat)
          (insert_rules equal_unit (A1_, A2_) B_ () r
            (empty (linorder_prod (linorder_compare_order A1_) linorder_nat)))
          fna
    of NONE => [] | SOME a => map snd a);

fun relpow_impl succ un memb new have m =
  (if equal_nata m zero_nata then un new have
    else (if null new then have
           else let
                  val maybe = succ new;
                  val havea = un new have;
                  val newa = filtera (fn n => not (memb n havea)) maybe;
                in
                  relpow_impl succ un memb newa havea (minus_nata m one_nata)
                end));

fun trancl_impl gen_succ un memb emp rel =
  let
    val succ = gen_succ rel;
    val n = size_list rel;
  in
    (fn asa => relpow_impl succ un memb (succ asa) emp n)
  end;

fun trancl_list_impl A_ =
  trancl_impl
    (fn r => fn asa =>
      remdups A_
        (map_filter
          (fn x => (if let
                         val (a, _) = x;
                       in
                         membera A_ asa a
                       end
                     then SOME (snd x) else NONE))
          r))
    (fn xs => fn ys => filtera (fn x => not (membera A_ ys x)) xs @ ys)
    (fn x => fn xs => membera A_ xs x) [];

fun memo_list_trancl A_ r =
  let
    val tr = trancl_list_impl A_ r;
    val rm = map (fn a => (a, tr [a])) ((remdups A_ o map fst) r);
  in
    (fn a => (case map_of A_ rm a of NONE => [] | SOME asa => asa))
  end;

fun mk_gt_fun A_ rs =
  let
    val in_trancl =
      memo_list_trancl (equal_option (equal_prod A_ equal_nat)) (gt1 rs);
  in
    (fn f => membera (equal_option (equal_prod A_ equal_nat)) (in_trancl f))
  end;

fun check_nonreachable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r s t Nonreachable_Tcap =
  check (not (matchb A6_ B5_ (tcapI A6_ B5_ r s) t))
    (shows_prec_list show_char zero_nata
      [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"s", #"h",
        #"o", #"w", #" ", #"n", #"o", #"n", #"r", #"e", #"a", #"c", #"h", #"a",
        #"b", #"i", #"l", #"i", #"t", #"y", #" ", #"v", #"i", #"a", #" ", #"t",
        #"c", #"a", #"p"])
  | check_nonreachable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r s t Nonreachable_Gtcap =
    let
      val nlv = list_all (fn lr => not (is_Var (fst lr))) r;
      val fs = funas_trs_list r;
    in
      check (not (matchb A6_ B5_ (tcapI A6_ B5_ r s) t) orelse
              nonreachable_gtcapRM
                (A2_, A3_, ccompare_cproper_interval A4_,
                  (compare_compare_order o compare_order_key) A7_, A6_, A8_)
                ((compare_compare_order o compare_order_key) B6_, B5_) fs nlv
                (not (null r)) (mk_gt_fun A6_ r)
                (rule_map (compare_order_key A7_, A6_) B5_ r) s t)
        (shows_prec_list show_char zero_nata
          [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"s",
            #"h", #"o", #"w", #" ", #"n", #"o", #"n", #"r", #"e", #"a", #"c",
            #"h", #"a", #"b", #"i", #"l", #"i", #"t", #"y", #" ", #"v", #"i",
            #"a", #" ", #"g", #"e", #"n", #"e", #"r", #"a", #"l", #"i", #"z",
            #"e", #"d", #" ", #"t", #"c", #"a", #"p"])
    end
  | check_nonreachable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r s t
    (Nonreachable_ETAC (f, aa, c, a)) =
    check_etac_nonreachable
      (A1_, A2_, A3_, A4_, (compare_compare_order o compare_order_key) A7_, A5_,
        A6_, A8_, A9_)
      (B1_, B2_, B3_, B4_, (compare_compare_order o compare_order_key) B6_, B5_,
        B8_, B9_)
      f aa c a r s t
  | check_nonreachable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) ra s t
    (Nonreachable_Subst_Approx (r, p)) =
    bindb (check_subst_overapproximation (A6_, A9_)
            (ccompare_cproper_interval B4_, B5_, B7_, B9_) ra r)
      (fn _ =>
        check_nonreachable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
          (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r s t p)
  | check_nonreachable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r s t (Nonreachable_Reverse p)
    = check_nonreachable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
        (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_)
        (map (fn (x, y) => (y, x)) r) t s p;

fun unifiable A_ s t = not (is_none (mergea A_ s t));

fun check_nonjoinable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r s t Nonjoinable_Tcap =
  check (not (unifiable A6_ (tcapI A6_ B5_ r s) (tcapI A6_ B5_ r t)))
    (shows_prec_list show_char zero_nata
      [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"s", #"h",
        #"o", #"w", #" ", #"n", #"o", #"n", #"j", #"o", #"i", #"n", #"a", #"b",
        #"i", #"l", #"i", #"t", #"y", #" ", #"v", #"i", #"a", #" ", #"t", #"c",
        #"a", #"p"])
  | check_nonjoinable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r s t
    (Nonjoinable_Ground_NF p) =
    (if is_NF_trs (A6_, A7_) (ccompare_cproper_interval B4_, B5_, B7_) r
          s andalso
          ground s
      then check_nonreachable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
             (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r t s p
      else (if is_NF_trs (A6_, A7_) (ccompare_cproper_interval B4_, B5_, B7_) r
                 t andalso
                 ground t
             then check_nonreachable
                    (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
                    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r s t p
             else Inl (shows_prec_list show_char zero_nata
                        [#"n", #"o", #"n", #" ", #"N", #"F"])));

fun check_infeasibleb (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r cs
  (Infeasible_Compound_Conditions (f, p)) =
  check_nonreachable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) (map fst r)
    (Fun (f, map fst cs)) (Fun (f, map snd cs)) p
  | check_infeasibleb (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r cs
    (Infeasible_Equation (s, t, p)) =
    bindb (check
            (membera (equal_prod (equal_term A6_ B5_) (equal_term A6_ B5_)) cs
              (s, t))
            (shows_prec_list show_char zero_nata
               [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #" "] o
               shows_eq (shows_prec A9_ zero_nata) (shows_prec B9_ zero_nata)
                 (s, t) o
               shows_prec_list show_char zero_nata
                 [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"i", #"n",
                   #" ", #"l", #"i", #"s", #"t", #" ", #"o", #"f", #" ", #"c",
                   #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s"] o
              shows_nl))
      (fn _ =>
        check_nonreachable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
          (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) (map fst r) s t p)
  | check_infeasibleb (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r csa
    (Infeasible_Subset (cs, p)) =
    bindb (catch_errora
            (check_subseteq
              (equal_prod (equal_term A6_ B5_) (equal_term A6_ B5_)) cs csa)
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #" "] o
                     shows_eq (shows_prec A9_ zero_nata)
                       (shows_prec B9_ zero_nata) x o
                     shows_prec_list show_char zero_nata
                       [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"i",
                         #"n", #" ", #"l", #"i", #"s", #"t", #" ", #"o", #"f",
                         #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o",
                         #"n", #"s"] o
                    shows_nl)))
      (fn _ =>
        check_infeasibleb (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
          (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r cs p)
  | check_infeasibleb (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r cs
    (Infeasible_Rhss_Equal (s, t, u, p)) =
    bindb (check
            (membera (equal_prod (equal_term A6_ B5_) (equal_term A6_ B5_)) cs
              (s, u))
            (shows_prec_list show_char zero_nata
               [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #" "] o
               shows_eq (shows_prec A9_ zero_nata) (shows_prec B9_ zero_nata)
                 (s, u) o
               shows_prec_list show_char zero_nata
                 [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"i", #"n",
                   #" ", #"l", #"i", #"s", #"t", #" ", #"o", #"f", #" ", #"c",
                   #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s"] o
              shows_nl))
      (fn _ =>
        bindb (check
                (membera (equal_prod (equal_term A6_ B5_) (equal_term A6_ B5_))
                  cs (t, u))
                (shows_prec_list show_char zero_nata
                   [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #" "] o
                   shows_eq (shows_prec A9_ zero_nata)
                     (shows_prec B9_ zero_nata) (t, u) o
                   shows_prec_list show_char zero_nata
                     [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"i",
                       #"n", #" ", #"l", #"i", #"s", #"t", #" ", #"o", #"f",
                       #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o",
                       #"n", #"s"] o
                  shows_nl))
          (fn _ =>
            check_nonjoinable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
              (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) (map fst r) s t p));

fun check_infeasible (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) css r cs =
  catch_errora
    (existsM
      (fn (csa, p) =>
        bindb (check (equal_nata (size_list csa) (size_list cs))
                (shows_prec_list show_char zero_nata
                  [#"l", #"e", #"n", #"g", #"t", #"h", #"s", #" ", #"d", #"i",
                    #"f", #"f", #"e", #"r"]))
          (fn _ =>
            bindb (check
                    (not (is_none
                           (match_rules A6_
                             (ccompare_cproper_interval B4_, B5_, B7_) cs
                             csa)) andalso
                      not (is_none
                            (match_rules A6_
                              (ccompare_cproper_interval B4_, B5_, B7_) csa
                              cs)))
                    id)
              (fn _ =>
                check_infeasibleb (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
                  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r csa p)))
      css)
    (fn x => Inl (shows_sep id shows_nl x));

fun check_CCPs (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_) cj css uo r =
  catch_errora
    (forallM
      (fn rho_1 =>
        let
          val l_1 = fst (fst rho_1);
        in
          catch_errora
            (forallM
              (fn rho_2 =>
                catch_errora
                  (forallM
                    (check_overlap
                      (ccompare_list ccompare_char, equal_list equal_char,
                        mapping_impl_list, infinite_list, show_list show_char)
                      (A6_, A9_) (fn a => #"x" :: a) (fn a => #"y" :: a)
                      (check_context_joinable (A6_, A7_, A9_)
                        (finite_UNIV_list, cenum_list, ceq_list ceq_char,
                          cproper_interval_list ccompare_char,
                          compare_list compare_char, equal_list equal_char,
                          mapping_impl_list, infinite_list, set_impl_list,
                          show_list show_char)
                        cj)
                      (check_infeasible
                        (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
                        (finite_UNIV_list, cenum_list, ceq_list ceq_char,
                          cproper_interval_list ccompare_char,
                          equal_list equal_char,
                          key_list (equal_char, key_char), mapping_impl_list,
                          set_impl_list, show_list show_char)
                        css)
                      (check_unfeasible (A6_, A7_, A9_) uo) r rho_1 rho_2)
                    (funposs_list l_1))
                  (fn x => Inl (snd x)))
              r)
            (fn x => Inl (snd x))
        end)
      r)
    (fn x => Inl (snd x));

fun check_type3 A_ (B1_, B2_) r =
  catch_errora
    (catch_errora
      (forallM
        (fn cr =>
          catch_errora
            (check_subseteq B1_ (vars_term_list (snd (fst cr)))
              (vars_term_list (fst (fst cr)) @ vars_trs_list (snd cr)))
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #" "] o
                     shows_prec B2_ zero_nata x o
                     shows_prec_list show_char zero_nata
                       [#" ", #"o", #"c", #"c", #"u", #"r", #"s", #" ", #"o",
                         #"n", #"l", #"y", #" ", #"i", #"n", #" ", #"r", #"i",
                         #"g", #"h", #"t", #"-", #"h", #"a", #"n", #"d", #" ",
                         #"s", #"i", #"d", #"e", #" ", #"o", #"f", #" ", #"r",
                         #"u", #"l", #"e", #" "] o
                     shows_crule (shows_prec A_ zero_nata)
                       (shows_prec B2_ zero_nata) cr o
                    shows_nl)))
        r)
      (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"t", #"h", #"e", #" ", #"C", #"T", #"R", #"S", #" ", #"i", #"s",
               #" ", #"n", #"o", #"t", #" ", #"o", #"f", #" ", #"t", #"y", #"p",
               #"e", #" ", #"3"] o
             shows_nl o
            x));

fun x_impl cr i =
  concat
    (vars_term_list (fst (fst cr)) ::
      map (vars_term_list o snd) (take i (snd cr)));

fun check_dctrs A_ (B1_, B2_) r =
  catch_errora
    (catch_errora
      (forallM
        (fn cr =>
          catch_errora
            (forallM
              (fn i =>
                catch_errora
                  (check_subseteq B1_ (vars_term_list (fst (nth (snd cr) i)))
                    (x_impl cr i))
                  (fn x =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e",
                             #" "] o
                           shows_prec B2_ zero_nata x o
                           shows_prec_list show_char zero_nata
                             [#" ", #"i", #"n", #" ", #"c", #"o", #"n", #"d",
                               #"i", #"t", #"i", #"o", #"n", #" "] o
                           shows_rule (shows_prec A_ zero_nata)
                             (shows_prec B2_ zero_nata) [#" ", #"-", #">", #" "]
                             (nth (snd cr) i) o
                           shows_prec_list show_char zero_nata
                             [#" ", #"o", #"f", #" ", #"r", #"u", #"l", #"e",
                               #" "] o
                           shows_crule (shows_prec A_ zero_nata)
                             (shows_prec B2_ zero_nata) cr o
                           shows_prec_list show_char zero_nata
                             [#"v", #"i", #"o", #"l", #"a", #"t", #"e", #"s",
                               #" ", #"D", #"C", #"T", #"R", #"S", #" ", #"c",
                               #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n"] o
                          shows_nl)))
              (upt zero_nata (size_list (snd cr))))
            (fn x => Inl (snd x)))
        r)
      (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"t", #"h", #"e", #" ", #"C", #"T", #"R", #"S", #" ", #"i", #"s",
               #" ", #"n", #"o", #"t", #" ", #"d", #"e", #"t", #"e", #"r", #"m",
               #"i", #"n", #"i", #"s", #"t", #"i", #"c"] o
             shows_nl o
            x));

fun check_wf_ctrs A_ (B1_, B2_) r =
  catch_errora
    (bindb (check_varcond_no_Var_lhs A_ B2_ (map fst r))
      (fn _ =>
        bindb (check_dctrs A_ (B1_, B2_) r)
          (fn _ => check_type3 A_ (B1_, B2_) r)))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"t", #"h", #"e", #" ", #"C", #"T", #"R", #"S", #" ", #"i", #"s",
               #" ", #"n", #"o", #"t", #" ", #"w", #"e", #"l", #"l", #"-", #"f",
               #"o", #"r", #"m", #"e", #"d"] o
             shows_nl o
            x));

fun check_adtrs (A1_, A2_) r =
  catch_errora
    (catch_errora
      (forallM
        (fn cr =>
          catch_errora
            (forallM (fn i => let
                                val a = snd (nth (snd cr) i);
                              in
                                check_airr (A1_, A2_) r a
                              end)
              (upt zero_nata (size_list (snd cr))))
            (fn x => Inl (snd x)))
        r)
      (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"t", #"h", #"e", #" ", #"C", #"T", #"R", #"S", #" ", #"i", #"s",
               #" ", #"n", #"o", #"t", #" ", #"a", #"b", #"s", #"o", #"l", #"u",
               #"t", #"e", #"l", #"y", #" ", #"d", #"e", #"t", #"e", #"r", #"m",
               #"i", #"n", #"i", #"s", #"t", #"i", #"c"] o
             shows_nl o
            x));

fun check_al94 (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_) cj css uo r =
  catch_errora
    (bindb (check_wf_ctrs A9_ (equal_list equal_char, show_list show_char) r)
      (fn _ =>
        bindb (check_adtrs (A6_, A9_) r)
          (fn _ =>
            check_CCPs (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_) cj css uo
              r)))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"A", #"v", #"e", #"n", #"h", #"a", #"u", #"s", #" ", #"&", #" ",
               #"L", #"o", #"r", #"i", #"a", #"-", #"S", #"a", #"e", #"n", #"z",
               #" ", #"1", #"9", #"9", #"4", #" ", #"d", #"o", #"e", #"s", #" ",
               #"n", #"o", #"t", #" ", #"a", #"p", #"p", #"l", #"y"] o
             shows_nl o
            x));

fun orig_crule m r =
  ((orig_term m (fst (fst r)), orig_term m (snd (fst r))),
    map (fn (s, t) => (orig_term m s, orig_term m t)) (snd r));

fun orig_cstep m (Cstep_step (rho, p, sigma, s, t, css)) =
  Cstep_step
    (orig_crule m rho, p, orig_term m o sigma, orig_term m s, orig_term m t,
      map (map (orig_cstep m)) css);

fun arith_fun xml =
  singleton
    [#"a", #"r", #"i", #"t", #"h", #"F", #"u", #"n", #"c", #"t", #"i", #"o",
      #"n"]
    (options
      [([#"n", #"a", #"t", #"u", #"r", #"a", #"l"],
         change (nata [#"n", #"a", #"t", #"u", #"r", #"a", #"l"]) Const),
        ([#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e"],
          change (nata [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e"])
            (fn n => Arg (minus_nata n one_nata))),
        ([#"s", #"u", #"m"], many [#"s", #"u", #"m"] arith_fun Sum),
        ([#"p", #"r", #"o", #"d", #"u", #"c", #"t"],
          many [#"p", #"r", #"o", #"d", #"u", #"c", #"t"] arith_fun Prod),
        ([#"m", #"i", #"n"], many [#"m", #"i", #"n"] arith_fun Min),
        ([#"m", #"a", #"x"], many [#"m", #"a", #"x"] arith_fun Max),
        ([#"i", #"f", #"E", #"q", #"u", #"a", #"l"],
          tuple4 [#"i", #"f", #"E", #"q", #"u", #"a", #"l"] arith_fun arith_fun
            arith_fun arith_fun
            (fn a => fn b => fn c => fn d => IfEqual (a, b, c, d)))])
    id xml;

fun int_coeff x = int [#"i", #"n", #"t", #"e", #"g", #"e", #"r"] x;

fun vec_coeff xml2coeff =
  many [#"v", #"e", #"c", #"t", #"o", #"r"]
    (singleton
      [#"c", #"o", #"e", #"f", #"f", #"i", #"c", #"i", #"e", #"n", #"t"]
      xml2coeff id)
    vec_of_list;

fun mat_coeff n ze xml2coeff =
  options
    [([#"m", #"a", #"t", #"r", #"i", #"x"],
       many [#"m", #"a", #"t", #"r", #"i", #"x"] (vec_coeff xml2coeff)
         (mat_of_cols n)),
      ([#"v", #"e", #"c", #"t", #"o", #"r"],
        change (vec_coeff xml2coeff)
          (fn v =>
            mat n n
              (fn (i, j) =>
                (if equal_nata j zero_nata then vec_index v i else ze))))];

fun closed_criterion x =
  xml_do [#"c", #"r", #"i", #"t", #"e", #"r", #"i", #"o", #"n"]
    (xml_take
      (xml_or
        (xml_leaf
          [#"c", #"o", #"m", #"p", #"a", #"t", #"i", #"b", #"i", #"l", #"i",
            #"t", #"y"]
          Id_Relation)
        (xml_or
          (xml_do
            [#"s", #"t", #"a", #"t", #"e", #"C", #"o", #"m", #"p", #"a", #"t",
              #"i", #"b", #"i", #"l", #"i", #"t", #"y"]
            (xml_take
              (xml_do [#"r", #"e", #"l", #"a", #"t", #"i", #"o", #"n"]
                (xml_take_many_sub [] zero_nata Infinity_enat
                  (xml_do [#"e", #"n", #"t", #"r", #"y"]
                    (xml_take state
                      (fn a => xml_take state (fn b => xml_return (a, b)))))
                  xml_return))
              (fn xa => xml_return (Some_Relation xa))))
          (xml_or
            (xml_leaf
              [#"d", #"e", #"c", #"i", #"s", #"i", #"o", #"n", #"P", #"r", #"o",
                #"c", #"e", #"d", #"u", #"r", #"e"]
              Decision_Proc)
            (xml_leaf
              [#"d", #"e", #"c", #"i", #"s", #"i", #"o", #"n", #"P", #"r", #"o",
                #"c", #"e", #"d", #"u", #"r", #"e", #"O", #"l", #"d"]
              Decision_Proc_Old))))
      xml_return)
    x;

fun final_states x =
  xml_do [#"f", #"i", #"n", #"a", #"l", #"S", #"t", #"a", #"t", #"e", #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat state xml_return) x;

fun transition xml2lhs =
  xml_do [#"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n"]
    (xml_take xml2lhs
      (fn a =>
        xml_take
          (xml_do [#"r", #"h", #"s"]
            (xml_take state (fn x => xml_return (id x))))
          (fn b =>
            xml_return
              (case a of Inl (f, qs) => Inl (TA_rule (f, qs, b))
                | Inr q => Inr (q, b)))));

fun transitions xml2lhs =
  xml_do [#"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n", #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat (transition xml2lhs)
      (fn rls =>
        let
          val (rules, eps) =
            partition (fn a => (case a of Inl _ => true | Inr _ => false)) rls;
          val ruls = map (fn Inl r => r) rules;
          val ep = map (fn Inr e => e) eps;
        in
          xml_return (ruls, ep)
        end));

fun tree_automaton xml2lhs =
  xml_do
    [#"t", #"r", #"e", #"e", #"A", #"u", #"t", #"o", #"m", #"a", #"t", #"o",
      #"n"]
    (xml_take final_states
      (fn a =>
        xml_take (transitions xml2lhs)
          (fn b => xml_return let
                                val (ba, c) = b;
                              in
                                Tree_Automaton (a, ba, c)
                              end)));

fun ta_normal_lhs xml2name =
  xml_do [#"l", #"h", #"s"]
    (xml_or (xml_take state (fn a => xml_return (Inr a)))
      (xml_take xml2name
        (fn a =>
          xml_take_many_sub [] zero_nata Infinity_enat state
            (fn b => xml_return (Inl (a, b))))));

fun not_wn_ta (A1_, A2_) (B1_, B2_) xml2name =
  xml_do
    [#"n", #"o", #"t", #"W", #"N", #"T", #"r", #"e", #"e", #"A", #"u", #"t",
      #"o", #"m", #"a", #"t", #"o", #"n"]
    (xml_take (tree_automaton (ta_normal_lhs xml2name))
      (fn a =>
        xml_take closed_criterion (fn b => xml_return (Not_wn_ta_prf (a, b)))));

fun precedence_weight A_ xml2name =
  xml_do
    [#"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c", #"e", #"W", #"e",
      #"i", #"g", #"h", #"t"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c", #"e", #"W", #"e",
          #"i", #"g", #"h", #"t", #"E", #"n", #"t", #"r", #"y"]
        (xml_take xml2name
          (fn f =>
            xml_take (xml_nat [#"a", #"r", #"i", #"t", #"y"])
              (fn a =>
                xml_take
                  (xml_nat
                    [#"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c",
                      #"e"])
                  (fn p =>
                    xml_take (xml_nat [#"w", #"e", #"i", #"g", #"h", #"t"])
                      (fn w =>
                        xml_take_optional
                          (xml_do
                            [#"s", #"u", #"b", #"t", #"e", #"r", #"m", #"C",
                              #"o", #"e", #"f", #"f", #"i", #"c", #"i", #"e",
                              #"n", #"t", #"E", #"n", #"t", #"r", #"i", #"e",
                              #"s"]
                            (xml_take_many_sub [] zero_nata Infinity_enat
                              (xml_nat [#"e", #"n", #"t", #"r", #"y"])
                              xml_return))
                          (fn e => xml_return ((f, a), (p, (w, e))))))))))
      (fn ret => xml_return (fn a => (ret, a))));

fun knuth_bendix_order A_ xml2name =
  xml_do
    [#"k", #"n", #"u", #"t", #"h", #"B", #"e", #"n", #"d", #"i", #"x", #"O",
      #"r", #"d", #"e", #"r"]
    (xml_take (xml_nat [#"w", #"0"])
      (fn w0 =>
        xml_take (precedence_weight A_ xml2name)
          (fn prw =>
            xml_take_default [] (afs A_ xml2name)
              (fn afsa => xml_return (KBO (prw w0, afsa))))));

fun arctic_rat_linear_poly (Arctic_rat_linear_poly x4) = x4;

fun real_non_linear_poly (Real_non_linear_poly x13) = x13;

fun rat_non_linear_poly (Rat_non_linear_poly x12) = x12;

fun int_non_linear_poly (Int_non_linear_poly x11) = x11;

fun arctic_linear_poly (Arctic_linear_poly x3) = x3;

fun arctic_rat_matrix (Arctic_rat_matrix x9) = x9;

fun real_linear_poly (Real_linear_poly x5) = x5;

fun rat_linear_poly (Rat_linear_poly x2) = x2;

fun int_linear_poly (Int_linear_poly x1) = x1;

fun arctic_matrix (Arctic_matrix x8) = x8;

fun real_matrix (Real_matrix x10) = x10;

fun rat_matrix (Rat_matrix x7) = x7;

fun int_matrix (Int_matrix x6) = x6;

fun class_semiring (A1_, A2_, A3_, A4_, A5_, A6_, A7_) uu b =
  Partial_object_ext
    (top_set (A1_, A2_, A7_),
      Monoid_ext (times A5_, onea A3_, Ring_ext (zerob A6_, plus A4_, b)));

fun real_domain x =
  singleton
    [#"a", #"l", #"g", #"e", #"b", #"r", #"a", #"i", #"c", #"N", #"u", #"m",
      #"b", #"e", #"r", #"s"]
    (singleton [#"d", #"e", #"l", #"t", #"a"] real id) id x;

fun rat_domain x =
  singleton [#"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s"]
    (singleton [#"d", #"e", #"l", #"t", #"a"] rat id) id x;

fun basic_domain x =
  options
    [([#"n", #"a", #"t", #"u", #"r", #"a", #"l", #"s"],
       leaf [#"n", #"a", #"t", #"u", #"r", #"a", #"l", #"s"] Natural),
      ([#"i", #"n", #"t", #"e", #"g", #"e", #"r", #"s"],
        leaf [#"i", #"n", #"t", #"e", #"g", #"e", #"r", #"s"]
          (fn _ => Integer)),
      ([#"a", #"r", #"c", #"t", #"i", #"c"],
        singleton [#"a", #"r", #"c", #"t", #"i", #"c"]
          (singleton [#"d", #"o", #"m", #"a", #"i", #"n"]
            (options
              [([#"n", #"a", #"t", #"u", #"r", #"a", #"l", #"s"],
                 leaf [#"n", #"a", #"t", #"u", #"r", #"a", #"l", #"s"]
                   (fn _ => Arctic)),
                ([#"i", #"n", #"t", #"e", #"g", #"e", #"r", #"s"],
                  leaf [#"i", #"n", #"t", #"e", #"g", #"e", #"r", #"s"]
                    (fn _ => Arctic)),
                ([#"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s"],
                  change rat_domain (fn _ => fn _ => Arctic_rat))])
            id)
          id),
      ([#"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s"],
        change rat_domain (fn a => fn b => Rational (a, b))),
      ([#"a", #"l", #"g", #"e", #"b", #"r", #"a", #"i", #"c", #"N", #"u", #"m",
         #"b", #"e", #"r", #"s"],
        change real_domain (fn a => fn b => Mini_Alg (a, b)))]
    x;

fun interpretation_type x =
  singleton [#"t", #"y", #"p", #"e"]
    (options
      [([#"p", #"o", #"l", #"y", #"n", #"o", #"m", #"i", #"a", #"l"],
         pair [#"p", #"o", #"l", #"y", #"n", #"o", #"m", #"i", #"a", #"l"]
           (singleton [#"d", #"o", #"m", #"a", #"i", #"n"]
             (options
               [([#"n", #"a", #"t", #"u", #"r", #"a", #"l", #"s"],
                  basic_domain),
                 ([#"i", #"n", #"t", #"e", #"g", #"e", #"r", #"s"],
                   basic_domain),
                 ([#"a", #"r", #"c", #"t", #"i", #"c"], basic_domain),
                 ([#"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s"],
                   basic_domain),
                 ([#"a", #"l", #"g", #"e", #"b", #"r", #"a", #"i", #"c", #"N",
                    #"u", #"m", #"b", #"e", #"r", #"s"],
                   basic_domain),
                 ([#"m", #"a", #"t", #"r", #"i", #"c", #"e", #"s"],
                   triple [#"m", #"a", #"t", #"r", #"i", #"c", #"e", #"s"]
                     (nata [#"d", #"i", #"m", #"e", #"n", #"s", #"i", #"o",
                             #"n"])
                     (nata [#"s", #"t", #"r", #"i", #"c", #"t", #"D", #"i",
                             #"m", #"e", #"n", #"s", #"i", #"o", #"n"])
                     (singleton [#"d", #"o", #"m", #"a", #"i", #"n"]
                       basic_domain id)
                     (fn di => fn sd => fn domain => fn d =>
                       (case domain d of Natural _ => Int_mat (di, sd)
                         | Integer => Int_mat (di, sd) | Arctic => Arctic_mat di
                         | Arctic_rat => Arctic_rat_mat di
                         | Rational (_, _) => Rat_mat (di, sd)
                         | Mini_Alg (_, _) => Mini_Alg_mat (di, sd))))])
             id)
           (nata [#"d", #"e", #"g", #"r", #"e", #"e"]) (fn typea => typea)),
        ([#"m", #"a", #"t", #"r", #"i", #"x", #"I", #"n", #"t", #"e", #"r",
           #"p", #"r", #"e", #"t", #"a", #"t", #"i", #"o", #"n"],
          triple
            [#"m", #"a", #"t", #"r", #"i", #"x", #"I", #"n", #"t", #"e", #"r",
              #"p", #"r", #"e", #"t", #"a", #"t", #"i", #"o", #"n"]
            (singleton [#"d", #"o", #"m", #"a", #"i", #"n"] basic_domain id)
            (nata [#"d", #"i", #"m", #"e", #"n", #"s", #"i", #"o", #"n"])
            (nata [#"s", #"t", #"r", #"i", #"c", #"t", #"D", #"i", #"m", #"e",
                    #"n", #"s", #"i", #"o", #"n"])
            (fn domain => fn di => fn sd =>
              (case domain zero_nata of Natural _ => Int_mat (di, sd)
                | Integer => Int_mat (di, sd) | Arctic => Arctic_mat di
                | Arctic_rat => Arctic_rat_mat di
                | Rational (_, _) => Rat_mat (di, sd)
                | Mini_Alg (_, _) => Mini_Alg_mat (di, sd))))])
    id x;

fun arctic_rat_coeff x =
  options
    [([#"i", #"n", #"t", #"e", #"g", #"e", #"r"], change rat Num_arc_delta),
      ([#"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l"],
        change rat Num_arc_delta),
      ([#"m", #"i", #"n", #"u", #"s", #"I", #"n", #"f", #"i", #"n", #"i", #"t",
         #"y"],
        leaf [#"m", #"i", #"n", #"u", #"s", #"I", #"n", #"f", #"i", #"n", #"i",
               #"t", #"y"]
          MinInfty_delta)]
    x;

fun arctic_coeff x =
  options
    [([#"i", #"n", #"t", #"e", #"g", #"e", #"r"],
       change (int [#"i", #"n", #"t", #"e", #"g", #"e", #"r"]) Num_arc),
      ([#"m", #"i", #"n", #"u", #"s", #"I", #"n", #"f", #"i", #"n", #"i", #"t",
         #"y"],
        leaf [#"m", #"i", #"n", #"u", #"s", #"I", #"n", #"f", #"i", #"n", #"i",
               #"t", #"y"]
          MinInfty)]
    x;

fun polynomial xml2coeff x =
  singleton [#"p", #"o", #"l", #"y", #"n", #"o", #"m", #"i", #"a", #"l"]
    (options
      [([#"c", #"o", #"e", #"f", #"f", #"i", #"c", #"i", #"e", #"n", #"t"],
         singleton
           [#"c", #"o", #"e", #"f", #"f", #"i", #"c", #"i", #"e", #"n", #"t"]
           xml2coeff PNum),
        ([#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e"],
          change (nata [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e"])
            (fn n => PVar (minus_nata n one_nata))),
        ([#"s", #"u", #"m"],
          many [#"s", #"u", #"m"] (polynomial xml2coeff) PSum),
        ([#"p", #"r", #"o", #"d", #"u", #"c", #"t"],
          many [#"p", #"r", #"o", #"d", #"u", #"c", #"t"] (polynomial xml2coeff)
            PMult)])
    id x;

fun fit_length c n uu =
  (if equal_nata n zero_nata then []
    else (case uu of [] => replicate (suc (minus_nata n one_nata)) (zero c)
           | b :: bs => b :: fit_length c (minus_nata n one_nata) bs));

fun interpretation bi xml2name =
  many1_gen
    [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t", #"a", #"t", #"i",
      #"o", #"n"]
    interpretation_type
    (fn a =>
      (case a
        of Natural deg =>
          (if less_eq_nat deg one_nata andalso not bi
            then triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"]
                   xml2name (nata [#"a", #"r", #"i", #"t", #"y"])
                   (fn x =>
                     binda (polynomial int_coeff x)
                       (lpoly_of equal_int
                         (class_semiring
                           (ceq_int, ccompare_int, one_int, plus_int, times_int,
                             zero_int, set_impl_int)
                           Type ())))
                   (fn f => fn aa => fn poly =>
                     Int_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length
                             (class_semiring
                               (ceq_int, ccompare_int, one_int, plus_int,
                                 times_int, zero_int, set_impl_int)
                               Type ())
                             aa (snd poly))))
            else triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"]
                   xml2name (nata [#"a", #"r", #"i", #"t", #"y"])
                   (fn x =>
                     binda (polynomial int_coeff x)
                       (fn p =>
                         return
                           (poly_of (equal_nat, linorder_nat)
                             (equal_int, comm_semiring_1_int) p)))
                   (fn f => fn aa => fn poly =>
                     Int_non_linear_poly ((f, aa), poly)))
        | Integer =>
          triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"] xml2name
            (nata [#"a", #"r", #"i", #"t", #"y"])
            (fn x =>
              binda (polynomial int_coeff x)
                (fn p =>
                  return
                    (poly_of (equal_nat, linorder_nat)
                      (equal_int, comm_semiring_1_int) p)))
            (fn f => fn aa => fn poly => Int_non_linear_poly ((f, aa), poly))
        | Arctic =>
          triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"] xml2name
            (nata [#"a", #"r", #"i", #"t", #"y"])
            (fn x =>
              binda (polynomial arctic_coeff x)
                (lpoly_of equal_arctic
                  (class_semiring
                    (ceq_arctic, ccompare_arctic, one_arctic, plus_arctic,
                      times_arctic, zero_arctic, set_impl_arctic)
                    Type ())))
            (fn f => fn aa => fn poly =>
              Arctic_linear_poly
                ((f, aa),
                  (fst poly,
                    fit_length
                      (class_semiring
                        (ceq_arctic, ccompare_arctic, one_arctic, plus_arctic,
                          times_arctic, zero_arctic, set_impl_arctic)
                        Type ())
                      aa (snd poly))))
        | Arctic_rat =>
          triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"] xml2name
            (nata [#"a", #"r", #"i", #"t", #"y"])
            (fn x =>
              binda (polynomial arctic_rat_coeff x)
                (lpoly_of (equal_arctic_delta equal_rat)
                  (class_semiring
                    (ceq_arctic_delta equal_rat,
                      ccompare_arctic_delta compare_rat,
                      one_arctic_delta linordered_field_rat,
                      plus_arctic_delta linordered_field_rat,
                      times_arctic_delta linordered_field_rat,
                      zero_arctic_delta linordered_field_rat,
                      set_impl_arctic_delta)
                    Type ())))
            (fn f => fn aa => fn poly =>
              Arctic_rat_linear_poly
                ((f, aa),
                  (fst poly,
                    fit_length
                      (class_semiring
                        (ceq_arctic_delta equal_rat,
                          ccompare_arctic_delta compare_rat,
                          one_arctic_delta linordered_field_rat,
                          plus_arctic_delta linordered_field_rat,
                          times_arctic_delta linordered_field_rat,
                          zero_arctic_delta linordered_field_rat,
                          set_impl_arctic_delta)
                        Type ())
                      aa (snd poly))))
        | Int_mat (n, _) =>
          triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"] xml2name
            (nata [#"a", #"r", #"i", #"t", #"y"])
            (fn x =>
              binda (polynomial (mat_coeff n zero_inta int_coeff) x)
                (lpoly_of (equal_mat equal_int)
                  (ring_mat semiring_1_int Type n ())))
            (fn f => fn aa => fn poly =>
              Int_matrix
                ((f, aa),
                  (fst poly,
                    fit_length (ring_mat semiring_1_int Type n ()) aa
                      (snd poly))))
        | Arctic_mat n =>
          triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"] xml2name
            (nata [#"a", #"r", #"i", #"t", #"y"])
            (fn x =>
              binda (polynomial (mat_coeff n MinInfty arctic_coeff) x)
                (lpoly_of (equal_mat equal_arctic)
                  (ring_mat semiring_1_arctic Type n ())))
            (fn f => fn aa => fn poly =>
              Arctic_matrix
                ((f, aa),
                  (fst poly,
                    fit_length (ring_mat semiring_1_arctic Type n ()) aa
                      (snd poly))))
        | Arctic_rat_mat n =>
          triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"] xml2name
            (nata [#"a", #"r", #"i", #"t", #"y"])
            (fn x =>
              binda (polynomial (mat_coeff n MinInfty_delta arctic_rat_coeff) x)
                (lpoly_of (equal_mat (equal_arctic_delta equal_rat))
                  (ring_mat (semiring_1_arctic_delta linordered_field_rat) Type
                    n ())))
            (fn f => fn aa => fn poly =>
              Arctic_rat_matrix
                ((f, aa),
                  (fst poly,
                    fit_length
                      (ring_mat (semiring_1_arctic_delta linordered_field_rat)
                        Type n ())
                      aa (snd poly))))
        | Rational (_, deg) =>
          (if less_eq_nat deg one_nata andalso not bi
            then triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"]
                   xml2name (nata [#"a", #"r", #"i", #"t", #"y"])
                   (fn x =>
                     binda (polynomial rat x)
                       (lpoly_of equal_rat
                         (class_semiring
                           (ceq_rat, ccompare_rat, one_rat, plus_rat, times_rat,
                             zero_rat, set_impl_rat)
                           Type ())))
                   (fn f => fn aa => fn poly =>
                     Rat_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length
                             (class_semiring
                               (ceq_rat, ccompare_rat, one_rat, plus_rat,
                                 times_rat, zero_rat, set_impl_rat)
                               Type ())
                             aa (snd poly))))
            else triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"]
                   xml2name (nata [#"a", #"r", #"i", #"t", #"y"])
                   (fn x =>
                     binda (polynomial rat x)
                       (fn p =>
                         return
                           (poly_of (equal_nat, linorder_nat)
                             (equal_rat, comm_semiring_1_rat) p)))
                   (fn f => fn aa => fn poly =>
                     Rat_non_linear_poly ((f, aa), poly)))
        | Rat_mat (n, _) =>
          triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"] xml2name
            (nata [#"a", #"r", #"i", #"t", #"y"])
            (fn x =>
              binda (polynomial (mat_coeff n zero_rata rat) x)
                (lpoly_of (equal_mat equal_rat)
                  (ring_mat semiring_1_rat Type n ())))
            (fn f => fn aa => fn poly =>
              Rat_matrix
                ((f, aa),
                  (fst poly,
                    fit_length (ring_mat semiring_1_rat Type n ()) aa
                      (snd poly))))
        | Mini_Alg (_, deg) =>
          (if less_eq_nat deg one_nata andalso not bi
            then triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"]
                   xml2name (nata [#"a", #"r", #"i", #"t", #"y"])
                   (fn x =>
                     binda (polynomial real x)
                       (lpoly_of equal_real
                         (class_semiring
                           (ceq_real, ccompare_real, one_real, plus_real,
                             times_real, zero_real, set_impl_real)
                           Type ())))
                   (fn f => fn aa => fn poly =>
                     Real_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length
                             (class_semiring
                               (ceq_real, ccompare_real, one_real, plus_real,
                                 times_real, zero_real, set_impl_real)
                               Type ())
                             aa (snd poly))))
            else triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"]
                   xml2name (nata [#"a", #"r", #"i", #"t", #"y"])
                   (fn x =>
                     binda (polynomial real x)
                       (fn p =>
                         return
                           (poly_of (equal_nat, linorder_nat)
                             (equal_real, comm_semiring_1_real) p)))
                   (fn f => fn aa => fn poly =>
                     Real_non_linear_poly ((f, aa), poly)))
        | Mini_Alg_mat (n, _) =>
          triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"] xml2name
            (nata [#"a", #"r", #"i", #"t", #"y"])
            (fn x =>
              binda (polynomial (mat_coeff n zero_reala real) x)
                (lpoly_of (equal_mat equal_real)
                  (ring_mat semiring_1_real Type n ())))
            (fn f => fn aa => fn poly =>
              Real_matrix
                ((f, aa),
                  (fst poly,
                    fit_length (ring_mat semiring_1_real Type n ()) aa
                      (snd poly))))))
    (fn typea => fn pi =>
      (case typea
        of Natural deg =>
          (if less_eq_nat deg one_nata andalso not bi
            then Int_carrier (map int_linear_poly pi)
            else Int_nl_carrier (map int_non_linear_poly pi))
        | Integer => Int_nl_carrier (map int_non_linear_poly pi)
        | Arctic => Arctic_carrier (map arctic_linear_poly pi)
        | Arctic_rat => Arctic_rat_carrier (map arctic_rat_linear_poly pi)
        | Int_mat (n, sd) => Int_mat_carrier (n, sd, map int_matrix pi)
        | Arctic_mat n => Arctic_mat_carrier (n, map arctic_matrix pi)
        | Arctic_rat_mat n =>
          Arctic_rat_mat_carrier (n, map arctic_rat_matrix pi)
        | Rational (d, deg) =>
          (if less_eq_nat deg one_nata andalso not bi
            then Rat_carrier (map rat_linear_poly pi)
            else Rat_nl_carrier (d, map rat_non_linear_poly pi))
        | Rat_mat (n, sd) => Rat_mat_carrier (n, sd, map rat_matrix pi)
        | Mini_Alg (d, deg) =>
          (if less_eq_nat deg one_nata andalso not bi
            then Real_carrier (map real_linear_poly pi)
            else Real_nl_carrier (d, map real_non_linear_poly pi))
        | Mini_Alg_mat (n, sd) =>
          Real_mat_carrier (n, sd, map real_matrix pi)));

fun wpo_params A_ xml2name =
  xml_do
    [#"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c", #"e", #"S", #"t",
      #"a", #"t", #"u", #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c", #"e", #"S", #"t",
          #"a", #"t", #"u", #"s", #"E", #"n", #"t", #"r", #"y"]
        (xml_take xml2name
          (fn f =>
            xml_take (xml_nat [#"a", #"r", #"i", #"t", #"y"])
              (fn a =>
                xml_take
                  (xml_nat
                    [#"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c",
                      #"e"])
                  (fn p =>
                    xml_take
                      (xml_do [#"s", #"t", #"a", #"t", #"u", #"s"]
                        (xml_take_many_sub [] zero_nata Infinity_enat position
                          xml_return))
                      (fn s => xml_return ((f, a), (p, s))))))))
      xml_return);

fun status_precedence A_ xml2name =
  xml_do
    [#"s", #"t", #"a", #"t", #"u", #"s", #"P", #"r", #"e", #"c", #"e", #"d",
      #"e", #"n", #"c", #"e"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"s", #"t", #"a", #"t", #"u", #"s", #"P", #"r", #"e", #"c", #"e", #"d",
          #"e", #"n", #"c", #"e", #"E", #"n", #"t", #"r", #"y"]
        (xml_take xml2name
          (fn f =>
            xml_take (xml_nat [#"a", #"r", #"i", #"t", #"y"])
              (fn a =>
                xml_take
                  (xml_nat
                    [#"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c",
                      #"e"])
                  (fn p =>
                    xml_take
                      (xml_or (xml_leaf [#"l", #"e", #"x"] Lex)
                        (xml_leaf [#"m", #"u", #"l"] Mul))
                      (fn s => xml_return ((f, a), (p, s))))))))
      xml_return);

fun path_order A_ xml2name =
  xml_do [#"p", #"a", #"t", #"h", #"O", #"r", #"d", #"e", #"r"]
    (xml_take (status_precedence A_ xml2name)
      (fn prec_tau =>
        xml_take_default [] (afs A_ xml2name)
          (fn af => xml_return (RPO (prec_tau, af)))));

fun redtriple A_ xml2name bi x =
  xml_or (path_order A_ xml2name)
    (xml_or (knuth_bendix_order A_ xml2name)
      (xml_or
        (xml_do
          [#"w", #"e", #"i", #"g", #"h", #"t", #"e", #"d", #"P", #"a", #"t",
            #"h", #"O", #"r", #"d", #"e", #"r"]
          (xml_take (wpo_params A_ xml2name)
            (fn a =>
              xml_take (redtriple A_ xml2name bi)
                (fn b => xml_return (WPO (a, b))))))
        (xmlt2 (interpretation bi (xmlt_of_xmlt2 xml2name)))))
    x;

fun joinable_critical_pairs A_ xml2name =
  let
    val rew = rsteps A_ xml2name;
  in
    xml_do
      [#"j", #"o", #"i", #"n", #"a", #"b", #"l", #"e", #"C", #"r", #"i", #"t",
        #"i", #"c", #"a", #"l", #"P", #"a", #"i", #"r", #"s"]
      (xml_take_many_sub [] zero_nata Infinity_enat
        (xml_do
          [#"j", #"o", #"i", #"n", #"a", #"b", #"l", #"e", #"C", #"r", #"i",
            #"t", #"i", #"c", #"a", #"l", #"P", #"a", #"i", #"r"]
          (xml_take rew
            (fn (s, sseq) =>
              xml_take rew
                (fn (t, tseq) => xml_return (s, (sseq, (t, tseq)))))))
        xml_return)
  end;

fun wcr_proof A_ xml2name =
  xml_do [#"w", #"c", #"r", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_change (joinable_critical_pairs A_ xml2name) (xml_return o Guided))
        (xml_or
          (xml_change
            (xml_nat
              [#"j", #"o", #"i", #"n", #"a", #"b", #"l", #"e", #"C", #"r", #"i",
                #"t", #"i", #"c", #"a", #"l", #"P", #"a", #"i", #"r", #"s",
                #"B", #"F", #"S"])
            (xml_return o Join_BFS))
          (xml_leaf
            [#"j", #"o", #"i", #"n", #"a", #"b", #"l", #"e", #"C", #"r", #"i",
              #"t", #"i", #"c", #"a", #"l", #"P", #"a", #"i", #"r", #"s", #"A",
              #"u", #"t", #"o"]
            Join_NF)))
      (fn x => xml_return (id x)));

fun exp_parsera v xml =
  xml_or
    (xml_do [#"p", #"r", #"o", #"d", #"u", #"c", #"t"]
      (xml_take_many_sub [] zero_nata Infinity_enat (exp_parsera v)
        (fn exps => xml_return (Fun (ProdF (size_list exps), exps)))))
    (xml_or
      (xml_do [#"s", #"u", #"m"]
        (xml_take_many_sub [] zero_nata Infinity_enat (exp_parsera v)
          (fn exps => xml_return (Fun (SumF (size_list exps), exps)))))
      (xml_or
        (xml_change (xml_int [#"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t"])
          (fn i => xml_return (Fun (ConstF i, []))))
        (xml_change v (fn x => xml_return (Var (x, IntT))))))
    xml;

fun bexp_parser A_ v =
  xml_or
    (xml_do [#"l", #"e", #"q"]
      (xml_take (exp_parsera v)
        (fn l =>
          xml_take (exp_parsera v) (fn r => xml_return (Fun (LeF, [l, r]))))))
    (xml_or
      (xml_do [#"l", #"e", #"s", #"s"]
        (xml_take (exp_parsera v)
          (fn l =>
            xml_take (exp_parsera v)
              (fn r => xml_return (Fun (LessF, [l, r]))))))
      (xml_do [#"e", #"q"]
        (xml_take (exp_parsera v)
          (fn l =>
            xml_take (exp_parsera v)
              (fn r => xml_return (Fun (EqF, [l, r])))))));

fun variable_parser x =
  xml_text [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #"I", #"d"] x;

fun trans_var_parser x =
  xml_or
    (xml_do [#"p", #"o", #"s", #"t"]
      (xml_take variable_parser (fn v => xml_return (Post v))))
    (xml_or
      (xml_change (xml_text [#"a", #"u", #"x"]) (xml_return o Intermediate))
      (xml_change variable_parser (xml_return o Pre)))
    x;

fun tatom_parsera x =
  xml_change
    (bexp_parser (show_trans_var (show_list show_char)) trans_var_parser)
    (xml_return o Atom) x;

fun formula_parser atom_parser x =
  xml_or
    (xml_do [#"d", #"i", #"s", #"j", #"u", #"n", #"c", #"t", #"i", #"o", #"n"]
      (xml_take_many_sub [] zero_nata Infinity_enat (formula_parser atom_parser)
        (fn fs => xml_return (Disjunction fs))))
    (xml_or
      (xml_do [#"c", #"o", #"n", #"j", #"u", #"n", #"c", #"t", #"i", #"o", #"n"]
        (xml_take_many_sub [] zero_nata Infinity_enat
          (formula_parser atom_parser) (fn fs => xml_return (Conjunction fs))))
      atom_parser)
    x;

fun transition_parser location_parser trans_parser tatom_parser =
  xml_do [#"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n"]
    (xml_take trans_parser
      (fn tr =>
        xml_take
          (xml_do [#"s", #"o", #"u", #"r", #"c", #"e"]
            (xml_take location_parser xml_return))
          (fn l =>
            xml_take
              (xml_do [#"t", #"a", #"r", #"g", #"e", #"t"]
                (xml_take location_parser xml_return))
              (fn r =>
                xml_take
                  (xml_do [#"f", #"o", #"r", #"m", #"u", #"l", #"a"]
                    (xml_take (formula_parser tatom_parser) xml_return))
                  (fn phi => xml_return (tr, Transition (l, r, phi)))))));

fun lts_parser location_parser trans_parser tatom_parser tag =
  xml_do tag
    (xml_take
      (xml_do [#"i", #"n", #"i", #"t", #"i", #"a", #"l"]
        (xml_take_many_sub [] one_nata Infinity_enat location_parser
          xml_return))
      (fn i =>
        xml_take_many_sub [] zero_nata Infinity_enat
          (transition_parser location_parser trans_parser tatom_parser)
          (fn t => xml_return (Lts_Impl (i, t, [])))));

fun safety_input_parser location_parser trans_parser tatom_parser =
  xml_do
    [#"l", #"t", #"s", #"S", #"a", #"f", #"e", #"t", #"y", #"I", #"n", #"p",
      #"u", #"t"]
    (xml_take
      (lts_parser location_parser trans_parser tatom_parser [#"l", #"t", #"s"])
      (fn lts =>
        xml_take
          (xml_do [#"e", #"r", #"r", #"o", #"r"]
            (xml_take_many_sub [] one_nata Infinity_enat location_parser
              xml_return))
          (fn err => xml_return (lts, err))));

fun location_parser location_id_parser =
  location_id_parser
    [#"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n", #"I", #"d"];

fun lts_safety_input_parser x =
  safety_input_parser (location_parser xml_text) (trans_id xml_text)
    tatom_parsera x;

fun precedence_weighta A_ xml2name =
  xml_do
    [#"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c", #"e", #"W", #"e",
      #"i", #"g", #"h", #"t"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c", #"e", #"W", #"e",
          #"i", #"g", #"h", #"t", #"E", #"n", #"t", #"r", #"y"]
        (xml_take xml2name
          (fn f =>
            xml_take (xml_nat [#"a", #"r", #"i", #"t", #"y"])
              (fn a =>
                xml_take
                  (xml_nat
                    [#"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c",
                      #"e"])
                  (fn p =>
                    xml_take (xml_nat [#"w", #"e", #"i", #"g", #"h", #"t"])
                      (fn w =>
                        xml_take_optional
                          (xml_do
                            [#"s", #"u", #"b", #"t", #"e", #"r", #"m", #"C",
                              #"o", #"e", #"f", #"f", #"i", #"c", #"i", #"e",
                              #"n", #"t", #"E", #"n", #"t", #"r", #"i", #"e",
                              #"s"]
                            (xml_take_many_sub [] zero_nata Infinity_enat
                              (xml_nat [#"e", #"n", #"t", #"r", #"y"])
                              xml_return))
                          (fn e => xml_return ((f, a), (p, (w, e))))))))))
      (fn ret => xml_return (fn a => (ret, a))));

fun kbo_input A_ xml2name =
  xml_do
    [#"k", #"n", #"u", #"t", #"h", #"B", #"e", #"n", #"d", #"i", #"x", #"O",
      #"r", #"d", #"e", #"r"]
    (xml_take (xml_nat [#"w", #"0"])
      (fn w0 =>
        xml_take (precedence_weighta A_ xml2name)
          (fn prw => xml_return (KBO_Input (prw w0)))));

fun xml2ordered_completion_input A_ xml2name =
  xml_do
    [#"o", #"r", #"d", #"e", #"r", #"e", #"d", #"C", #"o", #"m", #"p", #"l",
      #"e", #"t", #"i", #"o", #"n", #"I", #"n", #"p", #"u", #"t"]
    (xml_take
      (xml_do [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"s"]
        (xml_take (rules A_ xml2name) xml_return))
      (fn es0 =>
        xml_take
          (xml_do [#"t", #"r", #"s"] (xml_take (rules A_ xml2name) xml_return))
          (fn rs =>
            xml_take
              (xml_do [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"s"]
                (xml_take (rules A_ xml2name) xml_return))
              (fn es =>
                xml_take
                  (xml_do
                    [#"r", #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n", #"O",
                      #"r", #"d", #"e", #"r"]
                    (xml_take (kbo_input A_ xml2name) xml_return))
                  (fn ro => xml_return (OCOMP_input (es0, es, rs, ro)))))));

fun lts_input_parser x =
  lts_parser (location_parser xml_text) (trans_id xml_text) tatom_parsera
    [#"l", #"t", #"s"] x;

fun xml2equational_input A_ xml2name =
  xml_do
    [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"R", #"e",
      #"a", #"s", #"o", #"n", #"i", #"n", #"g", #"I", #"n", #"p", #"u", #"t"]
    (xml_take
      (xml_do [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"s"]
        (xml_take (rules A_ xml2name) xml_return))
      (fn eqs =>
        xml_take
          (xml_or
            (xml_do [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n"]
              (xml_take (term A_ xml2name)
                (fn a =>
                  xml_take (term A_ xml2name)
                    (fn b => xml_return (Equation (a, b))))))
            (xml_do [#"i", #"n", #"e", #"q", #"u", #"a", #"l", #"i", #"t", #"y"]
              (xml_take (term A_ xml2name)
                (fn a =>
                  xml_take (term A_ xml2name)
                    (fn b => xml_return (Inequality (a, b)))))))
          (fn goal => xml_return (EQ_input (eqs, goal)))));

fun xml2completion_input A_ xml2name =
  xml_do
    [#"c", #"o", #"m", #"p", #"l", #"e", #"t", #"i", #"o", #"n", #"I", #"n",
      #"p", #"u", #"t"]
    (xml_take
      (xml_do [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"s"]
        (xml_take (rules A_ xml2name) xml_return))
      (fn a =>
        xml_take
          (xml_do [#"t", #"r", #"s"] (xml_take (rules A_ xml2name) xml_return))
          (fn b => xml_return (COMP_input (a, b)))));

fun cPFsignature A_ xml2name =
  symbols A_ xml2name [#"s", #"i", #"g", #"n", #"a", #"t", #"u", #"r", #"e"];

fun complexity_measure A_ xml2name =
  xml_or
    (xml_do
      [#"d", #"e", #"r", #"i", #"v", #"a", #"t", #"i", #"o", #"n", #"a", #"l",
        #"C", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y"]
      (xml_take (cPFsignature A_ xml2name)
        (fn a => xml_return (Derivational_Complexity a))))
    (xml_do
      [#"r", #"u", #"n", #"t", #"i", #"m", #"e", #"C", #"o", #"m", #"p", #"l",
        #"e", #"x", #"i", #"t", #"y"]
      (xml_take (cPFsignature A_ xml2name)
        (fn a =>
          xml_take (cPFsignature A_ xml2name)
            (fn b => xml_return (Runtime_Complexity (a, b))))));

fun complexity_class x =
  xml_change
    (xml_nat [#"p", #"o", #"l", #"y", #"n", #"o", #"m", #"i", #"a", #"l"])
    (xml_return o Comp_Poly) x;

fun forbidden_pattern A_ xml2name =
  xml_do
    [#"f", #"o", #"r", #"b", #"i", #"d", #"d", #"e", #"n", #"P", #"a", #"t",
      #"t", #"e", #"r", #"n"]
    (xml_take (term A_ xml2name)
      (fn t =>
        xml_take pos
          (fn p =>
            xml_take
              (xml_or (xml_leaf [#"h", #"e", #"r", #"e"] H)
                (xml_or (xml_leaf [#"a", #"b", #"o", #"v", #"e"] A)
                  (xml_or (xml_leaf [#"b", #"e", #"l", #"o", #"w"] Ba)
                    (xml_leaf [#"b", #"e", #"l", #"o", #"w"] Ra))))
              (fn l =>
                (if in_poss p t
                  then xml_return (ctxt_of_pos_term p t, (subt_at t p, l))
                  else xml_error (show_list (show_list show_char))
                         [#"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n", #" ",
                           #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ",
                           #"e", #"x", #"i", #"s", #"t", #" ", #"i", #"n", #" ",
                           #"t", #"e", #"r", #"m"])))));

fun forbidden_patterns A_ xml2name =
  xml_do
    [#"f", #"o", #"r", #"b", #"i", #"d", #"d", #"e", #"n", #"P", #"a", #"t",
      #"t", #"e", #"r", #"n", #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (forbidden_pattern A_ xml2name) xml_return);

fun replacement_map A_ xml2name =
  xml_do
    [#"c", #"o", #"n", #"t", #"e", #"x", #"t", #"S", #"e", #"n", #"s", #"i",
      #"t", #"i", #"v", #"e"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"r", #"e", #"p", #"l", #"a", #"c", #"e", #"m", #"e", #"n", #"t", #"M",
          #"a", #"p", #"E", #"n", #"t", #"r", #"y"]
        (xml_take xml2name
          (fn f =>
            xml_take (xml_nat [#"a", #"r", #"i", #"t", #"y"])
              (fn a =>
                xml_take_many_sub [] zero_nata Infinity_enat position
                  (fn is => xml_return ((f, a), is))))))
      xml_return);

fun inn_fp_strategy A_ xml2name =
  xml_do [#"s", #"t", #"r", #"a", #"t", #"e", #"g", #"y"]
    (xml_take
      (xml_or
        (xml_leaf [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t"]
          (Inl Innermost))
        (xml_or
          (xml_leaf [#"o", #"u", #"t", #"e", #"r", #"m", #"o", #"s", #"t"]
            (Inr Outermost))
          (xml_or
            (xml_change (replacement_map A_ xml2name)
              (fn p => xml_return (Inr (Context_Sensitive p))))
            (xml_or
              (xml_change (forbidden_patterns A_ xml2name)
                (fn p => xml_return (Inr (Forbidden_Patterns p))))
              (xml_change (innermostLhss A_ xml2name)
                (fn q => xml_return (Inl (Innermost_Q q))))))))
      xml_return);

fun xml2_trs_input A_ xml2name =
  xml_do [#"t", #"r", #"s", #"I", #"n", #"p", #"u", #"t"]
    (xml_take
      (xml_do [#"t", #"r", #"s"] (xml_take (rules A_ xml2name) xml_return))
      (fn r =>
        xml_take_default (Inl No_Strategy) (inn_fp_strategy A_ xml2name)
          (fn str =>
            xml_take_default []
              (xml_do
                [#"r", #"e", #"l", #"a", #"t", #"i", #"v", #"e", #"R", #"u",
                  #"l", #"e", #"s"]
                (xml_take (rules A_ xml2name) xml_return))
              (fn rel =>
                (case str
                  of Inl istrat =>
                    xml_return (Inn_TRS_input (istrat, r, rel, Full))
                  | Inr fpstrat =>
                    (if null rel then xml_return (FP_TRS_input (fpstrat, r))
                      else xml_error (show_list (show_list show_char))
                             [#"t", #"h", #"e", #" ", #"c", #"o", #"m", #"b",
                               #"i", #"n", #"a", #"t", #"i", #"o", #"n", #" ",
                               #"o", #"f", #" ", #"r", #"e", #"l", #"a", #"t",
                               #"i", #"v", #"e", #" ", #"r", #"u", #"l", #"e",
                               #"s", #" ", #"w", #"i", #"t", #"h", #" ", #"s",
                               #"t", #"r", #"a", #"t", #"e", #"g", #"i", #"e",
                               #"s", #" ", #"i", #"s", #" ", #"o", #"n", #"l",
                               #"y", #" ", #"s", #"u", #"p", #"p", #"o", #"r",
                               #"t", #"e", #"d", #" ", #"f", #"o", #"r", #" ",
                               #"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s",
                               #"t"]))))));

fun xml2complexity_input A_ xml2name =
  xml_do
    [#"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y", #"I", #"n",
      #"p", #"u", #"t"]
    (xml_take
      (xml_change (xml2_trs_input A_ xml2name)
        (fn a =>
          (case a
            of DP_input (_, _, _, _) =>
              xml_error (show_list (show_list show_char))
                [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"i", #"n",
                  #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"t", #"r",
                  #"s", #" ", #"a", #"t", #" ", #"t", #"h", #"i", #"s", #" ",
                  #"p", #"o", #"i", #"n", #"t"]
            | Inn_TRS_input (q, r, s, start) => xml_return (q, (r, (s, start)))
            | CPX_input (_, _, _, _, _) =>
              xml_error (show_list (show_list show_char))
                [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"i", #"n",
                  #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"t", #"r",
                  #"s", #" ", #"a", #"t", #" ", #"t", #"h", #"i", #"s", #" ",
                  #"p", #"o", #"i", #"n", #"t"]
            | COMP_input (_, _) =>
              xml_error (show_list (show_list show_char))
                [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"i", #"n",
                  #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"t", #"r",
                  #"s", #" ", #"a", #"t", #" ", #"t", #"h", #"i", #"s", #" ",
                  #"p", #"o", #"i", #"n", #"t"]
            | OCOMP_input (_, _, _, _) =>
              xml_error (show_list (show_list show_char))
                [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"i", #"n",
                  #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"t", #"r",
                  #"s", #" ", #"a", #"t", #" ", #"t", #"h", #"i", #"s", #" ",
                  #"p", #"o", #"i", #"n", #"t"]
            | EQ_input (_, _) =>
              xml_error (show_list (show_list show_char))
                [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"i", #"n",
                  #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"t", #"r",
                  #"s", #" ", #"a", #"t", #" ", #"t", #"h", #"i", #"s", #" ",
                  #"p", #"o", #"i", #"n", #"t"]
            | FP_TRS_input (_, _) =>
              xml_error (show_list (show_list show_char))
                [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"i", #"n",
                  #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"t", #"r",
                  #"s", #" ", #"a", #"t", #" ", #"t", #"h", #"i", #"s", #" ",
                  #"p", #"o", #"i", #"n", #"t"]
            | CTRS_input _ =>
              xml_error (show_list (show_list show_char))
                [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"i", #"n",
                  #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"t", #"r",
                  #"s", #" ", #"a", #"t", #" ", #"t", #"h", #"i", #"s", #" ",
                  #"p", #"o", #"i", #"n", #"t"]
            | TA_input (_, _) =>
              xml_error (show_list (show_list show_char))
                [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"i", #"n",
                  #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"t", #"r",
                  #"s", #" ", #"a", #"t", #" ", #"t", #"h", #"i", #"s", #" ",
                  #"p", #"o", #"i", #"n", #"t"]
            | AC_input (_, _, _) =>
              xml_error (show_list (show_list show_char))
                [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"i", #"n",
                  #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"t", #"r",
                  #"s", #" ", #"a", #"t", #" ", #"t", #"h", #"i", #"s", #" ",
                  #"p", #"o", #"i", #"n", #"t"]
            | LTS_input _ =>
              xml_error (show_list (show_list show_char))
                [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"i", #"n",
                  #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"t", #"r",
                  #"s", #" ", #"a", #"t", #" ", #"t", #"h", #"i", #"s", #" ",
                  #"p", #"o", #"i", #"n", #"t"]
            | LTS_safety_input (_, _) =>
              xml_error (show_list (show_list show_char))
                [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"i", #"n",
                  #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"t", #"r",
                  #"s", #" ", #"a", #"t", #" ", #"t", #"h", #"i", #"s", #" ",
                  #"p", #"o", #"i", #"n", #"t"]
            | Unknown_input _ =>
              xml_error (show_list (show_list show_char))
                [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"i", #"n",
                  #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"t", #"r",
                  #"s", #" ", #"a", #"t", #" ", #"t", #"h", #"i", #"s", #" ",
                  #"p", #"o", #"i", #"n", #"t"])))
      (fn (q, (r, (s, _))) =>
        xml_take (complexity_measure A_ xml2name)
          (fn cm =>
            xml_take complexity_class
              (fn cc => xml_return (CPX_input (q, r, s, cm, cc))))));

fun xml2unknown_input x =
  xml_text
    [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #"I", #"n", #"p", #"u", #"t"] x;

fun symbols_no_arity A_ xml2name tagname =
  xml_do tagname
    (xml_take_many_sub [] zero_nata Infinity_enat xml2name xml_return);

fun xml2ac_tp_input A_ xml2name =
  xml_do
    [#"a", #"c", #"R", #"e", #"w", #"r", #"i", #"t", #"e", #"S", #"y", #"s",
      #"t", #"e", #"m"]
    (xml_take
      (xml_do [#"t", #"r", #"s"]
        (xml_take (rules A_ xml2name) (fn x => xml_return (id x))))
      (fn a =>
        xml_take
          (symbols_no_arity A_ xml2name
            [#"A", #"s", #"y", #"m", #"b", #"o", #"l", #"s"])
          (fn b =>
            xml_take
              (symbols_no_arity A_ xml2name
                [#"C", #"s", #"y", #"m", #"b", #"o", #"l", #"s"])
              (fn c => xml_return (AC_input (a, b, c))))));

fun xml2ctrs_input A_ xml2name =
  xml_do [#"c", #"t", #"r", #"s", #"I", #"n", #"p", #"u", #"t"]
    (xml_take
      (xml_do [#"r", #"u", #"l", #"e", #"s"]
        (xml_take_many_sub [] zero_nata Infinity_enat
          (crule A_ xml2name [#"r", #"u", #"l", #"e"]) xml_return))
      (fn a => xml_return (CTRS_input a)));

fun xml2dp_input A_ xml2name =
  xml_do [#"d", #"p", #"I", #"n", #"p", #"u", #"t"]
    (xml_take
      (xml_do [#"t", #"r", #"s"]
        (xml_take (rules A_ xml2name) (fn x => xml_return (id x))))
      (fn r =>
        xml_take
          (xml_do [#"d", #"p", #"s"]
            (xml_take (rules A_ xml2name) (fn x => xml_return (id x))))
          (fn p =>
            xml_take_default No_Strategy (strategy A_ xml2name)
              (fn s =>
                xml_take (xml_bool [#"m", #"i", #"n", #"i", #"m", #"a", #"l"])
                  (fn m => xml_return (DP_input (m, p, s, r)))))));

fun xml2input A_ xml2name =
  xml_do [#"i", #"n", #"p", #"u", #"t"]
    (xml_take
      (xml_or (xml2dp_input A_ xml2name)
        (xml_or (xml2completion_input A_ xml2name)
          (xml_or (xml2ordered_completion_input A_ xml2name)
            (xml_or (xml2_trs_input A_ xml2name)
              (xml_or (xml2equational_input A_ xml2name)
                (xml_or (xml2complexity_input A_ xml2name)
                  (xml_or (xml2ctrs_input A_ xml2name)
                    (xml_or
                      (xml_do
                        [#"t", #"r", #"e", #"e", #"A", #"u", #"t", #"o", #"m",
                          #"a", #"t", #"o", #"n", #"P", #"r", #"o", #"b", #"l",
                          #"e", #"m"]
                        (xml_take (tree_automaton (ta_normal_lhs xml2name))
                          (fn a =>
                            xml_take
                              (xml_do [#"t", #"r", #"s"]
                                (xml_take (rules A_ xml2name)
                                  (fn x => xml_return (id x))))
                              (fn b => xml_return (TA_input (a, b))))))
                      (xml_or (xml2ac_tp_input A_ xml2name)
                        (xml_or
                          (xml_change lts_input_parser (xml_return o LTS_input))
                          (xml_or
                            (xml_change lts_safety_input_parser
                              (fn (x, y) =>
                                xml_return (LTS_safety_input (x, y))))
                            (xml_change xml2unknown_input
                              (xml_return o Unknown_input)))))))))))))
      (fn x => xml_return (id x)));

fun missing s x =
  shows_string [#"t", #"h", #"e", #" "] o
    (shows_string s o
      (shows_string [#" "] o
        (x o shows_string
               [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n",
                 #"g"])));

fun toomuch s x =
  shows_string
    [#"s", #"u", #"p", #"e", #"r", #"f", #"l", #"u", #"o", #"u", #"s", #" "] o
    (shows_string s o (shows_string [#" "] o (x o x)));

fun array_get (FArray.IsabelleMapping.array_of_list a) n = nth a n;

fun array_set (FArray.IsabelleMapping.array_of_list aa) n a =
  FArray.IsabelleMapping.array_of_list (list_update aa n a);

fun as_length x = snd x;

fun array_shrink (FArray.IsabelleMapping.array_of_list a) sz =
  (if less_nat (size_list a) sz then (raise Fail "undefined")
    else FArray.IsabelleMapping.array_of_list (take sz a));

fun array_length (FArray.IsabelleMapping.array_of_list a) = size_list a;

fun as_shrink s =
  let
    val a = s;
    val (aa, n) = a;
    val ab =
      (if less_eq_nat (times_nata (nat_of_integer (128 : IntInf.int)) n)
            (array_length aa) andalso
            less_nat (nat_of_integer (4 : IntInf.int)) n
        then array_shrink aa n else aa);
  in
    (ab, n)
  end;

fun as_take m s = let
                    val a = s;
                    val (aa, n) = a;
                  in
                    (if less_nat m n then as_shrink (aa, m) else (aa, n))
                  end;

fun as_top s = let
                 val a = s;
                 val (aa, n) = a;
               in
                 array_get aa (minus_nata n one_nata)
               end;

fun as_pop s = let
                 val a = s;
                 val (aa, n) = a;
               in
                 as_shrink (aa, minus_nata n one_nata)
               end;

fun as_get s i = let
                   val a = s;
                   val (aa, _) = a;
                 in
                   array_get aa i
                 end;

fun whilea b c s = (if b s then whilea b c (c s) else s);

fun pop_tr A_ s =
  let
    val (a, (aa, (ab, bb))) = s;
    val x = minus_nata (as_length aa) one_nata;
    val xa =
      let
        val (_, bc) =
          whilea
            (fn (xf, _) =>
              less_nat xf
                (if equal_nata (plus_nata x one_nata) (as_length aa)
                  then as_length a else as_get aa (plus_nata x one_nata)))
            (fn (ac, bc) =>
              (suc ac, rbt_insert A_ (as_get a ac) (uminus_inta one_inta) bc))
            (as_get aa x, ab);
      in
        bc
      end;
    val xb = as_take (as_top aa) a;
    val xc = as_pop aa;
  in
    (xb, (xc, (xa, bb)))
  end;

fun gen_disjoint it1 mem2 s1 s2 =
  it1 s1 (fn x => x) (fn x => fn _ => not (mem2 x s2)) true;

fun is_NF_subset is_Q_nf q = list_all (fn qa => not (is_Q_nf qa)) q;

fun icap_impl_gen A_ nf isQnf ls s sx (Var x) =
  (if nf andalso sx x then Var (Inr x) else Var (Inl ()))
  | icap_impl_gen A_ nf isQnf ls s sx (Fun (f, ts)) =
    let
      val t = Fun (f, map (icap_impl_gen A_ nf isQnf ls s sx) ts);
    in
      (if list_ex
            (fn l =>
              (case mgu_class A_ t l of NONE => false
                | SOME mu =>
                  list_all
                    (fn u =>
                      isQnf (subst_apply_term
                              (map_term (fn x => x) (fn a => #"y" :: a) u) mu))
                    (args l) andalso
                    list_all (fn u => isQnf (subst_apply_term u mu)) s))
            ls
        then Var (Inl ()) else t)
    end;

fun ins_rm_basic_ops A_ x s = insert A_ x () s;

fun g_from_list_aux_dflt_basic_oops_rm_basic_ops A_ accs (x :: l) =
  g_from_list_aux_dflt_basic_oops_rm_basic_ops A_ (ins_rm_basic_ops A_ x accs) l
  | g_from_list_aux_dflt_basic_oops_rm_basic_ops A_ y [] = y;

fun empty_rm_basic_ops A_ = (fn _ => empty A_);

fun g_from_list_dflt_basic_oops_rm_basic_ops A_ l =
  g_from_list_aux_dflt_basic_oops_rm_basic_ops A_
    (empty_rm_basic_ops (linorder_compare_order A_) ()) l;

fun memb_rm_basic_ops A_ x s = not (is_none (lookup A_ s x));

fun ceta_set_of A_ ps =
  let
    val tree =
      g_from_list_dflt_basic_oops_rm_basic_ops (compare_order_key A_) ps;
  in
    (fn a => memb_rm_basic_ops (compare_order_key A_) a tree)
  end;

fun icap_impl A_ isnf r =
  let
    val ls = map fst r;
    val nf = is_NF_subset isnf ls;
    val ic = icap_impl_gen A_ nf isnf ls;
  in
    (fn s =>
      let
        val sa = map (map_term (fn x => x) (fn a => #"x" :: a)) s;
        val sx =
          ceta_set_of (key_list (equal_char, key_char))
            (maps vars_term_list sa);
      in
        (fn t => ic sa sx (map_term (fn x => x) (fn a => #"x" :: a) t))
      end)
  end;

fun rep_subst_incr (Abs_subst_incr x) = x;

fun si_W xa = snd (snd (rep_subst_incr xa));

fun kbo_nstrict A_ (B1_, B2_) pr w w0 least scf =
  (fn (s, t) =>
    check (snd (kbo_impl B1_ w w0 pr least scf s t))
      (shows_string
         [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"o",
           #"r", #"i", #"e", #"n", #"t", #" "] o
        (shows_prec_term A_ B2_ zero_nata s o
          (shows_string [#" ", #">", #"=", #"K", #"B", #"O", #" "] o
            (shows_prec_term A_ B2_ zero_nata t o shows_nl)))));

fun succ_transitions D_ (Lts_Impl (i, ts, lc)) l =
  maps (fn (_, tau) => (if eq D_ (source tau) l then [tau] else [])) ts;

fun default_I A_ def n =
  (one_monom linorder_nat, def) ::
    map (fn i =>
          (var_monom linorder_nat i,
            onea ((one_numeral o numeral_semiring_numeral o
                    semiring_numeral_semiring_1 o semiring_1_comm_semiring_1 o
                    comm_semiring_1_poly_carrier)
                   A_)))
      (upt zero_nata n);

fun proper_prefix_list Empty = []
  | proper_prefix_list (PCons (i, p)) =
    Empty :: map (fn a => PCons (i, a)) (proper_prefix_list p);

fun prefix_list p = p :: proper_prefix_list p;

fun scnp_arity af = max_list (map (fn (_, a) => size_list a) af);

fun rules_no_left_vara
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = rules_no_left_var;

fun rules_mapc
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = rules_map;

fun tcapRM_dpp B_ C_ i dpp =
  tcapRM B_ C_ (rules_no_left_vara i dpp) (rules_mapc i dpp);

fun funas_term_list (Var uu) = []
  | funas_term_list (Fun (f, ts)) =
    (f, size_list ts) :: maps funas_term_list ts;

fun check_supt (A1_, A2_) (B1_, B2_) s t =
  check (supt_impl A1_ B1_ s t)
    (shows_prec_term A2_ B2_ zero_nata t o
      (shows_string
         [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"p",
           #"r", #"o", #"p", #"e", #"r", #" ", #"s", #"u", #"b", #"t", #"e",
           #"r", #"m", #" ", #"o", #"f", #" "] o
        shows_prec_term A2_ B2_ zero_nata s));

fun compute_trancl (A1_, A2_, A3_, A4_) a r =
  let
    val b = imagea (A2_, A3_) (A2_, A3_, A4_) r a;
  in
    (if less_eq_set (A1_, A2_, A3_) b (bot_set (A2_, A3_, A4_))
      then bot_set (A2_, A3_, A4_)
      else sup_seta (A2_, A3_) b
             (compute_trancl (A1_, A2_, A3_, A4_) b
               (filter (ceq_prod A2_ A2_, ccompare_prod A3_ A3_)
                 (fn ab =>
                   not (member (A2_, A3_) (fst ab) a) andalso
                     not (member (A2_, A3_) (snd ab) b))
                 r)))
  end;

fun ta_res (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) ta (Fun (f, ts)) =
  let
    val qs = map (ta_res (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) ta) ts;
    val g = (f, size_list ts);
  in
    sup_seta (A2_, A3_)
      (image (ceq_ta_rule A4_ B2_, ccompare_ta_rule A3_ B1_) (A2_, A3_, A5_)
        r_rhs
        (filter (ceq_ta_rule A4_ B2_, ccompare_ta_rule A3_ B1_)
          (fn r =>
            equal_proda B2_ equal_nat (r_sym r) g andalso
              list_all (fn qq => member (A2_, A3_) (snd qq) (fst qq))
                (zip qs (r_lhs_states r)))
          (ta_rules ta)))
      (compute_trancl (A1_, A2_, A3_, A5_)
        (image (ceq_ta_rule A4_ B2_, ccompare_ta_rule A3_ B1_) (A2_, A3_, A5_)
          r_rhs
          (filter (ceq_ta_rule A4_ B2_, ccompare_ta_rule A3_ B1_)
            (fn r =>
              equal_proda B2_ equal_nat (r_sym r) g andalso
                list_all (fn qq => member (A2_, A3_) (snd qq) (fst qq))
                  (zip qs (r_lhs_states r)))
            (ta_rules ta)))
        (ta_eps ta))
  end
  | ta_res (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) ta (Var q) =
    sup_seta (A2_, A3_) (inserta (A2_, A3_) q (bot_set (A2_, A3_, A5_)))
      (compute_trancl (A1_, A2_, A3_, A5_)
        (inserta (A2_, A3_) q (bot_set (A2_, A3_, A5_))) (ta_eps ta));

fun eq_rule_mod_vars A_ (B1_, B2_, B3_) lr st =
  instance_rule A_ B2_ (B1_, B2_, B3_) lr st andalso
    instance_rule A_ B2_ (B1_, B2_, B3_) st lr;

fun is_NF_terms (A1_, A2_) (B1_, B2_, B3_) q =
  is_NF_main (A1_, A2_) (B1_, B2_, B3_) (list_ex is_Var q) (null q)
    (term_map A2_ q);

fun generate_var i = #"x" :: shows_prec_nat zero_nata i [];

fun uncurry_term A_ a sm t =
  (case unapp A_ a t
    of (Var x, ts) => apply_args a (Var x) (map (uncurry_term A_ a sm) ts)
    | (Fun (f, ss), ts) =>
      let
        val n = size_list ss;
        val uss = map (uncurry_term A_ a sm) ss;
        val uts = map (uncurry_term A_ a sm) ts;
        val aa = aarity sm f n;
        val m = min ord_nat (size_list ts) aa;
        val fm = get_symbol sm f n m;
      in
        apply_args a (Fun (fm, uss @ take m uts)) (drop m uts)
      end);

fun xml2claim x =
  xml_or
    (xml_do [#"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"n", #"g"]
      (xml_take_optional
        (xml_do [#"u", #"p", #"p", #"e", #"r", #"b", #"o", #"u", #"n", #"d"]
          (xml_take
            (xml_do [#"p", #"o", #"l", #"y", #"n", #"o", #"m", #"i", #"a", #"l"]
              (xml_take_attribute [#"d", #"e", #"g", #"r", #"e", #"e"]
                (fn deg_s =>
                  (case nat_of_string deg_s
                    of Inl a => xml_error (show_list (show_list show_char)) a
                    | Inr deg => xml_return (Upperbound deg)))))
            xml_return))
        (fn a =>
          (case a of NONE => xml_return Terminating
            | SOME aa => xml_return aa))))
    (xml_or
      (xml_leaf
        [#"n", #"o", #"n", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
          #"n", #"g"]
        Nonterminating)
      (xml_or
        (xml_leaf [#"c", #"o", #"n", #"f", #"l", #"u", #"e", #"n", #"t"]
          Confluent)
        (xml_leaf
          [#"n", #"o", #"n", #"c", #"o", #"n", #"f", #"l", #"u", #"e", #"n",
            #"t"]
          Nonconfluent)))
    x;

fun conversion A_ xml2name =
  xml_do [#"c", #"o", #"n", #"v", #"e", #"r", #"s", #"i", #"o", #"n"]
    (xml_take
      (xml_do [#"s", #"t", #"a", #"r", #"t", #"T", #"e", #"r", #"m"]
        (xml_take (term A_ xml2name) (fn x => xml_return (id x))))
      (fn a =>
        xml_take_many_sub [] zero_nata Infinity_enat (estep A_ xml2name)
          (fn b => xml_return (a, b))));

fun plain_name x =
  xml_or (xml_change (xml_text [#"n", #"a", #"m", #"e"]) (xml_return o UnLab))
    (xml_or
      (xml_do [#"s", #"h", #"a", #"r", #"p"]
        (xml_take plain_name (fn xa => xml_return (Sharp xa))))
      (xml_do
        [#"l", #"a", #"b", #"e", #"l", #"e", #"d", #"S", #"y", #"m", #"b", #"o",
          #"l"]
        (xml_take plain_name
          (fn a =>
            xml_take
              (xml_or
                (xml_do
                  [#"n", #"u", #"m", #"b", #"e", #"r", #"L", #"a", #"b", #"e",
                    #"l"]
                  (xml_take_many_sub [] zero_nata Infinity_enat
                    (xml_nat [#"n", #"u", #"m", #"b", #"e", #"r"])
                    (fn aa => xml_return (Inl aa))))
                (xml_do
                  [#"s", #"y", #"m", #"b", #"o", #"l", #"L", #"a", #"b", #"e",
                    #"l"]
                  (xml_take_many_sub [] zero_nata Infinity_enat plain_name
                    (fn aa => xml_return (Inr aa)))))
              (fn b =>
                xml_return
                  (case b of Inl ba => Lab (a, ba)
                    | Inr ba => FunLab (a, ba)))))))
    x;

fun level_mapping A_ xml2name =
  xml_do
    [#"l", #"e", #"v", #"e", #"l", #"M", #"a", #"p", #"p", #"i", #"n", #"g"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"l", #"e", #"v", #"e", #"l", #"M", #"a", #"p", #"p", #"i", #"n", #"g",
          #"E", #"n", #"t", #"r", #"y"]
        (xml_take xml2name
          (fn f =>
            xml_take (xml_nat [#"a", #"r", #"i", #"t", #"y"])
              (fn a =>
                xml_take_many_sub [] zero_nata Infinity_enat
                  (xml_do
                    [#"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n", #"L", #"e",
                      #"v", #"e", #"l", #"E", #"n", #"t", #"r", #"y"]
                    (xml_take
                      (xml_nat [#"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n"])
                      (fn aa =>
                        xml_take (xml_nat [#"l", #"e", #"v", #"e", #"l"])
                          (fn b => xml_return (aa, b)))))
                  (fn ps =>
                    xml_return
                      ((f, a),
                        map (fn (p, b) =>
                              ((if equal_nata p zero_nata then a
                                 else minus_nata p one_nata),
                                b))
                          ps))))))
      xml_return);

fun redtriplea A_ xml2name bi =
  xml_do [#"r", #"e", #"d", #"P", #"a", #"i", #"r"]
    (xml_take
      (xml_or
        (xml_do [#"s", #"c", #"n", #"p"]
          (xml_take
            (xml_do [#"s", #"t", #"a", #"t", #"u", #"s"]
              (xml_take
                (xml_or (xml_leaf [#"m", #"s"] MS_Ext)
                  (xml_or (xml_leaf [#"m", #"i", #"n"] Min_Ext)
                    (xml_or (xml_leaf [#"d", #"m", #"s"] Dms_Ext)
                      (xml_leaf [#"m", #"a", #"x"] Max_Ext))))
                xml_return))
            (fn a =>
              xml_take (level_mapping A_ xml2name)
                (fn b =>
                  xml_take
                    (xml_do [#"r", #"e", #"d", #"P", #"a", #"i", #"r"]
                      (xml_take (redtriple A_ xml2name false)
                        (fn x => xml_return (id x))))
                    (fn c => xml_return (Inl (SCNP (a, b, c))))))))
        (xml_change (redtriple A_ xml2name bi) (xml_return o Inr)))
      xml_return);

fun rule_pairs A_ xml2name s p =
  xml_do s
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do p
        (xml_take (rule A_ xml2name)
          (fn a => xml_take (rule A_ xml2name) (fn b => xml_return (a, b)))))
      xml_return);

fun xml1or2many_elements tag p1 p2 p3 f (XML (name, atts, cs)) =
  (if equal_lista equal_char name tag andalso (null atts andalso not (null cs))
    then let
           val cs0 :: tt = cs;
         in
           binda (p1 cs0)
             (fn x =>
               (case tt of [] => return (f x NONE [])
                 | cs1 :: t =>
                   catch_error
                     (binda (p2 cs1)
                       (fn y =>
                         binda (map_sum_bot p3 t)
                           (fn xs => return (f x (SOME y) xs))))
                     (fn _ =>
                       binda (map_sum_bot p3 tt)
                         (fn xs => return (f x NONE xs)))))
         end
    else fail tag (XML (name, atts, cs)))
  | xml1or2many_elements tag p1 p2 p3 f (XML_text v) = fail tag (XML_text v);

fun sl_variant xml2name =
  singleton [#"m", #"o", #"d", #"e", #"l"]
    (options
      [([#"f", #"i", #"n", #"i", #"t", #"e", #"M", #"o", #"d", #"e", #"l"],
         xml1or2many_elements
           [#"f", #"i", #"n", #"i", #"t", #"e", #"M", #"o", #"d", #"e", #"l"]
           (change
             (nata [#"c", #"a", #"r", #"r", #"i", #"e", #"r", #"S", #"i", #"z",
                     #"e"])
             (fn n => minus_nata n one_nata))
           (singleton
             [#"t", #"u", #"p", #"l", #"e", #"O", #"r", #"d", #"e", #"r"]
             (leaf [#"p", #"o", #"i", #"n", #"t", #"W", #"i", #"s", #"e"] ())
             id)
           (triple [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t"]
             xml2name (nata [#"a", #"r", #"i", #"t", #"y"]) arith_fun
             (fn f => fn a => (fn b => ((f, a), b))))
           (fn n => fn model => fn xs =>
             (if is_none model then Finitelab (SL_Inter (n, xs))
               else QuasiFinitelab (SL_Inter (n, xs), [])))),
        ([#"r", #"o", #"o", #"t", #"L", #"a", #"b", #"e", #"l", #"i", #"n",
           #"g"],
          guard (fn x => equal_nata (num_children x) zero_nata)
            (leaf [#"r", #"o", #"o", #"t", #"L", #"a", #"b", #"e", #"l", #"i",
                    #"n", #"g"]
              (Rootlab NONE))
            (singleton
              [#"r", #"o", #"o", #"t", #"L", #"a", #"b", #"e", #"l", #"i", #"n",
                #"g"]
              xml2name (fn f => Rootlab (SOME (f, one_nata)))))])
    id;

fun char_matrix A_ a e =
  plus_mat
    ((plus_semigroup_add o semigroup_add_numeral o numeral_neg_numeral o
       neg_numeral_ring_1 o ring_1_comm_ring_1 o comm_ring_1_idom o
       idom_idom_divide o idom_divide_field)
      A_)
    a (smult_mat
        ((times_dvd o dvd_comm_monoid_mult o comm_monoid_mult_comm_semiring_1 o
           comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
           idom_divide_field)
          A_)
        (uminus
          ((uminus_group_add o group_add_neg_numeral o neg_numeral_ring_1 o
             ring_1_comm_ring_1 o comm_ring_1_idom o idom_idom_divide o
             idom_divide_field)
            A_)
          e)
        (one_mat
          ((one_numeral o numeral_neg_numeral o neg_numeral_ring_1 o
             ring_1_comm_ring_1 o comm_ring_1_idom o idom_idom_divide o
             idom_divide_field)
             A_,
            (zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
              semiring_1_comm_semiring_1 o
              comm_semiring_1_comm_semiring_1_cancel o
              comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
              idom_divide_field)
              A_)
          (dim_row a)));

fun array_grow (FArray.IsabelleMapping.array_of_list a) inc x =
  FArray.IsabelleMapping.array_of_list (a @ replicate inc x);

fun roots1 A_ p =
  divide ((divide_inverse o inverse_division_ring o division_ring_field) A_)
    (uminus
      ((uminus_group_add o group_add_neg_numeral o neg_numeral_ring_1 o
         ring_1_comm_ring_1 o comm_ring_1_idom o idom_idom_divide o
         idom_divide_field)
        A_)
      (case coeffs
              ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
                 semiring_1_comm_semiring_1 o
                 comm_semiring_1_comm_semiring_1_cancel o
                 comm_semiring_1_cancel_semidom o semidom_idom o
                 idom_idom_divide o idom_divide_field)
                A_)
              p
        of [] =>
          zerob ((zero_mult_zero o mult_zero_semiring_0 o
                   semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                   comm_semiring_1_comm_semiring_1_cancel o
                   comm_semiring_1_cancel_semidom o semidom_idom o
                   idom_idom_divide o idom_divide_field)
                  A_)
        | x :: _ => x))
    (coeff
      ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
         semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
         comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
         idom_divide_field)
        A_)
      p one_nata);

fun diff_by_label (A1_, A2_) pairs l =
  filtera (fn v => not (member (A1_, A2_) (fst v) l)) pairs;

fun formula_pos_parser x =
  xml_or
    (xml_do [#"c", #"o", #"n", #"c", #"l", #"u", #"s", #"i", #"o", #"n"]
      (xml_return zero_nata))
    (xml_or
      (xml_do [#"a", #"s", #"s", #"e", #"r", #"t", #"i", #"o", #"n"]
        (xml_return (nat_of_integer (2 : IntInf.int))))
      (xml_or
        (xml_do [#"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n"]
          (xml_return (nat_of_integer (3 : IntInf.int))))
        (xml_do
          [#"t", #"a", #"r", #"g", #"e", #"t", #"A", #"s", #"s", #"e", #"r",
            #"t", #"i", #"o", #"n"]
          (xml_return (nat_of_integer (4 : IntInf.int))))))
    x;

fun hints_parser A_ hint_parser xml =
  xml_or (xml_do [#"a", #"u", #"t", #"o"] (xml_return (default_hinta A_)))
    (xml_or
      (xml_do [#"d", #"i", #"s", #"t", #"r", #"i", #"b", #"u", #"t", #"e"]
        (xml_take formula_pos_parser
          (fn pos =>
            xml_take_many_sub [] zero_nata Infinity_enat
              (hints_parser A_ hint_parser)
              (fn hints => xml_return (Distribute (pos, hints))))))
      (xml_or
        (xml_do [#"e", #"r", #"a", #"s", #"e"]
          (xml_take formula_pos_parser
            (fn pos =>
              xml_take (hints_parser A_ hint_parser)
                (fn hint => xml_return (Erase (pos, hint))))))
        (xml_or
          (xml_do [#"l", #"e", #"x", #"W", #"e", #"a", #"k"]
            (xml_take_many_sub [] zero_nata Infinity_enat
              (hints_parser A_ hint_parser)
              (fn hints => xml_return (LexWeak hints))))
          (xml_or
            (xml_do [#"l", #"e", #"x", #"S", #"t", #"r", #"i", #"c", #"t"]
              (xml_take_many_sub [] zero_nata Infinity_enat
                (hints_parser A_ hint_parser)
                (fn hints => xml_return (LexStrict hints))))
            (xml_change hint_parser (xml_return o Base))))))
    xml;

fun art_node_parser G_ art_node_id_parser location_parser trans_parser
  atom_parser hint_parser =
  xml_do [#"n", #"o", #"d", #"e"]
    (xml_take_default false
      (xml_do [#"i", #"n", #"i", #"t", #"i", #"a", #"l"] (xml_return true))
      (fn init =>
        xml_take (art_node_id_parser [#"n", #"o", #"d", #"e", #"I", #"d"])
          (fn nodeId =>
            xml_take
              (xml_do [#"i", #"n", #"v", #"a", #"r", #"i", #"a", #"n", #"t"]
                (xml_take (formula_parser atom_parser) xml_return))
              (fn invariant =>
                xml_take
                  (xml_do [#"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n"]
                    (xml_take location_parser xml_return))
                  (fn location =>
                    xml_take
                      (xml_or
                        (xml_do [#"c", #"h", #"i", #"l", #"d", #"r", #"e", #"n"]
                          (xml_take_many_sub [] zero_nata Infinity_enat
                            (xml_do [#"c", #"h", #"i", #"l", #"d"]
                              (xml_take trans_parser
                                (fn tr =>
                                  xml_take
                                    (art_node_id_parser
                                      [#"n", #"o", #"d", #"e", #"I", #"d"])
                                    (fn n =>
                                      xml_take_default (default_hinta G_)
(xml_do [#"h", #"i", #"n", #"t", #"s"]
  (xml_take (hints_parser G_ hint_parser) xml_return))
(fn h => xml_return (tr, (n, h)))))))
                            (fn chs => xml_return (Children_Edge chs))))
                        (xml_do
                          [#"c", #"o", #"v", #"e", #"r", #"E", #"d", #"g", #"e"]
                          (xml_take
                            (art_node_id_parser
                              [#"n", #"o", #"d", #"e", #"I", #"d"])
                            (fn n =>
                              xml_take_default (default_hinta G_)
                                (xml_do [#"h", #"i", #"n", #"t", #"s"]
                                  (xml_take (hints_parser G_ hint_parser)
                                    xml_return))
                                (fn h => xml_return (Cover_Edge (n, h)))))))
                      (fn edges =>
                        xml_return
                          (Art_Node (nodeId, invariant, location, edges),
                            (if init then [nodeId] else []))))))));

fun art_parser G_ art_node_id_parser location_parser trans_parser atom_parser
  hint_parser =
  xml_do [#"i", #"m", #"p", #"a", #"c", #"t"]
    (xml_take_default []
      (xml_change
        (art_node_id_parser [#"i", #"n", #"i", #"t", #"i", #"a", #"l"])
        (fn x => xml_return [x]))
      (fn init =>
        xml_take
          (xml_do [#"n", #"o", #"d", #"e", #"s"]
            (xml_take_many_sub [] zero_nata Infinity_enat
              (art_node_parser G_ art_node_id_parser location_parser
                trans_parser atom_parser hint_parser)
              xml_return))
          (fn pairs => let
                         val nodes = map fst pairs;
                         val inits = init @ maps snd pairs;
                       in
                         xml_return (Art_impl_ext (inits, nodes, ()))
                       end)));

fun check_prop_rstep_rule (A1_, A2_) (B1_, B2_, B3_, B4_) nfs pa p rule s t =
  bindb (check (in_poss p s)
          (shows_prec_pos zero_nata p o
            (shows_string
               [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ",
                 #"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n", #" ", #"o",
                 #"f", #" "] o
              (shows_prec_term A2_ B4_ zero_nata s o shows_nl))))
    (fn _ =>
      bindb (check (in_poss p t)
              (shows_prec_pos zero_nata p o
                (shows_string
                   [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ",
                     #"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n", #" ", #"o",
                     #"f", #" "] o
                  (shows_prec_term A2_ B4_ zero_nata t o shows_nl))))
        (fn _ =>
          let
            val c = ctxt_of_pos_term p s;
            val d = ctxt_of_pos_term p t;
            val u = subt_at s p;
            val v = subt_at t p;
          in
            (case match_list (B1_, B2_, B3_) A1_ B2_ Var
                    [(fst rule, u), (snd rule, v)]
              of NONE =>
                Inl (shows_string
                       [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #" "] o
                      (shows_prec_term A2_ B4_ zero_nata t o
                        (shows_string
                           [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o",
                             #"t", #" ", #"r", #"e", #"s", #"u", #"l", #"t",
                             #" ", #"f", #"r", #"o", #"m", #" ", #"a", #" ",
                             #"p", #"r", #"o", #"p", #"e", #"r", #" ", #"a",
                             #"p", #"p", #"l", #"i", #"c", #"a", #"t", #"i",
                             #"o", #"n", #" ", #"o", #"f", #" ", #"r", #"u",
                             #"l", #"e", #" "] o
                          (shows_nl o
                            (shows_rule (shows_prec A2_ zero_nata)
                               (shows_prec B4_ zero_nata)
                               [#" ", #"-", #">", #" "] rule o
                              (shows_string
                                 [#" ", #"a", #"t", #" ", #"p", #"o", #"s",
                                   #"i", #"t", #"i", #"o", #"n", #" "] o
                                (shows_prec_pos zero_nata p o shows_nl)))))))
              | SOME tau =>
                bindb (catch_errora
                        (forallM pa
                          (args u @
                            (if nfs then map tau (vars_rule_list rule)
                              else [])))
                        (fn x => Inl (snd x)))
                  (fn _ =>
                    check (equal_ctxta A1_ B2_ c d)
                      (shows_string
                         [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m",
                           #" "] o
                        (shows_prec_term A2_ B4_ zero_nata t o
                          (shows_string
                             [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o",
                               #"t", #" ", #"r", #"e", #"s", #"u", #"l", #"t",
                               #" ", #"f", #"r", #"o", #"m", #" ", #"a", #" ",
                               #"p", #"r", #"o", #"p", #"e", #"r", #" ", #"a",
                               #"p", #"p", #"l", #"i", #"c", #"a", #"t", #"i",
                               #"o", #"n", #" ", #"o", #"f", #" ", #"r", #"u",
                               #"l", #"e", #" "] o
                            (shows_nl o
                              (shows_rule (shows_prec A2_ zero_nata)
                                 (shows_prec B4_ zero_nata)
                                 [#" ", #"-", #">", #" "] rule o
                                (shows_string
                                   [#" ", #"a", #"t", #" ", #"p", #"o", #"s",
                                     #"i", #"t", #"i", #"o", #"n", #" "] o
                                  (shows_prec_pos zero_nata p o
                                    shows_nl)))))))))
          end));

fun check_prop_rstep (A1_, A2_) (B1_, B2_, B3_, B4_) nfs pa r p rule s t =
  check (list_ex
          (fn ra =>
            eq_rule_mod_vars A1_ (B1_, B2_, B3_) rule ra andalso
              isOK (check_prop_rstep_rule (A1_, A2_) (B1_, B2_, B3_, B4_) nfs pa
                     p ra s t))
          r)
    (shows_prec_list show_char zero_nata
       [#"t", #"h", #"e", #" ", #"s", #"t", #"e", #"p", #" ", #"f", #"r", #"o",
         #"m", #" "] o
      (shows_prec_term A2_ B4_ zero_nata s o
        (shows_prec_list show_char zero_nata [#" ", #"t", #"o", #" "] o
          (shows_prec_term A2_ B4_ zero_nata t o
            (shows_prec_list show_char zero_nata
               [#" ", #"v", #"i", #"a", #" ", #"r", #"u", #"l", #"e", #" "] o
              (shows_rule (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
                 [#" ", #"-", #">", #" "] rule o
                (shows_prec_list show_char zero_nata
                   [#" ", #"a", #"t", #" ", #"p", #"o", #"s", #"i", #"t", #"i",
                     #"o", #"n", #" "] o
                  (shows_prec_pos zero_nata p o
                    (shows_prec_list show_char zero_nata
                       [#" ", #"i", #"s", #" ", #"p", #"r", #"o", #"b", #"l",
                         #"e", #"m", #"a", #"t", #"i", #"c"] o
                      shows_nl)))))))));

fun check_qrstep (A1_, A2_) (B1_, B2_, B3_, B4_) nf nfs =
  check_prop_rstep (A1_, A2_) (B1_, B2_, B3_, B4_) nfs
    (fn t =>
      check (nf t)
        (shows_prec_term A2_ B4_ zero_nata t o
          shows_prec_list show_char zero_nata
            [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"i", #"n", #" ",
              #"Q", #"-", #"n", #"o", #"r", #"m", #"a", #"l", #" ", #"f", #"o",
              #"r", #"m"]));

fun check_rqrstep (A1_, A2_) (B1_, B2_, B3_, B4_) nf nfs r rule s t =
  check_qrstep (A1_, A2_) (B1_, B2_, B3_, B4_) nf nfs r Empty rule s t;

fun check_qsteps (A1_, A2_) (B1_, B2_, B3_, B4_) nf nfs p r [] s u =
  check (equal_terma A1_ B2_ s u)
    (shows_string
       [#"t", #"h", #"e", #" ", #"l", #"a", #"s", #"t", #" ", #"t", #"e", #"r",
         #"m", #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"r", #"e", #"w",
         #"r", #"i", #"t", #"e", #" ", #"s", #"e", #"q", #"u", #"e", #"n", #"c",
         #"e"] o
      (shows_nl o
        (shows_prec_term A2_ B4_ zero_nata s o
          (shows_nl o
            (shows_string
               [#"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"c",
                 #"o", #"r", #"r", #"e", #"s", #"p", #"o", #"n", #"d", #" ",
                 #"t", #"o", #" ", #"t", #"h", #"e", #" ", #"g", #"o", #"a",
                 #"l", #" ", #"t", #"e", #"r", #"m"] o
              (shows_nl o (shows_prec_term A2_ B4_ zero_nata u o shows_nl)))))))
  | check_qsteps (A1_, A2_) (B1_, B2_, B3_, B4_) nf nfs p ra
    ((uu, (r, (true, t))) :: prts) s u =
    bindb (check_rqrstep (A1_, A2_) (B1_, B2_, B3_, B4_) nf nfs p r s t)
      (fn _ =>
        check_qsteps (A1_, A2_) (B1_, B2_, B3_, B4_) nf nfs p ra prts t u)
  | check_qsteps (A1_, A2_) (B1_, B2_, B3_, B4_) nf nfs pa ra
    ((p, (r, (false, t))) :: prts) s u =
    bindb (check_qrstep (A1_, A2_) (B1_, B2_, B3_, B4_) nf nfs ra p r s t)
      (fn _ =>
        check_qsteps (A1_, A2_) (B1_, B2_, B3_, B4_) nf nfs pa ra prts t u);

fun check_qrsteps (A1_, A2_) (B1_, B2_, B3_, B4_) nf nfs r prts s u =
  check_qsteps (A1_, A2_) (B1_, B2_, B3_, B4_) nf nfs [] r
    (map (fn (p, (ra, t)) => (p, (ra, (false, t)))) prts) s u;

fun check_qrstep_subst (A1_, A2_) (B1_, B2_, B3_, B4_) cni nfs =
  let
    val main =
      check_prop_rstep (A1_, A2_) (B1_, B2_, B3_, B4_) nfs
        (fn t =>
          catch_errora (cni t)
            (fn _ =>
              Inl (shows_prec_term A2_ B4_ zero_nata t o
                    shows_prec_list show_char zero_nata
                      [#" ", #"m", #"u", #" ", #"^", #"^", #" ", #"i", #" ",
                        #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"i", #"n",
                        #" ", #"Q", #"-", #"n", #"o", #"r", #"m", #"a", #"l",
                        #" ", #"f", #"o", #"r", #"m", #" ", #"f", #"o", #"r",
                        #" ", #"a", #"l", #"l", #" ", #"i"])));
  in
    (fn r => fn p => fn ra => fn s => fn t =>
      bindb (check (not (is_Var (fst ra)))
              (shows_prec_list show_char zero_nata
                [#"l", #"o", #"o", #"p", #" ", #"c", #"h", #"e", #"c", #"k",
                  #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"s", #" ",
                  #"l", #"h", #"s", #"s", #" ", #"t", #"o", #" ", #"b", #"e",
                  #" ", #"n", #"o", #"n", #"-", #"v", #"a", #"r", #"i", #"a",
                  #"b", #"l", #"e"]))
        (fn _ => main r p ra s t))
  end;

fun check_rqrstep_subst (A1_, A2_) (B1_, B2_, B3_, B4_) cni nfs =
  (fn r => check_qrstep_subst (A1_, A2_) (B1_, B2_, B3_, B4_) cni nfs r Empty);

fun check_qsteps_subst (A1_, A2_) (B1_, B2_, B3_, B4_) cni nfs p r [] s u =
  check (equal_terma A1_ B2_ s u)
    (shows_string
       [#"t", #"h", #"e", #" ", #"l", #"a", #"s", #"t", #" ", #"t", #"e", #"r",
         #"m", #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"r", #"e", #"w",
         #"r", #"i", #"t", #"e", #" ", #"s", #"e", #"q", #"u", #"e", #"n", #"c",
         #"e"] o
      (shows_nl o
        (shows_prec_term A2_ B4_ zero_nata s o
          (shows_nl o
            (shows_string
               [#"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"c",
                 #"o", #"r", #"r", #"e", #"s", #"p", #"o", #"n", #"d", #" ",
                 #"t", #"o", #" ", #"t", #"h", #"e", #" ", #"g", #"o", #"a",
                 #"l", #" ", #"t", #"e", #"r", #"m"] o
              (shows_nl o (shows_prec_term A2_ B4_ zero_nata u o shows_nl)))))))
  | check_qsteps_subst (A1_, A2_) (B1_, B2_, B3_, B4_) cni nfs p ra
    ((uu, (r, (true, t))) :: prts) s u =
    bindb (check_rqrstep_subst (A1_, A2_) (B1_, B2_, B3_, B4_) cni nfs p r s t)
      (fn _ =>
        check_qsteps_subst (A1_, A2_) (B1_, B2_, B3_, B4_) cni nfs p ra prts t
          u)
  | check_qsteps_subst (A1_, A2_) (B1_, B2_, B3_, B4_) cni nfs pa ra
    ((p, (r, (false, t))) :: prts) s u =
    bindb (check_qrstep_subst (A1_, A2_) (B1_, B2_, B3_, B4_) cni nfs ra p r s
            t)
      (fn _ =>
        check_qsteps_subst (A1_, A2_) (B1_, B2_, B3_, B4_) cni nfs pa ra prts t
          u);

fun check_qrsteps_subst (A1_, A2_) (B1_, B2_, B3_, B4_) cni nfs r prts s u =
  check_qsteps_subst (A1_, A2_) (B1_, B2_, B3_, B4_) cni nfs [] r
    (map (fn (p, (ra, t)) => (p, (ra, (false, t)))) prts) s u;

fun si_subst xa = fst (rep_subst_incr xa);

fun match_prob_of_rp_impl A_ B_ mu (t, Var x) = [(t, Var x)]
  | match_prob_of_rp_impl A_ B_ mu (t, Fun (v, va)) =
    let
      val sterms =
        remdups (equal_term A_ B_) (t :: map (si_subst mu) (si_W mu t));
      val uterms =
        maps (filtera (fn ta => not (is_Var ta)) o supteq_list) sterms;
    in
      map (fn u => (u, Fun (v, va))) (remdups (equal_term A_ B_) uterms)
    end;

fun si_v_incr xa = fst (snd (rep_subst_incr xa));

fun simplify_mp A_ (B1_, B2_) mu_incr ((Var x, Fun (f, ls)) :: mp) solved =
  bind (guarda (member (B1_, B2_) x (si_v_incr mu_incr)))
    (fn _ =>
      let
        val m = map (fn (s, a) => (subst_apply_term s (si_subst mu_incr), a));
      in
        bind (simplify_mp A_ (B1_, B2_) mu_incr (m ((Var x, Fun (f, ls)) :: mp))
               (m solved))
          (fn (smp, i) => SOME (smp, suc i))
      end)
  | simplify_mp A_ (B1_, B2_) mu_incr ((Fun (g, ts), Fun (f, ls)) :: mp) solved
    = bind (guarda (eq A_ f g))
        (fn _ =>
          bind (zip_option ts ls)
            (fn pairs => simplify_mp A_ (B1_, B2_) mu_incr (pairs @ mp) solved))
  | simplify_mp A_ (B1_, B2_) mu_incr ((s, Var x) :: mp) solved =
    simplify_mp A_ (B1_, B2_) mu_incr mp ((s, Var x) :: solved)
  | simplify_mp A_ (B1_, B2_) mu_incr [] solved = SOME (solved, zero_nata);

fun conflicts A_ B_ mu (Fun (f, ts), (Fun (g, ss), n)) =
  (if eq B_ f g andalso equal_nata (size_list ts) (size_list ss)
    then maps (fn (s, t) => conflicts A_ B_ mu (s, (t, n))) (zip ts ss)
    else [(Fun (f, ts), (Fun (g, ss), n))])
  | conflicts A_ B_ mu (Var x, (Fun (g, ss), n)) = [(Var x, (Fun (g, ss), n))]
  | conflicts A_ B_ mu (Fun (f, ts), (Var y, n)) =
    (if equal_nata n zero_nata then [(Var y, (Fun (f, ts), zero_nata))]
      else conflicts A_ B_ mu (Fun (f, ts), (mu y, minus_nata n one_nata)))
  | conflicts A_ B_ mu (Var x, (Var y, n)) =
    (if equal_nata n zero_nata
      then (if eq A_ x y then [] else [(Var x, (Var y, zero_nata))])
      else conflicts A_ B_ mu (Var x, (mu y, minus_nata n one_nata)));

fun ident_solvea (A1_, A2_) (B1_, B2_) mu_incr cps st =
  let
    val cp = conflicts B2_ A2_ (si_subst mu_incr) st;
  in
    (if list_ex (fn (u, (_, _)) => not (is_Var u)) cp then NONE
      else (if list_ex
                 (fn (u, (v, _)) =>
                   member
                     (ceq_prod (ceq_term A2_ B2_) (ceq_term A2_ B2_),
                       ccompare_prod (ccompare_term A1_ B1_)
                         (ccompare_term A1_ B1_))
                     (u, v)
                     (image
                       (ceq_prod (ceq_term A2_ B2_)
                          (ceq_prod (ceq_term A2_ B2_) ceq_nat),
                         ccompare_prod (ccompare_term A1_ B1_)
                           (ccompare_prod (ccompare_term A1_ B1_) ccompare_nat))
                       (ceq_prod (ceq_term A2_ B2_) (ceq_term A2_ B2_),
                         ccompare_prod (ccompare_term A1_ B1_)
                           (ccompare_term A1_ B1_),
                         set_impl_prod set_impl_term set_impl_term)
                       (fn (ua, (va, _)) => (ua, va)) cps))
                 cp
             then NONE
             else bind (mapMa
                         (fn (u, (v, m)) =>
                           ident_solvea (A1_, A2_) (B1_, B2_) mu_incr
                             (inserta
                               (ceq_prod (ceq_term A2_ B2_)
                                  (ceq_prod (ceq_term A2_ B2_) ceq_nat),
                                 ccompare_prod (ccompare_term A1_ B1_)
                                   (ccompare_prod (ccompare_term A1_ B1_)
                                     ccompare_nat))
                               (u, (v, m)) cps)
                             (subst_apply_term u (si_subst mu_incr),
                               (v, suc m)))
                         (conflicts B2_ A2_ (si_subst mu_incr) st))
                    (fn is => SOME (max_list (map suc is)))))
  end;

fun ident_solve (A1_, A2_) (B1_, B2_) mu_incr =
  (fn (s, t) =>
    ident_solvea (A1_, A2_) (B1_, B2_) mu_incr
      (set_empty
        (ceq_prod (ceq_term A2_ B2_) (ceq_prod (ceq_term A2_ B2_) ceq_nat),
          ccompare_prod (ccompare_term A1_ B1_)
            (ccompare_prod (ccompare_term A1_ B1_) ccompare_nat))
        (of_phantom
          (set_impl_proda set_impl_term
            (set_impl_prod set_impl_term set_impl_nat))))
      (s, (t, zero_nata)));

fun ident_decision (A1_, A2_) (B1_, B2_) sigma ip =
  not (is_none (ident_solve (A1_, A2_) (B1_, B2_) sigma ip));

fun ident_prob_of_smp A_ B_ [] = []
  | ident_prob_of_smp A_ B_ ((t, l) :: other) =
    map_filter
      (fn x =>
        (if let
              val (_, s) = x;
            in
              equal_terma A_ B_ s l
            end
          then SOME let
                      val (s, _) = x;
                    in
                      (t, s)
                    end
          else NONE))
      other @
      ident_prob_of_smp A_ B_ other;

fun gmatch_decision (A1_, A2_) (B1_, B2_, B3_, B4_) sigma mp =
  not (is_none
        (bind (simplify_mp A2_ (B1_, B2_) sigma mp [])
          (fn (smp, _) =>
            guarda
              (list_all (ident_decision (A1_, A2_) (B3_, B4_) sigma)
                (ident_prob_of_smp A2_ B4_ smp)))));

fun match_decision (A1_, A2_) (B1_, B2_, B3_, B4_) mu mp =
  gmatch_decision (A1_, A2_) (B1_, B2_, B3_, B4_) mu [mp];

fun redex_decision (A1_, A2_) (B1_, B2_, B3_, B4_) mu rp =
  list_ex (match_decision (A1_, A2_) (B1_, B2_, B3_, B4_) mu)
    (match_prob_of_rp_impl A2_ B4_ mu rp);

fun new_as p bs asa = filtera (fn a => list_ex (fn b => p b a) bs) asa;

fun list_diff A_ [] ys = []
  | list_diff A_ (x :: xs) ys = let
                                  val zs = list_diff A_ xs ys;
                                in
                                  (if membera A_ ys x then zs else x :: zs)
                                end;

fun the_set_impl_main A_ B_ p q remain have bs =
  let
    val new = new_as p bs remain;
  in
    (if null new then have
      else the_set_impl_main A_ B_ p q (list_diff B_ remain new) (new @ have)
             (remdups A_ (maps q new)))
  end;

fun the_set_impl A_ B_ r p q bs = the_set_impl_main B_ A_ p q r [] bs;

fun inductive_set_impl A_ B_ = the_set_impl A_ B_;

fun v_incr_impl A_ B_ mu =
  inductive_set_impl A_ A_ (map fst mu) (eq A_)
    (fn x =>
      maps (fn (y, t) => (if equal_terma B_ A_ t (Var x) then [y] else [])) mu)
    (maps (fn (y, t) => (if not (is_Var t) then [y] else [])) mu);

fun rtrancl_impl gen_succ un memb emp rel =
  let
    val succ = gen_succ rel;
    val n = size_list rel;
  in
    (fn asa => relpow_impl succ un memb asa emp n)
  end;

fun rtrancl_list_impl A_ =
  rtrancl_impl
    (fn r => fn asa =>
      remdups A_
        (map_filter
          (fn x => (if let
                         val (a, _) = x;
                       in
                         membera A_ asa a
                       end
                     then SOME (snd x) else NONE))
          r))
    (fn xs => fn ys => filtera (fn x => not (membera A_ ys x)) xs @ ys)
    (fn x => fn xs => membera A_ xs x) [];

fun w_impl A_ d =
  let
    val filt = filtera (fn (x, y) => not (eq A_ x y));
    val xvs = maps (fn (x, t) => map (fn a => (x, a)) (vars_term_list t)) d;
    val rel = filt xvs;
    val rtran = rtrancl_list_impl A_ rel;
  in
    (fn t => rtran (vars_term_list t))
  end;

fun subst_incr (A1_, A2_, A3_, A4_) B_ xa =
  Abs_subst_incr
    let
      val dom = mk_subst_domain A3_ B_ xa;
    in
      (mk_subst A3_ Var xa,
        (set (A1_, A2_, A4_) (v_incr_impl A3_ B_ dom), w_impl A3_ dom))
    end;

fun redex_rps_decision (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) mu =
  let
    val mua = subst_incr (A1_, A2_, A4_, A5_) B2_ mu;
    val main = redex_decision (B1_, B2_) (A1_, A2_, A3_, A4_) mua;
  in
    (fn xs =>
      catch_errora (forallM (fn tl => check (not (main tl)) tl) xs)
        (fn x => Inl (snd x)))
  end;

fun check_NF_iteration (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) mu =
  let
    val dec = redex_rps_decision (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) mu;
  in
    (fn q => fn t => dec (map (fn a => (t, a)) q))
  end;

fun check_loop (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) q nfs s rseq
  sigma c r =
  bindb (check (not (null rseq))
          (shows_prec_list show_char zero_nata
            [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s", #"e", #"q",
              #"u", #"e", #"n", #"c", #"e", #" ", #"m", #"u", #"s", #"t", #" ",
              #"b", #"e", #" ", #"n", #"o", #"n", #"-", #"e", #"m", #"p", #"t",
              #"y"]))
    (fn _ =>
      (if null q
        then check_qrsteps (A2_, A3_) (B2_, B4_, B5_, B7_) (fn _ => true) nfs r
               rseq s
               (ctxt_apply_term c (subst_apply_term s (mk_subst B4_ Var sigma)))
        else check_qrsteps_subst (A2_, A3_) (B2_, B4_, B5_, B7_)
               (check_NF_iteration (B1_, B2_, B3_, B4_, B6_) (A1_, A2_) sigma q)
               nfs r rseq s
               (ctxt_apply_term c
                 (subst_apply_term s (mk_subst B4_ Var sigma)))));

fun min_list A_ [x] = x
  | min_list A_ (x :: v :: va) =
    min ((ord_preorder o preorder_order o order_linorder) A_) x
      (min_list A_ (v :: va));

fun delete_value A_ B_ key v m =
  (case key v of NONE => m
    | SOME k =>
      (case lookup B_ m k of NONE => m
        | SOME vs => insert B_ k (removeAll A_ v vs) m));

fun check_ge_v A_ v p =
  (case p of [] => true
    | [(m, c)] =>
      equal_monoma (equal_nat, linorder_nat) m (one_monom linorder_nat) andalso
        less_eq
          ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
             ordered_ab_semigroup_ordered_semiring_0 o
             ordered_semiring_0_ordered_semiring_1 o
             ordered_semiring_1_poly_carrier)
            A_)
          c v
    | (_, _) :: _ :: _ => false);

fun check_poly_weak_anti_mono_discrete (A1_, A2_) (B1_, B2_) p v =
  check_poly_ge (A1_, A2_)
    ((ordered_semiring_0_ordered_semiring_1 o ordered_semiring_1_poly_carrier)
      B2_)
    p (poly_subst A2_ (A1_, A2_) (B1_, comm_semiring_1_poly_carrier B2_)
        (fn w =>
          poly_of (A1_, A2_) (B1_, comm_semiring_1_poly_carrier B2_)
            (if eq A1_ w v
              then PSum [PNum (onea ((one_numeral o numeral_semiring_numeral o
                                       semiring_numeral_semiring_1 o
                                       semiring_1_comm_semiring_1 o
                                       comm_semiring_1_poly_carrier)
                                      B2_)),
                          PVar v]
              else PVar w))
        p);

fun monom_vars (A1_, A2_, A3_, A4_) m =
  set (A1_, A2_, A4_) (monom_vars_list A3_ m);

fun check_poly_weak_anti_mono (A1_, A2_, A3_, A4_) B_ p v =
  list_all
    (fn (m, c) =>
      less_eq
        ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
           ordered_ab_semigroup_ordered_semiring_0)
          B_)
        c (zerob
            ((zero_mult_zero o mult_zero_semiring_0 o
               semiring_0_ordered_semiring_0a)
              B_)) orelse
        not (member (A1_, A2_) v (monom_vars (A1_, A2_, A3_, A4_) m)))
    p;

fun check_poly_weak_anti_mono_smart (A1_, A2_, A3_, A4_, A5_) (B1_, B2_)
  discrete =
  (if discrete then check_poly_weak_anti_mono_discrete (A3_, A4_) (B1_, B2_)
    else check_poly_weak_anti_mono (A1_, A2_, A4_, A5_)
           ((ordered_semiring_0_ordered_semiring_1 o
              ordered_semiring_1_poly_carrier)
             B2_));

fun check_poly_weak_mono_discrete (A1_, A2_) (B1_, B2_) p v =
  check_poly_ge (A1_, A2_)
    ((ordered_semiring_0_ordered_semiring_1 o ordered_semiring_1_poly_carrier)
      B2_)
    (poly_subst A2_ (A1_, A2_) (B1_, comm_semiring_1_poly_carrier B2_)
      (fn w =>
        poly_of (A1_, A2_) (B1_, comm_semiring_1_poly_carrier B2_)
          (if eq A1_ w v
            then PSum [PNum (onea ((one_numeral o numeral_semiring_numeral o
                                     semiring_numeral_semiring_1 o
                                     semiring_1_comm_semiring_1 o
                                     comm_semiring_1_poly_carrier)
                                    B2_)),
                        PVar v]
            else PVar w))
      p)
    p;

fun check_poly_weak_mono (A1_, A2_, A3_, A4_) B_ p v =
  list_all
    (fn (m, c) =>
      less_eq
        ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
           ordered_ab_semigroup_ordered_semiring_0)
          B_)
        (zerob
          ((zero_mult_zero o mult_zero_semiring_0 o
             semiring_0_ordered_semiring_0a)
            B_))
        c orelse
        not (member (A1_, A2_) v (monom_vars (A1_, A2_, A3_, A4_) m)))
    p;

fun check_poly_weak_mono_smart (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) discrete =
  (if discrete then check_poly_weak_mono_discrete (A3_, A4_) (B1_, B2_)
    else check_poly_weak_mono (A1_, A2_, A4_, A5_)
           ((ordered_semiring_0_ordered_semiring_1 o
              ordered_semiring_1_poly_carrier)
             B2_));

fun fun_of_map_fun m d a = (case m a of NONE => d a | SOME b => b);

fun g_list_to_map_rm_basic_ops A_ l =
  foldl (fn m => fn (k, v) => insert A_ k v m)
    (empty (linorder_compare_order A_)) (rev l);

fun ceta_map_of A_ ps =
  lookup (compare_order_key A_)
    (g_list_to_map_rm_basic_ops (compare_order_key A_) ps);

fun poly_inter_list_to_inter A_ B_ def i =
  fun_of_map_fun (ceta_map_of (key_prod B_ key_nat) i)
    (fn fna => default_I A_ def (snd fna));

fun fun_of_map_funa m d f a = (case m a of NONE => d a | SOME aa => f aa);

fun create_dep (A1_, A2_) (B1_, B2_) discrete def i =
  let
    val fs = remdups (equal_prod B1_ equal_nat) (map fst i);
    val ii = poly_inter_list_to_inter A2_ B2_ def i;
    val fsres =
      map (fn fna =>
            let
              val p = ii fna;
              val vars = poly_vars_list (equal_nat, linorder_nat) p;
              val is = upt zero_nata (snd fna);
              val a =
                map (fn ia =>
                      (if membera equal_nat vars ia
                        then (if check_poly_weak_mono_smart
                                   (ceq_nat, ccompare_nat, equal_nat,
                                     linorder_nat, set_impl_nat)
                                   (A1_, A2_) discrete p ia
                               then Increase
                               else (if check_poly_weak_anti_mono_smart
  (ceq_nat, ccompare_nat, equal_nat, linorder_nat, set_impl_nat) (A1_, A2_)
  discrete p ia
                                      then Decrease else Wild))
                        else Ignore))
                  is;
            in
              (fna, a)
            end)
        fs;
    val iii =
      fun_of_map_funa (ceta_map_of (key_prod B2_ key_nat) fsres)
        (fn _ => fn _ => Increase) nth;
  in
    iii
  end;

fun eval_monom_list A_ B_ alpha [] =
  onea ((one_numeral o numeral_semiring_numeral o semiring_numeral_semiring_1 o
          semiring_1_comm_semiring_1)
         B_)
  | eval_monom_list A_ B_ alpha ((x, p) :: m) =
    times ((times_dvd o dvd_comm_monoid_mult o comm_monoid_mult_comm_semiring_1)
            B_)
      (eval_monom_list A_ B_ alpha m)
      (binary_power
        ((monoid_mult_semiring_numeral o semiring_numeral_semiring_1 o
           semiring_1_comm_semiring_1)
          B_)
        (alpha x) p);

fun eval_monom A_ B_ x xc = eval_monom_list A_ B_ x (rep_monom A_ xc);

fun eval_poly A_ B_ alpha [] =
  zerob ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1)
          B_)
  | eval_poly A_ B_ alpha (mc :: p) =
    plus ((plus_semigroup_add o semigroup_add_numeral o
            numeral_semiring_numeral o semiring_numeral_semiring_1 o
            semiring_1_comm_semiring_1)
           B_)
      (times
        ((times_dvd o dvd_comm_monoid_mult o comm_monoid_mult_comm_semiring_1)
          B_)
        (eval_monom A_ B_ alpha (fst mc)) (snd mc))
      (eval_poly A_ B_ alpha p);

fun poly_vars (A1_, A2_, A3_, A4_) p =
  set (A1_, A2_, A4_) (maps (monom_vars_list A3_ o fst) p);

fun max_list_non_empty A_ [x] = x
  | max_list_non_empty A_ (x :: v :: va) =
    max ((ord_preorder o preorder_order o order_linorder) A_) x
      (max_list_non_empty A_ (v :: va));

fun div_ceiling x y =
  let
    val q = divide_inta x y;
  in
    (if equal_inta (times_inta q y) x then q else plus_inta q one_inta)
  end;

fun root_bound p =
  let
    val n = degreea zero_int p;
    val m =
      plus_inta one_inta
        (div_ceiling
          (max_list_non_empty linorder_int
            (map (fn i => abs_inta (coeff zero_int p i)) (upt zero_nata n)))
          (abs_inta (coeff zero_int p (degreea zero_int p))));
  in
    of_int
      (binary_power monoid_mult_int (Int_of_integer (2 : IntInf.int))
        (log_ceiling (Int_of_integer (2 : IntInf.int)) m))
  end;

fun real_alg_2b ri p l r =
  let
    val (pa, (la, ra)) =
      normalize_bounds_1
        let
          val (la, (ra, _)) =
            tighten_poly_bounds_for_x p zero_rata l r
              (sgn_rata
                (fold_coeffs zero_int
                  (fn a => fn b => plus_rata (of_int a) (times_rata r b)) p
                  zero_rata));
        in
          (p, (la, ra))
        end;
  in
    Irrational (number_root ri ra, (pa, (la, ra)))
  end;

fun roots_of_2_main p ri cr lrs rais =
  (case lrs of [] => rais
    | (l, r) :: lrsa =>
      let
        val c = cr l r;
      in
        (if equal_nata c zero_nata then roots_of_2_main p ri cr lrsa rais
          else (if equal_nata c one_nata
                 then roots_of_2_main p ri cr lrsa
                        (real_alg_2b ri p l r :: rais)
                 else let
                        val m =
                          divide_rata (plus_rata l r)
                            (of_int (Int_of_integer (2 : IntInf.int)));
                      in
                        roots_of_2_main p ri cr ((m, r) :: (l, m) :: lrsa) rais
                      end))
      end);

fun roots_of_2_irr p =
  (if equal_nata (degreea zero_int p) one_nata
    then [Rationala
            (fract
              (uminus_inta
                (case coeffs zero_int p of [] => zero_inta | x :: _ => x))
              (coeff zero_int p one_nata))]
    else let
           val ri = root_info p;
           val cr = l_r ri;
           val b = root_bound p;
         in
           roots_of_2_main p ri cr [(uminus_rata b, b)] []
         end);

fun roots_of_2 p = maps roots_of_2_irr (factors_of_int_poly p);

fun rep_real_alg_2_list (Abs_real_alg_2_list x) = x;

fun real_alg_2_list_nil xa =
  (case rep_real_alg_2_list xa of [] => true | _ :: _ => false);

fun real_alg_2_list_tl xa = Abs_real_alg_2_list (tla (rep_real_alg_2_list xa));

fun real_alg_2_list_hd_intern (x :: xs) = x
  | real_alg_2_list_hd_intern [] = Rationala zero_rata;

fun real_alg_2_list_hd xa =
  Real_Alg_Invariant (real_alg_2_list_hd_intern (rep_real_alg_2_list xa));

fun real_alg_2_list_convert xs =
  (if real_alg_2_list_nil xs then []
    else real_alg_2_list_hd xs ::
           real_alg_2_list_convert (real_alg_2_list_tl xs));

fun roots_of_2_list xa = Abs_real_alg_2_list (roots_of_2 xa);

fun roots_of_3_impl p = real_alg_2_list_convert (roots_of_2_list p);

fun roots_of_3 p = roots_of_3_impl p;

fun enfc_q A_ isQnf isRnf r q s (Var x) = true
  | enfc_q A_ isQnf isRnf r q s (Fun (f, ts)) =
    list_all
      (fn qa =>
        (case mgu_class A_ (Fun (f, map (icap_impl A_ isQnf r s) ts)) qa
          of NONE => true
          | SOME mu =>
            not (list_all
                   (fn u =>
                     isQnf (subst_apply_term
                             (map_term (fn x => x) (fn a => #"x" :: a) u) mu))
                   s andalso
                  isRnf (subst_apply_term
                          (map_term (fn x => x) (fn a => #"y" :: a) qa) mu))))
      q;

fun delete_values A_ B_ uu [] m = m
  | delete_values A_ B_ key (v :: vs) m =
    delete_value A_ B_ key v (delete_values A_ B_ key vs m);

fun delete_rules A_ (B1_, B2_) C_ a rs =
  delete_values
    (equal_prod A_ (equal_prod (equal_term B2_ C_) (equal_term B2_ C_)))
    (compare_order_prod B1_ compare_order_nat) key (map (fn b => (a, b)) rs);

fun split_rulesc
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = split_rules;

fun split_pairsa
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = split_pairs;

fun delete_R_Rwc
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = delete_R_Rw;

fun delete_P_Pwa
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = delete_P_Pw;

fun minimal
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = minimal;

fun nfsc
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = nfs;

fun mkd
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = mk;

fun qc
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = q;

fun split_proc B_ C_ i d p_remove r_remove =
  let
    val (p, pw) = split_pairsa i d p_remove;
    val (r, rw) = split_rulesc i d r_remove;
    val dpp1 = mkd i (nfsc i d) (minimal i d) p pw (qc i d) r rw;
    val a =
      delete_R_Rwc i (delete_P_Pwa i d p_remove p_remove) r_remove r_remove;
  in
    (dpp1, a)
  end;

fun rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option
  (Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option x) = x;

fun sel21 xa =
  Abs_status
    (case rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option xa
      of NONE => status (raise Fail "undefined") | SOME x2 => x2);

fun dis1 xa =
  (case rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option xa
    of NONE => true | SOME _ => false);

fun rep_isom x = (if dis1 x then NONE else SOME (sel21 x));

fun status_of_aux A_ xa =
  Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option
    (if list_all
          (fn fidx => list_all (fn i => less_nat i (snd (fst fidx))) (snd fidx))
          xa
      then SOME (fun_of_map_fun (map_of (equal_prod A_ equal_nat) xa)
                  (fn (_, a) => upt zero_nata a))
      else NONE);

fun status_of A_ x = rep_isom (status_of_aux A_ x);

fun subst_apply_ctxt Hole sigma = Hole
  | subst_apply_ctxt (More (f, ss1, d, ss2)) sigma =
    More (f, map (fn t => subst_apply_term t sigma) ss1,
           subst_apply_ctxt d sigma,
           map (fn t => subst_apply_term t sigma) ss2);

fun shows_ctxt funa var Hole = shows_string [#"[", #"]"]
  | shows_ctxt funa var (More (f, ss1, d, ss2)) =
    funa f o
      (shows_string [#"("] o
        (shows_list_gen (shows_term funa var) [] [] [#",", #" "] [#",", #" "]
           ss1 o
          (shows_ctxt funa var d o
            shows_list_gen (shows_term funa var) [#")"] [#",", #" "]
              [#",", #" "] [#")"] ss2)));

fun r_states (A1_, A2_, A3_) =
  (fn ta_rule =>
    inserta (A1_, A2_) (r_rhs ta_rule)
      (set (A1_, A2_, A3_) (r_lhs_states ta_rule)));

fun ta_states (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) ta =
  sup_seta (A3_, ccompare_cproper_interval A4_)
    (sup_seta (A3_, ccompare_cproper_interval A4_)
      (sup_setb (A1_, A2_, A3_, A4_, A6_)
        (image
          (ceq_ta_rule A5_ B2_,
            ccompare_ta_rule (ccompare_cproper_interval A4_) B1_)
          (ceq_set (A2_, A3_, ccompare_cproper_interval A4_),
            ccompare_set (A1_, A3_, A4_, A6_), set_impl_set)
          (r_states (A3_, ccompare_cproper_interval A4_, A6_)) (ta_rules ta)))
      (sup_setb (A1_, A2_, A3_, A4_, A6_)
        (image
          (ceq_prod A3_ A3_,
            ccompare_prod (ccompare_cproper_interval A4_)
              (ccompare_cproper_interval A4_))
          (ceq_set (A2_, A3_, ccompare_cproper_interval A4_),
            ccompare_set (A1_, A3_, A4_, A6_), set_impl_set)
          (fn (q, qa) =>
            inserta (A3_, ccompare_cproper_interval A4_) q
              (inserta (A3_, ccompare_cproper_interval A4_) qa
                (bot_set (A3_, ccompare_cproper_interval A4_, A6_))))
          (ta_eps ta))))
    (ta_final ta);

fun prod_ta (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_, B4_)
  (C1_, C2_, C3_, C4_, C5_, C6_) tA1 tA2 f =
  Ta_ext
    (f, image (ceq_prod (ceq_ta_rule A5_ B3_) (ceq_ta_rule C5_ B3_),
                ccompare_prod
                  (ccompare_ta_rule (ccompare_cproper_interval A4_) B2_)
                  (ccompare_ta_rule (ccompare_cproper_interval C4_) B2_))
          (ceq_ta_rule (equal_prod A5_ C5_) B3_,
            ccompare_ta_rule
              (ccompare_prod (ccompare_cproper_interval A4_)
                (ccompare_cproper_interval C4_))
              B2_,
            set_impl_ta_rule)
          (fn (TA_rule (fa, qs1, q1), TA_rule (_, qs2, q2)) =>
            TA_rule (fa, zip qs1 qs2, (q1, q2)))
          (sup_setb
            (finite_UNIV_prod finite_UNIV_ta_rule finite_UNIV_ta_rule,
              cenum_prod cenum_ta_rule cenum_ta_rule,
              ceq_prod (ceq_ta_rule A5_ B3_) (ceq_ta_rule C5_ B3_),
              cproper_interval_prod
                (cproper_interval_ta_rule (ccompare_cproper_interval A4_) B2_)
                (cproper_interval_ta_rule (ccompare_cproper_interval C4_) B2_),
              set_impl_prod set_impl_ta_rule set_impl_ta_rule)
            (image (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat)
              (ceq_set
                 (cenum_prod cenum_ta_rule cenum_ta_rule,
                   ceq_prod (ceq_ta_rule A5_ B3_) (ceq_ta_rule C5_ B3_),
                   ccompare_cproper_interval
                     (cproper_interval_prod
                       (cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                         B2_)
                       (cproper_interval_ta_rule (ccompare_cproper_interval C4_)
                         B2_))),
                ccompare_set
                  (finite_UNIV_prod finite_UNIV_ta_rule finite_UNIV_ta_rule,
                    ceq_prod (ceq_ta_rule A5_ B3_) (ceq_ta_rule C5_ B3_),
                    cproper_interval_prod
                      (cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                        B2_)
                      (cproper_interval_ta_rule (ccompare_cproper_interval C4_)
                        B2_),
                    set_impl_prod set_impl_ta_rule set_impl_ta_rule),
                set_impl_set)
              (fn fa =>
                productc
                  (ceq_ta_rule A5_ B3_,
                    ccompare_ta_rule (ccompare_cproper_interval A4_) B2_,
                    set_impl_ta_rule)
                  (ceq_ta_rule C5_ B3_,
                    ccompare_ta_rule (ccompare_cproper_interval C4_) B2_,
                    set_impl_ta_rule)
                  (filter
                    (ceq_ta_rule A5_ B3_,
                      ccompare_ta_rule (ccompare_cproper_interval A4_) B2_)
                    (fn r => equal_proda B3_ equal_nat (r_sym r) fa)
                    (ta_rules tA1))
                  (filter
                    (ceq_ta_rule C5_ B3_,
                      ccompare_ta_rule (ccompare_cproper_interval C4_) B2_)
                    (fn r => equal_proda B3_ equal_nat (r_sym r) fa)
                    (ta_rules tA2)))
              (ta_syms (ccompare_cproper_interval A4_, A5_) (B1_, B2_, B3_, B4_)
                tA1))),
      sup_seta
        (ceq_prod (ceq_prod A3_ C3_) (ceq_prod A3_ C3_),
          ccompare_prod
            (ccompare_prod (ccompare_cproper_interval A4_)
              (ccompare_cproper_interval C4_))
            (ccompare_prod (ccompare_cproper_interval A4_)
              (ccompare_cproper_interval C4_)))
        (image
          (ceq_prod (ceq_prod A3_ A3_) C3_,
            ccompare_prod
              (ccompare_prod (ccompare_cproper_interval A4_)
                (ccompare_cproper_interval A4_))
              (ccompare_cproper_interval C4_))
          (ceq_prod (ceq_prod A3_ C3_) (ceq_prod A3_ C3_),
            ccompare_prod
              (ccompare_prod (ccompare_cproper_interval A4_)
                (ccompare_cproper_interval C4_))
              (ccompare_prod (ccompare_cproper_interval A4_)
                (ccompare_cproper_interval C4_)),
            set_impl_prod (set_impl_prod A6_ C6_) (set_impl_prod A6_ C6_))
          (fn (a, b) => let
                          val (q, qa) = a;
                        in
                          (fn p => ((q, p), (qa, p)))
                        end
                          b)
          (productc
            (ceq_prod A3_ A3_,
              ccompare_prod (ccompare_cproper_interval A4_)
                (ccompare_cproper_interval A4_),
              set_impl_prod A6_ A6_)
            (C3_, ccompare_cproper_interval C4_, C6_) (ta_eps tA1)
            (ta_states (C1_, C2_, C3_, C4_, C5_, C6_) (B2_, B3_) tA2)))
        (image
          (ceq_prod A3_ (ceq_prod C3_ C3_),
            ccompare_prod (ccompare_cproper_interval A4_)
              (ccompare_prod (ccompare_cproper_interval C4_)
                (ccompare_cproper_interval C4_)))
          (ceq_prod (ceq_prod A3_ C3_) (ceq_prod A3_ C3_),
            ccompare_prod
              (ccompare_prod (ccompare_cproper_interval A4_)
                (ccompare_cproper_interval C4_))
              (ccompare_prod (ccompare_cproper_interval A4_)
                (ccompare_cproper_interval C4_)),
            set_impl_prod (set_impl_prod A6_ C6_) (set_impl_prod A6_ C6_))
          (fn (p, (q, qa)) => ((p, q), (p, qa)))
          (productc (A3_, ccompare_cproper_interval A4_, A6_)
            (ceq_prod C3_ C3_,
              ccompare_prod (ccompare_cproper_interval C4_)
                (ccompare_cproper_interval C4_),
              set_impl_prod C6_ C6_)
            (ta_states (A1_, A2_, A3_, A4_, A5_, A6_) (B2_, B3_) tA1)
            (ta_eps tA2))),
      ());

fun productive_relation (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) ta =
  sup_seta
    (ceq_prod A3_ A3_,
      ccompare_prod (ccompare_cproper_interval A4_)
        (ccompare_cproper_interval A4_))
    (image
      (ceq_prod A3_ A3_,
        ccompare_prod (ccompare_cproper_interval A4_)
          (ccompare_cproper_interval A4_))
      (ceq_prod A3_ A3_,
        ccompare_prod (ccompare_cproper_interval A4_)
          (ccompare_cproper_interval A4_),
        set_impl_prod A6_ A6_)
      (fn (a, b) => (b, a)) (ta_eps ta))
    (sup_setb
      (finite_UNIV_prod A1_ A1_, cenum_prod A2_ A2_, ceq_prod A3_ A3_,
        cproper_interval_prod A4_ A4_, set_impl_prod A6_ A6_)
      (image
        (ceq_ta_rule A5_ B2_,
          ccompare_ta_rule (ccompare_cproper_interval A4_) B1_)
        (ceq_set
           (cenum_prod A2_ A2_, ceq_prod A3_ A3_,
             ccompare_cproper_interval (cproper_interval_prod A4_ A4_)),
          ccompare_set
            (finite_UNIV_prod A1_ A1_, ceq_prod A3_ A3_,
              cproper_interval_prod A4_ A4_, set_impl_prod A6_ A6_),
          set_impl_set)
        (fn r =>
          image (A3_, ccompare_cproper_interval A4_)
            (ceq_prod A3_ A3_,
              ccompare_prod (ccompare_cproper_interval A4_)
                (ccompare_cproper_interval A4_),
              set_impl_prod A6_ A6_)
            (fn a => (r_rhs r, a))
            (set (A3_, ccompare_cproper_interval A4_, A6_) (r_lhs_states r)))
        (ta_rules ta)));

fun ta_productive (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) ta =
  sup_seta (A3_, ccompare_cproper_interval A4_) (ta_final ta)
    (compute_trancl (A2_, A3_, ccompare_cproper_interval A4_, A6_) (ta_final ta)
      (productive_relation (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) ta));

fun ta_restrict (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) ta q =
  Ta_ext
    (inf_seta (A2_, A3_) (ta_final ta) q,
      filter (ceq_ta_rule A4_ B2_, ccompare_ta_rule A3_ B1_)
        (fn r => less_eq_set (A1_, A2_, A3_) (r_states (A2_, A3_, A5_) r) q)
        (ta_rules ta),
      inf_seta (ceq_prod A2_ A2_, ccompare_prod A3_ A3_) (ta_eps ta)
        (productc (A2_, A3_, A5_) (A2_, A3_, A5_) q q),
      ());

fun trim_ta (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_) ta =
  ta_restrict (A2_, A3_, ccompare_cproper_interval A4_, A5_, A6_) (B1_, B3_)
    (ta_restrict (A2_, A3_, ccompare_cproper_interval A4_, A5_, A6_) (B1_, B3_)
      ta (ta_reachable (A2_, A3_, ccompare_cproper_interval A4_, A5_, A6_)
           (B1_, B2_, B3_) ta))
    (ta_productive (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B3_)
      (ta_restrict (A2_, A3_, ccompare_cproper_interval A4_, A5_, A6_)
        (B1_, B3_) ta
        (ta_reachable (A2_, A3_, ccompare_cproper_interval A4_, A5_, A6_)
          (B1_, B2_, B3_) ta)));

fun check_varcond_subset A_ (B1_, B2_) r =
  catch_errora
    (forallM
      (fn rule =>
        catch_errora
          (check_subseteq B1_ (insert_vars_term B1_ (snd rule) [])
            (insert_vars_term B1_ (fst rule) []))
          (fn x =>
            Inl (shows_prec_list show_char zero_nata
                   [#"f", #"r", #"e", #"e", #" ", #"v", #"a", #"r", #"i", #"a",
                     #"b", #"l", #"e", #" "] o
                   shows_prec B2_ zero_nata x o
                   shows_prec_list show_char zero_nata
                     [#" ", #"i", #"n", #" ", #"r", #"i", #"g", #"h", #"t",
                       #"-", #"h", #"a", #"n", #"d", #" ", #"s", #"i", #"d",
                       #"e", #" ", #"o", #"f", #" ", #"r", #"u", #"l", #"e",
                       #" "] o
                   shows_rule (shows_prec A_ zero_nata)
                     (shows_prec B2_ zero_nata) [#" ", #"-", #">", #" "] rule o
                  shows_nl)))
      r)
    (fn x => Inl (snd x));

fun check_wf_trs A_ (B1_, B2_) r =
  catch_errora
    (bindb (check_varcond_no_Var_lhs A_ B2_ r)
      (fn _ => check_varcond_subset A_ (B1_, B2_) r))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"t", #"h", #"e", #" ", #"T", #"R", #"S", #" ", #"i", #"s", #" ",
               #"n", #"o", #"t", #" ", #"w", #"e", #"l", #"l", #"-", #"f", #"o",
               #"r", #"m", #"e", #"d"] o
             shows_nl o
            x));

fun defined_list r =
  maps (fn (l, _) => (if not (is_Var l) then [the (root l)] else [])) r;

fun generate_f_xs f n =
  Fun (f, map (fn i => Var (generate_var i)) (upt zero_nata n));

fun num_symbs (Var x) = one_nata
  | num_symbs (Fun (f, ts)) =
    plus_nata (sum_list monoid_add_nat (map num_symbs ts)) one_nata;

fun rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
  A_ (Abs_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
       x)
  = x;

fun sel21b A_ xa =
  Abs_afs
    (case rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
            A_ xa
      of NONE => rep_afs (raise Fail "undefined") | SOME x2 => x2);

fun dis1b A_ xa =
  (case rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
          A_ xa
    of NONE => true | SOME _ => false);

fun rep_isomb A_ x = (if dis1b A_ x then NONE else SOME (sel21b A_ x));

fun default_af_entry n = AFList (upt zero_nata n);

fun wf_af_entry n (Collapse i) = less_nat i n
  | wf_af_entry n (AFList is) = list_all (fn i => less_nat i n) is;

fun afs_of_aux (A1_, A2_, A3_, A4_) xa =
  Abs_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
    (if list_all (fn ((_, n), e) => wf_af_entry n e) xa
      then SOME (fun_of_map_fun (ceta_map_of (key_prod A3_ key_nat) xa)
                   (fn fna => default_af_entry (snd fna)),
                  set (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat,
                        set_impl_prod A4_ set_impl_nat)
                    (map fst xa))
      else NONE);

fun afs_of (A1_, A2_, A3_, A4_) x =
  rep_isomb A3_ (afs_of_aux (A1_, A2_, A3_, A4_) x);

fun ta_bounds_lhs xml2name =
  xml_do [#"l", #"h", #"s"]
    (xml_or (xml_take state (fn a => xml_return (Inr a)))
      (xml_take xml2name
        (fn f =>
          xml_take (xml_nat [#"h", #"e", #"i", #"g", #"h", #"t"])
            (fn h =>
              xml_take_many_sub [] zero_nata Infinity_enat state
                (fn qs => xml_return (Inl ((f, h), qs)))))));

fun bounds_bound x = xml_nat [#"b", #"o", #"u", #"n", #"d"] x;

fun bounds_type x =
  xml_do [#"t", #"y", #"p", #"e"]
    (xml_take
      (xml_or (xml_leaf [#"r", #"o", #"o", #"f"] Roof)
        (xml_leaf [#"m", #"a", #"t", #"c", #"h"] Match))
      (fn xa => xml_return (id xa)))
    x;

fun bounds_info xml2name =
  xml_do [#"b", #"o", #"u", #"n", #"d", #"s"]
    (xml_take bounds_type
      (fn a =>
        xml_take bounds_bound
          (fn b =>
            xml_take final_states
              (fn c =>
                xml_take (tree_automaton (ta_bounds_lhs xml2name))
                  (fn d =>
                    xml_take_default Id_Relation closed_criterion
                      (fn e => xml_return (Bounds_Info (a, b, c, d, e))))))));

fun multiset_af A_ xml2name =
  xml_do
    [#"m", #"u", #"l", #"t", #"i", #"s", #"e", #"t", #"A", #"r", #"g", #"u",
      #"m", #"e", #"n", #"t", #"F", #"i", #"l", #"t", #"e", #"r"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"m", #"u", #"l", #"t", #"i", #"s", #"e", #"t", #"A", #"r", #"g", #"u",
          #"m", #"e", #"n", #"t", #"F", #"i", #"l", #"t", #"e", #"r", #"E",
          #"n", #"t", #"r", #"y"]
        (xml_take xml2name
          (fn f =>
            xml_take (xml_nat [#"a", #"r", #"i", #"t", #"y"])
              (fn a =>
                xml_take
                  (xml_do [#"s", #"t", #"a", #"t", #"u", #"s"]
                    (xml_take_many_sub [] zero_nata Infinity_enat position
                      xml_return))
                  (fn p => xml_return ((f, a), p))))))
      xml_return);

fun word_pattern (A1_, A2_) (B1_, B2_) xml2name =
  xml_do [#"w", #"o", #"r", #"d", #"P", #"a", #"t", #"t", #"e", #"r", #"n"]
    (xml_take (stringa (A1_, A2_) (B1_, B2_) xml2name)
      (fn l =>
        xml_take (stringa (A1_, A2_) (B1_, B2_) xml2name)
          (fn m =>
            xml_take (xml_nat [#"f", #"a", #"c", #"t", #"o", #"r"])
              (fn f =>
                xml_take
                  (xml_nat [#"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t"])
                  (fn c =>
                    xml_take (stringa (A1_, A2_) (B1_, B2_) xml2name)
                      (fn r => xml_return (l, ((f, (c, m)), r))))))));

fun derivation_pattern (A1_, A2_) (B1_, B2_) xml2name =
  xml_do
    [#"d", #"e", #"r", #"i", #"v", #"a", #"t", #"i", #"o", #"n", #"P", #"a",
      #"t", #"t", #"e", #"r", #"n"]
    (xml_take (word_pattern (A1_, A2_) (B1_, B2_) xml2name)
      (fn a =>
        xml_take (word_pattern (A1_, A2_) (B1_, B2_) xml2name)
          (fn b => xml_return (a, b))));

fun derivation_pattern_proof (A1_, A2_) (B1_, B2_) xml2name =
  let
    val oc = oc_srs (A1_, A2_) (B1_, B2_) xml2name;
    val dp = derivation_pattern (A1_, A2_) (B1_, B2_) xml2name;
    val s = stringa (A1_, A2_) (B1_, B2_) xml2name;
  in
    xml_do
      [#"d", #"e", #"r", #"i", #"v", #"a", #"t", #"i", #"o", #"n", #"P", #"a",
        #"t", #"t", #"e", #"r", #"n", #"P", #"r", #"o", #"o", #"f"]
      (xml_take
        (xml_or
          (xml_do [#"O", #"C", #"1"]
            (xml_take oc
              (fn a =>
                xml_take (xml_bool [#"i", #"s", #"P", #"a", #"i", #"r"])
                  (fn b => xml_return (OC1 (a, b))))))
          (xml_or
            (xml_do [#"O", #"C", #"2"]
              (xml_take oc
                (fn a =>
                  xml_take oc
                    (fn b =>
                      xml_take oc
                        (fn c =>
                          xml_take s
                            (fn d =>
                              xml_take s
                                (fn e =>
                                  xml_take s
                                    (fn f =>
                                      xml_return
(OC2 (a, b, c, d, e, f))))))))))
            (xml_or
              (xml_do [#"O", #"C", #"2", #"p", #"r", #"i", #"m", #"e"]
                (xml_take oc
                  (fn a =>
                    xml_take oc
                      (fn b =>
                        xml_take oc
                          (fn c =>
                            xml_take s
                              (fn d =>
                                xml_take s
                                  (fn e =>
                                    xml_take s
                                      (fn f =>
xml_return (OC2p (a, b, c, d, e, f))))))))))
              (xml_or
                (xml_do [#"O", #"C", #"3"]
                  (xml_take oc
                    (fn a =>
                      xml_take oc
                        (fn b =>
                          xml_take oc
                            (fn c =>
                              xml_take s
                                (fn d =>
                                  xml_take s
                                    (fn e =>
                                      xml_return (OC3 (a, b, c, d, e)))))))))
                (xml_or
                  (xml_do [#"O", #"C", #"3", #"p", #"r", #"i", #"m", #"e"]
                    (xml_take oc
                      (fn a =>
                        xml_take oc
                          (fn b =>
                            xml_take oc
                              (fn c =>
                                xml_take s
                                  (fn d =>
                                    xml_take s
                                      (fn e =>
xml_return (OC3p (a, b, c, d, e)))))))))
                  (xml_or
                    (xml_do
                      [#"O", #"C", #"i", #"n", #"t", #"o", #"D", #"P", #"1"]
                      (xml_take dp
                        (fn a =>
                          xml_take oc (fn b => xml_return (OCDP1 (a, b))))))
                    (xml_or
                      (xml_do
                        [#"O", #"C", #"i", #"n", #"t", #"o", #"D", #"P", #"2"]
                        (xml_take dp
                          (fn a =>
                            xml_take oc (fn b => xml_return (OCDP2 (a, b))))))
                      (xml_or
                        (xml_do
                          [#"e", #"q", #"u", #"i", #"v", #"a", #"l", #"e", #"n",
                            #"t"]
                          (xml_take dp
                            (fn a =>
                              xml_take dp (fn b => xml_return (WPEQ (a, b))))))
                        (xml_or
                          (xml_do [#"l", #"i", #"f", #"t"]
                            (xml_take dp
                              (fn a =>
                                xml_take dp
                                  (fn b => xml_return (Lift (a, b))))))
                          (xml_or
                            (xml_do
                              [#"D", #"P", #"_", #"O", #"C", #"_", #"1", #"_",
                                #"1"]
                              (xml_take dp
                                (fn a =>
                                  xml_take dp
                                    (fn b =>
                                      xml_take oc
(fn c =>
  xml_take s
    (fn d => xml_take s (fn e => xml_return (DPOC1_1 (a, b, c, d, e)))))))))
                            (xml_or
                              (xml_do
                                [#"D", #"P", #"_", #"O", #"C", #"_", #"1", #"_",
                                  #"2"]
                                (xml_take dp
                                  (fn a =>
                                    xml_take dp
                                      (fn b =>
xml_take oc
  (fn c =>
    xml_take s
      (fn d =>
        xml_take s
          (fn e =>
            xml_take s (fn f => xml_return (DPOC1_2 (a, b, c, d, e, f))))))))))
                              (xml_or
                                (xml_do
                                  [#"D", #"P", #"_", #"O", #"C", #"_", #"2"]
                                  (xml_take dp
                                    (fn a =>
                                      xml_take dp
(fn b =>
  xml_take oc
    (fn c =>
      xml_take s
        (fn d => xml_take s (fn e => xml_return (DPOC2 (a, b, c, d, e)))))))))
                                (xml_or
                                  (xml_do
                                    [#"D", #"P", #"_", #"O", #"C", #"_", #"3",
                                      #"_", #"1"]
                                    (xml_take dp
                                      (fn a =>
xml_take dp
  (fn b =>
    xml_take oc
      (fn c =>
        xml_take s
          (fn d =>
            xml_take s (fn e => xml_return (DPOC3_1 (a, b, c, d, e)))))))))
                                  (xml_or
                                    (xml_do
                                      [#"D", #"P", #"_", #"O", #"C", #"_", #"3",
#"_", #"2"]
                                      (xml_take dp
(fn a =>
  xml_take dp
    (fn b =>
      xml_take oc
        (fn c =>
          xml_take s
            (fn d =>
              xml_take s
                (fn e =>
                  xml_take s
                    (fn f => xml_return (DPOC3_2 (a, b, c, d, e, f))))))))))
                                    (xml_or
                                      (xml_do
[#"D", #"P", #"_", #"D", #"P", #"_", #"1", #"_", #"1"]
(xml_take dp
  (fn a =>
    xml_take dp
      (fn b =>
        xml_take dp
          (fn c =>
            xml_take s
              (fn d =>
                xml_take s (fn e => xml_return (DPDP1_1 (a, b, c, d, e)))))))))
                                      (xml_or
(xml_do [#"D", #"P", #"_", #"D", #"P", #"_", #"1", #"_", #"2"]
  (xml_take dp
    (fn a =>
      xml_take dp
        (fn b =>
          xml_take dp
            (fn c =>
              xml_take s
                (fn d =>
                  xml_take s
                    (fn e => xml_return (DPDP1_2 (a, b, c, d, e)))))))))
(xml_or
  (xml_do [#"D", #"P", #"_", #"D", #"P", #"_", #"2", #"_", #"1"]
    (xml_take dp
      (fn a =>
        xml_take dp
          (fn b =>
            xml_take dp
              (fn c =>
                xml_take s
                  (fn d =>
                    xml_take s
                      (fn e => xml_return (DPDP2_1 (a, b, c, d, e)))))))))
  (xml_do [#"D", #"P", #"_", #"D", #"P", #"_", #"2", #"_", #"2"]
    (xml_take dp
      (fn a =>
        xml_take dp
          (fn b =>
            xml_take dp
              (fn c =>
                xml_take s
                  (fn d =>
                    xml_take s
                      (fn e =>
                        xml_return
                          (DPDP2_2 (a, b, c, d, e))))))))))))))))))))))))))
        (fn x => xml_return (id x)))
  end;

fun nonloop_srs_reason (A1_, A2_) (B1_, B2_) xml2name =
  xml_or
    (xml_do
      [#"s", #"e", #"l", #"f", #"E", #"m", #"b", #"e", #"d", #"d", #"i", #"n",
        #"g", #"O", #"C"]
      (xml_take (stringa (A1_, A2_) (B1_, B2_) xml2name)
        (fn a =>
          xml_take (stringa (A1_, A2_) (B1_, B2_) xml2name)
            (fn b =>
              xml_take (stringa (A1_, A2_) (B1_, B2_) xml2name)
                (fn c =>
                  xml_return (fn d => SE_OC ((b, a @ b @ c), a, c, d)))))))
    (xml_do
      [#"s", #"e", #"l", #"f", #"E", #"m", #"b", #"e", #"d", #"d", #"i", #"n",
        #"g", #"D", #"P"]
      (xml_take (derivation_pattern (A1_, A2_) (B1_, B2_) xml2name)
        (fn a =>
          xml_take (stringa (A1_, A2_) (B1_, B2_) xml2name)
            (fn b =>
              xml_take (stringa (A1_, A2_) (B1_, B2_) xml2name)
                (fn c => xml_return (fn d => SE_DP (a, b, c, d)))))));

fun nonloop_srs (A1_, A2_) (B1_, B2_) xml2name =
  xml_do
    [#"n", #"o", #"n", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
      #"n", #"g", #"S", #"R", #"S"]
    (xml_take
      (xml_do
        [#"d", #"e", #"r", #"i", #"v", #"a", #"t", #"i", #"o", #"n", #"P", #"a",
          #"t", #"t", #"e", #"r", #"n", #"s"]
        (xml_take_many_sub [] zero_nata Infinity_enat
          (derivation_pattern_proof (A1_, A2_) (B1_, B2_) xml2name)
          (fn a => xml_return (id a))))
      (fn a =>
        xml_take (nonloop_srs_reason (A1_, A2_) (B1_, B2_) xml2name)
          (fn b => xml_return (b a))));

val imaginary_unit : complex = Complex (zero_reala, one_reala);

fun croots2 p =
  let
    val a = coeff zero_complex p (nat_of_integer (2 : IntInf.int));
    val b = coeff zero_complex p one_nata;
    val c = (case coeffs zero_complex p of [] => zero_complexa | x :: _ => x);
    val b2a =
      divide_complexa b (times_complexa (numeral numeral_complex (Bit0 One)) a);
    val bac =
      minus_complexa
        (binary_power monoid_mult_complex b2a (nat_of_integer (2 : IntInf.int)))
        (divide_complexa c a);
    val e = csqrt bac;
  in
    remdups equal_complex
      [plus_complexa (uminus_complexa b2a) e,
        minus_complexa (uminus_complexa b2a) e]
  end;

fun showsp_formula show_a p (Disjunction x) =
  shows_pl p o
    shows_string
      [#"D", #"i", #"s", #"j", #"u", #"n", #"c", #"t", #"i", #"o", #"n"] o
    shows_space o
    showsp_list (showsp_formula show_a) one_nata x o
    shows_pr p
  | showsp_formula show_a p (Conjunction x) =
    shows_pl p o
      shows_string
        [#"C", #"o", #"n", #"j", #"u", #"n", #"c", #"t", #"i", #"o", #"n"] o
      shows_space o
      showsp_list (showsp_formula show_a) one_nata x o
      shows_pr p
  | showsp_formula show_a p (NegAtom x) =
    shows_pl p o shows_string [#"N", #"e", #"g", #"A", #"t", #"o", #"m"] o
      shows_space o
      show_a one_nata x o
      shows_pr p
  | showsp_formula show_a p (Atom x) =
    shows_pl p o shows_string [#"A", #"t", #"o", #"m"] o shows_space o
      show_a one_nata x o
      shows_pr p;

fun nFQ_subset_NF_rulesb
  (Tp_ops_ext
    (qreltrs, q, r, rw, rules, q_empty, is_QNF, nFQ_subset_NF_rules, rules_map,
      delete_R_Rw, split_rules, mk, nfs, more))
  = nFQ_subset_NF_rules;

fun is_QNFb
  (Tp_ops_ext
    (qreltrs, q, r, rw, rules, q_empty, is_QNF, nFQ_subset_NF_rules, rules_map,
      delete_R_Rw, split_rules, mk, nfs, more))
  = is_QNF;

fun rulesd
  (Tp_ops_ext
    (qreltrs, q, r, rw, rules, q_empty, is_QNF, nFQ_subset_NF_rules, rules_map,
      delete_R_Rw, split_rules, mk, nfs, more))
  = rules;

fun icap_impl_tp B_ i d =
  let
    val qr = nFQ_subset_NF_rulesb i d;
    val qnf = is_QNFb i d;
    val r = rulesd i d;
    val ic = icap_impl_gen B_ qr qnf (map fst r);
  in
    (fn s =>
      let
        val a =
          ceta_set_of (key_list (equal_char, key_char)) (maps vars_term_list s);
      in
        ic s a
      end)
  end;

fun has_type B_ type_of_fun (Fun (f, es)) ty =
  eq B_ ty (snd (type_of_fun f)) andalso
    (equal_nata (size_list es) (size_list (fst (type_of_fun f))) andalso
      all_interval_nat
        (fn i =>
          has_type B_ type_of_fun (nth es i) (nth (fst (type_of_fun f)) i))
        zero_nata (size_list es))
  | has_type B_ type_of_fun (Var v) ty = eq B_ (snd v) ty;

fun is_bool (B1_, B2_, B3_) type_of_fun bool_types e =
  bex (B1_, B2_) bool_types (has_type B3_ type_of_fun e) andalso not (is_Var e);

fun formula atom (Disjunction phi_s) = list_all (formula atom) phi_s
  | formula atom (Conjunction phi_s) = list_all (formula atom) phi_s
  | formula atom (NegAtom a) = atom a
  | formula atom (Atom a) = atom a;

fun transition_rule (B1_, B2_, B3_) type_of_fun bool_types
  (Transition (l, r, phi)) =
  formula (is_bool (B1_, B2_, B3_) type_of_fun bool_types) phi;

fun check_lts_impl (B1_, B2_, B3_) type_of_fun bool_types pi =
  let
    val Lts_Impl (_, ti, lc) = pi;
  in
    bindb (catch_errora
            (forallM
              (fn (_, t) =>
                check (transition_rule (B1_, B2_, B3_) type_of_fun bool_types t)
                  (shows_prec_list show_char zero_nata
                    [#"i", #"l", #"l", #"-", #"f", #"o", #"r", #"m", #"e", #"d",
                      #" ", #"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i",
                      #"o", #"n", #" ", #"i", #"n", #" ", #"L", #"T", #"S"]))
              ti)
            (fn x => Inl (snd x)))
      (fn _ =>
        catch_errora
          (forallM
            (fn (_, f) =>
              check (formula (is_bool (B1_, B2_, B3_) type_of_fun bool_types) f)
                (shows_prec_list show_char zero_nata
                  [#"i", #"l", #"l", #"-", #"f", #"o", #"r", #"m", #"e", #"d",
                    #" ", #"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n", #" ",
                    #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ",
                    #"i", #"n", #" ", #"L", #"T", #"S"]))
            lc)
          (fn x => Inl (snd x)))
  end;

fun label_decomp (Lab (f, l)) = (f, Inl l)
  | label_decomp (FunLab (f, l)) = (f, Inr l);

fun list_all_rec p [] = true
  | list_all_rec p (a :: l) = p a andalso list_all_rec p l;

fun root_unity (A1_, A2_) n =
  minus_polya ((ab_group_add_ring o ring_ring_1 o ring_1_comm_ring_1) A2_, A1_)
    (monom
      ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
         semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
         comm_semiring_1_cancel_comm_ring_1)
         A2_,
        A1_)
      (onea ((one_numeral o numeral_neg_numeral o neg_numeral_ring_1 o
               ring_1_comm_ring_1)
              A2_))
      n)
    (one_polyb
      ((comm_semiring_1_comm_semiring_1_cancel o
         comm_semiring_1_cancel_comm_ring_1)
        A2_));

fun set_ext s_ns =
  (fn asa => fn bs =>
    (not (null asa) andalso
       list_all (fn b => list_ex (fn a => fst (s_ns a b)) asa) bs,
      list_all (fn b => list_ex (fn a => snd (s_ns a b)) asa) bs));

fun check_no_var A_ B_ t =
  check (not (is_Var t))
    (shows_string
       [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #" ", #"f", #"o", #"u",
         #"n", #"d"] o
      shows_nl);

fun check_supteq (A1_, A2_) (B1_, B2_) s t =
  check (equal_terma A1_ B1_ s t orelse supt_impl A1_ B1_ s t)
    (shows_prec_term A2_ B2_ zero_nata t o
      (shows_string
         [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"s",
           #"u", #"b", #"t", #"e", #"r", #"m", #" ", #"o", #"f", #" "] o
        shows_prec_term A2_ B2_ zero_nata s));

fun ta_match (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) (C1_, C2_) ta qsig
  (Fun (f, ts)) q =
  let
    val n = size_list ts;
    val rls =
      filter (ceq_ta_rule A4_ B2_, ccompare_ta_rule A3_ B1_)
        (fn rule =>
          equal_proda B2_ equal_nat (r_sym rule) (f, n) andalso
            bex (A2_, A3_)
              (sup_seta (A2_, A3_)
                (inserta (A2_, A3_) (r_rhs rule) (bot_set (A2_, A3_, A5_)))
                (compute_trancl (A1_, A2_, A3_, A5_)
                  (inserta (A2_, A3_) (r_rhs rule) (bot_set (A2_, A3_, A5_)))
                  (ta_eps ta)))
              (fn qa => member (A2_, A3_) qa q))
        (ta_rules ta);
  in
    sup_setb
      (finite_UNIV_list, cenum_list, ceq_list (ceq_prod C1_ A2_),
        cproper_interval_list (ccompare_prod C2_ A3_), set_impl_list)
      (image (ceq_ta_rule A4_ B2_, ccompare_ta_rule A3_ B1_)
        (ceq_set
           (cenum_list, ceq_list (ceq_prod C1_ A2_),
             ccompare_cproper_interval
               (cproper_interval_list (ccompare_prod C2_ A3_))),
          ccompare_set
            (finite_UNIV_list, ceq_list (ceq_prod C1_ A2_),
              cproper_interval_list (ccompare_prod C2_ A3_), set_impl_list),
          set_impl_set)
        (fn TA_rule (_, qs, _) =>
          image (ceq_list (ceq_list (ceq_prod C1_ A2_)),
                  ccompare_list (ccompare_list (ccompare_prod C2_ A3_)))
            (ceq_list (ceq_prod C1_ A2_), ccompare_list (ccompare_prod C2_ A3_),
              set_impl_list)
            concat
            (listset
              (ceq_list (ceq_prod C1_ A2_),
                ccompare_list (ccompare_prod C2_ A3_), set_impl_list)
              (map (fn (tsi, qsi) =>
                     ta_match (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) (C1_, C2_) ta
                       qsig tsi
                       (inserta (A2_, A3_) qsi (bot_set (A2_, A3_, A5_))))
                (zip ts qs))))
        rls)
  end
  | ta_match (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) (C1_, C2_) ta qsig (Var x) q =
    image (A2_, A3_)
      (ceq_list (ceq_prod C1_ A2_), ccompare_list (ccompare_prod C2_ A3_),
        set_impl_list)
      (fn qa => [(x, qa)])
      (filter (A2_, A3_) (fn qa => member (A2_, A3_) qa qsig)
        (sup_seta (A2_, A3_) q
          (compute_trancl (A1_, A2_, A3_, A5_) q
            (converse (A2_, A3_, A5_) (A2_, A3_, A5_) (ta_eps ta)))));

fun generate_listset (A1_, A2_, A3_) n s =
  (if equal_nata n zero_nata
    then inserta (ceq_list A1_, ccompare_list A2_) []
           (set_empty (ceq_list A1_, ccompare_list A2_)
             (of_phantom set_impl_lista))
    else set_Cons (A1_, A2_, A3_) s
           (generate_listset (A1_, A2_, A3_) (minus_nata n one_nata) s));

fun minus_set (A1_, A2_) a b = inf_seta (A1_, A2_) a (uminus_set b);

fun mergeb A_ (Fun (fa, tsa)) (Fun (f, ts)) =
  bind (guarda (eq A_ fa f))
    (fn _ =>
      bind (guarda (equal_nata (size_list tsa) (size_list ts)))
        (fn _ =>
          bind (mapMa (fn (a, b) => mergeb A_ a b) (zip tsa ts))
            (fn tsb => SOME (Fun (fa, tsb)))))
  | mergeb A_ (Var ()) x = SOME x
  | mergeb A_ (Fun (v, va)) (Var ()) = SOME (Fun (v, va));

fun merge_cl (A1_, A2_) s =
  let
    val new =
      minus_set (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit)
        (these
          (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit,
            set_impl_term)
          (image
            (ceq_prod (ceq_term A2_ equal_unit) (ceq_term A2_ equal_unit),
              ccompare_prod (ccompare_term A1_ compare_unit)
                (ccompare_term A1_ compare_unit))
            (ceq_option (ceq_term A2_ equal_unit),
              ccompare_option (ccompare_term A1_ compare_unit),
              set_impl_option set_impl_term)
            (fn (a, b) => mergeb A2_ a b)
            (productc
              (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit,
                set_impl_term)
              (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit,
                set_impl_term)
              s s)))
        s;
  in
    (if set_eq
          (cenum_term, ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit)
          new (set_empty
                (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit)
                (of_phantom set_impl_terma))
      then s
      else merge_cl (A1_, A2_)
             (sup_seta (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit)
               s new))
  end;

fun subt_merge_cl (A1_, A2_) (B1_, B2_) s =
  merge_cl (A1_, A2_)
    (sup_seta (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit)
      (inserta (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit)
        (Var ())
        (set_empty (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit)
          (of_phantom set_impl_terma)))
      (sup_setb
        (finite_UNIV_term, cenum_term, ceq_term A2_ equal_unit,
          cproper_interval_term A1_ compare_unit, set_impl_term)
        (image (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit)
          (ceq_set
             (cenum_term, ceq_term A2_ equal_unit,
               ccompare_cproper_interval
                 (cproper_interval_term A1_ compare_unit)),
            ccompare_set
              (finite_UNIV_term, ceq_term A2_ equal_unit,
                cproper_interval_term A1_ compare_unit, set_impl_term),
            set_impl_set)
          (fn t =>
            set (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit,
                  set_impl_term)
              (supt_list t))
          (image (ceq_term A2_ B2_, ccompare_term A1_ B1_)
            (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit,
              set_impl_term)
            (map_term (fn x => x) (fn _ => ())) s))));

fun maxa (A1_, A2_, A3_, A4_) a = set_fold1 (A1_, A2_, A3_) (max_sls A4_) a;

fun matchd A_ (Var ()) x = true
  | matchd A_ (Fun (fa, tsa)) (Fun (f, ts)) =
    eq A_ fa f andalso list_all2 (matchd A_) tsa ts
  | matchd A_ (Fun (v, va)) (Var vb) = false;

fun shrinks (A1_, A2_) ta t =
  let
    val s =
      filter (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit)
        (fn s => matchd A2_ s ta) t;
    val max =
      maxa (ceq_nat, ccompare_nat, lattice_nat, linorder_nat)
        (image (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit)
          (ceq_nat, ccompare_nat, set_impl_nat) (size_list o funs_term_list) s);
  in
    filter (ceq_term A2_ equal_unit, ccompare_term A1_ compare_unit)
      (fn sa => equal_nata ((size_list o funs_term_list) sa) max) s
  end;

fun nf_rules_states_impl (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_) t siga =
  let
    val mcl = subt_merge_cl (A5_, A6_) (B1_, B2_) t;
    val states =
      filter (ceq_term A6_ equal_unit, ccompare_term A5_ compare_unit)
        (fn q =>
          ball (ceq_term A6_ B2_, ccompare_term A5_ B1_) t
            (fn ta =>
              not (matchd A6_ (map_term (fn x => x) (fn _ => ()) ta) q)))
        mcl;
    val lhss =
      sup_setb
        (finite_UNIV_prod A1_ finite_UNIV_list, cenum_prod A2_ cenum_list,
          ceq_prod A3_ (ceq_list (ceq_term A6_ equal_unit)),
          cproper_interval_prod A4_
            (cproper_interval_list (ccompare_term A5_ compare_unit)),
          set_impl_prod A7_ set_impl_list)
        (image
          (ceq_prod A3_ ceq_nat,
            ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat)
          (ceq_set
             (cenum_prod A2_ cenum_list,
               ceq_prod A3_ (ceq_list (ceq_term A6_ equal_unit)),
               ccompare_cproper_interval
                 (cproper_interval_prod A4_
                   (cproper_interval_list (ccompare_term A5_ compare_unit)))),
            ccompare_set
              (finite_UNIV_prod A1_ finite_UNIV_list,
                ceq_prod A3_ (ceq_list (ceq_term A6_ equal_unit)),
                cproper_interval_prod A4_
                  (cproper_interval_list (ccompare_term A5_ compare_unit)),
                set_impl_prod A7_ set_impl_list),
            set_impl_set)
          (fn (f, n) =>
            image (ceq_list (ceq_term A6_ equal_unit),
                    ccompare_list (ccompare_term A5_ compare_unit))
              (ceq_prod A3_ (ceq_list (ceq_term A6_ equal_unit)),
                ccompare_prod (ccompare_cproper_interval A4_)
                  (ccompare_list (ccompare_term A5_ compare_unit)),
                set_impl_prod A7_ set_impl_list)
              (fn a => (f, a))
              (generate_listset
                (ceq_term A6_ equal_unit, ccompare_term A5_ compare_unit,
                  set_impl_term)
                n states))
          siga);
    val flhss =
      filter
        (ceq_prod A3_ (ceq_list (ceq_term A6_ equal_unit)),
          ccompare_prod (ccompare_cproper_interval A4_)
            (ccompare_list (ccompare_term A5_ compare_unit)))
        (fn q =>
          ball (ceq_term A6_ B2_, ccompare_term A5_ B1_) t
            (fn ta =>
              not (matchd A6_ (map_term (fn x => x) (fn _ => ()) ta)
                    (Fun (fst q, snd q)))))
        lhss;
    val rules =
      image (ceq_prod A3_ (ceq_list (ceq_term A6_ equal_unit)),
              ccompare_prod (ccompare_cproper_interval A4_)
                (ccompare_list (ccompare_term A5_ compare_unit)))
        (ceq_set
           (cenum_ta_rule, ceq_ta_rule (equal_term A6_ equal_unit) A6_,
             ccompare_cproper_interval
               (cproper_interval_ta_rule (ccompare_term A5_ compare_unit)
                 (ccompare_cproper_interval A4_))),
          ccompare_set
            (finite_UNIV_ta_rule, ceq_ta_rule (equal_term A6_ equal_unit) A6_,
              cproper_interval_ta_rule (ccompare_term A5_ compare_unit)
                (ccompare_cproper_interval A4_),
              set_impl_ta_rule),
          set_impl_set)
        (fn (f, qs) =>
          image (ceq_term A6_ equal_unit, ccompare_term A5_ compare_unit)
            (ceq_ta_rule (equal_term A6_ equal_unit) A6_,
              ccompare_ta_rule (ccompare_term A5_ compare_unit)
                (ccompare_cproper_interval A4_),
              set_impl_ta_rule)
            (fn a => TA_rule (f, qs, a)) (shrinks (A5_, A6_) (Fun (f, qs)) mcl))
        flhss;
  in
    (sup_setb
       (finite_UNIV_ta_rule, cenum_ta_rule,
         ceq_ta_rule (equal_term A6_ equal_unit) A6_,
         cproper_interval_ta_rule (ccompare_term A5_ compare_unit)
           (ccompare_cproper_interval A4_),
         set_impl_ta_rule)
       rules,
      states)
  end;

fun ta_nf (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_) t siga =
  let
    val (rules, states) =
      nf_rules_states_impl (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_) t
        siga;
  in
    Ta_ext
      (states, rules,
        set_empty
          (ceq_prod (ceq_term A6_ equal_unit) (ceq_term A6_ equal_unit),
            ccompare_prod (ccompare_term A5_ compare_unit)
              (ccompare_term A5_ compare_unit))
          (of_phantom (set_impl_proda set_impl_term set_impl_term)),
        ())
  end;

fun compute_NF f a = (case f a of NONE => SOME a | SOME aa => compute_NF f aa);

fun first_rewrite A_ (B1_, B2_, B3_) r s =
  (case rewrite A_ (B1_, B2_, B3_) r s of [] => NONE | t :: _ => SOME t);

fun compute_rstep_NF A_ (B1_, B2_, B3_) r s =
  compute_NF (first_rewrite A_ (B1_, B2_, B3_) r) s;

fun check_join_NF (A1_, A2_) (B1_, B2_, B3_, B4_) r s t =
  (case (compute_rstep_NF A1_ (B1_, B2_, B3_) r s,
          compute_rstep_NF A1_ (B1_, B2_, B3_) r t)
    of (NONE, _) =>
      Inl (shows_prec_list show_char zero_nata
            [#"s", #"t", #"r", #"a", #"n", #"g", #"e", #" ", #"e", #"r", #"r",
              #"o", #"r", #" ", #"i", #"n", #" ", #"n", #"o", #"r", #"m", #"a",
              #"l", #" ", #"f", #"o", #"r", #"m", #" ", #"c", #"o", #"m", #"p",
              #"u", #"t", #"a", #"t", #"i", #"o", #"n"])
    | (SOME _, NONE) =>
      Inl (shows_prec_list show_char zero_nata
            [#"s", #"t", #"r", #"a", #"n", #"g", #"e", #" ", #"e", #"r", #"r",
              #"o", #"r", #" ", #"i", #"n", #" ", #"n", #"o", #"r", #"m", #"a",
              #"l", #" ", #"f", #"o", #"r", #"m", #" ", #"c", #"o", #"m", #"p",
              #"u", #"t", #"a", #"t", #"i", #"o", #"n"])
    | (SOME sa, SOME ta) =>
      check (equal_terma A1_ B2_ sa ta)
        (shows_string
           [#"t", #"h", #"e", #" ", #"n", #"o", #"r", #"m", #"a", #"l", #" ",
             #"f", #"o", #"r", #"m", #" "] o
          (shows_prec_term A2_ B4_ zero_nata sa o
            (shows_prec_list show_char zero_nata [#" ", #"o", #"f", #" "] o
              (shows_prec_term A2_ B4_ zero_nata s o
                (shows_prec_list show_char zero_nata
                   [#" ", #"d", #"i", #"f", #"f", #"e", #"r", #"s", #" ", #"f",
                     #"r", #"o", #"m", #" "] o
                  (shows_nl o
                    (shows_prec_list show_char zero_nata
                       [#"t", #"h", #"e", #" ", #"n", #"o", #"r", #"m", #"a",
                         #"l", #" ", #"f", #"o", #"r", #"m", #" "] o
                      (shows_prec_term A2_ B4_ zero_nata ta o
                        (shows_prec_list show_char zero_nata
                           [#" ", #"o", #"f", #" "] o
                          shows_prec_term A2_ B4_ zero_nata t))))))))));

fun in_rstep_impl (A1_, A2_) (B1_, B2_, B3_, B4_) s t r =
  list_ex
    (fn p =>
      in_poss p t andalso
        (equal_ctxta A2_ B3_ (ctxt_of_pos_term p s)
           (ctxt_of_pos_term p t) andalso
          let
            val sp = subt_at s p;
            val tp = subt_at t p;
          in
            bex (ceq_prod (ceq_term A2_ B3_) (ceq_term A2_ B3_),
                  ccompare_prod (ccompare_term A1_ B2_) (ccompare_term A1_ B2_))
              r (fn lr =>
                  not (is_none
                        (match_list (B1_, B3_, B4_) A2_ B3_ Var
                          [(fst lr, sp), (snd lr, tp)])))
          end))
    (poss_list s);

fun reverse_rules rs = map swap rs;

fun wf_rules_impl B_ r = filtera (wf_rule B_) r;

fun check_pairwise c [] = Inr ()
  | check_pairwise c (x :: xs) =
    bindb (catch_errora (forallM (c x) xs) (fn xa => Inl (snd xa)))
      (fn _ => check_pairwise c xs);

fun check_disjoint A_ xs ys =
  catch_errora
    (forallM (fn x => (if not (membera A_ ys x) then Inr () else Inl x)) xs)
    (fn x => Inl (snd x));

fun check_partition A_ xss = check_pairwise (check_disjoint A_) xss;

fun check_inj (A1_, A2_) (B1_, B2_) a nn sml =
  let
    val symbols =
      map (fn (aa, b) =>
            let
              val (_, n) = aa;
            in
              (fn fs =>
                map (fn (g, i) =>
                      (g, plus_nata n (times_nata i (minus_nata nn one_nata))))
                  (zip fs (upt zero_nata (size_list fs))))
            end
              b)
        sml;
    val fsymbols = concat symbols;
  in
    bindb (catch_errora
            (check_partition (equal_prod (equal_lab A1_ B1_) equal_nat) symbols)
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"s", #"y", #"m", #"b", #"o", #"l", #" "] o
                    (shows_prec_prod (show_lab A2_ B2_) show_nat zero_nata x o
                      shows_prec_list show_char zero_nata
                        [#" ", #"o", #"c", #"c", #"u", #"r", #"s", #" ", #"t",
                          #"w", #"i", #"c", #"e", #")"]))))
      (fn _ =>
        bindb (check
                (not (membera (equal_prod (equal_lab A1_ B1_) equal_nat)
                       fsymbols (a, nn)))
                (shows_prec_list show_char zero_nata
                   [#"a", #"p", #"p", #"l", #"i", #"c", #"a", #"t", #"i", #"o",
                     #"n", #" ", #"s", #"y", #"m", #"b", #"o", #"l"] o
                  (shows_prec_lab A2_ B2_ zero_nata a o
                    shows_prec_list show_char zero_nata
                      [#" ", #"m", #"u", #"s", #"t", #" ", #"n", #"o", #"t",
                        #" ", #"o", #"c", #"c", #"u", #"r", #" ", #"a", #"s",
                        #" ", #"n", #"e", #"w", #" ", #"s", #"y", #"m", #"b",
                        #"o", #"l"])))
          (fn _ =>
            bindb (check
                    (not (membera (equal_prod (equal_lab A1_ B1_) equal_nat)
                           (map fst sml) (a, nn)))
                    (shows_prec_list show_char zero_nata
                       [#"a", #"p", #"p", #"l", #"i", #"c", #"a", #"t", #"i",
                         #"o", #"n", #" ", #"s", #"y", #"m", #"b", #"o", #"l"] o
                      (shows_prec_lab A2_ B2_ zero_nata a o
                        shows_prec_list show_char zero_nata
                          [#" ", #"m", #"u", #"s", #"t", #" ", #"n", #"o", #"t",
                            #" ", #"b", #"e", #" ", #"u", #"n", #"c", #"u",
                            #"r", #"r", #"i", #"e", #"d"])))
              (fn _ =>
                (if less_eq_nat nn one_nata
                  then catch_errora
                         (forallM
                           (check_pairwise
                             (fn gn1 => fn gn2 =>
                               check (not (equal_proda (equal_lab A1_ B1_)
    equal_nat gn1 gn2))
                                 (shows_prec_list show_char zero_nata
                                    [#"s", #"y", #"m", #"b", #"o", #"l", #" "] o
                                   (shows_prec_prod (show_lab A2_ B2_) show_nat
                                      zero_nata gn1 o
                                     shows_prec_list show_char zero_nata
                                       [#" ", #"o", #"c", #"c", #"u", #"r",
 #"s", #" ", #"t", #"w", #"i", #"c", #"e"]))))
                           symbols)
                         (fn x => Inl (snd x))
                  else Inr ()))))
  end;

fun not_ws_ns
  (Redtriple_ext
    (valid, s, ns, nst, af, mono_af, mono, desc, not_ws_ns, cpx, more))
  = not_ws_ns;

fun no_complexity_check x =
  (fn _ => fn _ =>
    Inl (shows_prec_list show_char zero_nata
          [#"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y", #" ",
            #"a", #"n", #"a", #"l", #"y", #"s", #"i", #"s", #" ", #"u", #"n",
            #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d"]))
    x;

fun valid
  (Redtriple_ext
    (valid, s, ns, nst, af, mono_af, mono, desc, not_ws_ns, cpx, more))
  = valid;

fun desc
  (Redtriple_ext
    (valid, s, ns, nst, af, mono_af, mono, desc, not_ws_ns, cpx, more))
  = desc;

fun check_status_ws_info A_ sigma cns NONE =
  Inl (shows_prec_list show_char zero_nata
        [#"m", #"i", #"s", #"s", #"i", #"n", #"g", #" ", #"w", #"e", #"a", #"k",
          #"-", #"s", #"u", #"b", #"t", #"e", #"r", #"m", #" ", #"s", #"t",
          #"a", #"t", #"u", #"s", #" ", #"o", #"f", #" ", #"b", #"a", #"s",
          #"e", #" ", #"r", #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n",
          #" ", #"p", #"a", #"i", #"r"])
  | check_status_ws_info A_ sigma cns (SOME fs) =
    catch_errora
      (forallM
        (fn f =>
          catch_errora
            (forallM
              (fn i =>
                catch_errora
                  (cns (Fun (fst f,
                              map (fn ia =>
                                    Var (shows_prec_nat zero_nata ia []))
                                (upt zero_nata (snd f))),
                         Var (shows_prec_nat zero_nata i [])))
                  (fn _ =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"a", #"c", #"c", #"o", #"r", #"d", #"i", #"n",
                             #"g", #" ", #"t", #"o", #" ", #"w", #"e", #"a",
                             #"k", #"-", #"m", #"o", #"n", #".", #" ", #"i",
                             #"n", #"f", #"o", #"r", #"m", #"a", #"t", #"i",
                             #"o", #"n", #" ", #"o", #"f", #" ", #"o", #"r",
                             #"d", #"e", #"r", #",", #" ", #"a", #"r", #"g",
                             #"u", #"m", #"e", #"n", #"t", #" ", #"#"] o
                          (shows_prec_nat zero_nata (suc i) o
                            (shows_prec_list show_char zero_nata
                               [#" ", #"m", #"u", #"s", #"t", #" ", #"n", #"o",
                                 #"t", #" ", #"o", #"c", #"c", #"u", #"r", #" ",
                                 #"i", #"n", #" ", #"s", #"t", #"a", #"t", #"u",
                                 #"s", #" ", #"o", #"f", #" "] o
                              shows_prec_prod A_ show_nat zero_nata f)))))
              (status sigma f))
            (fn x => Inl (snd x)))
        fs)
      (fn x => Inl (snd x));

fun ns
  (Redtriple_ext
    (valid, s, ns, nst, af, mono_af, mono, desc, not_ws_ns, cpx, more))
  = ns;

fun af
  (Redtriple_ext
    (valid, s, ns, nst, af, mono_af, mono, desc, not_ws_ns, cpx, more))
  = af;

fun s (Redtriple_ext
        (valid, s, ns, nst, af, mono_af, mono, desc, not_ws_ns, cpx, more))
  = s;

fun shows_wpo_params A_ params =
  shows_prec_list show_char zero_nata
    [#"s", #"t", #"a", #"t", #"u", #"s", #" ", #"a", #"n", #"d", #" ", #"p",
      #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c", #"e", #" "] o
    (shows_nl o
      shows_sep
        (fn (f, (p, s)) =>
          shows_prec_list show_char zero_nata
            [#"s", #"y", #"m", #"b", #"o", #"l", #" "] o
            (shows_prec_prod A_ show_nat zero_nata f o
              (shows_prec_list show_char zero_nata
                 [#":", #" ", #"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n",
                   #"c", #"e", #" ", #"=", #" "] o
                (shows_prec_nat zero_nata p o
                  (shows_prec_list show_char zero_nata
                     [#" ", #" ", #" ", #"s", #"t", #"a", #"t", #"u", #"s",
                       #" ", #"=", #" "] o
                    shows_prec_list show_nat zero_nata s)))))
        shows_nl params);

fun faulty_redtriple uu uv err desc =
  Redtriple_ext
    (Inl err, (fn _ => Inr ()), (fn _ => Inr ()), (fn _ => Inr ()), full_af,
      empty_af, (fn _ => Inr ()), desc, NONE, no_complexity_check, ());

fun prl_nat pr = (fn f => equal_nata (pr f) zero_nata);

fun prc_nat pr = (fn f => fn g => let
                                    val pf = pr f;
                                    val pg = pr g;
                                  in
                                    (less_nat pg pf, less_eq_nat pg pf)
                                  end);

fun wpo_redtriple (A1_, A2_, A3_) rt params =
  let
    val stat = map (fn (f, ps) => (f, snd ps)) params;
    val pr =
      fun_of_map_funa (ceta_map_of (key_prod A2_ key_nat) params)
        (fn _ => zero_nata) fst;
    val desca =
      shows_prec_list show_char zero_nata
        [#"W", #"P", #"O", #" ", #"w", #"i", #"t", #"h", #" "] o
        (shows_wpo_params A3_ params o
          (shows_nl o
            (shows_prec_list show_char zero_nata
               [#"o", #"v", #"e", #"r", #" ", #"t", #"h", #"e", #" ", #"f",
                 #"o", #"l", #"l", #"o", #"w", #"i", #"n", #"g", #" ", #"r",
                 #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n", #" ", #"p",
                 #"a", #"i", #"r", #":"] o
              (shows_nl o desc rt))));
  in
    (case status_of A1_ stat
      of NONE =>
        faulty_redtriple Type Type
          (shows_prec_list show_char zero_nata
            [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"i", #"t",
              #"h", #" ", #"i", #"n", #"d", #"i", #"c", #"e", #"s", #" ", #"i",
              #"n", #" ", #"s", #"t", #"a", #"t", #"u", #"s", #" ", #"o", #"f",
              #" ", #"W", #"P", #"O", #"!"])
          desca
      | SOME sigma =>
        let
          val sa = (fn sa => fn t => isOK (s rt (sa, t)));
          val nsa = (fn sb => fn t => isOK (ns rt (sb, t)));
          val wpo =
            wpo_ub (equal_list equal_char) (prc_nat pr) (prl_nat pr) sa nsa
              sigma;
          val wpo_s =
            (fn (sb, t) =>
              check (fst (wpo sb t))
                (shows_prec_term A3_ (show_list show_char) zero_nata sb o
                  (shows_prec_list show_char zero_nata
                     [#" ", #">", #"w", #"p", #"o", #" "] o
                    (shows_prec_term A3_ (show_list show_char) zero_nata t o
                      shows_prec_list show_char zero_nata
                        [#" ", #"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
                          #"t", #" ", #"b", #"e", #" ", #"e", #"n", #"s", #"u",
                          #"r", #"e", #"d"]))));
          val wpo_ns =
            (fn (sb, t) =>
              check (snd (wpo sb t))
                (shows_prec_term A3_ (show_list show_char) zero_nata sb o
                  (shows_prec_list show_char zero_nata
                     [#" ", #">", #"=", #"w", #"p", #"o", #" "] o
                    (shows_prec_term A3_ (show_list show_char) zero_nata t o
                      shows_prec_list show_char zero_nata
                        [#" ", #"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
                          #"t", #" ", #"b", #"e", #" ", #"e", #"n", #"s", #"u",
                          #"r", #"e", #"d"]))));
        in
          Redtriple_ext
            (bindb (valid rt)
               (fn _ => check_status_ws_info A3_ sigma (ns rt) (not_ws_ns rt)),
              wpo_s, wpo_ns, wpo_ns, af_wpo (af rt) sigma, empty_af,
              (fn _ =>
                catch_errora
                  (forallM
                    (fn (a, b) =>
                      let
                        val (f, n) = a;
                      in
                        (fn idx =>
                          check (eq_set
                                  (card_UNIV_nat, cenum_nat, ceq_nat,
                                    ccompare_nat)
                                  (set (ceq_nat, ccompare_nat, set_impl_nat)
                                    idx)
                                  (set (ceq_nat, ccompare_nat, set_impl_nat)
                                    (upt zero_nata n)))
                            (shows_prec_list show_char zero_nata
                               [#"f", #"o", #"r", #" ", #"m", #"o", #"n", #"o",
                                 #"t", #"o", #"n", #"i", #"c", #"i", #"t", #"y",
                                 #",", #" ", #"s", #"t", #"a", #"t", #"u", #"s",
                                 #" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e",
                                 #" ", #"c", #"o", #"m", #"p", #"l", #"e", #"t",
                                 #"e", #",", #" ", #"b", #"u", #"t", #" ", #"s",
                                 #"t", #"a", #"t", #"u", #"s", #" ", #"o", #"f",
                                 #" "] o
                              (shows_prec_prod A3_ show_nat zero_nata (f, n) o
                                (shows_prec_list show_char zero_nata
                                   [#" ", #"i", #"s", #" "] o
                                  shows_prec_list show_nat zero_nata
                                    (map suc idx)))))
                      end
                        b)
                    stat)
                  (fn x => Inl (snd x))),
              desca, SOME (map fst stat), no_complexity_check, ())
        end)
  end;

fun parse_xml_string p str =
  (case string2xml str of Inl a => Inl a | Inr a => parse_xml p a);

fun parse_claim f = parse_xml_string xml2claim;

fun apply_af_entry uu (Collapse i) ts = nth ts i
  | apply_af_entry f (AFList is) ts = Fun (f, map (nth ts) is);

fun afs_term pi (Fun (f, ts)) =
  let
    val l = size_list ts;
  in
    apply_af_entry (FPair (f, l)) (afsa pi (f, l)) (map (afs_term pi) ts)
  end
  | afs_term pi (Var x) = Var x;

fun afs_rule pi lr = (afs_term pi (fst lr), afs_term pi (snd lr));

fun af_rule pi = (fn t => map_funs_rule filtered_fun (afs_rule pi t));

fun af_term pi t = map_term filtered_fun (fn x => x) (afs_term pi t);

fun nat_or_empty D_ ([], s) = Inr NONE
  | nat_or_empty D_ ([XML_text txt], s) =
    (case int_of_stringa txt of Inl err => xml_error D_ err ([], s)
      | Inr n => Inr (SOME (nat n)));

fun uncurry_info A_ xml2name =
  xml_do
    [#"u", #"n", #"c", #"u", #"r", #"r", #"y", #"I", #"n", #"f", #"o", #"r",
      #"m", #"a", #"t", #"i", #"o", #"n"]
    (xml_take xml2name
      (fn a =>
        xml_take
          (xml_do
            [#"u", #"n", #"c", #"u", #"r", #"r", #"i", #"e", #"d", #"S", #"y",
              #"m", #"b", #"o", #"l", #"s"]
            (xml_take_many_sub [] zero_nata Infinity_enat
              (xml_do
                [#"u", #"n", #"c", #"u", #"r", #"r", #"i", #"e", #"d", #"S",
                  #"y", #"m", #"b", #"o", #"l", #"E", #"n", #"t", #"r", #"y"]
                (xml_take xml2name
                  (fn f =>
                    xml_take (xml_nat [#"a", #"r", #"i", #"t", #"y"])
                      (fn n =>
                        xml_take_many_sub [] zero_nata Infinity_enat xml2name
                          (fn fs => xml_return ((f, n), fs))))))
              xml_return))
          (fn sml =>
            xml_take
              (xml_do
                [#"u", #"n", #"c", #"u", #"r", #"r", #"y", #"R", #"u", #"l",
                  #"e", #"s"]
                (xml_take (rules A_ xml2name) (fn x => xml_return (id x))))
              (fn u =>
                xml_take
                  (xml_do [#"e", #"t", #"a", #"R", #"u", #"l", #"e", #"s"]
                    (xml_take (rules A_ xml2name) (fn x => xml_return (id x))))
                  (fn e => xml_return (a, (sml, (u, e))))))));

fun convertible_critical_peaks A_ xml2name =
  let
    val rew = rsteps A_ xml2name;
    val conv = conversion A_ xml2name;
  in
    xml_do
      [#"c", #"o", #"n", #"v", #"e", #"r", #"t", #"i", #"b", #"l", #"e", #"C",
        #"r", #"i", #"t", #"i", #"c", #"a", #"l", #"P", #"e", #"a", #"k", #"s"]
      (xml_take_many_sub [] zero_nata Infinity_enat
        (xml_do
          [#"c", #"o", #"n", #"v", #"e", #"r", #"t", #"i", #"b", #"l", #"e",
            #"C", #"r", #"i", #"t", #"i", #"c", #"a", #"l", #"P", #"e", #"a",
            #"k"]
          (xml_take
            (xml_do [#"s", #"o", #"u", #"r", #"c", #"e"]
              (xml_take (term A_ xml2name) (fn x => xml_return (id x))))
            (fn s =>
              xml_take
                (xml_do
                  [#"c", #"o", #"n", #"v", #"e", #"r", #"s", #"i", #"o", #"n",
                    #"L", #"e", #"f", #"t"]
                  (xml_take conv
                    (fn (sa, c1) =>
                      xml_take rew
                        (fn (_, r) =>
                          xml_take conv
                            (fn (_, c2) => xml_return (sa, (c1, (r, c2))))))))
                (fn (s1, (cl1, (sl, cl2))) =>
                  xml_take
                    (xml_do
                      [#"c", #"o", #"n", #"v", #"e", #"r", #"s", #"i", #"o",
                        #"n", #"R", #"i", #"g", #"h", #"t"]
                      (xml_take conv
                        (fn (sa, c1) =>
                          xml_take rew
                            (fn (_, r) =>
                              xml_take conv
                                (fn (_, c2) =>
                                  xml_return (sa, (c1, (r, c2))))))))
                    (fn (s2, (cr1, (sr, cr2))) =>
                      xml_return
                        (s, (s1, (cl1, (sl,
 (cl2, (s2, (cr1, (sr, cr2)))))))))))))
        xml_return)
  end;

fun ordering_constraint_proof A_ xml2name bi =
  xml_do
    [#"o", #"r", #"d", #"e", #"r", #"i", #"n", #"g", #"C", #"o", #"n", #"s",
      #"t", #"r", #"a", #"i", #"n", #"t", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_do [#"r", #"e", #"d", #"P", #"a", #"i", #"r"]
        (xml_take (redtriple A_ xml2name bi) (fn x => xml_return (id x))))
      (fn x => xml_return (id x)));

fun ordering_constraint_proofa A_ xml2name bi =
  xml_do
    [#"o", #"r", #"d", #"e", #"r", #"i", #"n", #"g", #"C", #"o", #"n", #"s",
      #"t", #"r", #"a", #"i", #"n", #"t", #"P", #"r", #"o", #"o", #"f"]
    (xml_take (redtriplea A_ xml2name bi) (fn x => xml_return (id x)));

fun create_proj A_ (Projection p) =
  let
    val i = ceta_map_of (key_prod A_ key_nat) p;
  in
    (fn f => (case i f of NONE => zero_nata | SOME n => n))
  end;

fun xml2cond_constraint A_ xml2name x =
  xml_do
    [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a", #"l", #"C",
      #"o", #"n", #"s", #"t", #"r", #"a", #"i", #"n", #"t"]
    (xml_take
      (xml_or
        (xml_do [#"a", #"l", #"l"]
          (xml_take (xml_text [#"v", #"a", #"r"])
            (fn a =>
              xml_take (xml2cond_constraint A_ xml2name)
                (fn b => xml_return (CC_all (a, b))))))
        (xml_or
          (xml_do
            [#"i", #"m", #"p", #"l", #"i", #"c", #"a", #"t", #"i", #"o", #"n"]
            (xml_take (xml2cond_constraint A_ xml2name)
              (fn c =>
                xml_take_many_sub [] zero_nata Infinity_enat
                  (xml2cond_constraint A_ xml2name)
                  (fn cs =>
                    let
                      val ccs = c :: cs;
                    in
                      xml_return (CC_impl (take (size_list cs) ccs, last ccs))
                    end))))
          (xml_do [#"c", #"o", #"n", #"s", #"t", #"r", #"a", #"i", #"n", #"t"]
            (xml_take (term A_ xml2name)
              (fn s =>
                xml_take
                  (xml_or
                    (xml_leaf [#"r", #"e", #"w", #"r", #"i", #"t", #"e"] NONE)
                    (xml_or
                      (xml_leaf [#"s", #"t", #"r", #"i", #"c", #"t"]
                        (SOME true))
                      (xml_leaf
                        [#"n", #"o", #"n", #"S", #"t", #"r", #"i", #"c", #"t"]
                        (SOME false))))
                  (fn rel =>
                    xml_take (term A_ xml2name)
                      (fn t =>
                        xml_return
                          (case rel of NONE => CC_rewr (s, t)
                            | SOME stri => CC_cond (stri, (s, t))))))))))
      (fn xa => xml_return (id xa)))
    x;

fun xml2cond_constraint_prf A_ xml2name x =
  let
    val cc = xml2cond_constraint A_ xml2name;
  in
    xml_do
      [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a", #"l", #"C",
        #"o", #"n", #"s", #"t", #"r", #"a", #"i", #"n", #"t", #"P", #"r", #"o",
        #"o", #"f"]
      (xml_take
        (xml_or (xml_leaf [#"f", #"i", #"n", #"a", #"l"] Final)
          (xml_or
            (xml_do
              [#"d", #"i", #"f", #"f", #"e", #"r", #"e", #"n", #"t", #"C", #"o",
                #"n", #"s", #"t", #"r", #"u", #"c", #"t", #"o", #"r"]
              (xml_take cc (fn a => xml_return (Different_Constructor a))))
            (xml_or
              (xml_do
                [#"s", #"a", #"m", #"e", #"C", #"o", #"n", #"s", #"t", #"r",
                  #"u", #"c", #"t", #"o", #"r"]
                (xml_take cc
                  (fn a =>
                    xml_take cc
                      (fn b =>
                        xml_take (xml2cond_constraint_prf A_ xml2name)
                          (fn c => xml_return (Same_Constructor (a, b, c)))))))
              (xml_or
                (xml_do
                  [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #"E", #"q",
                    #"u", #"a", #"t", #"i", #"o", #"n"]
                  (xml_take (xml_text [#"v", #"a", #"r"])
                    (fn a =>
                      xml_take (term A_ xml2name)
                        (fn b =>
                          xml_take cc
                            (fn c =>
                              xml_take (xml2cond_constraint_prf A_ xml2name)
                                (fn d =>
                                  xml_return
                                    (Variable_Equation (a, b, c, d))))))))
                (xml_or
                  (xml_do
                    [#"f", #"u", #"n", #"a", #"r", #"g", #"I", #"n", #"t", #"o",
                      #"V", #"a", #"r"]
                    (xml_take cc
                      (fn a =>
                        xml_take position
                          (fn b =>
                            xml_take (xml_text [#"v", #"a", #"r"])
                              (fn c =>
                                xml_take cc
                                  (fn d =>
                                    xml_take
                                      (xml2cond_constraint_prf A_ xml2name)
                                      (fn e =>
xml_return (Funarg_Into_Var (a, b, c, d, e)))))))))
                  (xml_or
                    (xml_do
                      [#"s", #"i", #"m", #"p", #"l", #"i", #"f", #"y", #"C",
                        #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n"]
                      (xml_take cc
                        (fn a =>
                          xml_take (substa A_ xml2name)
                            (fn b =>
                              xml_take cc
                                (fn c =>
                                  xml_take (xml2cond_constraint_prf A_ xml2name)
                                    (fn d =>
                                      xml_return
(Simplify_Condition (a, b, c, d))))))))
                    (xml_or
                      (xml_do
                        [#"i", #"n", #"d", #"u", #"c", #"t", #"i", #"o", #"n"]
                        (xml_take cc
                          (fn a =>
                            xml_take
                              (xml_do
                                [#"c", #"o", #"n", #"j", #"u", #"n", #"c", #"t",
                                  #"s"]
                                (xml_take_many_sub [] zero_nata Infinity_enat cc
                                  xml_return))
                              (fn b =>
                                xml_take
                                  (xml_do
                                    [#"r", #"u", #"l", #"e", #"C", #"o", #"n",
                                      #"s", #"t", #"r", #"a", #"i", #"n", #"t",
                                      #"P", #"r", #"o", #"o", #"f", #"s"]
                                    (xml_take_many_sub [] zero_nata
                                      Infinity_enat
                                      (xml_do
[#"r", #"u", #"l", #"e", #"C", #"o", #"n", #"s", #"t", #"r", #"a", #"i", #"n",
  #"t", #"P", #"r", #"o", #"o", #"f"]
(xml_take (rule A_ xml2name)
  (fn lr =>
    xml_take
      (xml_do
        [#"s", #"u", #"b", #"t", #"e", #"r", #"m", #"V", #"a", #"r", #"E", #"n",
          #"t", #"r", #"i", #"e", #"s"]
        (xml_take_many_sub [] zero_nata Infinity_enat
          (xml_do
            [#"s", #"u", #"b", #"t", #"e", #"r", #"m", #"V", #"a", #"r", #"E",
              #"n", #"t", #"r", #"y"]
            (xml_take (term A_ xml2name)
              (fn aa =>
                xml_take_many_sub [] zero_nata Infinity_enat
                  (xml_text [#"v", #"a", #"r"])
                  (fn ba => xml_return (aa, ba)))))
          xml_return))
      (fn rys =>
        xml_take cc
          (fn cca =>
            xml_take (xml2cond_constraint_prf A_ xml2name)
              (fn p => xml_return (lr, (rys, (cca, p)))))))))
                                      xml_return))
                                  (fn c => xml_return (Induction (a, b, c)))))))
                      (xml_do
                        [#"d", #"e", #"l", #"e", #"t", #"e", #"C", #"o", #"n",
                          #"d", #"i", #"t", #"i", #"o", #"n"]
                        (xml_take cc
                          (fn a =>
                            xml_take (xml2cond_constraint_prf A_ xml2name)
                              (fn b =>
                                xml_return (Delete_Condition (a, b)))))))))))))
        (fn xa => xml_return (id xa)))
      x
  end;

fun xml2cond_red_pair_proof A_ xml2name =
  xml_do
    [#"c", #"o", #"n", #"d", #"R", #"e", #"d", #"P", #"a", #"i", #"r", #"P",
      #"r", #"o", #"o", #"f"]
    (xml_take xml2name
      (fn c =>
        xml_take (xml_nat [#"b", #"e", #"f", #"o", #"r", #"e"])
          (fn b =>
            xml_take (xml_nat [#"a", #"f", #"t", #"e", #"r"])
              (fn a =>
                xml_take
                  (xml_do
                    [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s"]
                    (xml_take_many_sub [] zero_nata Infinity_enat
                      (xml_do
                        [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n"]
                        (xml_take (xml2cond_constraint A_ xml2name)
                          (fn ca =>
                            xml_take
                              (xml_do
                                [#"d", #"p", #"S", #"e", #"q", #"u", #"e", #"n",
                                  #"c", #"e"]
                                (xml_take (rules A_ xml2name)
                                  (fn x => xml_return (id x))))
                              (fn s =>
                                xml_take (xml2cond_constraint_prf A_ xml2name)
                                  (fn p => xml_return (ca, (s, p)))))))
                      xml_return))
                  (fn ccs => xml_return (Cond_Red_Pair_Prf (c, ccs, b, a)))))));

fun projected_rseq (A1_, A2_) xml2name pi =
  xml_do
    [#"p", #"r", #"o", #"j", #"e", #"c", #"t", #"e", #"d", #"R", #"e", #"w",
      #"r", #"i", #"t", #"e", #"S", #"e", #"q", #"u", #"e", #"n", #"c", #"e"]
    (xml_take (rule A2_ xml2name)
      (fn r => xml_take (rseq (A1_, A2_) xml2name pi r) xml_return));

val default_nfs_nt_dp : bool = false;

fun strategy_to_Q A_ B_ No_Strategy uu = []
  | strategy_to_Q A_ B_ Innermost r = remdups (equal_term A_ B_) (map fst r)
  | strategy_to_Q A_ B_ (Innermost_Q q) uv = q;

val default_nfs_dp : bool = true;

fun xml2dp_inputa (A1_, A2_) xml2name termination =
  xml_change (xml2dp_input A2_ xml2name)
    (fn DP_input (m, p, q, r) =>
      xml_return
        ((if termination then default_nfs_dp else default_nfs_nt_dp),
          (m, (p, ([], (strategy_to_Q A1_ (equal_list equal_char) q r,
                         ([], r)))))));

fun flat_contexts A_ xml2name =
  xml_do
    [#"f", #"l", #"a", #"t", #"C", #"o", #"n", #"t", #"e", #"x", #"t", #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat (ctxt A_ xml2name)
      xml_return);

fun equal_start_term Full Constructor_Based = false
  | equal_start_term Constructor_Based Full = false
  | equal_start_term Constructor_Based Constructor_Based = true
  | equal_start_term Full Full = true;

fun o_to_fp_term t = (Hole, (t, Ba));

fun o_to_fp_impl x = map o_to_fp_term x;

fun mu_to_fp_impl A_ mu =
  let
    val fs = remdups (equal_prod A_ equal_nat) (map fst mu);
    val m = map_of (equal_prod A_ equal_nat) mu;
    val a =
      maps (fn f =>
             let
               val xs =
                 map Var (fresh_strings_list [#"x"] zero_nata [] (snd f));
             in
               map (fn i => (f, (xs, i)))
                 (maps (fn i =>
                         (if not (membera equal_nat (the (m f)) i) then [i]
                           else []))
                   (upt zero_nata (snd f)))
             end)
        fs;
  in
    maps (fn ((f, _), (xs, i)) =>
           map (fn loc =>
                 (ctxt_of_pos_term (PCons (i, Empty)) (Fun (f, xs)),
                   (nth xs i, loc)))
             [Ba, H])
      a
  end;

fun strategy_to_fp A_ (Forbidden_Patterns p) r = p
  | strategy_to_fp A_ Outermost r = o_to_fp_impl (map fst r)
  | strategy_to_fp A_ (Context_Sensitive mu) r = mu_to_fp_impl A_ mu;

val default_nfs_trs : bool = false;

fun xml2inn_fp_trs_assm (A1_, A2_) xml2name =
  xml_change (xml2_trs_input A2_ xml2name)
    (fn a =>
      (case a
        of DP_input (_, _, _, _) =>
          xml_error (show_list (show_list show_char))
            [#"t", #"r", #"s", #" ", #"a", #"s", #" ", #"i", #"n", #"p", #"u",
              #"t", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]
        | Inn_TRS_input (inn, r, s, start) =>
          (if not (equal_start_term start Full)
            then xml_error (show_list (show_list show_char))
                   [#"s", #"t", #"a", #"r", #"t", #" ", #"t", #"e", #"r", #"m",
                     #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l",
                     #"l", #"o", #"w", #"e", #"d", #" ", #"h", #"e", #"r", #"e"]
            else xml_return
                   (Inl (default_nfs_trs,
                          (strategy_to_Q A1_ (equal_list equal_char) inn r,
                            (r, s)))))
        | CPX_input (_, _, _, _, _) =>
          xml_error (show_list (show_list show_char))
            [#"t", #"r", #"s", #" ", #"a", #"s", #" ", #"i", #"n", #"p", #"u",
              #"t", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]
        | COMP_input (_, _) =>
          xml_error (show_list (show_list show_char))
            [#"t", #"r", #"s", #" ", #"a", #"s", #" ", #"i", #"n", #"p", #"u",
              #"t", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]
        | OCOMP_input (_, _, _, _) =>
          xml_error (show_list (show_list show_char))
            [#"t", #"r", #"s", #" ", #"a", #"s", #" ", #"i", #"n", #"p", #"u",
              #"t", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]
        | EQ_input (_, _) =>
          xml_error (show_list (show_list show_char))
            [#"t", #"r", #"s", #" ", #"a", #"s", #" ", #"i", #"n", #"p", #"u",
              #"t", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]
        | FP_TRS_input (fp, r) => xml_return (Inr (strategy_to_fp A1_ fp r, r))
        | CTRS_input _ =>
          xml_error (show_list (show_list show_char))
            [#"t", #"r", #"s", #" ", #"a", #"s", #" ", #"i", #"n", #"p", #"u",
              #"t", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]
        | TA_input (_, _) =>
          xml_error (show_list (show_list show_char))
            [#"t", #"r", #"s", #" ", #"a", #"s", #" ", #"i", #"n", #"p", #"u",
              #"t", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]
        | AC_input (_, _, _) =>
          xml_error (show_list (show_list show_char))
            [#"t", #"r", #"s", #" ", #"a", #"s", #" ", #"i", #"n", #"p", #"u",
              #"t", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]
        | LTS_input _ =>
          xml_error (show_list (show_list show_char))
            [#"t", #"r", #"s", #" ", #"a", #"s", #" ", #"i", #"n", #"p", #"u",
              #"t", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]
        | LTS_safety_input (_, _) =>
          xml_error (show_list (show_list show_char))
            [#"t", #"r", #"s", #" ", #"a", #"s", #" ", #"i", #"n", #"p", #"u",
              #"t", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]
        | Unknown_input _ =>
          xml_error (show_list (show_list show_char))
            [#"t", #"r", #"s", #" ", #"a", #"s", #" ", #"i", #"n", #"p", #"u",
              #"t", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]));

fun xml2inn_trs_assm (A1_, A2_) xml2name =
  xml_change (xml2inn_fp_trs_assm (A1_, A2_) xml2name)
    (fn a =>
      (case a of Inl aa => xml_return aa
        | Inr _ =>
          xml_error (show_list (show_list show_char))
            [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"(",
              #"r", #"e", #"l", #"a", #"t", #"i", #"v", #"e", #")", #" ", #"T",
              #"R", #"S", #" ", #"e", #"x", #"p", #"e", #"c", #"t", #"e", #"d",
              #" ", #"a", #"t", #" ", #"t", #"h", #"i", #"s", #" ", #"p", #"o",
              #"i", #"n", #"t"]));

fun xml2trs_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name x =
  xml_or
    (xml_do
      [#"t", #"r", #"s", #"T", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
        #"o", #"n", #"P", #"r", #"o", #"o", #"f"]
      (xml_take
        (xml2trs_termination_proof_inner (A1_, A2_, A3_) (B1_, B2_, B3_)
          xml2name)
        (fn xa => xml_return (id xa))))
    (xml_do
      [#"r", #"e", #"l", #"a", #"t", #"i", #"v", #"e", #"T", #"e", #"r", #"m",
        #"i", #"n", #"a", #"t", #"i", #"o", #"n", #"P", #"r", #"o", #"o", #"f"]
      (xml_take
        (xml2trs_termination_proof_inner (A1_, A2_, A3_) (B1_, B2_, B3_)
          xml2name)
        (fn xa => xml_return (id xa))))
    x
and xml2dp_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name x =
  xml_do [#"d", #"p", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_leaf [#"p", #"I", #"s", #"E", #"m", #"p", #"t", #"y"] P_is_Empty)
        (xml_or
          (xml_do
            [#"d", #"e", #"p", #"G", #"r", #"a", #"p", #"h", #"P", #"r", #"o",
              #"c"]
            (xml_take_many_sub [] zero_nata Infinity_enat
              (xml_do [#"c", #"o", #"m", #"p", #"o", #"n", #"e", #"n", #"t"]
                (xml_take
                  (xml_do [#"d", #"p", #"s"]
                    (xml_take (rules (show_lab A3_ B3_) xml2name)
                      (fn xa => xml_return (id xa))))
                  (fn dps =>
                    xml_take_optional
                      (xml_bool [#"r", #"e", #"a", #"l", #"S", #"c", #"c"])
                      (fn _ =>
                        xml_take_optional
                          (xml_do [#"a", #"r", #"c", #"s"]
                            (xml_take_many_sub [] zero_nata Infinity_enat
                              (fn xa => Inr (fst xa)) (fn _ => xml_return ())))
                          (fn _ =>
                            xml_take_optional
                              (xml2dp_termination_proof (A1_, A2_, A3_)
                                (B1_, B2_, B3_) xml2name)
                              (fn prfOpt => xml_return (prfOpt, dps)))))))
              (fn a => xml_return (Dep_Graph_Proc a))))
          (xml_or
            (xml_do
              [#"r", #"e", #"d", #"P", #"a", #"i", #"r", #"P", #"r", #"o", #"c"]
              (xml_take
                (ordering_constraint_proofa (show_lab A3_ B3_) xml2name false)
                (fn a =>
                  xml_take
                    (xml_do [#"d", #"p", #"s"]
                      (xml_take (rules (show_lab A3_ B3_) xml2name)
                        (fn xa => xml_return (id xa))))
                    (fn b =>
                      xml_take
                        (xml2dp_termination_proof (A1_, A2_, A3_)
                          (B1_, B2_, B3_) xml2name)
                        (fn c => xml_return (Redpair_Proc (a, b, c)))))))
            (xml_or
              (xml_do
                [#"u", #"s", #"a", #"b", #"l", #"e", #"R", #"u", #"l", #"e",
                  #"s", #"P", #"r", #"o", #"c"]
                (xml_take
                  (xml_do
                    [#"u", #"s", #"a", #"b", #"l", #"e", #"R", #"u", #"l", #"e",
                      #"s"]
                    (xml_take (rules (show_lab A3_ B3_) xml2name)
                      (fn xa => xml_return (id xa))))
                  (fn a =>
                    xml_take
                      (xml2dp_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                        xml2name)
                      (fn b => xml_return (Usable_Rules_Proc (a, b))))))
              (xml_or
                (xml_do
                  [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #"L",
                    #"h", #"s", #"s", #"R", #"e", #"m", #"o", #"v", #"a", #"l",
                    #"P", #"r", #"o", #"c"]
                  (xml_take (innermostLhss (show_lab A3_ B3_) xml2name)
                    (fn a =>
                      xml_take
                        (xml2dp_termination_proof (A1_, A2_, A3_)
                          (B1_, B2_, B3_) xml2name)
                        (fn b => xml_return (Q_Reduction_Proc (a, b))))))
                (xml_or
                  (xml_do
                    [#"r", #"e", #"w", #"r", #"i", #"t", #"i", #"n", #"g", #"P",
                      #"r", #"o", #"c"]
                    (xml_take (rule (show_lab A3_ B3_) xml2name)
                      (fn (s, t) =>
                        xml_take (rstep (show_lab A3_ B3_) xml2name)
                          (fn (p, (lr, ta)) =>
                            xml_take_default (s, ta)
                              (rule (show_lab A3_ B3_) xml2name)
                              (fn st =>
                                xml_take_optional
                                  (xml_do
                                    [#"u", #"s", #"a", #"b", #"l", #"e", #"R",
                                      #"u", #"l", #"e", #"s"]
                                    (xml_take
                                      (rules (show_lab A3_ B3_) xml2name)
                                      (fn xa => xml_return (id xa))))
                                  (fn ur =>
                                    xml_take
                                      (xml2dp_termination_proof (A1_, A2_, A3_)
(B1_, B2_, B3_) xml2name)
                                      (fn prof =>
xml_return (Rewriting_Proc (ur, (s, t), (s, ta), st, lr, p, prof)))))))))
                  (xml_or
                    (xml_do
                      [#"n", #"a", #"r", #"r", #"o", #"w", #"i", #"n", #"g",
                        #"P", #"r", #"o", #"c"]
                      (xml_take (rule (show_lab A3_ B3_) xml2name)
                        (fn a =>
                          xml_take pos
                            (fn b =>
                              xml_take
                                (xml_do
                                  [#"n", #"a", #"r", #"r", #"o", #"w", #"i",
                                    #"n", #"g", #"s"]
                                  (xml_take (rules (show_lab A3_ B3_) xml2name)
                                    (fn xa => xml_return (id xa))))
                                (fn c =>
                                  xml_take
                                    (xml2dp_termination_proof (A1_, A2_, A3_)
                                      (B1_, B2_, B3_) xml2name)
                                    (fn d =>
                                      xml_return
(Narrowing_Proc (a, b, c, d))))))))
                    (xml_or
                      (xml_do
                        [#"i", #"n", #"s", #"t", #"a", #"n", #"t", #"i", #"a",
                          #"t", #"i", #"o", #"n", #"P", #"r", #"o", #"c"]
                        (xml_take (rule (show_lab A3_ B3_) xml2name)
                          (fn a =>
                            xml_take
                              (xml_do
                                [#"i", #"n", #"s", #"t", #"a", #"n", #"t", #"i",
                                  #"a", #"t", #"i", #"o", #"n", #"s"]
                                (xml_take (rules (show_lab A3_ B3_) xml2name)
                                  (fn xa => xml_return (id xa))))
                              (fn b =>
                                xml_take
                                  (xml2dp_termination_proof (A1_, A2_, A3_)
                                    (B1_, B2_, B3_) xml2name)
                                  (fn c =>
                                    xml_return
                                      (Instantiation_Proc (a, b, c)))))))
                      (xml_or
                        (xml_do
                          [#"f", #"o", #"r", #"w", #"a", #"r", #"d", #"I", #"n",
                            #"s", #"t", #"a", #"n", #"t", #"i", #"a", #"t",
                            #"i", #"o", #"n", #"P", #"r", #"o", #"c"]
                          (xml_take (rule (show_lab A3_ B3_) xml2name)
                            (fn a =>
                              xml_take
                                (xml_do
                                  [#"i", #"n", #"s", #"t", #"a", #"n", #"t",
                                    #"i", #"a", #"t", #"i", #"o", #"n", #"s"]
                                  (xml_take (rules (show_lab A3_ B3_) xml2name)
                                    (fn xa => xml_return (id xa))))
                                (fn b =>
                                  xml_take_optional
                                    (xml_do
                                      [#"u", #"s", #"a", #"b", #"l", #"e", #"R",
#"u", #"l", #"e", #"s"]
                                      (xml_take
(rules (show_lab A3_ B3_) xml2name) (fn xa => xml_return (id xa))))
                                    (fn c =>
                                      xml_take
(xml2dp_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
(fn d => xml_return (Forward_Instantiation_Proc (a, b, c, d))))))))
                        (xml_or
                          (xml_do
                            [#"s", #"e", #"m", #"l", #"a", #"b", #"P", #"r",
                              #"o", #"c"]
                            (xml_take
                              (xmlt2 (sl_variant (xmlt_of_xmlt2 xml2name)))
                              (fn sli =>
                                xml_take
                                  (xml_do [#"d", #"p", #"s"]
                                    (xml_take
                                      (rules (show_lab A3_ B3_) xml2name)
                                      (fn xa => xml_return (id xa))))
                                  (fn lp =>
                                    xml_take
                                      (xml_do [#"t", #"r", #"s"]
(xml_take (rules (show_lab A3_ B3_) xml2name) (fn xa => xml_return (id xa))))
                                      (fn lr =>
xml_take_default [] (innermostLhss (show_lab A3_ B3_) xml2name)
  (fn lq =>
    xml_take (xml2dp_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
      (fn p => xml_return (Semlab_Proc (sli, lp, lq, lr, p)))))))))
                          (xml_or
                            (xml_do
                              [#"s", #"u", #"b", #"t", #"e", #"r", #"m", #"P",
                                #"r", #"o", #"c"]
                              (xml_take
                                (xml_or
                                  (xml_change (proj (show_lab A3_ B3_) xml2name)
                                    (xml_return o Inl))
                                  (xml_change
                                    (multiset_af (show_lab A3_ B3_) xml2name)
                                    (xml_return o Inr)))
                                (fn pi_mpi =>
                                  xml_take_many_sub [] zero_nata Infinity_enat
                                    (projected_rseq
                                      (equal_lab A1_ B1_, show_lab A3_ B3_)
                                      xml2name
                                      (create_proj (key_lab A2_ B2_)
(case pi_mpi of Inl lpi => lpi | Inr _ => Projection [])))
                                    (fn seq =>
                                      xml_take
(xml_do [#"d", #"p", #"s"]
  (xml_take (rules (show_lab A3_ B3_) xml2name) (fn xa => xml_return (id xa))))
(fn dps =>
  xml_take (xml2dp_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
    (fn prf =>
      xml_return
        (case pi_mpi of Inl lpi => Subterm_Criterion_Proc (lpi, seq, dps, prf)
          | Inr mpi => Gen_Subterm_Criterion_Proc (mpi, dps, prf))))))))
                            (xml_or
                              (xml_do
                                [#"r", #"e", #"d", #"P", #"a", #"i", #"r", #"U",
                                  #"r", #"P", #"r", #"o", #"c"]
                                (xml_take
                                  (ordering_constraint_proofa (show_lab A3_ B3_)
                                    xml2name false)
                                  (fn a =>
                                    xml_take
                                      (xml_do [#"d", #"p", #"s"]
(xml_take (rules (show_lab A3_ B3_) xml2name) (fn xa => xml_return (id xa))))
                                      (fn b =>
xml_take
  (xml_do [#"u", #"s", #"a", #"b", #"l", #"e", #"R", #"u", #"l", #"e", #"s"]
    (xml_take (rules (show_lab A3_ B3_) xml2name)
      (fn xa => xml_return (id xa))))
  (fn c =>
    xml_take (xml2dp_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
      (fn d => xml_return (Redpair_UR_Proc (a, b, c, d))))))))
                              (xml_or
                                (xml_do
                                  [#"m", #"o", #"n", #"o", #"R", #"e", #"d",
                                    #"P", #"a", #"i", #"r", #"U", #"r", #"P",
                                    #"r", #"o", #"c"]
                                  (xml_take
                                    (ordering_constraint_proof
                                      (show_lab A3_ B3_) xml2name false)
                                    (fn a =>
                                      xml_take
(xml_do [#"d", #"p", #"s"]
  (xml_take (rules (show_lab A3_ B3_) xml2name) (fn xa => xml_return (id xa))))
(fn b =>
  xml_take
    (xml_do [#"t", #"r", #"s"]
      (xml_take (rules (show_lab A3_ B3_) xml2name)
        (fn xa => xml_return (id xa))))
    (fn c =>
      xml_take
        (xml_do
          [#"u", #"s", #"a", #"b", #"l", #"e", #"R", #"u", #"l", #"e", #"s"]
          (xml_take (rules (show_lab A3_ B3_) xml2name)
            (fn xa => xml_return (id xa))))
        (fn d =>
          xml_take
            (xml2dp_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
            (fn e => xml_return (Mono_Redpair_UR_Proc (a, b, c, d, e)))))))))
                                (xml_or
                                  (xml_do
                                    [#"m", #"o", #"n", #"o", #"R", #"e", #"d",
                                      #"P", #"a", #"i", #"r", #"P", #"r", #"o",
                                      #"c"]
                                    (xml_take
                                      (ordering_constraint_proof
(show_lab A3_ B3_) xml2name false)
                                      (fn a =>
xml_take
  (xml_do [#"d", #"p", #"s"]
    (xml_take (rules (show_lab A3_ B3_) xml2name)
      (fn xa => xml_return (id xa))))
  (fn b =>
    xml_take
      (xml_do [#"t", #"r", #"s"]
        (xml_take (rules (show_lab A3_ B3_) xml2name)
          (fn xa => xml_return (id xa))))
      (fn c =>
        xml_take
          (xml2dp_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
          (fn d => xml_return (Mono_Redpair_Proc (a, b, c, d))))))))
                                  (xml_or
                                    (xml_do
                                      [#"i", #"n", #"n", #"e", #"r", #"m", #"o",
#"s", #"t", #"M", #"o", #"n", #"o", #"R", #"e", #"d", #"P", #"a", #"i", #"r",
#"P", #"r", #"o", #"c"]
                                      (xml_take
(ordering_constraint_proof (show_lab A3_ B3_) xml2name false)
(fn a =>
  xml_take
    (xml_do [#"d", #"e", #"l", #"e", #"t", #"e", #"d"]
      (xml_take
        (xml_do [#"d", #"p", #"s"]
          (xml_take (rules (show_lab A3_ B3_) xml2name)
            (fn xa => xml_return (id xa))))
        (fn aa =>
          xml_take
            (xml_do [#"t", #"r", #"s"]
              (xml_take (rules (show_lab A3_ B3_) xml2name)
                (fn xa => xml_return (id xa))))
            (fn b => xml_return (aa, b)))))
    (fn b =>
      xml_take
        (xml2dp_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
        (fn c =>
          xml_return (let
                        val (ba, ca) = b;
                      in
                        (fn d => Mono_URM_Redpair_Proc (a, ba, ca, d))
                      end
                       c))))))
                                    (xml_or
                                      (xml_do
[#"u", #"n", #"c", #"u", #"r", #"r", #"y", #"P", #"r", #"o", #"c"]
(xml_take_optional
  (xml_nat
    [#"a", #"p", #"p", #"l", #"i", #"c", #"a", #"t", #"i", #"v", #"e", #"T",
      #"o", #"p"])
  (fn a =>
    xml_take (uncurry_info (show_lab A3_ B3_) xml2name)
      (fn b =>
        xml_take
          (xml_do [#"d", #"p", #"s"]
            (xml_take (rules (show_lab A3_ B3_) xml2name)
              (fn xa => xml_return (id xa))))
          (fn c =>
            xml_take
              (xml_do [#"t", #"r", #"s"]
                (xml_take (rules (show_lab A3_ B3_) xml2name)
                  (fn xa => xml_return (id xa))))
              (fn d =>
                xml_take
                  (xml2dp_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                    xml2name)
                  (fn e => xml_return (Uncurry_Proc (a, b, c, d, e)))))))))
                                      (xml_or
(xml_do
  [#"f", #"l", #"a", #"t", #"C", #"o", #"n", #"t", #"e", #"x", #"t", #"C", #"l",
    #"o", #"s", #"u", #"r", #"e", #"P", #"r", #"o", #"c"]
  (xml_take
    (xml_do [#"f", #"r", #"e", #"s", #"h", #"S", #"y", #"m", #"b", #"o", #"l"]
      (xml_take xml2name (fn xa => xml_return (id xa))))
    (fn a =>
      xml_take (flat_contexts (show_lab A3_ B3_) xml2name)
        (fn b =>
          xml_take
            (xml_do [#"d", #"p", #"s"]
              (xml_take (rules (show_lab A3_ B3_) xml2name)
                (fn xa => xml_return (id xa))))
            (fn c =>
              xml_take
                (xml_do [#"t", #"r", #"s"]
                  (xml_take (rules (show_lab A3_ B3_) xml2name)
                    (fn xa => xml_return (id xa))))
                (fn d =>
                  xml_take
                    (xml2dp_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                      xml2name)
                    (fn e => xml_return (Fcc_Proc (a, b, c, d, e)))))))))
(xml_or
  (xml_do
    [#"s", #"w", #"i", #"t", #"c", #"h", #"I", #"n", #"n", #"e", #"r", #"m",
      #"o", #"s", #"t", #"P", #"r", #"o", #"c"]
    (xml_take (wcr_proof (show_lab A3_ B3_) xml2name)
      (fn a =>
        xml_take
          (xml2dp_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
          (fn b => xml_return (Switch_Innermost_Proc (a, b))))))
  (xml_or
    (xml_do [#"s", #"p", #"l", #"i", #"t", #"P", #"r", #"o", #"c"]
      (xml_take
        (xml_do [#"d", #"p", #"s"]
          (xml_take (rules (show_lab A3_ B3_) xml2name)
            (fn xa => xml_return (id xa))))
        (fn a =>
          xml_take
            (xml_do [#"t", #"r", #"s"]
              (xml_take (rules (show_lab A3_ B3_) xml2name)
                (fn xa => xml_return (id xa))))
            (fn b =>
              xml_take
                (xml2dp_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                  xml2name)
                (fn c =>
                  xml_take
                    (xml2dp_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                      xml2name)
                    (fn d => xml_return (Split_Proc (a, b, c, d))))))))
    (xml_or
      (xml_do
        [#"f", #"i", #"n", #"i", #"t", #"e", #"n", #"e", #"s", #"s", #"A", #"s",
          #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n"]
        (xml_take
          (xml2dp_inputa (equal_lab A1_ B1_, show_lab A3_ B3_) xml2name true)
          (fn xa => xml_return (Assume_Finite (xa, [])))))
      (xml_or
        (xml_do
          [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #"P", #"r", #"o", #"o",
            #"f"]
          (xml_take
            (xml_text
              [#"d", #"e", #"s", #"c", #"r", #"i", #"p", #"t", #"i", #"o",
                #"n"])
            (fn _ =>
              xml_take
                (xml2dp_inputa (equal_lab A1_ B1_, show_lab A3_ B3_) xml2name
                  true)
                (fn b =>
                  xml_take_many_sub [] zero_nata Infinity_enat
                    (fn xa => Inr (fst xa))
                    (fn _ => xml_return (Assume_Finite (b, [])))))))
        (xml_or
          (xml_do
            [#"s", #"w", #"i", #"t", #"c", #"h", #"T", #"o", #"T", #"R", #"S"]
            (xml_take
              (xml2trs_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                xml2name)
              (fn xa => xml_return (To_Trs_Proc xa))))
          (xml_or
            (xml_do [#"u", #"n", #"l", #"a", #"b", #"P", #"r", #"o", #"c"]
              (xml_take
                (xml_do [#"d", #"p", #"s"]
                  (xml_take (rules (show_lab A3_ B3_) xml2name)
                    (fn xa => xml_return (id xa))))
                (fn a =>
                  xml_take
                    (xml_do [#"t", #"r", #"s"]
                      (xml_take (rules (show_lab A3_ B3_) xml2name)
                        (fn xa => xml_return (id xa))))
                    (fn b =>
                      xml_take
                        (xml2dp_termination_proof (A1_, A2_, A3_)
                          (B1_, B2_, B3_) xml2name)
                        (fn c => xml_return (Unlab_Proc (a, b, c)))))))
            (xml_or
              (xml_do
                [#"g", #"e", #"n", #"e", #"r", #"a", #"l", #"R", #"e", #"d",
                  #"P", #"a", #"i", #"r", #"P", #"r", #"o", #"c"]
                (xml_take
                  (ordering_constraint_proof (show_lab A3_ B3_) xml2name true)
                  (fn rp =>
                    xml_take
                      (xml_do [#"s", #"t", #"r", #"i", #"c", #"t"]
                        (xml_take (rules (show_lab A3_ B3_) xml2name)
                          (fn xa => xml_return (id xa))))
                      (fn s =>
                        xml_take
                          (xml_do [#"b", #"o", #"u", #"n", #"d"]
                            (xml_take (rules (show_lab A3_ B3_) xml2name)
                              (fn xa => xml_return (id xa))))
                          (fn b =>
                            xml_take
                              (xml2cond_red_pair_proof (show_lab A3_ B3_)
                                xml2name)
                              (fn c =>
                                xml_take
                                  (xml2dp_termination_proof (A1_, A2_, A3_)
                                    (B1_, B2_, B3_) xml2name)
                                  (fn ps =>
                                    xml_take_optional
                                      (xml2dp_termination_proof (A1_, A2_, A3_)
(B1_, B2_, B3_) xml2name)
                                      (fn pbo =>
xml_return
  (General_Redpair_Proc
    (rp, s, b, c, (case pbo of NONE => [ps] | SOME pb => [ps, pb])))))))))))
              (xml_or
                (xml_do
                  [#"c", #"o", #"m", #"p", #"l", #"e", #"x", #"C", #"o", #"n",
                    #"s", #"t", #"a", #"n", #"t", #"R", #"e", #"m", #"o", #"v",
                    #"a", #"l", #"P", #"r", #"o", #"c"]
                  (xml_take (term (show_lab A3_ B3_) xml2name)
                    (fn a =>
                      xml_take
                        (xml_do [#"r", #"u", #"l", #"e", #"M", #"a", #"p"]
                          (xml_take_many_sub [] zero_nata Infinity_enat
                            (xml_do
                              [#"r", #"u", #"l", #"e", #"M", #"a", #"p", #"E",
                                #"n", #"t", #"r", #"y"]
                              (xml_take (rule (show_lab A3_ B3_) xml2name)
                                (fn aa =>
                                  xml_take (rule (show_lab A3_ B3_) xml2name)
                                    (fn b => xml_return (aa, b)))))
                            (fn aa => xml_return (id aa))))
                        (fn b =>
                          xml_take
                            (xml2dp_termination_proof (A1_, A2_, A3_)
                              (B1_, B2_, B3_) xml2name)
                            (fn c =>
                              xml_return
                                (Complex_Constant_Removal_Proc
                                  (Complex_Constant_Removal_Proof (a, b),
                                    c)))))))
                (xml_do
                  [#"s", #"i", #"z", #"e", #"C", #"h", #"a", #"n", #"g", #"e",
                    #"P", #"r", #"o", #"c"]
                  (xml_take
                    (xml_or
                      (xml_leaf
                        [#"s", #"u", #"b", #"t", #"e", #"r", #"m", #"C", #"r",
                          #"i", #"t", #"e", #"r", #"i", #"o", #"n"]
                        NONE)
                      (xml_do
                        [#"r", #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n",
                          #"P", #"a", #"i", #"r"]
                        (xml_take
                          (ordering_constraint_proof (show_lab A3_ B3_) xml2name
                            false)
                          (fn redp =>
                            xml_take_optional
                              (xml_do
                                [#"u", #"s", #"a", #"b", #"l", #"e", #"R", #"u",
                                  #"l", #"e", #"s"]
                                (xml_take (rules (show_lab A3_ B3_) xml2name)
                                  (fn xa => xml_return (id xa))))
                              (fn ur => xml_return (SOME (redp, ur)))))))
                    (fn version =>
                      xml_take_many_sub [] zero_nata Infinity_enat
                        (scg (show_lab A3_ B3_) xml2name)
                        (fn b =>
                          (case version
                            of NONE => xml_return (Size_Change_Subterm_Proc b)
                            | SOME redp_ur =>
                              xml_return
                                (Size_Change_Redpair_Proc
                                  (fst redp_ur, snd redp_ur,
                                    b))))))))))))))))))))))))))))))))
      (fn xa => xml_return (id xa)))
    x
and xml2trs_termination_proof_inner (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name x =
  xml_or (xml_leaf [#"r", #"I", #"s", #"E", #"m", #"p", #"t", #"y"] R_is_Empty)
    (xml_or
      (xml_do [#"s", #"I", #"s", #"E", #"m", #"p", #"t", #"y"]
        (xml_take
          (xml2trs_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
          xml_return))
      (xml_or
        (xml_do [#"s", #"e", #"m", #"l", #"a", #"b"]
          (xml_take (xmlt2 (sl_variant (xmlt_of_xmlt2 xml2name)))
            (fn sli =>
              xml_take
                (xml_do [#"t", #"r", #"s"]
                  (xml_take (rules (show_lab A3_ B3_) xml2name)
                    (fn xa => xml_return (id xa))))
                (fn lr =>
                  xml_take_default []
                    (xml_do [#"t", #"r", #"s"]
                      (xml_take (rules (show_lab A3_ B3_) xml2name)
                        (fn xa => xml_return (id xa))))
                    (fn lrw =>
                      xml_take_default []
                        (innermostLhss (show_lab A3_ B3_) xml2name)
                        (fn lq =>
                          xml_take
                            (xml2trs_termination_proof (A1_, A2_, A3_)
                              (B1_, B2_, B3_) xml2name)
                            (fn p =>
                              xml_return (Semlab (sli, lq, lr @ lrw, p)))))))))
        (xml_or
          (xml_do [#"s", #"p", #"l", #"i", #"t"]
            (xml_take
              (xml_do [#"t", #"r", #"s"]
                (xml_take (rules (show_lab A3_ B3_) xml2name)
                  (fn xa => xml_return (id xa))))
              (fn a =>
                xml_take
                  (xml2trs_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                    xml2name)
                  (fn b =>
                    xml_take
                      (xml2trs_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                        xml2name)
                      (fn c => xml_return (Split (a, b, c)))))))
          (xml_or
            (xml_do [#"d", #"p", #"T", #"r", #"a", #"n", #"s"]
              (xml_take
                (xml_do [#"d", #"p", #"s"]
                  (xml_take (rules (show_lab A3_ B3_) xml2name)
                    (fn xa => xml_return (id xa))))
                (fn a =>
                  xml_take
                    (xml_bool
                      [#"m", #"a", #"r", #"k", #"e", #"d", #"S", #"y", #"m",
                        #"b", #"o", #"l", #"s"])
                    (fn _ =>
                      xml_take
                        (xml2dp_termination_proof (A1_, A2_, A3_)
                          (B1_, B2_, B3_) xml2name)
                        (fn c =>
                          xml_return
                            (DP_Trans (default_nfs_dp, true, a, c)))))))
            (xml_or
              (xml_do
                [#"r", #"u", #"l", #"e", #"R", #"e", #"m", #"o", #"v", #"a",
                  #"l"]
                (xml_take
                  (ordering_constraint_proof (show_lab A3_ B3_) xml2name false)
                  (fn ord =>
                    xml_take
                      (xml_do [#"t", #"r", #"s"]
                        (xml_take (rules (show_lab A3_ B3_) xml2name)
                          (fn xa => xml_return (id xa))))
                      (fn r =>
                        xml_take_default []
                          (xml_do [#"t", #"r", #"s"]
                            (xml_take (rules (show_lab A3_ B3_) xml2name)
                              (fn xa => xml_return (id xa))))
                          (fn s =>
                            xml_take
                              (xml2trs_termination_proof (A1_, A2_, A3_)
                                (B1_, B2_, B3_) xml2name)
                              (fn p =>
                                xml_return (Rule_Removal (ord, r @ s, p))))))))
              (xml_or (xml_change (bounds_info xml2name) (xml_return o Bounds))
                (xml_or
                  (xml_do
                    [#"s", #"t", #"r", #"i", #"n", #"g", #"R", #"e", #"v", #"e",
                      #"r", #"s", #"a", #"l"]
                    (xml_take
                      (xml_do [#"t", #"r", #"s"]
                        (xml_take (rules (show_lab A3_ B3_) xml2name)
                          (fn xa => xml_return (id xa))))
                      (fn _ =>
                        xml_take_optional
                          (xml_do [#"t", #"r", #"s"]
                            (xml_take (rules (show_lab A3_ B3_) xml2name)
                              (fn xa => xml_return (id xa))))
                          (fn _ =>
                            xml_take
                              (xml2trs_termination_proof (A1_, A2_, A3_)
                                (B1_, B2_, B3_) xml2name)
                              (fn prf => xml_return (String_Reversal prf))))))
                  (xml_or
                    (xml_do
                      [#"e", #"q", #"u", #"a", #"l", #"i", #"t", #"y", #"R",
                        #"e", #"m", #"o", #"v", #"a", #"l"]
                      (xml_take
                        (xml2trs_termination_proof (A1_, A2_, A3_)
                          (B1_, B2_, B3_) xml2name)
                        (fn xa => xml_return (Drop_Equality xa))))
                    (xml_or
                      (xml_do
                        [#"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t", #"T",
                          #"o", #"U", #"n", #"a", #"r", #"y"]
                        (xml_take plain_var
                          (fn v =>
                            xml_take (renaming (show_lab A3_ B3_) xml2name)
                              (fn ren =>
                                xml_take
                                  (xml_do [#"t", #"r", #"s"]
                                    (xml_take
                                      (rules (show_lab A3_ B3_) xml2name)
                                      (fn xa => xml_return (id xa))))
                                  (fn s =>
                                    xml_take_default []
                                      (xml_do [#"t", #"r", #"s"]
(xml_take (rules (show_lab A3_ B3_) xml2name) (fn xa => xml_return (id xa))))
                                      (fn sw =>
xml_take (xml2trs_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
  (fn p =>
    xml_return
      (Constant_String (Const_string_sound_proof (v, ren, s, sw), p)))))))))
                      (xml_or
                        (xml_do
                          [#"r", #"e", #"m", #"o", #"v", #"e", #"N", #"o", #"n",
                            #"A", #"p", #"p", #"l", #"i", #"c", #"a", #"b",
                            #"l", #"e", #"R", #"u", #"l", #"e", #"s"]
                          (xml_take
                            (xml_do [#"t", #"r", #"s"]
                              (xml_take (rules (show_lab A3_ B3_) xml2name)
                                (fn xa => xml_return (id xa))))
                            (fn a =>
                              xml_take
                                (xml2trs_termination_proof (A1_, A2_, A3_)
                                  (B1_, B2_, B3_) xml2name)
                                (fn b =>
                                  xml_return
                                    (Remove_Nonapplicable_Rules (a, b))))))
                        (xml_or
                          (xml_do [#"u", #"n", #"c", #"u", #"r", #"r", #"y"]
                            (xml_take (uncurry_info (show_lab A3_ B3_) xml2name)
                              (fn i =>
                                xml_take
                                  (xml_do [#"t", #"r", #"s"]
                                    (xml_take
                                      (rules (show_lab A3_ B3_) xml2name)
                                      (fn xa => xml_return (id xa))))
                                  (fn r =>
                                    xml_take_default []
                                      (xml_do [#"t", #"r", #"s"]
(xml_take (rules (show_lab A3_ B3_) xml2name) (fn xa => xml_return (id xa))))
                                      (fn s =>
xml_take (xml2trs_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
  (fn p => xml_return (Uncurry (i, r @ s, p))))))))
                          (xml_or
                            (xml_do
                              [#"f", #"l", #"a", #"t", #"C", #"o", #"n", #"t",
                                #"e", #"x", #"t", #"C", #"l", #"o", #"s", #"u",
                                #"r", #"e"]
                              (xml_take
                                (flat_contexts (show_lab A3_ B3_) xml2name)
                                (fn i =>
                                  xml_take
                                    (xml_do [#"t", #"r", #"s"]
                                      (xml_take
(rules (show_lab A3_ B3_) xml2name) (fn xa => xml_return (id xa))))
                                    (fn r =>
                                      xml_take_default []
(xml_do [#"t", #"r", #"s"]
  (xml_take (rules (show_lab A3_ B3_) xml2name) (fn xa => xml_return (id xa))))
(fn s =>
  xml_take (xml2trs_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
    (fn p => xml_return (Fcc (i, r @ s, p))))))))
                            (xml_or
                              (xml_do
                                [#"s", #"w", #"i", #"t", #"c", #"h", #"I", #"n",
                                  #"n", #"e", #"r", #"m", #"o", #"s", #"t"]
                                (xml_take
                                  (wcr_proof (show_lab A3_ B3_) xml2name)
                                  (fn a =>
                                    xml_take
                                      (xml2trs_termination_proof (A1_, A2_, A3_)
(B1_, B2_, B3_) xml2name)
                                      (fn b =>
xml_return (Switch_Innermost (a, b))))))
                              (xml_or
                                (xml_do
                                  [#"p", #"e", #"r", #"m", #"u", #"t", #"i",
                                    #"n", #"g", #"A", #"r", #"g", #"u", #"m",
                                    #"e", #"n", #"t", #"F", #"i", #"l", #"t",
                                    #"e", #"r"]
                                  (xml_take (afs (show_lab A3_ B3_) xml2name)
                                    (fn a =>
                                      xml_take
(xml2trs_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
(fn b => xml_return (Permuting_AFS (a, b))))))
                                (xml_or
                                  (xml_do
                                    [#"t", #"e", #"r", #"m", #"i", #"n", #"a",
                                      #"t", #"i", #"o", #"n", #"A", #"s", #"s",
                                      #"u", #"m", #"p", #"t", #"i", #"o", #"n"]
                                    (xml_take
                                      (xml2inn_trs_assm
(equal_lab A1_ B1_, show_lab A3_ B3_) xml2name)
                                      (fn xa =>
xml_return (Assume_SN (xa, [])))))
                                  (xml_or
                                    (xml_do
                                      [#"r", #"e", #"l", #"a", #"t", #"i", #"v",
#"e", #"T", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n", #"A",
#"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n"]
                                      (xml_take
(xml_do [#"t", #"r", #"s", #"I", #"n", #"p", #"u", #"t"]
  (xml_take
    (xml_do [#"t", #"r", #"s"]
      (xml_take (rules (show_lab A3_ B3_) xml2name)
        (fn xa => xml_return (id xa))))
    (fn r =>
      xml_take_default []
        (xml_do
          [#"r", #"e", #"l", #"a", #"t", #"i", #"v", #"e", #"R", #"u", #"l",
            #"e", #"s"]
          (xml_take (rules (show_lab A3_ B3_) xml2name)
            (fn xa => xml_return (id xa))))
        (fn rw =>
          xml_return (Assume_SN ((default_nfs_trs, ([], (r, rw))), []))))))
xml_return))
                                    (xml_do
                                      [#"u", #"n", #"k", #"n", #"o", #"w", #"n",
#"P", #"r", #"o", #"o", #"f"]
                                      (xml_take
(xml_text [#"d", #"e", #"s", #"c", #"r", #"i", #"p", #"t", #"i", #"o", #"n"])
(fn _ =>
  xml_take (xml2inn_trs_assm (equal_lab A1_ B1_, show_lab A3_ B3_) xml2name)
    (fn b =>
      xml_take_many_sub [] zero_nata Infinity_enat (fn xa => Inr (fst xa))
        (fn _ => xml_return (Assume_SN (b, [])))))))))))))))))))))))
    x;

fun rule_labeling_function (A1_, A2_) (B1_, B2_) xml2name =
  xml_do
    [#"r", #"u", #"l", #"e", #"L", #"a", #"b", #"e", #"l", #"i", #"n", #"g",
      #"F", #"u", #"n", #"c", #"t", #"i", #"o", #"n"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"r", #"u", #"l", #"e", #"L", #"a", #"b", #"e", #"l", #"i", #"n", #"g",
          #"F", #"u", #"n", #"c", #"t", #"i", #"o", #"n", #"E", #"n", #"t",
          #"r", #"y"]
        (xml_take (rule (show_lab A2_ B2_) xml2name)
          (fn a =>
            xml_take (xml_nat [#"l", #"a", #"b", #"e", #"l"])
              (fn b => xml_return (a, b)))))
      (fn a => xml_return (id a)));

fun add_source_lab_proof (Rule_Labeling (rl, js, uu)) uv prf =
  Rule_Labeling (rl, js, SOME prf)
  | add_source_lab_proof (Rule_Labeling_Conv (rl, cs, uw)) (SOME n) prf =
    Rule_Labeling_Conv (rl, cs, SOME (n, prf));

fun xml2cr_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name x =
  xml_do [#"c", #"r", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_do [#"w", #"c", #"r", #"A", #"n", #"d", #"S", #"N"]
          (xml_take (wcr_proof (show_lab A3_ B3_) xml2name)
            (fn a =>
              xml_take
                (xml2trs_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                  xml2name)
                (fn b => xml_return (SN_WCR (a, b))))))
        (xml_or
          (xml_leaf [#"o", #"r", #"t", #"h", #"o", #"g", #"o", #"n", #"a", #"l"]
            Weakly_Orthogonal)
          (xml_or
            (xml_change
              (xml_nat
                [#"s", #"t", #"r", #"o", #"n", #"g", #"l", #"y", #"C", #"l",
                  #"o", #"s", #"e", #"d"])
              (xml_return o Strongly_Closed))
            (xml_or
              (xml_change
                (xml_do
                  [#"p", #"a", #"r", #"a", #"l", #"l", #"e", #"l", #"C", #"l",
                    #"o", #"s", #"e", #"d"]
                  (nat_or_empty (show_list (show_list show_char))))
                (xml_return o Parallel_Closed))
              (xml_or
                (xml_do
                  [#"c", #"r", #"i", #"t", #"i", #"c", #"a", #"l", #"P", #"a",
                    #"i", #"r", #"C", #"l", #"o", #"s", #"i", #"n", #"g", #"S",
                    #"y", #"s", #"t", #"e", #"m"]
                  (xml_take
                    (xml_do [#"t", #"r", #"s"]
                      (xml_take (rules (show_lab A3_ B3_) xml2name)
                        (fn xa => xml_return (id xa))))
                    (fn a =>
                      xml_take
                        (xml2trs_termination_proof (A1_, A2_, A3_)
                          (B1_, B2_, B3_) xml2name)
                        (fn b =>
                          xml_take
                            (xml_nat [#"n", #"r", #"S", #"t", #"e", #"p", #"s"])
                            (fn c =>
                              xml_return
                                (Critical_Pair_Closing_System (a, b, c)))))))
                (xml_or
                  (xml_do
                    [#"r", #"u", #"l", #"e", #"L", #"a", #"b", #"e", #"l", #"i",
                      #"n", #"g"]
                    (xml_take
                      (rule_labeling_function (A2_, A3_) (B2_, B3_) xml2name)
                      (fn a =>
                        xml_take
                          (joinable_critical_pairs (show_lab A3_ B3_) xml2name)
                          (fn b => xml_return (Rule_Labeling (a, b, NONE))))))
                  (xml_or
                    (xml_do
                      [#"d", #"e", #"c", #"r", #"e", #"a", #"s", #"i", #"n",
                        #"g", #"D", #"i", #"a", #"g", #"r", #"a", #"m", #"s"]
                      (xml_take_optional
                        (xml2trs_termination_proof (A1_, A2_, A3_)
                          (B1_, B2_, B3_) xml2name)
                        (fn a =>
                          xml_take
                            (xml_or
                              (xml_do
                                [#"r", #"u", #"l", #"e", #"L", #"a", #"b", #"e",
                                  #"l", #"i", #"n", #"g"]
                                (xml_take
                                  (rule_labeling_function (A2_, A3_) (B2_, B3_)
                                    xml2name)
                                  (fn rl =>
                                    xml_take
                                      (joinable_critical_pairs
(show_lab A3_ B3_) xml2name)
                                      (fn js =>
(case a of NONE => xml_return (Rule_Labeling (rl, js, NONE))
  | SOME prf =>
    xml_return
      (add_source_lab_proof (Rule_Labeling (rl, js, NONE)) NONE prf))))))
                              (xml_do
                                [#"r", #"u", #"l", #"e", #"L", #"a", #"b", #"e",
                                  #"l", #"i", #"n", #"g", #"C", #"o", #"n",
                                  #"v"]
                                (xml_take
                                  (rule_labeling_function (A2_, A3_) (B2_, B3_)
                                    xml2name)
                                  (fn rl =>
                                    xml_take
                                      (convertible_critical_peaks
(show_lab A3_ B3_) xml2name)
                                      (fn cs =>
(case a of NONE => xml_return (Rule_Labeling_Conv (rl, cs, NONE))
  | SOME prf =>
    xml_take (xml_nat [#"n", #"r", #"S", #"t", #"e", #"p", #"s"])
      (fn n =>
        xml_return
          (add_source_lab_proof (Rule_Labeling_Conv (rl, cs, NONE)) (SOME n)
            prf))))))))
                            xml_return)))
                    (xml_do
                      [#"r", #"e", #"d", #"u", #"n", #"d", #"a", #"n", #"t",
                        #"R", #"u", #"l", #"e", #"s"]
                      (xml_take
                        (xml_do [#"t", #"r", #"s"]
                          (xml_take (rules (show_lab A3_ B3_) xml2name)
                            (fn xa => xml_return (id xa))))
                        (fn trs =>
                          xml_take
                            (xml_nat [#"n", #"r", #"S", #"t", #"e", #"p", #"s"])
                            (fn n =>
                              xml_take_default []
                                (xml_do
                                  [#"c", #"o", #"n", #"v", #"e", #"r", #"s",
                                    #"i", #"o", #"n", #"s"]
                                  (xml_take_many_sub [] zero_nata Infinity_enat
                                    (conversion (show_lab A3_ B3_) xml2name)
                                    (fn a => xml_return (map snd a))))
                                (fn cs =>
                                  xml_take
                                    (xml2cr_proof (A1_, A2_, A3_)
                                      (B1_, B2_, B3_) xml2name)
                                    (fn prf =>
                                      xml_return
(Redundant_Rules (trs, n, cs, prf)))))))))))))))
      (fn xa => xml_return (id xa)))
    x;

fun xml2eq_proof A_ xml2name x =
  xml_or
    (xml_do [#"r", #"e", #"f", #"l"]
      (xml_take (term A_ xml2name) (fn xa => xml_return (Refl xa))))
    (xml_or
      (xml_do [#"s", #"y", #"m"]
        (xml_take (xml2eq_proof A_ xml2name) (fn xa => xml_return (Sym xa))))
      (xml_or
        (xml_do [#"t", #"r", #"a", #"n", #"s"]
          (xml_take (xml2eq_proof A_ xml2name)
            (fn a =>
              xml_take (xml2eq_proof A_ xml2name)
                (fn b => xml_return (Trans (a, b))))))
        (xml_or
          (xml_do [#"a", #"s", #"s", #"m"]
            (xml_take (rule A_ xml2name)
              (fn a =>
                xml_take (substa A_ xml2name)
                  (fn b =>
                    xml_return
                      (Assm (a, mk_subst (equal_list equal_char) Var b))))))
          (xml_do [#"c", #"o", #"n", #"g"]
            (xml_take xml2name
              (fn a =>
                xml_take_many_sub [] zero_nata Infinity_enat
                  (xml2eq_proof A_ xml2name)
                  (fn b => xml_return (Cong (a, b)))))))))
    x;

fun mk_cpx (B1_, B2_) (C1_, C2_) i (q, (s, (w, (cm, cc)))) =
  (mkc i false q s w, (cm, cc));

fun mk_tp i (nfs, (q, (r, rw))) = mkc i nfs q r rw;

fun in_vars_formula A_ x (Atom a) = membera A_ (vars_term_list a) x
  | in_vars_formula A_ x (NegAtom a) = membera A_ (vars_term_list a) x
  | in_vars_formula A_ x (Conjunction phi_s) =
    list_ex (in_vars_formula A_ x) phi_s
  | in_vars_formula A_ x (Disjunction phi_s) =
    list_ex (in_vars_formula A_ x) phi_s;

fun trivial_checker A_ lits = let
                                val (asa, nas) = partition is_Atom lits;
                                val pos = map get_Atom asa;
                                val neg = map get_Atom nas;
                              in
                                list_ex (membera A_ neg) pos
                              end;

fun trivial_formula (Disjunction phi_s) = list_ex trivial_formula phi_s
  | trivial_formula (Conjunction phi_s) = list_all trivial_formula phi_s
  | trivial_formula (Atom v) = false
  | trivial_formula (NegAtom v) = false;

fun find_max_nat n uu =
  (if equal_nata n zero_nata then zero_nata
    else (if uu (minus_nata n one_nata) then minus_nata n one_nata
           else find_max_nat (minus_nata n one_nata) uu));

fun rbt_lookup less (Branch (uu, l, x, y, r)) k =
  (if less k x then rbt_lookup less l k
    else (if less x k then rbt_lookup less r k else SOME y))
  | rbt_lookup less Emptya k = NONE;

fun idx_of_tr A_ s v =
  let
    val (_, (aa, (ab, _))) = v;
    val x =
      let
        val SOME i =
          rbt_lookup
            (less ((ord_preorder o preorder_order o order_linorder) A_)) ab s;
        val true = less_eq_int zero_inta i;
      in
        nat i
      end;
    val xa = find_max_nat (as_length aa) (fn j => less_eq_nat (as_get aa j) x);
  in
    xa
  end;

fun gi_E (Gen_g_impl_ext (gi_V, gi_E, gi_V0, more)) = gi_E;

fun stat_newnode x = (fn _ => ()) x;

fun is_Nil a = (case a of [] => true | _ :: _ => false);

fun as_push s x =
  let
    val a = s;
    val (aa, n) = a;
    val ab =
      (if equal_nata n (array_length aa)
        then array_grow aa
               (max ord_nat (nat_of_integer (4 : IntInf.int))
                 (times_nata (nat_of_integer (2 : IntInf.int)) n))
               x
        else aa);
    val ac = array_set ab n x;
  in
    (ac, plus_nata n one_nata)
  end;

fun push_code A_ g_impl =
  (fn x => fn (xa, (xb, (xc, xd))) =>
    let
      val _ = stat_newnode ();
      val xf = as_length xa;
      val xg = as_push xa x;
      val xh = as_push xb xf;
      val xi = rbt_insert A_ x (int_of_nat xf) xc;
      val xj =
        (if is_Nil (gi_E g_impl x) then xd else as_push xd (xf, gi_E g_impl x));
    in
      (xg, (xh, (xi, xj)))
    end);

fun nFQ_subset_NF_rulesc
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = nFQ_subset_NF_rules;

fun is_QNFc
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = is_QNF;

fun rulese
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = rules;

fun icap_impl_dpp B_ i d =
  let
    val qr = nFQ_subset_NF_rulesc i d;
    val qnf = is_QNFc i d;
    val r = rulese i d;
    val ic = icap_impl_gen B_ qr qnf (map fst r);
  in
    (fn s =>
      let
        val a =
          ceta_set_of (key_list (equal_char, key_char)) (maps vars_term_list s);
      in
        ic s a
      end)
  end;

fun as_set s i x = let
                     val a = s;
                     val (aa, b) = a;
                   in
                     (array_set aa i x, b)
                   end;

fun of_inta A_ k =
  (if equal_inta k zero_inta
    then zerob ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
                  semiring_1_semiring_1_cancel o semiring_1_cancel_ring_1)
                 A_)
    else (if less_int k zero_inta
           then uminus
                  ((uminus_group_add o group_add_neg_numeral o
                     neg_numeral_ring_1)
                    A_)
                  (of_inta A_ (uminus_inta k))
           else let
                  val l =
                    times ((times_power o power_monoid_mult o
                             monoid_mult_semiring_numeral o
                             semiring_numeral_semiring_1 o
                             semiring_1_semiring_1_cancel o
                             semiring_1_cancel_ring_1)
                            A_)
                      (numeral ((numeral_neg_numeral o neg_numeral_ring_1) A_)
                        (Bit0 One))
                      (of_inta A_
                        (divide_inta k (Int_of_integer (2 : IntInf.int))));
                  val j = modulo_inta k (Int_of_integer (2 : IntInf.int));
                in
                  (if equal_inta j zero_inta then l
                    else plus ((plus_semigroup_add o semigroup_add_numeral o
                                 numeral_neg_numeral o neg_numeral_ring_1)
                                A_)
                           l (onea ((one_numeral o numeral_neg_numeral o
                                      neg_numeral_ring_1)
                                     A_)))
                end));

fun shows_kbo_repr A_ (prs, w0) =
  shows_prec_list show_char zero_nata
    [#"K", #"B", #"O", #" ", #"w", #"i", #"t", #"h", #" ", #"t", #"h", #"e",
      #" ", #"f", #"o", #"l", #"l", #"o", #"w", #"i", #"n", #"g", #" ", #"p",
      #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c", #"e", #" ", #"a", #"n",
      #"d", #" ", #"w", #"e", #"i", #"g", #"h", #"t", #" ", #"f", #"u", #"n",
      #"c", #"t", #"i", #"o", #"n"] o
    shows_nl o
    foldr (fn (a, b) =>
            let
              val (f, n) = a;
            in
              (fn (pr, (_, _)) =>
                shows_prec_list show_char zero_nata
                  [#"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c", #"e",
                    #"("] o
                  shows_prec A_ zero_nata f o
                  shows_prec_list show_char zero_nata [#"["] o
                  shows_prec_nat zero_nata n o
                  shows_prec_list show_char zero_nata
                    [#"]", #")", #" ", #"=", #" "] o
                  shows_prec_nat zero_nata pr o
                  shows_nl)
            end
              b)
      prs o
    shows_nl o
    shows_prec_list show_char zero_nata
      [#"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c", #"e", #"(", #"_",
        #")", #" ", #"=", #" ", #"0"] o
    shows_nl o
    shows_prec_list show_char zero_nata
      [#"a", #"n", #"d", #" ", #"t", #"h", #"e", #" ", #"f", #"o", #"l", #"l",
        #"o", #"w", #"i", #"n", #"g", #" ", #"w", #"e", #"i", #"g", #"h",
        #"t"] o
    shows_nl o
    foldr (fn (a, b) =>
            let
              val (f, n) = a;
            in
              (fn (_, (w, _)) =>
                shows_prec_list show_char zero_nata
                  [#"w", #"e", #"i", #"g", #"h", #"t", #"("] o
                  shows_prec A_ zero_nata f o
                  shows_prec_list show_char zero_nata [#"["] o
                  shows_prec_nat zero_nata n o
                  shows_prec_list show_char zero_nata
                    [#"]", #")", #" ", #"=", #" "] o
                  shows_prec_nat zero_nata w o
                  shows_nl)
            end
              b)
      prs o
    shows_nl o
    shows_prec_list show_char zero_nata
      [#"w", #"e", #"i", #"g", #"h", #"t", #"(", #"_", #")", #" ", #"=", #" "] o
    shows_prec_nat zero_nata (suc w0) o
    shows_nl o
    shows_prec_list show_char zero_nata [#"w", #"0", #" ", #"=", #" "] o
    shows_prec_nat zero_nata w0 o
    shows_nl o
    shows_prec_list show_char zero_nata
      [#"a", #"n", #"d", #" ", #"t", #"h", #"e", #" ", #"f", #"o", #"l", #"l",
        #"o", #"w", #"i", #"n", #"g", #" ", #"s", #"u", #"b", #"t", #"e", #"r",
        #"m", #" ", #"c", #"o", #"e", #"f", #"f", #"i", #"c", #"i", #"e", #"n",
        #"t", #" ", #"f", #"u", #"n", #"c", #"t", #"i", #"o", #"n", #"s"] o
    shows_nl o
    foldr (fn (a, b) =>
            let
              val (f, n) = a;
            in
              (fn (_, (_, scf)) =>
                shows_prec_list show_char zero_nata [#"s", #"c", #"f", #"("] o
                  shows_prec A_ zero_nata f o
                  shows_prec_list show_char zero_nata [#"["] o
                  shows_prec_nat zero_nata n o
                  shows_prec_list show_char zero_nata
                    [#"]", #")", #" ", #"=", #" "] o
                  (if is_none scf
                    then shows_prec_list show_char zero_nata
                           [#"a", #"l", #"l", #" ", #"1"]
                    else shows_prec_list show_nat zero_nata (the scf)) o
                  shows_nl)
            end
              b)
      prs o
    shows_nl o
    shows_prec_list show_char zero_nata
      [#"s", #"c", #"f", #"(", #"_", #")", #" ", #"=", #" ", #"a", #"l", #"l",
        #" ", #"1"] o
    shows_nl;

fun roots_of_cm (Derivational_Complexity f) = f
  | roots_of_cm (Runtime_Complexity (c, d)) = d;

fun sym_collect p (Var x) = []
  | sym_collect p (Fun (f, ts)) =
    (if p (Fun (f, ts)) then [f] else []) @ maps (sym_collect p) ts;

fun upper_triangular (A1_, A2_) a =
  all_interval_nat
    (fn i =>
      all_interval_nat (fn j => eq A2_ (index_mat a (i, j)) (zerob A1_))
        zero_nata i)
    zero_nata (dim_row a);

fun list_inter A_ [] bs = []
  | list_inter A_ (a :: asa) bs =
    (if membera A_ bs a then a :: list_inter A_ asa bs
      else list_inter A_ asa bs);

fun list_union A_ [] ys = ys
  | list_union A_ (x :: xs) ys = let
                                   val zs = list_union A_ xs ys;
                                 in
                                   (if membera A_ zs x then zs else x :: zs)
                                 end;

fun pat_of (OC1 (rl, uu)) =
  (([], ((zero_nata, (zero_nata, [])), fst rl)),
    ([], ((zero_nata, (zero_nata, [])), snd rl)))
  | pat_of (OC2 (rl, uv, uw, ux, uy, uz)) =
    (([], ((zero_nata, (zero_nata, [])), fst rl)),
      ([], ((zero_nata, (zero_nata, [])), snd rl)))
  | pat_of (OC2p (rl, va, vb, vc, vd, ve)) =
    (([], ((zero_nata, (zero_nata, [])), fst rl)),
      ([], ((zero_nata, (zero_nata, [])), snd rl)))
  | pat_of (OC3 (rl, vf, vg, vh, vi)) =
    (([], ((zero_nata, (zero_nata, [])), fst rl)),
      ([], ((zero_nata, (zero_nata, [])), snd rl)))
  | pat_of (OC3p (rl, vj, vk, vl, vm)) =
    (([], ((zero_nata, (zero_nata, [])), fst rl)),
      ([], ((zero_nata, (zero_nata, [])), snd rl)))
  | pat_of (OCDP1 (p, vn)) = p
  | pat_of (OCDP2 (p, vo)) = p
  | pat_of (WPEQ (p, vp)) = p
  | pat_of (Lift (p, vq)) = p
  | pat_of (DPOC1_1 (p, vr, vs, vt, vu)) = p
  | pat_of (DPOC1_2 (p, vv, vw, vx, vy, vz)) = p
  | pat_of (DPOC2 (p, wa, wb, wc, wd)) = p
  | pat_of (DPOC3_1 (p, we, wf, wg, wh)) = p
  | pat_of (DPOC3_2 (p, wi, wj, wk, wl, wm)) = p
  | pat_of (DPDP1_1 (p, wn, wo, wp, wq)) = p
  | pat_of (DPDP1_2 (p, wr, ws, wt, wu)) = p
  | pat_of (DPDP2_1 (p, wv, ww, wx, wy)) = p
  | pat_of (DPDP2_2 (p, wz, xa, xb, xc)) = p;

fun power A_ a n =
  (if equal_nata n zero_nata then onea (one_power A_)
    else times (times_power A_) a (power A_ a (minus_nata n one_nata)));

fun mk_rtrancl_list_main subsumes r todo fin =
  (case todo of [] => fin
    | a :: tod =>
      (if list_ex (fn b => subsumes b a) fin
        then mk_rtrancl_list_main subsumes r tod fin
        else mk_rtrancl_list_main subsumes r (r a @ tod) (a :: fin)));

fun mk_rtrancl_list subsumes r init = mk_rtrancl_list_main subsumes r init [];

fun ins_dj_rm_basic_ops A_ x s = insert A_ x () s;

fun mk_rtrancl_set_main A_ r todo fin =
  (case todo of [] => fin
    | a :: tod =>
      (if memb_rm_basic_ops A_ a fin then mk_rtrancl_set_main A_ r tod fin
        else mk_rtrancl_set_main A_ r (r a @ tod)
               (ins_dj_rm_basic_ops A_ a fin)));

fun mk_rtrancl_set A_ r init =
  mk_rtrancl_set_main A_ r init
    (empty_rm_basic_ops (linorder_compare_order A_) ());

fun eq_rules_no_left_vara
  (Ac_dpp_ops_ext
    (ac_dpp, p, pw, pairs, r, rw, rules, e, mk, eq_rules_map,
      reverse_eq_rules_map, delete_pairs_rules, eq_rules_no_left_var,
      eq_rules_non_collapsing, intersect_pairs, more))
  = eq_rules_no_left_var;

fun eq_rules_map
  (Ac_dpp_ops_ext
    (ac_dpp, p, pw, pairs, r, rw, rules, e, mk, eq_rules_map,
      reverse_eq_rules_map, delete_pairs_rules, eq_rules_no_left_var,
      eq_rules_non_collapsing, intersect_pairs, more))
  = eq_rules_map;

fun tcapRM_ac_dpp B_ C_ i dpp =
  tcapRM B_ C_ (eq_rules_no_left_vara i dpp) (eq_rules_map i dpp);

fun subst_compose_impl A_ B_ sigma tau =
  let
    val sigmaa = mk_subst_domain A_ B_ sigma;
    val taua = mk_subst_domain A_ B_ tau;
    val d_sigma = map fst sigmaa;
  in
    map (fn (x, t) => (x, subst_apply_term t (mk_subst A_ Var taua))) sigmaa @
      filtera (fn (x, _) => not (membera A_ d_sigma x)) taua
  end;

fun commutes_impl (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) sigma mu =
  subst_eq (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_)
    (subst_compose_impl A5_ B2_ sigma mu) (subst_compose_impl A5_ B2_ mu sigma);

fun mk_subst_case A_ B_ xs sigma tau =
  subst_compose_impl A_ B_ (map (fn x => (x, sigma x)) xs) tau;

fun ta_matcha (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) (C1_, C2_) ta q t =
  ta_match (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) (C1_, C2_) ta q t q;

fun adapt_vars (Fun (f, ts)) = Fun (f, map adapt_vars ts);

fun ta_member (A1_, A2_) (C1_, C2_, C3_, C4_, C5_) t ta =
  ground t andalso
    not (less_eq_set (C1_, C2_, C3_)
          (inf_seta (C2_, C3_) (ta_final ta)
            (ta_res (C1_, C2_, C3_, C4_, C5_) (A1_, A2_) ta (adapt_vars t)))
          (bot_set (C2_, C3_, C5_)));

fun rhs_eps_cl_memo (A1_, A2_) (B1_, B2_, B3_, B4_, B5_) (C1_, C2_) memo rules =
  sup_setb (B1_, B2_, B3_, B4_, B5_)
    (image (ceq_ta_rule A2_ C2_, ccompare_ta_rule A1_ C1_)
      (ceq_set (B2_, B3_, ccompare_cproper_interval B4_),
        ccompare_set (B1_, B3_, B4_, B5_), set_impl_set)
      (memo o r_rhs) rules);

fun list_intera (A1_, A2_, A3_) [] = top_set (A1_, A2_, A3_)
  | list_intera (A1_, A2_, A3_) [x] = x
  | list_intera (A1_, A2_, A3_) (x :: v :: va) =
    inf_seta (A1_, A2_) x (list_intera (A1_, A2_, A3_) (v :: va));

fun ps_states_cons_impl (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_, B4_, B5_)
  (C1_, C2_) (D1_, D2_) meps parts rules q =
  let
    val lhs_nth_in_Q =
      (fn (n, rs) =>
        map (fn i =>
              minus_set
                (ceq_set
                   (cenum_ta_rule, ceq_ta_rule A5_ D2_,
                     ccompare_cproper_interval
                       (cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                         D1_)),
                  ccompare_set
                    (finite_UNIV_ta_rule, ceq_ta_rule A5_ D2_,
                      cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                        D1_,
                      set_impl_ta_rule))
                (image
                  (ceq_set (A2_, A3_, ccompare_cproper_interval A4_),
                    ccompare_set (A1_, A3_, A4_, A6_))
                  (ceq_set
                     (cenum_ta_rule, ceq_ta_rule A5_ D2_,
                       ccompare_cproper_interval
                         (cproper_interval_ta_rule
                           (ccompare_cproper_interval A4_) D1_)),
                    ccompare_set
                      (finite_UNIV_ta_rule, ceq_ta_rule A5_ D2_,
                        cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                          D1_,
                        set_impl_ta_rule),
                    set_impl_set)
                  (fn p =>
                    filter
                      (ceq_ta_rule A5_ D2_,
                        ccompare_ta_rule (ccompare_cproper_interval A4_) D1_)
                      (fn r =>
                        member (A3_, ccompare_cproper_interval A4_)
                          (nth (r_lhs_states r) i) p)
                      rs)
                  q)
                (inserta
                  (ceq_set
                     (cenum_ta_rule, ceq_ta_rule A5_ D2_,
                       ccompare_cproper_interval
                         (cproper_interval_ta_rule
                           (ccompare_cproper_interval A4_) D1_)),
                    ccompare_set
                      (finite_UNIV_ta_rule, ceq_ta_rule A5_ D2_,
                        cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                          D1_,
                        set_impl_ta_rule))
                  (set_empty
                    (ceq_ta_rule A5_ D2_,
                      ccompare_ta_rule (ccompare_cproper_interval A4_) D1_)
                    (of_phantom set_impl_ta_rulea))
                  (set_empty
                    (ceq_set
                       (cenum_ta_rule, ceq_ta_rule A5_ D2_,
                         ccompare_cproper_interval
                           (cproper_interval_ta_rule
                             (ccompare_cproper_interval A4_) D1_)),
                      ccompare_set
                        (finite_UNIV_ta_rule, ceq_ta_rule A5_ D2_,
                          cproper_interval_ta_rule
                            (ccompare_cproper_interval A4_) D1_,
                          set_impl_ta_rule))
                    (of_phantom set_impl_seta))))
          (upt zero_nata n));
  in
    sup_setb
      (finite_UNIV_set (finite_UNIV_card_UNIV B1_),
        cenum_set (B2_, B3_, ccompare_cproper_interval B4_, B5_),
        ceq_set (B2_, B3_, ccompare_cproper_interval B4_),
        cproper_interval_set (B1_, B3_, B4_, B5_), set_impl_set)
      (image
        (ceq_prod C1_
           (ceq_prod ceq_nat
             (ceq_set
               (cenum_ta_rule, ceq_ta_rule A5_ D2_,
                 ccompare_cproper_interval
                   (cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                     D1_)))),
          ccompare_prod C2_
            (ccompare_prod ccompare_nat
              (ccompare_set
                (finite_UNIV_ta_rule, ceq_ta_rule A5_ D2_,
                  cproper_interval_ta_rule (ccompare_cproper_interval A4_) D1_,
                  set_impl_ta_rule))))
        (ceq_set
           (cenum_set (B2_, B3_, ccompare_cproper_interval B4_, B5_),
             ceq_set (B2_, B3_, ccompare_cproper_interval B4_),
             ccompare_cproper_interval
               (cproper_interval_set (B1_, B3_, B4_, B5_))),
          ccompare_set
            (finite_UNIV_set (finite_UNIV_card_UNIV B1_),
              ceq_set (B2_, B3_, ccompare_cproper_interval B4_),
              cproper_interval_set (B1_, B3_, B4_, B5_), set_impl_set),
          set_impl_set)
        (fn (_, nrs) =>
          minus_set
            (ceq_set (B2_, B3_, ccompare_cproper_interval B4_),
              ccompare_set (finite_UNIV_card_UNIV B1_, B3_, B4_, B5_))
            (image
              (ceq_list
                 (ceq_set
                   (cenum_ta_rule, ceq_ta_rule A5_ D2_,
                     ccompare_cproper_interval
                       (cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                         D1_))),
                ccompare_list
                  (ccompare_set
                    (finite_UNIV_ta_rule, ceq_ta_rule A5_ D2_,
                      cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                        D1_,
                      set_impl_ta_rule)))
              (ceq_set (B2_, B3_, ccompare_cproper_interval B4_),
                ccompare_set (finite_UNIV_card_UNIV B1_, B3_, B4_, B5_),
                set_impl_set)
              (fn rs =>
                rhs_eps_cl_memo (ccompare_cproper_interval A4_, A5_)
                  (finite_UNIV_card_UNIV B1_, B2_, B3_, B4_, B5_) (D1_, D2_)
                  meps
                  (list_intera
                    (ceq_ta_rule A5_ D2_,
                      ccompare_ta_rule (ccompare_cproper_interval A4_) D1_,
                      set_impl_ta_rule)
                    rs))
              (listset
                (ceq_set
                   (cenum_ta_rule, ceq_ta_rule A5_ D2_,
                     ccompare_cproper_interval
                       (cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                         D1_)),
                  ccompare_set
                    (finite_UNIV_ta_rule, ceq_ta_rule A5_ D2_,
                      cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                        D1_,
                      set_impl_ta_rule),
                  set_impl_set)
                (lhs_nth_in_Q nrs)))
            (inserta
              (ceq_set (B2_, B3_, ccompare_cproper_interval B4_),
                ccompare_set (finite_UNIV_card_UNIV B1_, B3_, B4_, B5_))
              (bot_set (B3_, ccompare_cproper_interval B4_, B5_))
              (set_empty
                (ceq_set (B2_, B3_, ccompare_cproper_interval B4_),
                  ccompare_set (finite_UNIV_card_UNIV B1_, B3_, B4_, B5_))
                (of_phantom set_impl_seta))))
        parts)
  end;

fun ps_states_nil_impl (A1_, A2_) (B1_, B2_, B3_, B4_, B5_) (C1_, C2_, C3_, C4_)
  meps rules =
  let
    val rsz =
      filter (ceq_ta_rule A2_ C3_, ccompare_ta_rule A1_ C2_)
        (fn r => null (r_lhs_states r)) rules;
  in
    image (C1_, C2_)
      (ceq_set (B2_, B3_, ccompare_cproper_interval B4_),
        ccompare_set (B1_, B3_, B4_, B5_), set_impl_set)
      (fn f =>
        rhs_eps_cl_memo (A1_, A2_) (B1_, B2_, B3_, B4_, B5_) (C2_, C3_) meps
          (filter (ceq_ta_rule A2_ C3_, ccompare_ta_rule A1_ C2_)
            (fn r => eq C3_ (r_root r) f) rsz))
      (image (ceq_ta_rule A2_ C3_, ccompare_ta_rule A1_ C2_) (C1_, C2_, C4_)
        r_root rsz)
  end;

fun ps_rules_cons_impl (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_) (C1_, C2_)
  meps parts rules q =
  let
    val lhs_nth =
      (fn (n, rs) =>
        map (fn i =>
              filter
                (ceq_prod (ceq_set (A2_, A3_, ccompare_cproper_interval A4_))
                   (ceq_set
                     (cenum_ta_rule, ceq_ta_rule A5_ C2_,
                       ccompare_cproper_interval
                         (cproper_interval_ta_rule
                           (ccompare_cproper_interval A4_) C1_))),
                  ccompare_prod
                    (ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_))
                    (ccompare_set
                      (finite_UNIV_ta_rule, ceq_ta_rule A5_ C2_,
                        cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                          C1_,
                        set_impl_ta_rule)))
                (fn x =>
                  not (set_eq
                        (cenum_ta_rule, ceq_ta_rule A5_ C2_,
                          ccompare_ta_rule (ccompare_cproper_interval A4_) C1_)
                        (snd x)
                        (set_empty
                          (ceq_ta_rule A5_ C2_,
                            ccompare_ta_rule (ccompare_cproper_interval A4_)
                              C1_)
                          (of_phantom set_impl_ta_rulea))))
                (image
                  (ceq_set (A2_, A3_, ccompare_cproper_interval A4_),
                    ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_))
                  (ceq_prod (ceq_set (A2_, A3_, ccompare_cproper_interval A4_))
                     (ceq_set
                       (cenum_ta_rule, ceq_ta_rule A5_ C2_,
                         ccompare_cproper_interval
                           (cproper_interval_ta_rule
                             (ccompare_cproper_interval A4_) C1_))),
                    ccompare_prod
                      (ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_))
                      (ccompare_set
                        (finite_UNIV_ta_rule, ceq_ta_rule A5_ C2_,
                          cproper_interval_ta_rule
                            (ccompare_cproper_interval A4_) C1_,
                          set_impl_ta_rule)),
                    set_impl_prod set_impl_set set_impl_set)
                  (fn p =>
                    (p, filter
                          (ceq_ta_rule A5_ C2_,
                            ccompare_ta_rule (ccompare_cproper_interval A4_)
                              C1_)
                          (fn r =>
                            member (A3_, ccompare_cproper_interval A4_)
                              (nth (r_lhs_states r) i) p)
                          rs))
                  q))
          (upt zero_nata n));
  in
    sup_setb
      (finite_UNIV_ta_rule, cenum_ta_rule,
        ceq_ta_rule (equal_set (A2_, A3_, ccompare_cproper_interval A4_, A5_))
          B3_,
        cproper_interval_ta_rule
          (ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_)) B2_,
        set_impl_ta_rule)
      (image
        (ceq_prod B1_
           (ceq_prod ceq_nat
             (ceq_set
               (cenum_ta_rule, ceq_ta_rule A5_ C2_,
                 ccompare_cproper_interval
                   (cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                     C1_)))),
          ccompare_prod B2_
            (ccompare_prod ccompare_nat
              (ccompare_set
                (finite_UNIV_ta_rule, ceq_ta_rule A5_ C2_,
                  cproper_interval_ta_rule (ccompare_cproper_interval A4_) C1_,
                  set_impl_ta_rule))))
        (ceq_set
           (cenum_ta_rule,
             ceq_ta_rule
               (equal_set (A2_, A3_, ccompare_cproper_interval A4_, A5_)) B3_,
             ccompare_cproper_interval
               (cproper_interval_ta_rule
                 (ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_))
                 B2_)),
          ccompare_set
            (finite_UNIV_ta_rule,
              ceq_ta_rule
                (equal_set (A2_, A3_, ccompare_cproper_interval A4_, A5_)) B3_,
              cproper_interval_ta_rule
                (ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_)) B2_,
              set_impl_ta_rule),
          set_impl_set)
        (fn (f, nrs) =>
          filter
            (ceq_ta_rule
               (equal_set (A2_, A3_, ccompare_cproper_interval A4_, A5_)) B3_,
              ccompare_ta_rule
                (ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_)) B2_)
            (fn r => not (is_empty (A1_, A3_, A4_, A6_) (r_rhs r)))
            (image
              (ceq_list
                 (ceq_prod (ceq_set (A2_, A3_, ccompare_cproper_interval A4_))
                   (ceq_set
                     (cenum_ta_rule, ceq_ta_rule A5_ C2_,
                       ccompare_cproper_interval
                         (cproper_interval_ta_rule
                           (ccompare_cproper_interval A4_) C1_)))),
                ccompare_list
                  (ccompare_prod
                    (ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_))
                    (ccompare_set
                      (finite_UNIV_ta_rule, ceq_ta_rule A5_ C2_,
                        cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                          C1_,
                        set_impl_ta_rule))))
              (ceq_ta_rule
                 (equal_set (A2_, A3_, ccompare_cproper_interval A4_, A5_)) B3_,
                ccompare_ta_rule
                  (ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_)) B2_,
                set_impl_ta_rule)
              (fn rs =>
                TA_rule
                  (f, map fst rs,
                    rhs_eps_cl_memo (ccompare_cproper_interval A4_, A5_)
                      (finite_UNIV_card_UNIV A1_, A2_, A3_, A4_, A6_) (C1_, C2_)
                      meps
                      (list_intera
                        (ceq_ta_rule A5_ C2_,
                          ccompare_ta_rule (ccompare_cproper_interval A4_) C1_,
                          set_impl_ta_rule)
                        (map snd rs))))
              (listset
                (ceq_prod (ceq_set (A2_, A3_, ccompare_cproper_interval A4_))
                   (ceq_set
                     (cenum_ta_rule, ceq_ta_rule A5_ C2_,
                       ccompare_cproper_interval
                         (cproper_interval_ta_rule
                           (ccompare_cproper_interval A4_) C1_))),
                  ccompare_prod
                    (ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_))
                    (ccompare_set
                      (finite_UNIV_ta_rule, ceq_ta_rule A5_ C2_,
                        cproper_interval_ta_rule (ccompare_cproper_interval A4_)
                          C1_,
                        set_impl_ta_rule)),
                  set_impl_prod set_impl_set set_impl_set)
                (lhs_nth nrs))))
        parts)
  end;

fun ps_rules_nil_impl (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_)
  (C1_, C2_, C3_, C4_) meps rules =
  let
    val rsz =
      filter (ceq_ta_rule A2_ C3_, ccompare_ta_rule A1_ C2_)
        (fn r => null (r_lhs_states r)) rules;
  in
    image (C1_, C2_)
      (ceq_ta_rule (equal_set (B2_, B3_, ccompare_cproper_interval B4_, B5_))
         C3_,
        ccompare_ta_rule (ccompare_set (B1_, B3_, B4_, B6_)) C2_,
        set_impl_ta_rule)
      (fn f =>
        TA_rule
          (f, [],
            rhs_eps_cl_memo (A1_, A2_) (B1_, B2_, B3_, B4_, B6_) (C2_, C3_) meps
              (filter (ceq_ta_rule A2_ C3_, ccompare_ta_rule A1_ C2_)
                (fn r => eq C3_ (r_root r) f) rsz)))
      (image (ceq_ta_rule A2_ C3_, ccompare_ta_rule A1_ C2_) (C1_, C2_, C4_)
        r_root rsz)
  end;

fun memo_list_rtrancl_set (A1_, A2_, A3_, A4_) r =
  let
    val tr = rtrancl_list_impl A3_ r;
    val rm =
      map_of A3_
        (map (fn a => (a, set (A1_, A2_, A4_) (tr [a])))
          ((remdups A3_ o map fst) r));
  in
    (fn a =>
      (case rm a of NONE => inserta (A1_, A2_) a (bot_set (A1_, A2_, A4_))
        | SOME asa => asa))
  end;

fun memo_rtrancl (A1_, A2_, A3_, A4_) (RBT_set rbt) =
  (case ccompare A2_
    of NONE =>
      (raise Fail "memo_rtrancl RBT_set: ccompare = None")
        (fn _ => memo_rtrancl (A1_, A2_, A3_, A4_) (RBT_set rbt))
    | SOME _ =>
      memo_list_rtrancl_set (A1_, A2_, A3_, A4_)
        (keysa (ccompare_prod A2_ A2_) rbt))
  | memo_rtrancl (A1_, A2_, A3_, A4_) (DList_set dxs) =
    (case ceq A1_
      of NONE =>
        (raise Fail "memo_rtrancl DList_set: ceq = None")
          (fn _ => memo_rtrancl (A1_, A2_, A3_, A4_) (DList_set dxs))
      | SOME _ =>
        memo_list_rtrancl_set (A1_, A2_, A3_, A4_)
          (list_of_dlist (ceq_prod A1_ A1_) dxs))
  | memo_rtrancl (A1_, A2_, A3_, A4_) (Set_Monad xs) =
    memo_list_rtrancl_set (A1_, A2_, A3_, A4_) xs;

fun sym_parts (A1_, A2_) (B1_, B2_, B3_, B4_) rules =
  image (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat)
    (ceq_prod B1_
       (ceq_prod ceq_nat
         (ceq_set
           (cenum_ta_rule, ceq_ta_rule A2_ B3_,
             ccompare_cproper_interval (cproper_interval_ta_rule A1_ B2_)))),
      ccompare_prod B2_
        (ccompare_prod ccompare_nat
          (ccompare_set
            (finite_UNIV_ta_rule, ceq_ta_rule A2_ B3_,
              cproper_interval_ta_rule A1_ B2_, set_impl_ta_rule))),
      set_impl_prod B4_ (set_impl_prod set_impl_nat set_impl_set))
    (fn (f, n) =>
      (f, (n, filter (ceq_ta_rule A2_ B3_, ccompare_ta_rule A1_ B2_)
                (fn r => equal_proda B3_ equal_nat (r_sym r) (f, n)) rules)))
    (image (ceq_ta_rule A2_ B3_, ccompare_ta_rule A1_ B2_)
      (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat,
        set_impl_prod B4_ set_impl_nat)
      r_sym rules);

fun ps_ta (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_, B4_) ta =
  let
    val eps = ta_eps ta;
    val rules = ta_rules ta;
  in
    (if finite
          (finite_UNIV_prod (finite_UNIV_card_UNIV A1_)
             (finite_UNIV_card_UNIV A1_),
            ceq_prod A3_ A3_,
            ccompare_prod (ccompare_cproper_interval A4_)
              (ccompare_cproper_interval A4_))
          eps andalso
          finitea finite_UNIV_ta_rule rules
      then let
             val meps =
               memo_rtrancl (A3_, ccompare_cproper_interval A4_, A5_, A6_) eps;
             val parts =
               sym_parts (ccompare_cproper_interval A4_, A5_)
                 (B1_, B2_, B3_, B4_)
                 (filter
                   (ceq_ta_rule A5_ B3_,
                     ccompare_ta_rule (ccompare_cproper_interval A4_) B2_)
                   (fn r => not (null (r_lhs_states r))) rules);
             val qinit =
               ps_states_nil_impl (ccompare_cproper_interval A4_, A5_)
                 (finite_UNIV_card_UNIV A1_, A2_, A3_, A4_, A6_)
                 (B1_, B2_, B3_, B4_) meps rules;
             val q =
               fst (whilea
                     (fn (qold, qnew) =>
                       not (less_eq_set
                             (cenum_set
                                (A2_, A3_, ccompare_cproper_interval A4_, A6_),
                               ceq_set
                                 (A2_, A3_, ccompare_cproper_interval A4_),
                               ccompare_set
                                 (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_))
                             qnew qold))
                     (fn (_, qnew) =>
                       (qnew,
                         sup_seta
                           (ceq_set (A2_, A3_, ccompare_cproper_interval A4_),
                             ccompare_set
                               (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_))
                           qinit
                           (ps_states_cons_impl
                             (finite_UNIV_card_UNIV A1_, A2_, A3_, A4_, A5_,
                               A6_)
                             (A1_, A2_, A3_, A4_, A6_) (B1_, B2_) (B2_, B3_)
                             meps parts rules qnew)))
                     (set_empty
                        (ceq_set (A2_, A3_, ccompare_cproper_interval A4_),
                          ccompare_set
                            (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_))
                        (of_phantom set_impl_seta),
                       qinit));
             val final =
               filter
                 (ceq_set (A2_, A3_, ccompare_cproper_interval A4_),
                   ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_))
                 (fn qa =>
                   not (is_empty (A1_, A3_, A4_, A6_)
                         (inf_seta (A3_, ccompare_cproper_interval A4_) qa
                           (ta_final ta))))
                 q;
             val rulesa =
               sup_seta
                 (ceq_ta_rule
                    (equal_set (A2_, A3_, ccompare_cproper_interval A4_, A5_))
                    B3_,
                   ccompare_ta_rule
                     (ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_))
                     B2_)
                 (ps_rules_nil_impl (ccompare_cproper_interval A4_, A5_)
                   (finite_UNIV_card_UNIV A1_, A2_, A3_, A4_, A5_, A6_)
                   (B1_, B2_, B3_, B4_) meps rules)
                 (ps_rules_cons_impl (A1_, A2_, A3_, A4_, A5_, A6_)
                   (B1_, B2_, B3_) (B2_, B3_) meps parts rules q);
           in
             Ta_ext
               (final, rulesa,
                 set_empty
                   (ceq_prod (ceq_set (A2_, A3_, ccompare_cproper_interval A4_))
                      (ceq_set (A2_, A3_, ccompare_cproper_interval A4_)),
                     ccompare_prod
                       (ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_))
                       (ccompare_set
                         (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_)))
                   (of_phantom (set_impl_proda set_impl_set set_impl_set)),
                 ())
           end
      else ps_ta (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_, B4_) ta)
  end;

fun add_funas_args_term t fs = foldr add_funas_term (args t) fs;

fun add_funas_args_rule r fs =
  add_funas_args_term (fst r) (add_funas_args_term (snd r) fs);

fun funas_args_trs_list trs = foldr add_funas_args_rule trs [];

fun rwc
  (Tp_ops_ext
    (qreltrs, q, r, rw, rules, q_empty, is_QNF, nFQ_subset_NF_rules, rules_map,
      delete_R_Rw, split_rules, mk, nfs, more))
  = rw;

fun rc
  (Tp_ops_ext
    (qreltrs, q, r, rw, rules, q_empty, is_QNF, nFQ_subset_NF_rules, rules_map,
      delete_R_Rw, split_rules, mk, nfs, more))
  = r;

fun uncurry_of_sig_list a sml sm =
  maps (fn (b, c) =>
         let
           val (f, n) = b;
         in
           (fn _ =>
             let
               val g = get_symbol sm f n;
             in
               map (fn i =>
                     (Fun (a, [generate_f_xs (g i) (plus_nata n i),
                                Var (generate_var (plus_nata n i))]),
                       generate_f_xs (g (suc i)) (plus_nata n (suc i))))
                 (upt zero_nata (aarity sm f n))
             end)
         end
           c)
    sml;

fun sig_list_to_sig_map A_ a sml fmap =
  let
    val fm = fmap sml;
  in
    (fn f => fn n =>
      (case map_of (equal_prod A_ equal_nat) sml (f, n) of NONE => [fm f n]
        | SOME xs => (if null xs then [fm f n] else xs)))
  end;

fun uncurry_eta_split A_ (B1_, B2_, B3_) eboth rtest =
  let
    val test =
      (fn (l, r) =>
        less_nat zero_nata (size_list (args l)) andalso
          (less_nat zero_nata (size_list (args r)) andalso
            list_ex
              (eq_rule_mod_vars A_ (B1_, B2_, B3_) (hda (args l), hda (args r)))
              rtest));
  in
    partition test eboth
  end;

fun insert_vars_rule B_ r xs =
  insert_vars_term B_ (fst r) (insert_vars_term B_ (snd r) xs);

fun eta_closed_rules (A1_, A2_) (B1_, B2_, B3_, B4_) a sm ra r =
  catch_errora
    (forallM
      (fn (l, raa) =>
        (case aarity_term A1_ a sm l of NONE => Inr ()
          | SOME ab =>
            (if equal_nata ab zero_nata then Inr ()
              else check (list_ex
                           (fn (lll, rrr) =>
                             (case (lll, rrr) of (Var _, _) => false
                               | (Fun (_, []), _) => false
                               | (Fun (_, [_]), _) => false
                               | (Fun (_, [_, Var _]), Var _) => false
                               | (Fun (_, [_, Var _]), Fun (_, [])) => false
                               | (Fun (_, [_, Var _]), Fun (_, [_])) => false
                               | (Fun (f, [ll, Var x]), Fun (g, [rr, Var y])) =>
                                 eq A1_ f a andalso
                                   (eq A1_ g a andalso
                                     (eq B2_ x y andalso
                                       (not
  (membera B2_ (insert_vars_rule B2_ (ll, rr) []) x) andalso
 instance_rule A1_ B2_ (B1_, B2_, B3_) (l, raa) (ll, rr))))
                               | (Fun (_, [_, Var _]),
                                   Fun (_, _ :: Var _ :: _ :: _))
                                 => false
                               | (Fun (_, [_, Var _]),
                                   Fun (_, _ :: Fun (_, _) :: _))
                                 => false
                               | (Fun (_, _ :: Var _ :: _ :: _), _) => false
                               | (Fun (_, _ :: Fun (_, _) :: _), _) => false))
                           r)
                     (shows_prec_list show_char zero_nata
                        [#"e", #"t", #"a", #" ", #"e", #"x", #"p", #"a", #"n",
                          #"s", #"i", #"o", #"n", #" ", #"o", #"f", #" "] o
                        shows_rule (shows_prec A2_ zero_nata)
                          (shows_prec B4_ zero_nata) [#" ", #"-", #">", #" "]
                          (l, raa) o
                       shows_prec_list show_char zero_nata
                         [#" ", #"m", #"i", #"s", #"s", #"i", #"n", #"g"]))))
      ra)
    (fn x => Inl (snd x));

fun uncurry_rules A_ a sm =
  map (fn (l, r) => (uncurry_term A_ a sm l, uncurry_term A_ a sm r));

fun check_CS_subseteq A_ (B1_, B2_, B3_) r s =
  catch_errora
    (forallM
      (fn (l, ra) =>
        check (list_ex (instance_rule A_ B2_ (B1_, B2_, B3_) (l, ra)) s)
          (l, ra))
      r)
    (fn x => Inl (snd x));

fun uncurry_tt (B1_, B2_) i info r tp =
  let
    val (a, (sml, (u, eb))) = info;
    val ra = rc i tp;
    val rw = rwc i tp;
    val (e, ew) =
      uncurry_eta_split B1_
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list)
        eb ra;
    val r_eta = e @ ra;
    val rw_eta = ew @ rw;
    val rb_eta = r_eta @ rw_eta;
    val fmap = (fn _ => fn f => fn _ => f);
    val sm = sig_list_to_sig_map B1_ a sml fmap;
    val uR = uncurry_rules B1_ a sm r_eta;
    val uRw = uncurry_rules B1_ a sm rw_eta;
  in
    (case let
            val s = uncurry_of_sig_list a sml sm;
          in
            bindb (catch_errora
                    (forallM
                      (fn (l, _) =>
                        check (hvf_term B1_ a l)
                          (shows_prec_list show_char zero_nata
                             [#"h", #"e", #"a", #"d", #" ", #"v", #"a", #"r",
                               #"i", #"a", #"b", #"l", #"e", #" ", #"i", #"n",
                               #" ", #"l", #"h", #"s", #" "] o
                            (shows_term (shows_prec B2_ zero_nata)
                               (shows_prec_list show_char zero_nata) l o
                              shows_prec_list show_char zero_nata
                                [#" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l",
                                  #"o", #"w", #"e", #"d"])))
                      r_eta)
                    (fn x => Inl (snd x)))
              (fn _ =>
                bindb (catch_errora
                        (forallM
                          (fn (l, _) =>
                            check (hvf_term B1_ a l)
                              (shows_prec_list show_char zero_nata
                                 [#"h", #"e", #"a", #"d", #" ", #"v", #"a",
                                   #"r", #"i", #"a", #"b", #"l", #"e", #" ",
                                   #"i", #"n", #" ", #"l", #"h", #"s", #" "] o
                                (shows_term (shows_prec B2_ zero_nata)
                                   (shows_prec_list show_char zero_nata) l o
                                  shows_prec_list show_char zero_nata
                                    [#" ", #"n", #"o", #"t", #" ", #"a", #"l",
                                      #"l", #"o", #"w", #"e", #"d"])))
                          rw_eta)
                        (fn x => Inl (snd x)))
                  (fn _ =>
                    bindb (eta_closed_rules (B1_, B2_)
                            (ccompare_list ccompare_char, equal_list equal_char,
                              mapping_impl_list, show_list show_char)
                            a sm r_eta r_eta)
                      (fn _ =>
                        bindb (eta_closed_rules (B1_, B2_)
                                (ccompare_list ccompare_char,
                                  equal_list equal_char, mapping_impl_list,
                                  show_list show_char)
                                a sm rb_eta rb_eta)
                          (fn _ =>
                            bindb (catch_errora
                                    (forallM
                                      (fn (l, rb) =>
check (not (is_Var l))
  (shows_prec_list show_char zero_nata
     [#"l", #"h", #"s", #" ", #"m", #"u", #"s", #"t", #" ", #"n", #"o", #"t",
       #" ", #"b", #"e", #" ", #"a", #" ", #"v", #"a", #"r", #"i", #"a", #"b",
       #"l", #"e", #" ", #"i", #"n", #" ", #"r", #"u", #"l", #"e", #" "] o
    shows_rule (shows_prec B2_ zero_nata) (shows_prec_list show_char zero_nata)
      [#" ", #"-", #">", #" "] (l, rb)))
                                      rw_eta)
                                    (fn x => Inl (snd x)))
                              (fn _ =>
                                bindb (catch_errora
(check_subseteq
  (equal_prod (equal_term B1_ (equal_list equal_char))
    (equal_term B1_ (equal_list equal_char)))
  uR r)
(fn x =>
  Inl (shows_prec_list show_char zero_nata
         [#"u", #"n", #"c", #"u", #"r", #"r", #"i", #"e", #"d", #" ", #"r",
           #"u", #"l", #"e", #" "] o
        (shows_rule (shows_prec B2_ zero_nata)
           (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] x o
          shows_prec_list show_char zero_nata
            [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n",
              #"g"]))))
                                  (fn _ =>
                                    bindb (catch_errora
    (check_subseteq
      (equal_prod (equal_term B1_ (equal_list equal_char))
        (equal_term B1_ (equal_list equal_char)))
      uRw r)
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"u", #"n", #"c", #"u", #"r", #"r", #"i", #"e", #"d", #" ", #"r",
               #"u", #"l", #"e", #" "] o
            (shows_rule (shows_prec B2_ zero_nata)
               (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "]
               x o
              shows_prec_list show_char zero_nata
                [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n",
                  #"g"]))))
                                      (fn _ =>
bindb (catch_errora
        (check_CS_subseteq B1_
          (ccompare_list ccompare_char, equal_list equal_char,
            mapping_impl_list)
          s u)
        (fn x =>
          Inl (shows_prec_list show_char zero_nata
                 [#"u", #"n", #"c", #"u", #"r", #"r", #"y", #" ", #"r", #"u",
                   #"l", #"e", #" "] o
                (shows_rule (shows_prec B2_ zero_nata)
                   (shows_prec_list show_char zero_nata)
                   [#" ", #"-", #">", #" "] x o
                  shows_prec_list show_char zero_nata
                    [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n",
                      #"g"]))))
  (fn _ =>
    catch_errora
      (check_subseteq
        (equal_prod (equal_term B1_ (equal_list equal_char))
          (equal_term B1_ (equal_list equal_char)))
        u r)
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"u", #"n", #"c", #"u", #"r", #"r", #"y", #" ", #"r", #"u",
                 #"l", #"e", #" "] o
              (shows_rule (shows_prec B2_ zero_nata)
                 (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "]
                 x o
                shows_prec_list show_char zero_nata
                  [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n",
                    #"g", #" ", #"i", #"n", #" ", #"n", #"e", #"w", #" ", #"T",
                    #"R", #"S"])))))))))))
          end
      of Inl aa => Inl aa | Inr _ => Inr (mkc i (nfsb i tp) [] uR (uRw @ u)))
  end;

fun check_prefix_equivalent (A1_, A2_) (B1_, B2_) rhoa rho n =
  catch_errora
    (bindb
      (check (less_nat n (size_list (snd rhoa)))
        (shows_string
           [#"T", #"h", #"e", #"r", #"e", #" ", #"a", #"r", #"e", #" ", #"f",
             #"e", #"w", #"e", #"r", #" ", #"t", #"h", #"a", #"n", #" "] o
          (shows_prec_nat zero_nata n o
            (shows_string
               [#" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
                 #"s", #" ", #"i", #"n", #" "] o
              shows_crule (shows_prec A2_ zero_nata) (shows_prec B2_ zero_nata)
                rhoa))))
      (fn _ =>
        bindb (check (less_nat n (size_list (snd rho)))
                (shows_string
                   [#"T", #"h", #"e", #"r", #"e", #" ", #"a", #"r", #"e", #" ",
                     #"f", #"e", #"w", #"e", #"r", #" ", #"t", #"h", #"a", #"n",
                     #" "] o
                  (shows_prec_nat zero_nata n o
                    (shows_string
                       [#" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o",
                         #"n", #"s", #" ", #"i", #"n", #" "] o
                      shows_crule (shows_prec A2_ zero_nata)
                        (shows_prec B2_ zero_nata) rho))))
          (fn _ =>
            bindb (check (equal_terma A1_ B1_ (fst (fst rhoa)) (fst (fst rho)))
                    (shows_prec_list show_char zero_nata
                      [#"L", #"e", #"f", #"t", #"-", #"h", #"a", #"n", #"d",
                        #" ", #"s", #"i", #"d", #"e", #"s", #" ", #"a", #"r",
                        #"e", #" ", #"d", #"i", #"f", #"f", #"e", #"r", #"e",
                        #"n", #"t", #"."]))
              (fn _ =>
                bindb (catch_errora
                        (forallM
                          (fn i =>
                            check (equal_terma A1_ B1_ (snd (nth (snd rhoa) i))
                                    (snd (nth (snd rho) i)))
                              (shows_string
                                 [#"R", #"h", #"s", #" ", #"o", #"f", #" ",
                                   #"c", #"o", #"n", #"d", #"i", #"t", #"i",
                                   #"o", #"n", #"s", #" ", #"a", #"r", #"e",
                                   #" ", #"d", #"i", #"f", #"f", #"e", #"r",
                                   #"e", #"n", #"t", #" "] o
                                shows_nl))
                          (upt zero_nata n))
                        (fn x => Inl (snd x)))
                  (fn _ =>
                    catch_errora
                      (forallM
                        (fn i =>
                          check (equal_terma A1_ B1_ (fst (nth (snd rhoa) i))
                                  (fst (nth (snd rho) i)))
                            (shows_string
                               [#"L", #"h", #"s", #" ", #"o", #"f", #" ", #"c",
                                 #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
                                 #"s", #" ", #"a", #"r", #"e", #" ", #"d", #"i",
                                 #"f", #"f", #"e", #"r", #"e", #"n", #"t",
                                 #" "] o
                              shows_nl))
                        (upt zero_nata (suc n)))
                      (fn x => Inl (snd x)))))))
    (fn x =>
      Inl (shows_string [#"R", #"u", #"l", #"e", #"s"] o
            (shows_crule (shows_prec A2_ zero_nata) (shows_prec B2_ zero_nata)
               rhoa o
              (shows_string [#" ", #"a", #"n", #"d", #" "] o
                (shows_crule (shows_prec A2_ zero_nata)
                   (shows_prec B2_ zero_nata) rho o
                  (shows_string
                     [#" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" "] o
                    (shows_prec_nat zero_nata n o
                      (shows_string
                         [#" ", #"e", #"q", #"u", #"i", #"v", #"a", #"l", #"e",
                           #"n", #"t", #"."] o
                        (shows_nl o x)))))))));

fun check_f (A1_, A2_) (B1_, B2_) cr j f crs u =
  catch_errora
    (forallM
      (fn cra =>
        catch_errora
          (forallM
            (fn i =>
              (case u cra i of Hole => Inr ()
                | More (g, _, _, _) =>
                  (if eq A1_ f g
                    then catch_errora
                           (bindb
                             (check (equal_nata i j)
                               (shows_string
                                  [#"S", #"a", #"m", #"e", #" ", #"s", #"y",
                                    #"m", #"b", #"o", #"l", #" ", #"o", #"c",
                                    #"c", #"u", #"r", #"s", #" ", #"a", #"t",
                                    #" ", #"d", #"i", #"f", #"f", #"e", #"r",
                                    #"e", #"n", #"t", #" ", #"l", #"e", #"v",
                                    #"e", #"l", #"s"] o
                                 shows_nl))
                             (fn _ =>
                               bindb (catch_errora
                                       (forallM
 (fn k =>
   check (equal_ctxta A1_ B1_ (u cra k) (u cr k))
     (shows_string
        [#"C", #"o", #"n", #"t", #"e", #"x", #"t", #"s", #" ", #"a", #"r", #"e",
          #" ", #"d", #"i", #"f", #"f", #"e", #"r", #"e", #"n", #"t", #" "] o
       shows_nl))
 (upt zero_nata (suc j)))
                                       (fn x => Inl (snd x)))
                                 (fn _ =>
                                   check_prefix_equivalent (A1_, A2_) (B1_, B2_)
                                     cra cr j)))
                           (fn x =>
                             Inl (shows_string [#"R", #"u", #"l", #"e", #"s"] o
                                   (shows_crule (shows_prec A2_ zero_nata)
                                      (shows_prec B2_ zero_nata) cra o
                                     (shows_string
[#" ", #"a", #"n", #"d", #" "] o
                                       (shows_crule (shows_prec A2_ zero_nata)
  (shows_prec B2_ zero_nata) cr o
 (shows_string
    [#" ", #"s", #"h", #"a", #"r", #"e", #" ", #"a", #" ", #"s", #"y", #"m",
      #"b", #"o", #"l", #"."] o
   (shows_nl o x)))))))
                    else Inr ())))
            (upt zero_nata (size_list (snd cra))))
          (fn x => Inl (snd x)))
      crs)
    (fn x => Inl (snd x));

fun af_rules pi r = map (af_rule pi) r;

fun afs_syms xa = snd (rep_afs xa);

fun mono_af_entry n (Collapse i) = less_eq_nat n one_nata
  | mono_af_entry n (AFList ids) =
    all_interval_nat (membera equal_nat ids) zero_nata n;

fun mono_afs (A1_, A2_) pi =
  ball (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat) (afs_syms pi)
    (fn (f, n) => mono_af_entry n (afsa pi (f, n)));

fun compatible_ta (A1_, A2_) (B1_, B2_) xml2name tag =
  xml_do tag
    (xml_take (tree_automaton (ta_normal_lhs xml2name))
      (fn a =>
        xml_take_default Id_Relation closed_criterion
          (fn b => xml_return (a, b))));

fun xml2const_map (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name =
  xml_do [#"c", #"o", #"n", #"s", #"t", #"M", #"a", #"p"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do [#"e", #"n", #"t", #"r", #"y"]
        (xml_take
          (xml_do [#"s", #"y", #"m", #"b", #"o", #"l"]
            (xml_take xml2name (fn x => xml_return (id x))))
          (fn a =>
            xml_take (xml_text [#"c", #"o", #"n", #"s", #"t"])
              (fn b => xml_return (a, b)))))
      (fn a => xml_return (map_of (equal_lab A1_ B1_) a)));

fun default_grd_fun s t =
  let
    val f = funs_rule_list (s, t);
    val m =
      fold (fn fa => fn m =>
             (case fa of Lab (_, _) => m | FunLab (_, _) => m | UnLab _ => m
               | Sharp (Lab (_, _)) => m | Sharp (FunLab (_, _)) => m
               | Sharp (UnLab g) => max ord_nat (size_list g) m
               | Sharp (Sharp _) => m))
        f zero_nata;
    val suffix = replicate (suc m) #"a";
  in
    (fn x => Fun (Sharp (UnLab (x @ suffix)), []))
  end;

fun xml2non_join_info xml2name x =
  xml_or
    (xml_leaf
      [#"d", #"i", #"s", #"t", #"i", #"n", #"c", #"t", #"N", #"o", #"r", #"m",
        #"a", #"l", #"F", #"o", #"r", #"m", #"s"]
      Diff_NFs)
    (xml_or
      (xml_leaf [#"c", #"a", #"p", #"N", #"o", #"t", #"U", #"n", #"i", #"f"]
        (Tcap_Non_Unif default_grd_fun))
      (xml_or
        (xml_do [#"s", #"u", #"b", #"t", #"e", #"r", #"m"]
          (xml_take pos
            (fn a =>
              xml_take (xml2non_join_info xml2name)
                (fn b => xml_return (Subterm_NJ (a, b))))))
        (xml_or
          (xml_do [#"g", #"r", #"o", #"u", #"n", #"d", #"i", #"n", #"g"]
            (xml_take
              (substa (show_lab (show_list show_char) (show_list show_nat))
                xml2name)
              (fn a =>
                xml_take (xml2non_join_info xml2name)
                  (fn b => xml_return (Grounding (a, b))))))
          (xml_or
            (xml_do
              [#"e", #"m", #"p", #"t", #"y", #"T", #"r", #"e", #"e", #"A", #"u",
                #"t", #"o", #"m", #"a", #"t", #"a", #"I", #"n", #"t", #"e",
                #"r", #"s", #"e", #"c", #"t", #"i", #"o", #"n"]
              (xml_take
                (compatible_ta
                  (key_list (equal_char, key_char), show_list show_char)
                  (key_list (equal_nat, key_nat), show_list show_nat) xml2name
                  [#"f", #"i", #"r", #"s", #"t", #"A", #"u", #"t", #"o", #"m",
                    #"a", #"t", #"o", #"n"])
                (fn a =>
                  xml_take
                    (compatible_ta
                      (key_list (equal_char, key_char), show_list show_char)
                      (key_list (equal_nat, key_nat), show_list show_nat)
                      xml2name
                      [#"s", #"e", #"c", #"o", #"n", #"d", #"A", #"u", #"t",
                        #"o", #"m", #"a", #"t", #"o", #"n"])
                    (fn b =>
                      xml_return
                        (let
                           val (ta1, rel1) = a;
                         in
                           (fn (aa, ba) =>
                             Tree_Aut_Intersect_Empty (ta1, rel1, aa, ba))
                         end
                          b)))))
            (xml_or
              (xml_do
                [#"d", #"i", #"f", #"f", #"e", #"r", #"e", #"n", #"t", #"I",
                  #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t", #"a", #"t",
                  #"i", #"o", #"n"]
                (xml_take (xmlt2 (sl_variant (xmlt_of_xmlt2 xml2name)))
                  (fn xa => xml_return (Finite_Model_Gt xa))))
              (xml_or
                (xml_do
                  [#"s", #"t", #"r", #"i", #"c", #"t", #"D", #"e", #"c", #"r",
                    #"e", #"a", #"s", #"e"]
                  (xml_take
                    (ordering_constraint_proof
                      (show_lab (show_list show_char) (show_list show_nat))
                      xml2name false)
                    (fn xa => xml_return (Reduction_Pair_Gt xa))))
                (xml_or
                  (xml_do
                    [#"a", #"r", #"g", #"u", #"m", #"e", #"n", #"t", #"F", #"i",
                      #"l", #"t", #"e", #"r", #"N", #"o", #"n", #"J", #"o",
                      #"i", #"n"]
                    (xml_take
                      (afs (show_lab (show_list show_char) (show_list show_nat))
                        xml2name)
                      (fn a =>
                        xml_take (xml2non_join_info xml2name)
                          (fn b => xml_return (Argument_Filter_NJ (a, b))))))
                  (xml_do
                    [#"u", #"s", #"a", #"b", #"l", #"e", #"R", #"u", #"l", #"e",
                      #"s", #"N", #"o", #"n", #"J", #"o", #"i", #"n"]
                    (xml_take_optional
                      (xml_or (xml_leaf [#"l", #"e", #"f", #"t"] true)
                        (xml_leaf [#"r", #"i", #"g", #"h", #"t"] false))
                      (fn a =>
                        (case a
                          of NONE =>
                            xml_take (xml2non_join_info xml2name)
                              (fn b => xml_return (Usable_Rules_Reach_NJ b))
                          | SOME left =>
                            xml_take
                              (xml_do
                                [#"u", #"s", #"a", #"b", #"l", #"e", #"R", #"u",
                                  #"l", #"e", #"s"]
                                (xml_take
                                  (rules
                                    (show_lab (show_list show_char)
                                      (show_list show_nat))
                                    xml2name)
                                  (fn xa => xml_return (id xa))))
                              (fn u =>
                                xml_take (xml2non_join_info xml2name)
                                  (fn p =>
                                    xml_return
                                      (Usable_Rules_Reach_Unif_NJ
((if left then Inl u else Inr u), p)))))))))))))))
    x;

fun xml2ncr_proof xml2name x =
  let
    val rew =
      rsteps (show_lab (show_list show_char) (show_list show_nat)) xml2name;
  in
    xml_do [#"c", #"r", #"D", #"i", #"s", #"p", #"r", #"o", #"o", #"f"]
      (xml_take
        (xml_or
          (xml_do
            [#"n", #"o", #"n", #"W", #"c", #"r", #"A", #"n", #"d", #"S", #"N"]
            (xml_take (fn xa => Inr (fst xa))
              (fn _ =>
                xml_take
                  (xml2trs_termination_proof
                    (equal_list equal_char, key_list (equal_char, key_char),
                      show_list show_char)
                    (equal_list equal_nat, key_list (equal_nat, key_nat),
                      show_list show_nat)
                    xml2name)
                  (fn prf => xml_return (SN_NWCR prf)))))
          (xml_or
            (xml_do
              [#"n", #"o", #"n", #"J", #"o", #"i", #"n", #"a", #"b", #"l", #"e",
                #"F", #"o", #"r", #"k"]
              (xml_take rew
                (fn a =>
                  xml_take rew
                    (fn b =>
                      xml_take (xml2non_join_info xml2name)
                        (fn c =>
                          xml_return
                            (let
                               val (s, seq1) = a;
                             in
                               (fn (_, aa) =>
                                 (fn ba => Non_Join (s, seq1, aa, ba)))
                             end
                               b
                              c))))))
            (xml_or
              (xml_do
                [#"m", #"o", #"d", #"u", #"l", #"a", #"r", #"i", #"t", #"y",
                  #"D", #"i", #"s", #"j", #"o", #"i", #"n", #"t"]
                (xml_take
                  (xml_do [#"t", #"r", #"s"]
                    (xml_take
                      (rules
                        (show_lab (show_list show_char) (show_list show_nat))
                        xml2name)
                      (fn xa => xml_return (id xa))))
                  (fn a =>
                    xml_take (xml2ncr_proof xml2name)
                      (fn b => xml_return (NCR_Disj_Subtrs (a, b))))))
              (xml_do
                [#"r", #"e", #"d", #"u", #"n", #"d", #"a", #"n", #"t", #"R",
                  #"u", #"l", #"e", #"s"]
                (xml_take
                  (xml_do [#"t", #"r", #"s"]
                    (xml_take
                      (rules
                        (show_lab (show_list show_char) (show_list show_nat))
                        xml2name)
                      (fn xa => xml_return (id xa))))
                  (fn a =>
                    xml_take
                      (xml_nat [#"n", #"r", #"S", #"t", #"e", #"p", #"s"])
                      (fn b =>
                        xml_take (xml2ncr_proof xml2name)
                          (fn c =>
                            xml_return (NCR_Redundant_Rules (a, b, c))))))))))
        (fn xa => xml_return (id xa)))
      x
  end;

fun xml2state_map (A1_, A2_) (B1_, B2_) xml2name =
  xml_do [#"s", #"t", #"a", #"t", #"e", #"M", #"a", #"p"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do [#"e", #"n", #"t", #"r", #"y"]
        (xml_take state
          (fn a =>
            xml_take (term (show_lab A2_ B2_) xml2name)
              (fn b => xml_return (a, b)))))
      (fn a => xml_return (fn x => the (map_of (equal_list equal_char) a x))));

fun is_root_step A_ (B1_, B2_, B3_) r s t =
  list_ex
    (fn (l, ra) =>
      (case match A_ (B1_, B2_, B3_) s l of NONE => false
        | SOME sigma => equal_terma A_ B2_ (subst_apply_term ra sigma) t))
    r;

fun is_par_rstep A_ (B1_, B2_, B3_) r (Var x) (Var y) = eq B2_ x y
  | is_par_rstep A_ (B1_, B2_, B3_) r (Fun (f, ss)) (Fun (g, ts)) =
    equal_terma A_ B2_ (Fun (f, ss)) (Fun (g, ts)) orelse
      (is_root_step A_ (B1_, B2_, B3_) r (Fun (f, ss)) (Fun (g, ts)) orelse
        (if eq A_ f g andalso equal_nata (size_list ss) (size_list ts)
          then list_all2 (is_par_rstep A_ (B1_, B2_, B3_) r) ss ts else false))
  | is_par_rstep A_ (B1_, B2_, B3_) r (Fun (v, va)) (Var vb) =
    is_root_step A_ (B1_, B2_, B3_) r (Fun (v, va)) (Var vb)
  | is_par_rstep A_ (B1_, B2_, B3_) r (Var vb) (Fun (v, va)) =
    is_root_step A_ (B1_, B2_, B3_) r (Var vb) (Fun (v, va));

fun reachable_terms A_ (B1_, B2_, B3_) r s n =
  (if equal_nata n zero_nata then [s]
    else let
           val ts =
             reachable_terms A_ (B1_, B2_, B3_) r s (minus_nata n one_nata);
         in
           remdups (equal_term A_ B2_)
             (ts @ maps (rewrite A_ (B1_, B2_, B3_) r) ts)
         end);

fun is_critical_pair_closing_cp A_ (B1_, B2_, B3_) c n (false, (s, t)) =
  not (is_none
        (find (is_par_rstep A_ (B1_, B2_, B3_) c t)
          (reachable_terms A_ (B1_, B2_, B3_) c s n)))
  | is_critical_pair_closing_cp A_ (B1_, B2_, B3_) c n (true, (s, t)) =
    not (is_none
          (find (membera (equal_term A_ B2_)
                  (reachable_terms A_ (B1_, B2_, B3_) c s n))
            (reachable_terms A_ (B1_, B2_, B3_) c t n)));

fun critical_pairs_impl A_ p r =
  maps (fn (l, ra) =>
         maps (fn pa =>
                let
                  val c = ctxt_of_pos_term pa l;
                  val la = subt_at l pa;
                  val b = equal_ctxta A_ (equal_list equal_char) c Hole;
                in
                  (if is_Var la then []
                    else maps (fn (laa, rb) =>
                                (case mgu_var_disjoint_generic
(equal_list equal_char) A_ (fn a => #"x" :: a) (fn a => #"y" :: a) la laa
                                  of NONE => []
                                  | SOME (sigma, tau) =>
                                    [(b, (subst_apply_term ra sigma,
   ctxt_apply_term (subst_apply_ctxt c sigma) (subst_apply_term rb tau)))]))
                           r)
                end)
           (poss_list l))
    p;

fun check_left_linear_trs A_ (B1_, B2_, B3_, B4_) trs =
  catch_errora
    (catch_errora
      (forallM
        (fn x =>
          (if linear_term (B1_, B2_, B3_) (fst x) then Inr () else Inl x))
        trs)
      (fn x => Inl (snd x)))
    (fn _ =>
      Inl (shows_prec_list (show_prod (show_term A_ B4_) (show_term A_ B4_))
             zero_nata trs o
             shows_nl o
             shows_prec_list show_char zero_nata
               [#"i", #"s", #" ", #"n", #"o", #"t", #" ", #"l", #"e", #"f",
                 #"t", #"-", #"l", #"i", #"n", #"e", #"a", #"r"] o
            shows_nl));

fun indent p s =
  maps (fn c => (if ((c : char) = #"\n") then [#"\n", #" "] else [c])) (p s);

fun check_critical_pair_closing (A1_, A2_) r c n =
  catch_errora
    (bindb
      (check_left_linear_trs A2_
        (ceq_list ceq_char, ccompare_list ccompare_char, set_impl_list,
          show_list show_char)
        r)
      (fn _ =>
        bindb (catch_errora
                (check_subseteq
                  (equal_prod (equal_term A1_ (equal_list equal_char))
                    (equal_term A1_ (equal_list equal_char)))
                  c r)
                (fn _ =>
                  Inl (shows_prec_list show_char zero_nata
                        [#"C", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"s",
                          #"u", #"b", #"s", #"y", #"s", #"t", #"e", #"m", #" ",
                          #"o", #"f", #" ", #"R"])))
          (fn _ =>
            catch_errora
              (forallM
                (fn (b, (s, t)) =>
                  check (is_critical_pair_closing_cp A1_
                          (ccompare_list ccompare_char, equal_list equal_char,
                            mapping_impl_list)
                          c n (b, (s, t)))
                    (shows_prec_list show_char zero_nata
                       [#"t", #"h", #"e", #" ", #"c", #"r", #"i", #"t", #"i",
                         #"c", #"a", #"l", #" ", #"p", #"a", #"i", #"r", #" "] o
                      (shows_term (shows_prec A2_ zero_nata)
                         (shows_prec_list show_char zero_nata) s o
                        (shows_prec_list show_char zero_nata
                           [#" ", #"<", #"-", #" ", #".", #" ", #"-", #">",
                             #" "] o
                          (shows_term (shows_prec A2_ zero_nata)
                             (shows_prec_list show_char zero_nata) t o
                            (shows_prec_list show_char zero_nata
                               [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                                 #"c", #"l", #"o", #"s", #"e", #"d", #" ", #"w",
                                 #"i", #"t", #"h", #"i", #"n", #" "] o
                              (shows_prec_nat zero_nata n o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"s", #"t", #"e", #"p", #"s",
                                    #"."])))))))
                (critical_pairs_impl A1_ r r))
              (fn x => Inl (snd x)))))
    (fn x =>
      Inl (x o (shows_nl o
                 (shows_prec_list show_char zero_nata
                    [#"h", #"e", #"n", #"c", #"e", #" ", #"t", #"h", #"e", #" ",
                      #"f", #"o", #"l", #"l", #"o", #"w", #"i", #"n", #"g",
                      #" ", #"T", #"R", #"S", #" ", #"i", #"s", #" ", #"n",
                      #"o", #"t", #" ", #"c", #"r", #"i", #"t", #"i", #"c",
                      #"a", #"l", #" ", #"p", #"a", #"i", #"r", #" ", #"c",
                      #"l", #"o", #"s", #"i", #"n", #"g", #" "] o
                   (shows_nl o
                     (shows_trs (shows_prec A2_ zero_nata)
                        (shows_prec_list show_char zero_nata)
                        [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s",
                          #"y", #"s", #"t", #"e", #"m", #":"]
                        [#" ", #"-", #">", #" "] r o
                       indent x))))));

fun check_strongly_closed (A1_, A2_) r n =
  catch_errora
    (bindb
      (check_linear_trs A2_
        (ceq_list ceq_char, ccompare_list ccompare_char, set_impl_list,
          show_list show_char)
        r)
      (fn _ =>
        catch_errora
          (forallM
            (fn (_, (s, t)) =>
              check (not (is_none
                           (find (membera
                                   (equal_term A1_ (equal_list equal_char))
                                   (reachable_terms A1_
                                     (ccompare_list ccompare_char,
                                       equal_list equal_char, mapping_impl_list)
                                     r s n))
                             (reachable_terms A1_
                               (ccompare_list ccompare_char,
                                 equal_list equal_char, mapping_impl_list)
                               r t (suc zero_nata)))) andalso
                      not (is_none
                            (find (membera
                                    (equal_term A1_ (equal_list equal_char))
                                    (reachable_terms A1_
                                      (ccompare_list ccompare_char,
equal_list equal_char, mapping_impl_list)
                                      r t n))
                              (reachable_terms A1_
                                (ccompare_list ccompare_char,
                                  equal_list equal_char, mapping_impl_list)
                                r s (suc zero_nata)))))
                (shows_prec_list show_char zero_nata
                   [#"t", #"h", #"e", #" ", #"c", #"r", #"i", #"t", #"i", #"c",
                     #"a", #"l", #" ", #"p", #"a", #"i", #"r", #" "] o
                  (shows_term (shows_prec A2_ zero_nata)
                     (shows_prec_list show_char zero_nata) s o
                    (shows_prec_list show_char zero_nata
                       [#" ", #"<", #"-", #" ", #".", #" ", #"-", #">", #" "] o
                      (shows_term (shows_prec A2_ zero_nata)
                         (shows_prec_list show_char zero_nata) t o
                        (shows_prec_list show_char zero_nata
                           [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                             #"s", #"t", #"r", #"o", #"n", #"g", #"l", #"y",
                             #" ", #"c", #"l", #"o", #"s", #"e", #"d", #" ",
                             #"w", #"i", #"t", #"h", #"i", #"n", #" "] o
                          (shows_prec_nat zero_nata n o
                            shows_prec_list show_char zero_nata
                              [#" ", #"s", #"t", #"e", #"p", #"s", #"."])))))))
            (critical_pairs_impl A1_ r r))
          (fn x => Inl (snd x))))
    (fn x =>
      Inl (x o (shows_nl o
                 (shows_prec_list show_char zero_nata
                    [#"h", #"e", #"n", #"c", #"e", #" ", #"t", #"h", #"e", #" ",
                      #"f", #"o", #"l", #"l", #"o", #"w", #"i", #"n", #"g",
                      #" ", #"T", #"R", #"S", #" ", #"i", #"s", #" ", #"n",
                      #"o", #"t", #" ", #"s", #"t", #"r", #"o", #"n", #"g",
                      #"l", #"y", #" ", #"c", #"l", #"o", #"s", #"e", #"d",
                      #" "] o
                   (shows_nl o
                     (shows_trs (shows_prec A2_ zero_nata)
                        (shows_prec_list show_char zero_nata)
                        [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s",
                          #"y", #"s", #"t", #"e", #"m", #":"]
                        [#" ", #"-", #">", #" "] r o
                       indent x))))));

fun showsp_option show_a p (SOME x) =
  shows_pl p o shows_string [#"S", #"o", #"m", #"e"] o shows_space o
    show_a one_nata x o
    shows_pr p
  | showsp_option show_a p NONE = shows_string [#"N", #"o", #"n", #"e"];

fun shows_prec_option A_ = showsp_option (shows_prec A_);

fun root_rewrite A_ (B1_, B2_, B3_) r s =
  maps (fn (l, ra) =>
         (case match A_ (B1_, B2_, B3_) s l of NONE => []
           | SOME sigma => [subst_apply_term ra sigma]))
    r;

fun parallel_rewrite A_ (B1_, B2_, B3_) r (Var x) = [Var x]
  | parallel_rewrite A_ (B1_, B2_, B3_) r (Fun (f, ss)) =
    remdups (equal_term A_ B2_)
      (root_rewrite A_ (B1_, B2_, B3_) r (Fun (f, ss)) @
        map (fn a => Fun (f, a))
          (product_lists (map (parallel_rewrite A_ (B1_, B2_, B3_) r) ss)));

fun is_parallel_closed_cp A_ (B1_, B2_, B3_) r uu (false, (s, t)) =
  is_par_rstep A_ (B1_, B2_, B3_) r t s
  | is_parallel_closed_cp A_ (B1_, B2_, B3_) r (SOME n) (true, (s, t)) =
    not (is_none
          (find (is_par_rstep A_ (B1_, B2_, B3_) r t)
            (reachable_terms A_ (B1_, B2_, B3_) r s n)))
  | is_parallel_closed_cp A_ (B1_, B2_, B3_) r NONE (true, (s, t)) =
    not (is_none
          (find (is_par_rstep A_ (B1_, B2_, B3_) r t)
            (parallel_rewrite A_ (B1_, B2_, B3_) r s)));

fun check_parallel_closed (A1_, A2_) r n =
  catch_errora
    (bindb
      (check_left_linear_trs A2_
        (ceq_list ceq_char, ccompare_list ccompare_char, set_impl_list,
          show_list show_char)
        r)
      (fn _ =>
        catch_errora
          (forallM
            (fn (b, (s, t)) =>
              check (is_parallel_closed_cp A1_
                      (ccompare_list ccompare_char, equal_list equal_char,
                        mapping_impl_list)
                      r n (b, (s, t)))
                (shows_prec_list show_char zero_nata
                   [#"t", #"h", #"e", #" ", #"c", #"r", #"i", #"t", #"i", #"c",
                     #"a", #"l", #" ", #"p", #"a", #"i", #"r", #" "] o
                  (shows_term (shows_prec A2_ zero_nata)
                     (shows_prec_list show_char zero_nata) s o
                    (shows_prec_list show_char zero_nata
                       [#" ", #"<", #"-", #" ", #".", #" ", #"-", #">", #" "] o
                      (shows_term (shows_prec A2_ zero_nata)
                         (shows_prec_list show_char zero_nata) t o
                        (shows_prec_list show_char zero_nata
                           [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                             #"(", #"a", #"l", #"m", #"o", #"s", #"t", #")",
                             #" ", #"p", #"a", #"r", #"a", #"l", #"l", #"e",
                             #"l", #" ", #"c", #"l", #"o", #"s", #"e", #"d",
                             #" ", #"w", #"i", #"t", #"h", #"i", #"n", #" "] o
                          (shows_prec_option show_nat zero_nata n o
                            shows_prec_list show_char zero_nata
                              [#" ", #"s", #"t", #"e", #"p", #"s", #"."])))))))
            (critical_pairs_impl A1_ r r))
          (fn x => Inl (snd x))))
    (fn x =>
      Inl (x o (shows_nl o
                 (shows_prec_list show_char zero_nata
                    [#"h", #"e", #"n", #"c", #"e", #" ", #"t", #"h", #"e", #" ",
                      #"f", #"o", #"l", #"l", #"o", #"w", #"i", #"n", #"g",
                      #" ", #"T", #"R", #"S", #" ", #"i", #"s", #" ", #"n",
                      #"o", #"t", #" ", #"(", #"a", #"l", #"m", #"o", #"s",
                      #"t", #")", #" ", #"p", #"a", #"r", #"a", #"l", #"l",
                      #"e", #"l", #" ", #"c", #"l", #"o", #"s", #"e", #"d",
                      #" "] o
                   (shows_nl o
                     (shows_trs (shows_prec A2_ zero_nata)
                        (shows_prec_list show_char zero_nata)
                        [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s",
                          #"y", #"s", #"t", #"e", #"m", #":"]
                        [#" ", #"-", #">", #" "] r o
                       indent x))))));

fun applicable_rule_impl isNF = (fn (l, _) => list_all isNF (args l));

fun check_non_applicable_rules isNF r =
  catch_errora
    (forallM
      (fn x => (if not (applicable_rule_impl isNF x) then Inr () else Inl x)) r)
    (fn x => Inl (snd x));

fun rule_match_impl A_ nfq e_cap s f ts l =
  (case mgu_class A_ (Fun (f, map e_cap ts)) l of NONE => false
    | SOME mu =>
      list_all
        (fn u =>
          nfq (subst_apply_term (map_term (fn x => x) (fn a => #"y" :: a) u)
                mu))
        (args l) andalso
        list_all (fn u => nfq (subst_apply_term u mu)) s);

fun is_ur_closed_term_af_impl A_ C_ nfq e_cap pi r u s (Var x) = true
  | is_ur_closed_term_af_impl A_ C_ nfq e_cap pi r u s (Fun (f, ts)) =
    let
      val n = size_list ts;
      val pi_f = pi (f, n);
    in
      list_all
        (fn (i, t) =>
          (if member (ceq_nat, ccompare_nat) i pi_f
            then is_ur_closed_term_af_impl A_ C_ nfq e_cap pi r u s t
            else true))
        (zip (upt zero_nata n) ts) andalso
        list_all
          (fn (l, ra) =>
            membera (equal_prod (equal_term A_ (equal_list equal_char)) C_) u
              (l, ra) orelse
              not (rule_match_impl A_ nfq e_cap s f ts l))
          r
    end;

fun is_ur_closed_af_impl_dpp_mv (B1_, B2_, B3_) i d pi =
  let
    val ic = icap_impl_dpp B1_ i d;
    val qnf = is_QNFc i d;
    val r = rulese i d;
    val urc =
      (fn s =>
        is_ur_closed_term_af_impl B1_ (equal_term B1_ (equal_list equal_char))
          qnf (ic s) pi r);
  in
    (fn u => fn s =>
      let
        val sa = map (map_term (fn x => x) (fn a => #"x" :: a)) s;
      in
        (fn t => urc sa u sa (map_term (fn x => x) (fn a => #"x" :: a) t))
      end)
  end;

fun wwf_rulesa
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = wwf_rules;

fun q_emptyc
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = q_empty;

fun matchCapRMBelow A_ B_ rm l (Fun (f, ts)) =
  matchb A_ B_ (GCFun (f, map (tcapRM2 A_ B_ rm) ts)) l;

fun forallM_index_aux p i [] = Inr ()
  | forallM_index_aux p i (x :: xs) =
    bindb (catch_errora (p x i) (fn xa => Inl ((x, i), xa)))
      (fn _ => forallM_index_aux p (suc i) xs);

fun forallM_index p xs = forallM_index_aux p zero_nata xs;

fun check_ur_closed_term_rm_af (A1_, A2_) (B1_, B2_) uu uv uw (Var x) = Inr ()
  | check_ur_closed_term_rm_af (A1_, A2_) (B1_, B2_) rm ur pi (Fun (f, ts)) =
    let
      val n = size_list ts;
      val pia = pi (f, n);
    in
      bindb (catch_errora
              (forallM_index
                (fn t => fn i =>
                  (if member (ceq_nat, ccompare_nat) i pia
                    then check_ur_closed_term_rm_af (A1_, A2_) (B1_, B2_) rm ur
                           pi t
                    else Inr ()))
                ts)
              (fn x => Inl (snd x)))
        (fn _ =>
          catch_errora
            (forallM
              (fn lr =>
                check (membera
                         (equal_prod (equal_term A1_ B1_) (equal_term A1_ B1_))
                         ur lr orelse
                        not (matchCapRMBelow A1_ B1_ rm (fst lr) (Fun (f, ts))))
                  (shows_string
                     [#"d", #"u", #"e", #" ", #"t", #"o", #" ", #"t", #"h",
                       #"e", #" ", #"s", #"u", #"b", #"t", #"e", #"r", #"m",
                       #" "] o
                    (shows_prec_term A2_ B2_ zero_nata (Fun (f, ts)) o
                      (shows_string
                         [#" ", #"o", #"f", #" ", #"s", #"o", #"m", #"e", #" ",
                           #"u", #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"h",
                           #"s", #",", #" ", #"r", #"u", #"l", #"e", #" "] o
                        (shows_rule (shows_prec A2_ zero_nata)
                           (shows_prec B2_ zero_nata) [#" ", #"-", #">", #" "]
                           lr o
                          shows_string
                            [#" ", #"s", #"h", #"o", #"u", #"l", #"d", #" ",
                              #"b", #"e", #" ", #"u", #"s", #"a", #"b", #"l",
                              #"e", #"."])))))
              (rm (f, n)))
            (fn x => Inl (snd x)))
    end;

fun check_ur_P_closed_rm_af (A1_, A2_) (B1_, B2_) rm ur pi p =
  bindb (catch_errora
          (catch_errora
            (forallM
              (fn lr =>
                check_ur_closed_term_rm_af (A1_, A2_) (B1_, B2_) rm ur pi
                  (snd lr))
              ur)
            (fn x => Inl (snd x)))
          (fn x =>
            Inl (shows_string
                   [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e", #"n",
                     #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ",
                     #"c", #"l", #"o", #"s", #"u", #"r", #"e", #" ", #"p", #"r",
                     #"o", #"p", #"e", #"r", #"t", #"i", #"e", #"s", #" ", #"o",
                     #"f", #" ", #"r", #"h", #"s", #" ", #"o", #"f", #" ", #"u",
                     #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"u", #"l", #"e",
                     #"s"] o
                  (shows_nl o x))))
    (fn _ =>
      catch_errora
        (catch_errora
          (forallM
            (fn st =>
              check_ur_closed_term_rm_af (A1_, A2_) (B1_, B2_) rm ur pi
                (snd st))
            p)
          (fn x => Inl (snd x)))
        (fn x =>
          Inl (shows_string
                 [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e", #"n",
                   #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ",
                   #"c", #"l", #"o", #"s", #"u", #"r", #"e", #" ", #"p", #"r",
                   #"o", #"p", #"e", #"r", #"t", #"i", #"e", #"s", #" ", #"o",
                   #"f", #" ", #"r", #"h", #"s", #" ", #"o", #"f", #" ", #"D",
                   #"P", #"s"] o
                (shows_nl o x))));

fun smart_usable_rules_checker_impl (B1_, B2_, B3_) i d pi u_opt sts =
  let
    val nfs = nfsc i d;
    val m = minimal i d;
    val wwf = wwf_rulesa i d;
    val qempty = q_emptyc i d;
  in
    (case u_opt of NONE => Inr (rulese i d)
      | SOME u =>
        (if nFQ_subset_NF_rulesc i d andalso
              ((nfs orelse
                 isOK (check_varcond_subset B3_
                        (equal_list equal_char, show_list show_char)
                        sts)) andalso
                (nfs orelse (m orelse wwf)))
          then let
                 val urc = is_ur_closed_af_impl_dpp_mv (B1_, B2_, B3_) i d pi u;
                 val check_urc =
                   (fn s => fn t =>
                     check (urc s t)
                       (shows_prec_list show_char zero_nata
                          [#"t", #"e", #"r", #"m", #" "] o
                         (shows_prec_term B3_ (show_list show_char) zero_nata
                            t o
                           shows_prec_list show_char zero_nata
                             [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                               #"c", #"l", #"o", #"s", #"e", #"d", #" ", #"u",
                               #"n", #"d", #"e", #"r", #" ", #"u", #"s", #"a",
                               #"b", #"l", #"e", #" ", #"r", #"u", #"l", #"e",
                               #"s"])));
               in
                 bindb (catch_errora
                         (forallM (fn (s, a) => check_urc [s] a) sts)
                         (fn x => Inl (snd x)))
                   (fn _ =>
                     bindb (catch_errora
                             (forallM (fn (l, a) => check_urc (args l) a) u)
                             (fn x => Inl (snd x)))
                       (fn _ => Inr u))
               end
          else bindb (check
                       (m andalso (if nfs then qempty orelse wwf else true))
                       (shows_prec_list show_char zero_nata
                         [#"m", #"i", #"n", #"i", #"m", #"a", #"l", #"i", #"t",
                           #"y", #" ", #"a", #"n", #"d", #" ", #"w", #"e", #"l",
                           #"l", #" ", #"f", #"o", #"r", #"m", #"e", #"d", #"n",
                           #"e", #"s", #"s", #" ", #"r", #"e", #"q", #"u", #"i",
                           #"r", #"e", #"d"]))
                 (fn _ =>
                   bindb (catch_errora
                           (forallM
                             (fn (l, _) =>
                               check (not (is_Var l))
                                 (shows_prec_list show_char zero_nata
                                   [#"v", #"a", #"r", #"i", #"a", #"b", #"l",
                                     #"e", #"s", #" ", #"a", #"s", #" ", #"l",
                                     #"h", #"s", #"s", #" ", #"n", #"o", #"t",
                                     #" ", #"a", #"l", #"l", #"o", #"w", #"e",
                                     #"d"]))
                             (rulese i d))
                           (fn x => Inl (snd x)))
                     (fn _ =>
                       let
                         val rm = rules_mapc i d;
                       in
                         bindb (check_ur_P_closed_rm_af (B1_, B3_)
                                 (equal_list equal_char, show_list show_char) rm
                                 u pi sts)
                           (fn _ => Inr u)
                       end))))
  end;

fun root_aft_to_entry s t pi =
  let
    val rt = the (root t);
    val pi_t = pi rt;
    val ts = args t;
  in
    map_filter
      (fn x =>
        (if member (ceq_nat, ccompare_nat) x pi_t then SOME (s, nth ts x)
          else NONE))
      (upt zero_nata (snd rt))
  end;

fun check_no_defined_root A_ B_ isdef t =
  check (not (isdef (the (root t))))
    (shows_string
       [#"t", #"h", #"e", #" ", #"r", #"o", #"o", #"t", #" ", #"o", #"f",
         #" "] o
      (shows_prec_term A_ B_ zero_nata t o
        shows_string
          [#" ", #"i", #"s", #" ", #"d", #"e", #"f", #"i", #"n", #"e", #"d"]));

fun pairsb
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = pairs;

fun validb (Root_redtriple_ext (valid, s, ns, nst, af, aft, desc, more)) =
  valid;

fun descb (Root_redtriple_ext (valid, s, ns, nst, af, aft, desc, more)) = desc;

fun nsta (Root_redtriple_ext (valid, s, ns, nst, af, aft, desc, more)) = nst;

fun aft (Root_redtriple_ext (valid, s, ns, nst, af, aft, desc, more)) = aft;

fun nsa (Root_redtriple_ext (valid, s, ns, nst, af, aft, desc, more)) = ns;

fun afa (Root_redtriple_ext (valid, s, ns, nst, af, aft, desc, more)) = af;

fun sa (Root_redtriple_ext (valid, s, ns, nst, af, aft, desc, more)) = s;

fun generic_ur_af_root_redtriple_proc (B1_, B2_, B3_) i rp u_opt premove dpp =
  (case catch_errora
          (bindb (validb rp)
            (fn _ =>
              let
                val (ps, pns) = split_pairsa i dpp premove;
                val p = pairsb i dpp;
                val pi = afa rp;
                val pia = aft rp;
                val is_def = (fn fna => not (null (rules_mapc i dpp fna)));
              in
                bindb (catch_errora
                        (forallM
                          (fn (l, r) =>
                            bindb (check_no_var B3_ (show_list show_char) l)
                              (fn _ =>
                                bindb (check_no_var B3_ (show_list show_char) r)
                                  (fn _ =>
                                    check_no_defined_root B3_
                                      (show_list show_char) is_def r)))
                          p)
                        (fn x => Inl (snd x)))
                  (fn _ =>
                    bindb (catch_errora
                            (forallM
                              (fn (l, _) =>
                                check_no_var B3_ (show_list show_char) l)
                              (rulese i dpp))
                            (fn x => Inl (snd x)))
                      (fn _ =>
                        bindb (smart_usable_rules_checker_impl (B1_, B2_, B3_) i
                                dpp pi u_opt
                                (maps (fn (s, t) => root_aft_to_entry s t pia)
                                  p))
                          (fn u =>
                            bindb (catch_errora
                                    (catch_errora (forallM (nsa rp) u)
                                      (fn x => Inl (snd x)))
                                    (fn x =>
                                      Inl
(shows_string
   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n",
     #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"(",
     #"u", #"s", #"a", #"b", #"l", #"e", #")", #" ", #"r", #"u", #"l", #"e",
     #"s"] o
  (shows_nl o x))))
                              (fn _ =>
                                bindb (catch_errora
(catch_errora (forallM (nsta rp) pns) (fn x => Inl (snd x)))
(fn x =>
  Inl (shows_string
         [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
           #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g",
           #" ", #"D", #"P", #"s"] o
        (shows_nl o x))))
                                  (fn _ =>
                                    catch_errora
                                      (catch_errora (forallM (sa rp) ps)
(fn x => Inl (snd x)))
                                      (fn x =>
Inl (shows_string
       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n",
         #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"D",
         #"P", #"s"] o
      (shows_nl o x))))))))
              end))
          (fn x =>
            Inl (shows_string
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"a", #"p", #"p", #"l", #"y", #" ", #"t", #"h", #"e", #" ",
                     #"g", #"e", #"n", #"e", #"r", #"i", #"c", #" ", #"r", #"o",
                     #"o", #"t", #" ", #"r", #"e", #"d", #"u", #"c", #"t", #"i",
                     #"o", #"n", #" ", #"p", #"a", #"i", #"r", #" ", #"p", #"r",
                     #"o", #"c", #"e", #"s", #"s", #"o", #"r", #" ", #"w", #"i",
                     #"t", #"h", #" ", #"t", #"h", #"e", #" ", #"f", #"o", #"l",
                     #"l", #"o", #"w", #"i", #"n", #"g"] o
                  (shows_nl o (descb rp o (shows_nl o x)))))
    of Inl a => Inl a | Inr _ => Inr (delete_P_Pwa i dpp premove premove));

fun nst
  (Redtriple_ext
    (valid, s, ns, nst, af, mono_af, mono, desc, not_ws_ns, cpx, more))
  = nst;

fun generic_ur_af_redtriple_proc (B1_, B2_, B3_) i rp u_opt premove dpp =
  (case catch_errora
          (bindb (valid rp)
            (fn _ =>
              let
                val (ps, pns) = split_pairsa i dpp premove;
                val p = pairsb i dpp;
              in
                bindb (smart_usable_rules_checker_impl (B1_, B2_, B3_) i dpp
                        (af rp) u_opt p)
                  (fn u =>
                    bindb (catch_errora
                            (catch_errora (forallM (ns rp) u)
                              (fn x => Inl (snd x)))
                            (fn x =>
                              Inl (shows_string
                                     [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                       #" ", #"w", #"h", #"e", #"n", #" ", #"o",
                                       #"r", #"i", #"e", #"n", #"t", #"i", #"n",
                                       #"g", #" ", #"(", #"u", #"s", #"a", #"b",
                                       #"l", #"e", #")", #" ", #"r", #"u", #"l",
                                       #"e", #"s"] o
                                    (shows_nl o x))))
                      (fn _ =>
                        bindb (catch_errora
                                (catch_errora (forallM (nst rp) pns)
                                  (fn x => Inl (snd x)))
                                (fn x =>
                                  Inl (shows_string
 [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n", #" ",
   #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"D", #"P",
   #"s"] o
(shows_nl o x))))
                          (fn _ =>
                            catch_errora
                              (catch_errora (forallM (s rp) ps)
                                (fn x => Inl (snd x)))
                              (fn x =>
                                Inl (shows_string
                                       [#"p", #"r", #"o", #"b", #"l", #"e",
 #"m", #" ", #"w", #"h", #"e", #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t",
 #"i", #"n", #"g", #" ", #"D", #"P", #"s"] o
                                      (shows_nl o x))))))
              end))
          (fn x =>
            Inl (shows_string
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"a", #"p", #"p", #"l", #"y", #" ", #"t", #"h", #"e", #" ",
                     #"g", #"e", #"n", #"e", #"r", #"i", #"c", #" ", #"r", #"e",
                     #"d", #"u", #"c", #"t", #"i", #"o", #"n", #" ", #"p", #"a",
                     #"i", #"r", #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s",
                     #"o", #"r", #" ", #"w", #"i", #"t", #"h", #" ", #"t", #"h",
                     #"e", #" ", #"f", #"o", #"l", #"l", #"o", #"w", #"i", #"n",
                     #"g"] o
                  (shows_nl o (desc rp o (shows_nl o x)))))
    of Inl a => Inl a | Inr _ => Inr (delete_P_Pwa i dpp premove premove));

fun is_ur_closed_term_impl A_ C_ nfq e_cap r u s (Var x) = true
  | is_ur_closed_term_impl A_ C_ nfq e_cap r u s (Fun (f, ts)) =
    list_all (is_ur_closed_term_impl A_ C_ nfq e_cap r u s) ts andalso
      list_all
        (fn (l, ra) =>
          membera (equal_prod (equal_term A_ (equal_list equal_char)) C_) u
            (l, ra) orelse
            not (rule_match_impl A_ nfq e_cap s f ts l))
        r;

fun is_ur_closed_impl_dpp_mv (B1_, B2_, B3_) i d =
  let
    val ic = icap_impl_dpp B1_ i d;
    val qnf = is_QNFc i d;
    val r = rulese i d;
    val urc =
      (fn s =>
        is_ur_closed_term_impl B1_ (equal_term B1_ (equal_list equal_char)) qnf
          (ic s) r);
  in
    (fn u => fn s =>
      let
        val sa = map (map_term (fn x => x) (fn a => #"x" :: a)) s;
      in
        (fn t => urc sa u sa (map_term (fn x => x) (fn a => #"x" :: a) t))
      end)
  end;

fun intersect_rulesb
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = intersect_rules;

fun usable_rules_proc (B1_, B2_, B3_) i u dpp =
  (case bindb (check (nFQ_subset_NF_rulesc i dpp)
                (shows_prec_list show_char zero_nata
                  [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ",
                    #"r", #"e", #"w", #"r", #"i", #"t", #"i", #"n", #"g", #" ",
                    #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]))
          (fn _ =>
            bindb (check
                    (nfsc i dpp orelse (minimal i dpp orelse wwf_rulesa i dpp))
                    (shows_prec_list show_char zero_nata
                      [#"n", #"o", #"r", #"m", #"a", #"l", #" ", #"f", #"o",
                        #"r", #"m", #" ", #"s", #"u", #"b", #"s", #"t", #",",
                        #" ", #"m", #"i", #"n", #"i", #"m", #"a", #"l", #"i",
                        #"t", #"y", #" ", #"o", #"r", #" ", #"w", #"e", #"l",
                        #"l", #"-", #"f", #"o", #"r", #"m", #"e", #"d", #"n",
                        #"e", #"s", #"s", #" ", #"r", #"e", #"q", #"u", #"i",
                        #"r", #"e", #"d"]))
              (fn _ =>
                let
                  val p = pairsb i dpp;
                  val urc = is_ur_closed_impl_dpp_mv (B1_, B2_, B3_) i dpp u;
                  val check_urc =
                    (fn s => fn t =>
                      check (urc s t)
                        (shows_prec_list show_char zero_nata
                           [#"t", #"e", #"r", #"m", #" "] o
                          (shows_prec_term B3_ (show_list show_char) zero_nata
                             t o
                            shows_prec_list show_char zero_nata
                              [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                                #"c", #"l", #"o", #"s", #"e", #"d", #" ", #"u",
                                #"n", #"d", #"e", #"r", #" ", #"u", #"s", #"a",
                                #"b", #"l", #"e", #" ", #"r", #"u", #"l", #"e",
                                #"s"])));
                  val nfs = nfsc i dpp;
                in
                  bindb (catch_errora
                          (forallM
                            (fn (l, r) =>
                              bindb (if nfs then Inr ()
                                      else catch_errora
     (check_subseteq (equal_list equal_char) (vars_term_list r)
       (vars_term_list l))
     (fn _ =>
       Inl (shows_prec_list show_char zero_nata
             [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #" ", #"c", #"o",
               #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ", #"i", #"n", #" ",
               #"P", #" ", #"v", #"i", #"o", #"l", #"a", #"t", #"e", #"d"])))
                                (fn _ => check_urc [l] r))
                            p)
                          (fn x => Inl (snd x)))
                    (fn _ =>
                      catch_errora
                        (forallM (fn (l, a) => check_urc (args l) a) u)
                        (fn x => Inl (snd x)))
                end))
    of Inl a => Inl a | Inr _ => Inr (intersect_rulesb i dpp u));

fun mono
  (Redtriple_ext
    (valid, s, ns, nst, af, mono_af, mono, desc, not_ws_ns, cpx, more))
  = mono;

fun mono_inn_usable_rules_ce_proc (B1_, B2_, B3_, B4_, B5_, B6_) i rp premove
  rremove ur dpp =
  (case catch_errora
          (bindb (usable_rules_proc (B3_, B4_, B6_) i ur dpp)
            (fn _ =>
              let
                val p = pairsb i dpp;
                val us =
                  foldr (sup_seta
                           (ceq_prod B1_ ceq_nat,
                             ccompare_prod B2_ ccompare_nat) o
                          (funas_term (B1_, B2_, B5_) o snd))
                    (p @ ur)
                    (bot_set
                      (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat,
                        set_impl_prod B5_ set_impl_nat));
                val filt =
                  (fn lr =>
                    ball (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat)
                      (funas_term (B1_, B2_, B5_) (fst lr))
                      (fn f =>
                        member
                          (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat)
                          f us));
                val (pms, pns) = split_pairsa i dpp premove;
                val (ps, pnwf) = partition filt pms;
                val (urms, urns) =
                  partition
                    (membera
                      (equal_prod (equal_term B3_ (equal_list equal_char))
                        (equal_term B3_ (equal_list equal_char)))
                      rremove)
                    ur;
                val (urs, urnwf) = partition filt urms;
              in
                bindb (valid rp)
                  (fn _ =>
                    bindb (mono rp (ps @ urs @ urns @ urnwf @ pns @ pnwf))
                      (fn _ =>
                        bindb (catch_errora
                                (catch_errora (forallM (ns rp) (urns @ urnwf))
                                  (fn x => Inl (snd x)))
                                (fn x =>
                                  Inl (shows_string
 [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n", #" ",
   #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"u", #"s", #"a",
   #"b", #"l", #"e", #" ", #"r", #"u", #"l", #"e", #"s"] o
(shows_nl o x))))
                          (fn _ =>
                            bindb (catch_errora
                                    (catch_errora (forallM (s rp) urs)
                                      (fn x => Inl (snd x)))
                                    (fn x =>
                                      Inl
(shows_string
   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n",
     #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"u",
     #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"u", #"l", #"e", #"s"] o
  (shows_nl o x))))
                              (fn _ =>
                                bindb (catch_errora
(catch_errora (forallM (ns rp) (pns @ pnwf)) (fn x => Inl (snd x)))
(fn x =>
  Inl (shows_string
         [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
           #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g",
           #" ", #"D", #"P", #"s"] o
        (shows_nl o x))))
                                  (fn _ =>
                                    catch_errora
                                      (catch_errora (forallM (s rp) ps)
(fn x => Inl (snd x)))
                                      (fn x =>
Inl (shows_string
       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n",
         #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"D",
         #"P", #"s"] o
      (shows_nl o x))))))))
              end))
          (fn x =>
            Inl (shows_string
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"a", #"p", #"p", #"l", #"y", #" ", #"t", #"h", #"e", #" ",
                     #"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ",
                     #"u", #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"u", #"l",
                     #"e", #"s", #" ", #"r", #"e", #"d", #"u", #"c", #"t", #"i",
                     #"o", #"n", #" ", #"p", #"a", #"i", #"r", #" ", #"p", #"r",
                     #"o", #"c", #"e", #"s", #"s", #"o", #"r", #" ", #"w", #"i",
                     #"t", #"h", #" ", #"t", #"h", #"e", #" ", #"f", #"o", #"l",
                     #"l", #"o", #"w", #"i", #"n", #"g"] o
                  (shows_nl o (desc rp o (shows_nl o x)))))
    of Inl a => Inl a
    | Inr _ =>
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove
            rremove));

fun mono_ur_redpair_proc (B1_, B2_, B3_, B4_, B5_) (C1_, C2_) i rp premove
  rremove ur dpp =
  (case catch_errora
          (bindb
            (check (minimal i dpp)
              (shows_prec_list show_char zero_nata
                [#"m", #"i", #"n", #"i", #"m", #"a", #"l", #"i", #"t", #"y",
                  #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]))
            (fn _ =>
              bindb (check
                      (if nfsc i dpp
                        then (if not (q_emptyc i dpp) then wwf_rulesa i dpp
                               else true)
                        else true)
                      (shows_prec_list show_char zero_nata
                        [#"w", #"e", #"l", #"l", #" ", #"f", #"o", #"r", #"m",
                          #"e", #"d", #"n", #"e", #"s", #"s", #" ", #"r", #"e",
                          #"q", #"u", #"i", #"r", #"e", #"d"]))
                (fn _ =>
                  let
                    val p = pairsb i dpp;
                    val us =
                      foldr (sup_seta
                               (ceq_prod B1_ ceq_nat,
                                 ccompare_prod B2_ ccompare_nat) o
                              (funas_term (B1_, B2_, B4_) o snd))
                        (p @ ur)
                        (bot_set
                          (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat,
                            set_impl_prod B4_ set_impl_nat));
                    val filt =
                      (fn lr =>
                        ball (ceq_prod B1_ ceq_nat,
                               ccompare_prod B2_ ccompare_nat)
                          (funas_term (B1_, B2_, B4_) (fst lr))
                          (fn f =>
                            member
                              (ceq_prod B1_ ceq_nat,
                                ccompare_prod B2_ ccompare_nat)
                              f us));
                    val (pms, pns) = split_pairsa i dpp premove;
                    val (ps, pnwf) = partition filt pms;
                    val (urms, urns) =
                      partition
                        (membera
                          (equal_prod (equal_term B3_ C1_) (equal_term B3_ C1_))
                          rremove)
                        ur;
                    val (urs, urnwf) = partition filt urms;
                    val rm = rules_mapc i dpp;
                  in
                    bindb (valid rp)
                      (fn _ =>
                        bindb (mono rp (ps @ urs @ urns @ urnwf @ pns @ pnwf))
                          (fn _ =>
                            bindb (check_ur_P_closed_rm_af (B3_, B5_) (C1_, C2_)
                                    rm ur full_af p)
                              (fn _ =>
                                bindb (catch_errora
(forallM
  (fn (l, _) =>
    check (not (is_Var l))
      (shows_prec_list show_char zero_nata
        [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #"s", #" ", #"a", #"s",
          #" ", #"l", #"h", #"s", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
          #"l", #"l", #"o", #"w", #"e", #"d"]))
  (rulese i dpp))
(fn x => Inl (snd x)))
                                  (fn _ =>
                                    bindb (catch_errora
    (catch_errora (forallM (ns rp) (urns @ urnwf)) (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_string
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
               #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g",
               #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"u", #"l",
               #"e", #"s"] o
            (shows_nl o x))))
                                      (fn _ =>
bindb (catch_errora (catch_errora (forallM (s rp) urs) (fn x => Inl (snd x)))
        (fn x =>
          Inl (shows_string
                 [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h",
                   #"e", #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i",
                   #"n", #"g", #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ",
                   #"r", #"u", #"l", #"e", #"s"] o
                (shows_nl o x))))
  (fn _ =>
    bindb (catch_errora
            (catch_errora (forallM (ns rp) (pns @ pnwf)) (fn x => Inl (snd x)))
            (fn x =>
              Inl (shows_string
                     [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w",
                       #"h", #"e", #"n", #" ", #"o", #"r", #"i", #"e", #"n",
                       #"t", #"i", #"n", #"g", #" ", #"D", #"P", #"s"] o
                    (shows_nl o x))))
      (fn _ =>
        catch_errora (catch_errora (forallM (s rp) ps) (fn x => Inl (snd x)))
          (fn x =>
            Inl (shows_string
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h",
                     #"e", #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i",
                     #"n", #"g", #" ", #"D", #"P", #"s"] o
                  (shows_nl o x))))))))))
                  end)))
          (fn x =>
            Inl (shows_string
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"a", #"p", #"p", #"l", #"y", #" ", #"t", #"h", #"e", #" ",
                     #"m", #"o", #"n", #"o", #"t", #"o", #"n", #"i", #"c", #" ",
                     #"r", #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n", #" ",
                     #"p", #"a", #"i", #"r", #" ", #"p", #"r", #"o", #"c", #"e",
                     #"s", #"s", #"o", #"r", #" ", #"w", #"i", #"t", #"h", #" ",
                     #"t", #"h", #"e", #" ", #"f", #"o", #"l", #"l", #"o", #"w",
                     #"i", #"n", #"g"] o
                  (shows_nl o (desc rp o (shows_nl o x)))))
    of Inl a => Inl a
    | Inr _ =>
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove
            rremove));

fun generic_mono_ur_redpair_proc (B1_, B2_, B3_, B4_, B5_, B6_) i rp premove
  rremove ur dpp =
  (if nFQ_subset_NF_rulesc i dpp
    then mono_inn_usable_rules_ce_proc (B1_, B2_, B3_, B4_, B5_, B6_) i rp
           premove rremove ur dpp
    else bindb (check (minimal i dpp)
                 (shows_prec_list show_char zero_nata
                   [#"m", #"i", #"n", #"i", #"m", #"a", #"l", #"i", #"t", #"y",
                     #" ", #"o", #"r", #" ", #"i", #"n", #"n", #"e", #"r", #"m",
                     #"o", #"s", #"t", #" ", #"r", #"e", #"q", #"u", #"i", #"r",
                     #"e", #"d", #" ", #"f", #"o", #"r", #" ", #"m", #"o", #"n",
                     #".", #" ", #"r", #"e", #"d", #".", #" ", #"p", #"a", #"i",
                     #"r", #" ", #"p", #"r", #"o", #"c", #".", #" ", #"w", #"i",
                     #"t", #"h", #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ",
                     #"r", #"u", #"l", #"e", #"s"]))
           (fn _ =>
             mono_ur_redpair_proc (B1_, B2_, B3_, B5_, B6_)
               (equal_list equal_char, show_list show_char) i rp premove rremove
               ur dpp));

fun compat_roota A_ uu NONE = false
  | compat_roota A_ (Var uv) (SOME v) = false
  | compat_roota A_ (Fun (va, vb)) (SOME v) =
    equal_optiona (equal_prod A_ equal_nat) (root (Fun (va, vb))) (SOME v);

fun usable_rules_gen2 A_ r (fna, b) =
  let
    val rr =
      maps (fn (l, ra) => (if compat_roota A_ l fna then [(l, ra)] else [])) r;
  in
    (if b then rr else map (fn (l, ra) => (ra, l)) rr)
  end;

fun rel_dep_prod uu Ignore = []
  | rel_dep_prod b Increase = [b]
  | rel_dep_prod b Decrease = [not b]
  | rel_dep_prod uv Wild = [true, false];

fun compat_root A_ uu (Var uv) = false
  | compat_root A_ (Var uw) (Fun (v, va)) = false
  | compat_root A_ (Fun (vb, vc)) (Fun (v, va)) =
    equal_optiona (equal_prod A_ equal_nat) (root (Fun (vb, vc)))
      (root (Fun (v, va)));

fun usable_rules_gen1 A_ pi r (Var uu, uv) = []
  | usable_rules_gen1 A_ pi r (Fun (f, ts), b) =
    let
      val n = size_list ts;
    in
      maps (fn (l, ra) =>
             (if compat_root A_ l (Fun (f, ts)) then [(ra, b)] else []))
        r @
        maps (fn i =>
               map (fn a => (nth ts i, a)) (rel_dep_prod b (pi (f, n) i)))
          (upt zero_nata n)
    end;

fun usable_rules_gen A_ B_ pi r p =
  maps (usable_rules_gen2 A_ r)
    (remdups (equal_prod (equal_option (equal_prod A_ equal_nat)) equal_bool)
      (map (fn (t, a) => (root t, a))
        (mk_rtrancl_list (equal_proda (equal_term A_ B_) equal_bool)
          (usable_rules_gen1 A_ pi r) (map (fn (_, t) => (t, true)) p))));

fun generate_lists n xs = concat_lists (map (fn _ => xs) (upt zero_nata n));

fun initial_conditions_gen_impl pa bef_len aft_len p st =
  let
    val pairs = (fn n => generate_lists n p);
    val a =
      maps (fn bef => map (fn aft => bef @ st :: aft) (pairs aft_len))
        (pairs bef_len);
  in
    filtera
      (fn bef_st_aft =>
        all_interval_nat
          (fn i => pa (nth bef_st_aft i) (nth bef_st_aft (suc i))) zero_nata
          (plus_nata bef_len aft_len))
      a
  end;

fun is_partition_impl (A1_, A2_, A3_, A4_) [] =
  SOME (bot_set (A2_, ccompare_cproper_interval A3_, A4_))
  | is_partition_impl (A1_, A2_, A3_, A4_) (asa :: rest) =
    bind (is_partition_impl (A1_, A2_, A3_, A4_) rest)
      (fn all =>
        (if is_empty (A1_, A2_, A3_, A4_)
              (inf_seta (A2_, ccompare_cproper_interval A3_) asa all)
          then SOME (sup_seta (A2_, ccompare_cproper_interval A3_) all asa)
          else NONE));

fun is_partition (A1_, A2_, A3_, A4_) asa =
  not (is_none (is_partition_impl (A1_, A2_, A3_, A4_) asa));

fun disjoint_variant (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) sts uvs
  = equal_nata (size_list sts) (size_list uvs) andalso
      (all_interval_nat
         (fn i =>
           eq_rule_mod_vars A2_ (ccompare_cproper_interval B4_, B6_, B7_)
             (nth sts i) (nth uvs i))
         zero_nata (size_list sts) andalso
        is_partition (B1_, B3_, B4_, B8_)
          (map (vars_rule (A1_, A2_)
                 (finite_UNIV_card_UNIV B1_, B2_, B3_, B4_, B5_, B6_, B8_))
            uvs));

fun condition_of c Bound (s, uu) = CC_cond (false, (s, Fun (c, [])))
  | condition_of c Strict st = CC_cond (true, st)
  | condition_of c Non_Strict st = CC_cond (false, st);

fun constraint_of c ctype uvs bef =
  CC_impl
    (map (fn i => CC_rewr (snd (nth uvs i), fst (nth uvs (suc i))))
       (upt zero_nata (minus_nata (size_list uvs) one_nata)),
      condition_of c ctype (nth uvs bef));

fun the_set_impl_main_lazy (A1_, A2_, A3_) B_ q gen_as have_asa have_as bs =
  let
    val new_as =
      maps (fn b =>
             maps (fn a =>
                    (if not (member (A1_, A2_) a have_as) then [a] else []))
               (gen_as b))
        bs;
  in
    (if null new_as then have_asa
      else the_set_impl_main_lazy (A1_, A2_, A3_) B_ q gen_as
             (new_as @ have_asa)
             (sup_seta (A1_, A2_) (set (A1_, A2_, A3_) new_as) have_as)
             (remdups B_ (maps q new_as)))
  end;

fun the_set_impl_lazy (A1_, A2_, A3_) B_ q gen_as bs =
  the_set_impl_main_lazy (A1_, A2_, A3_) B_ q gen_as []
    (bot_set (A1_, A2_, A3_)) bs;

fun inductive_set_impl_lazy A_ (B1_, B2_, B3_) q p =
  the_set_impl_lazy (B1_, B2_, B3_) A_ p q;

fun ur_term_impl A_ C_ nfq e_cap r pi s (Var x) = []
  | ur_term_impl A_ C_ nfq e_cap r pi s (Fun (f, ts)) =
    let
      val n = size_list ts;
      val reca = map (ur_term_impl A_ C_ nfq e_cap r pi s) ts;
    in
      remdups (equal_prod (equal_term A_ (equal_list equal_char)) C_)
        (maps (fn (i, urs) =>
                (if member (ceq_nat, ccompare_nat) i (pi (f, n)) then urs
                  else []))
           (zip (upt zero_nata n) reca) @
          filtera (fn (l, _) => rule_match_impl A_ nfq e_cap s f ts l) r)
    end;

fun precompute_fun A_ f asa =
  fun_of_map_fun (ceta_map_of A_ (map (fn a => (a, f a)) asa)) f;

fun usable_rules_calc_impl (A1_, A2_) nfq e_cap r =
  let
    val urt =
      (fn (s, t) =>
        let
          val sa = map (map_term (fn x => x) (fn a => #"x" :: a)) s;
        in
          ur_term_impl A1_ (equal_term A1_ (equal_list equal_char)) nfq
            (e_cap sa) r full_af sa (map_term (fn x => x) (fn a => #"x" :: a) t)
        end);
    val urules = map (fn (l, a) => (args l, a)) r;
    val ufun =
      precompute_fun
        (key_prod
          (key_list
            (equal_term A1_ (equal_list equal_char),
              key_term A2_ (key_list (equal_char, key_char))))
          (key_term A2_ (key_list (equal_char, key_char))))
        urt urules;
  in
    inductive_set_impl_lazy
      (equal_prod (equal_list (equal_term A1_ (equal_list equal_char)))
        (equal_term A1_ (equal_list equal_char)))
      (ceq_prod (ceq_term A1_ (equal_list equal_char))
         (ceq_term A1_ (equal_list equal_char)),
        ccompare_prod
          (ccompare_term ((compare_compare_order o compare_order_key) A2_)
            (compare_list compare_char))
          (ccompare_term ((compare_compare_order o compare_order_key) A2_)
            (compare_list compare_char)),
        set_impl_prod set_impl_term set_impl_term)
      ufun (fn (l, ra) => [(args l, ra)])
  end;

fun ur_calc_singleton (A1_, A2_) nfq e_cap r st =
  usable_rules_calc_impl (A1_, A2_) nfq e_cap r [st];

fun inn_usable_rules_pair (B1_, B2_) i d =
  let
    val inn = nFQ_subset_NF_rulesc i d;
    val r = rulese i d;
    val qnf = is_QNFc i d;
    val ic = icap_impl_dpp B1_ i d;
    val calc = ur_calc_singleton (B1_, B2_) qnf ic r;
    val nfs = nfsc i d;
    val wwf = wwf_rulesa i d;
    val m = minimal i d;
  in
    (fn (s, t) =>
      (if inn andalso
            ((nfs orelse
               subset
                 (card_UNIV_list, cenum_list, ceq_list ceq_char,
                   ccompare_list ccompare_char)
                 (vars_term
                   ((compare_compare_order o compare_order_key) B2_, B1_)
                   (finite_UNIV_list, cenum_list, ceq_list ceq_char,
                     cproper_interval_list ccompare_char,
                     compare_list compare_char, equal_list equal_char,
                     set_impl_list)
                   t)
                 (vars_term
                   ((compare_compare_order o compare_order_key) B2_, B1_)
                   (finite_UNIV_list, cenum_list, ceq_list ceq_char,
                     cproper_interval_list ccompare_char,
                     compare_list compare_char, equal_list equal_char,
                     set_impl_list)
                   s)) andalso
              (nfs orelse (m orelse wwf)))
        then calc ([s], t) else r))
  end;

fun icap_impl_dpp_mv B_ i d =
  let
    val qr = nFQ_subset_NF_rulesc i d;
    val qnf = is_QNFc i d;
    val r = rulese i d;
    val ic = icap_impl_gen B_ qr qnf (map fst r);
  in
    (fn s =>
      let
        val sa = map (map_term (fn x => x) (fn a => #"x" :: a)) s;
        val sx =
          ceta_set_of (key_list (equal_char, key_char))
            (maps vars_term_list sa);
      in
        (fn t => ic sa sx (map_term (fn x => x) (fn a => #"x" :: a) t))
      end)
  end;

fun is_iedg_edge_dpp (B1_, B2_, B3_) i d =
  let
    val qnf = is_QNFc i d;
    val ic = icap_impl_dpp_mv B1_ i d;
    val _ = rulese i d;
    val urules = inn_usable_rules_pair (B1_, B2_) i d;
  in
    (fn (s, t) =>
      let
        val cst = ic [s] t;
        val urls = reverse_rules (urules (s, t));
        val ica =
          icap_impl B1_
            (is_NF_terms (B1_, B2_)
              (ccompare_list ccompare_char, equal_list equal_char,
                mapping_impl_list)
              [])
            urls;
      in
        (fn u =>
          (case mgu_class B1_ cst u of NONE => false
            | SOME mu =>
              qnf (subst_apply_term (map_term (fn x => x) (fn a => #"x" :: a) s)
                    mu) andalso
                qnf (subst_apply_term
                      (map_term (fn x => x) (fn a => #"y" :: a) u) mu)) andalso
            let
              val cu = ica [] u;
            in
              (case mgu_class B1_ cu t of NONE => false
                | SOME mu =>
                  qnf (subst_apply_term
                        (map_term (fn x => x) (fn a => #"y" :: a) s) mu))
            end)
      end)
  end;

fun deep_normalize_cca (CC_impl ([], c)) = deep_normalize_cca c
  | deep_normalize_cca (CC_impl (v :: va, c)) =
    CC_impl (map deep_normalize_cca (v :: va), deep_normalize_cca c)
  | deep_normalize_cca (CC_cond (s, c)) = CC_cond (s, c)
  | deep_normalize_cca (CC_all (s, c)) = CC_all (s, deep_normalize_cca c)
  | deep_normalize_cca (CC_rewr (s, c)) = CC_rewr (s, c);

fun vars_cc_list B_ (CC_cond (ct, (s, t))) = vars_term_list s @ vars_term_list t
  | vars_cc_list B_ (CC_rewr (s, t)) = vars_term_list s @ vars_term_list t
  | vars_cc_list B_ (CC_impl (c1, c2)) =
    maps (vars_cc_list B_) c1 @ vars_cc_list B_ c2
  | vars_cc_list B_ (CC_all (x, c)) =
    maps (fn y => (if not (eq B_ y x) then [y] else [])) (vars_cc_list B_ c);

fun cc_subst_apply A_ fresh (CC_all (x, c)) (sigma, vs) =
  let
    val y = fresh (vs @ vars_cc_list A_ (CC_all (x, c)));
  in
    CC_all (y, cc_subst_apply A_ fresh c (fun_upd A_ sigma x (Var y), y :: vs))
  end
  | cc_subst_apply A_ fresh (CC_impl (c1, c2)) sigma =
    CC_impl
      (map (fn c => cc_subst_apply A_ fresh c sigma) c1,
        cc_subst_apply A_ fresh c2 sigma)
  | cc_subst_apply A_ fresh (CC_rewr (s, t)) (sigma, uv) =
    CC_rewr (subst_apply_term s sigma, subst_apply_term t sigma)
  | cc_subst_apply A_ fresh (CC_cond (ct, (s, t))) (sigma, uu) =
    CC_cond (ct, (subst_apply_term s sigma, subst_apply_term t sigma));

fun normalize_alpha A_ fresh c = cc_subst_apply A_ fresh c (Var, []);

fun deep_normalize_cc A_ fresh c =
  normalize_alpha A_ fresh (deep_normalize_cca c);

fun check_subsumesa A_ B_ (CC_impl (cs, c)) (CC_impl (ds, d)) =
  check_subsumesa A_ B_ c d andalso
    list_all (fn ca => list_ex (fn da => check_subsumesa A_ B_ da ca) ds) cs
  | check_subsumesa A_ B_ (CC_cond (v, va)) (CC_impl (ds, d)) =
    check_subsumesa A_ B_ (CC_cond (v, va)) d
  | check_subsumesa A_ B_ (CC_rewr (v, va)) (CC_impl (ds, d)) =
    check_subsumesa A_ B_ (CC_rewr (v, va)) d
  | check_subsumesa A_ B_ (CC_all (v, va)) (CC_impl (ds, d)) =
    check_subsumesa A_ B_ (CC_all (v, va)) d
  | check_subsumesa A_ B_ (CC_all (x, c)) (CC_all (y, d)) =
    eq B_ x y andalso check_subsumesa A_ B_ c d
  | check_subsumesa A_ B_ (CC_cond (v, va)) (CC_cond (vb, vc)) =
    equal_cond_constrainta A_ B_ (CC_cond (v, va)) (CC_cond (vb, vc))
  | check_subsumesa A_ B_ (CC_cond (v, va)) (CC_rewr (vb, vc)) =
    equal_cond_constrainta A_ B_ (CC_cond (v, va)) (CC_rewr (vb, vc))
  | check_subsumesa A_ B_ (CC_cond (v, va)) (CC_all (vb, vc)) =
    equal_cond_constrainta A_ B_ (CC_cond (v, va)) (CC_all (vb, vc))
  | check_subsumesa A_ B_ (CC_rewr (v, va)) (CC_cond (vb, vc)) =
    equal_cond_constrainta A_ B_ (CC_rewr (v, va)) (CC_cond (vb, vc))
  | check_subsumesa A_ B_ (CC_rewr (v, va)) (CC_rewr (vb, vc)) =
    equal_cond_constrainta A_ B_ (CC_rewr (v, va)) (CC_rewr (vb, vc))
  | check_subsumesa A_ B_ (CC_rewr (v, va)) (CC_all (vb, vc)) =
    equal_cond_constrainta A_ B_ (CC_rewr (v, va)) (CC_all (vb, vc))
  | check_subsumesa A_ B_ (CC_all (v, va)) (CC_cond (vb, vc)) =
    equal_cond_constrainta A_ B_ (CC_all (v, va)) (CC_cond (vb, vc))
  | check_subsumesa A_ B_ (CC_all (v, va)) (CC_rewr (vb, vc)) =
    equal_cond_constrainta A_ B_ (CC_all (v, va)) (CC_rewr (vb, vc))
  | check_subsumesa A_ B_ c (CC_cond (v, va)) =
    equal_cond_constrainta A_ B_ c (CC_cond (v, va))
  | check_subsumesa A_ B_ c (CC_rewr (v, va)) =
    equal_cond_constrainta A_ B_ c (CC_rewr (v, va))
  | check_subsumesa A_ B_ (CC_impl (vb, vc)) (CC_all (v, va)) =
    equal_cond_constrainta A_ B_ (CC_impl (vb, vc)) (CC_all (v, va));

fun check_subsumes A_ B_ fresh c d = let
                                       val n = deep_normalize_cc A_ fresh;
                                     in
                                       check_subsumesa B_ A_ (n c) (n d)
                                     end;

fun check_constraint_present (B1_, B2_, B3_) i dpp constant p bef aft ccs =
  let
    val edg = is_iedg_edge_dpp (B1_, B2_, B3_) i dpp;
    val init_conds =
      initial_conditions_gen_impl (fn st => fn uv => edg st (fst uv)) bef aft p;
  in
    (fn ct => fn st =>
      catch_errora
        (forallM
          (fn sts =>
            check (list_ex
                    (fn (c, uvs) =>
                      disjoint_variant
                        ((compare_compare_order o compare_order_key) B2_, B1_)
                        (card_UNIV_list, cenum_list, ceq_list ceq_char,
                          cproper_interval_list ccompare_char,
                          compare_list compare_char, equal_list equal_char,
                          mapping_impl_list, set_impl_list)
                        sts uvs andalso
                        check_subsumes (equal_list equal_char) B1_
                          (fresh_string [#"x", #"x"]) c
                          (constraint_of constant ct uvs bef))
                    ccs)
              (shows_prec_list show_char zero_nata
                 [#"d", #"i", #"d", #" ", #"n", #"o", #"t", #" ", #"f", #"i",
                   #"n", #"d", #" "] o
                (shows_prec_list show_char zero_nata
                   (case ct of Bound => [#"b", #"o", #"u", #"n", #"d"]
                     | Strict => [#"s", #"t", #"r", #"i", #"c", #"t"]
                     | Non_Strict =>
                       [#"n", #"o", #"n", #"-", #"s", #"t", #"r", #"i", #"c",
                         #"t"]) o
                  (shows_prec_list show_char zero_nata
                     [#" ", #"c", #"o", #"n", #"s", #"t", #"r", #"a", #"i",
                       #"n", #"t", #" ", #"f", #"o", #"r", #" ", #"s", #"e",
                       #"q", #"u", #"e", #"n", #"c", #"e", #" "] o
                    shows_rules (shows_prec B3_ zero_nata)
                      (shows_prec_list show_char zero_nata)
                      [#" ", #"-", #">", #" "] sts))))
          (init_conds st))
        (fn x => Inl (snd x)))
  end;

fun check_weakly_orthogonal (A1_, A2_) r =
  catch_errora
    (bindb
      (check_left_linear_trs A2_
        (ceq_list ceq_char, ccompare_list ccompare_char, set_impl_list,
          show_list show_char)
        r)
      (fn _ =>
        bindb (catch_errora
                (forallM
                  (fn (l, _) =>
                    check (not (is_Var l))
                      (shows_prec_list show_char zero_nata
                        [#"t", #"h", #"e", #" ", #"T", #"R", #"S", #" ", #"h",
                          #"a", #"s", #" ", #"v", #"a", #"r", #"i", #"a", #"b",
                          #"l", #"e", #"s", #" ", #"a", #"s", #" ", #"l", #"e",
                          #"f", #"t", #"-", #"h", #"a", #"n", #"d", #" ", #"s",
                          #"i", #"d", #"e", #"s"]))
                  r)
                (fn x => Inl (snd x)))
          (fn _ =>
            catch_errora
              (forallM
                (fn (_, (s, t)) =>
                  check (equal_terma A1_ (equal_list equal_char) s t)
                    (shows_prec_list show_char zero_nata
                       [#"t", #"h", #"e", #"r", #"e", #" ", #"i", #"s", #" ",
                         #"a", #" ", #"n", #"o", #"n", #"-", #"t", #"r", #"i",
                         #"v", #"i", #"a", #"l", #" ", #"c", #"r", #"i", #"t",
                         #"i", #"c", #"a", #"l", #" ", #"p", #"a", #"i", #"r",
                         #":", #" "] o
                      (shows_term (shows_prec A2_ zero_nata)
                         (shows_prec_list show_char zero_nata) s o
                        (shows_prec_list show_char zero_nata
                           [#" ", #"<", #"-", #" ", #".", #" ", #"-", #">",
                             #" "] o
                          shows_term (shows_prec A2_ zero_nata)
                            (shows_prec_list show_char zero_nata) t))))
                (critical_pairs_impl A1_ r r))
              (fn x => Inl (snd x)))))
    (fn x =>
      Inl (x o (shows_nl o
                 (shows_prec_list show_char zero_nata
                    [#"h", #"e", #"n", #"c", #"e", #",", #" ", #"t", #"h", #"e",
                      #" ", #"f", #"o", #"l", #"l", #"o", #"w", #"i", #"n",
                      #"g", #" ", #"T", #"R", #"S", #" ", #"i", #"s", #" ",
                      #"n", #"o", #"t", #" ", #"w", #"e", #"a", #"k", #"l",
                      #"y", #" ", #"o", #"r", #"t", #"h", #"o", #"g", #"o",
                      #"n", #"a", #"l", #" "] o
                   (shows_nl o
                     (shows_trs (shows_prec A2_ zero_nata)
                        (shows_prec_list show_char zero_nata)
                        [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s",
                          #"y", #"s", #"t", #"e", #"m", #":"]
                        [#" ", #"-", #">", #" "] r o
                       indent x))))));

fun validc (Non_inf_order_ext (valid, ns, cc, af, desc, more)) = valid;

fun descc (Non_inf_order_ext (valid, ns, cc, af, desc, more)) = desc;

fun nsb (Non_inf_order_ext (valid, ns, cc, af, desc, more)) = ns;

fun cc (Non_inf_order_ext (valid, ns, cc, af, desc, more)) = cc;

fun afb (Non_inf_order_ext (valid, ns, cc, af, desc, more)) = af;

fun range_vars_impl A_ B_ sigma = let
                                    val a = mk_subst_domain A_ B_ sigma;
                                  in
                                    maps (vars_term_list o snd) a
                                  end;

fun cc_bound [] c = c
  | cc_bound (x :: xs) c = CC_all (x, cc_bound xs c);

fun cc_ih_prems A_ B_ fresh f q xs phi psi rs_ys_list =
  map (fn (r, ys) =>
        let
          val rs = args r;
          val mu = mk_subst A_ Var (zip xs rs);
          val vs = range_vars_impl A_ B_ (zip xs rs);
          val mua = (fn c => cc_subst_apply A_ fresh c (mu, vs));
          val a =
            CC_impl
              (CC_rewr (r, subst_apply_term q mu) :: map mua phi, mua psi);
        in
          cc_bound ys a
        end)
    rs_ys_list;

fun cc_rule_constraint A_ B_ fresh f ls r q xs phi psi rs_ys_list =
  let
    val sigma = mk_subst A_ Var (zip xs ls);
    val vs = range_vars_impl A_ B_ (zip xs ls);
    val rew = CC_rewr (r, subst_apply_term q sigma);
    val phi_sig = map (fn c => cc_subst_apply A_ fresh c (sigma, vs)) phi;
    val psi_sig = cc_subst_apply A_ fresh psi (sigma, vs);
    val ihs = cc_ih_prems A_ B_ fresh f q xs phi psi rs_ys_list;
  in
    CC_impl (rew :: phi_sig @ ihs, psi_sig)
  end;

fun cc_unbound (CC_all (x, c)) = let
                                   val (xs, a) = cc_unbound c;
                                 in
                                   (x :: xs, a)
                                 end
  | cc_unbound (CC_cond (v, va)) = ([], CC_cond (v, va))
  | cc_unbound (CC_rewr (v, va)) = ([], CC_rewr (v, va))
  | cc_unbound (CC_impl (v, va)) = ([], CC_impl (v, va));

fun funas_args_term_list t = maps funas_term_list (args t);

fun check_rys (A1_, A2_) (B1_, B2_) d rt r rys =
  let
    val (ra, ys) = rys;
  in
    bindb (check (equal_optiona (equal_prod A1_ equal_nat) (root ra) rt)
            (shows_string [#"r", #"o", #"o", #"t", #" ", #"o", #"f", #" "] o
              (shows_prec_term A2_ B2_ zero_nata ra o
                (shows_string [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" "] o
                  shows_prec_prod A2_ show_nat zero_nata (the rt)))))
      (fn _ =>
        bindb (check (equal_terma A1_ B1_ r ra orelse supt_impl A1_ B1_ r ra)
                (shows_prec_term A2_ B2_ zero_nata ra o
                  (shows_string
                     [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                       #" ", #"s", #"u", #"b", #"t", #"e", #"r", #"m", #" ",
                       #"o", #"f", #" "] o
                    shows_prec_term A2_ B2_ zero_nata r)))
          (fn _ =>
            bindb (catch_errora
                    (forallM
                      (fn f =>
                        check (not (d f))
                          (shows_string
                             [#"t", #"h", #"e", #" ", #"d", #"e", #"f", #"i",
                               #"n", #"e", #"d", #" ", #"s", #"y", #"m", #"b",
                               #"o", #"l", #" "] o
                            (shows_prec_prod A2_ show_nat zero_nata f o
                              (shows_string
                                 [#" ", #"o", #"c", #"c", #"u", #"r", #"s",
                                   #" ", #"i", #"n", #" ", #"t", #"h", #"e",
                                   #" ", #"s", #"u", #"b", #"t", #"e", #"r",
                                   #"m", #" "] o
                                (shows_prec_term A2_ B2_ zero_nata ra o
                                  shows_prec_list show_char zero_nata
                                    [#" ", #"o", #"f", #" ", #"t", #"h", #"e",
                                      #" ", #"r", #"h", #"s"])))))
                      (funas_args_term_list ra))
                    (fn x => Inl (snd x)))
              (fn _ =>
                catch_errora (check_disjoint B1_ ys (vars_term_list r))
                  (fn x =>
                    Inl (shows_prec B2_ zero_nata x o
                          (shows_string
                             [#" ", #"o", #"c", #"c", #"u", #"r", #"s", #" ",
                               #"i", #"n", #" "] o
                            shows_prec_term A2_ B2_ zero_nata r))))))
  end;

fun shows_cc_aux A_ B_ b (CC_rewr (s, t)) =
  shows_prec_term A_ B_ zero_nata s o
    (shows_prec_list show_char zero_nata [#" ", #"=", #" "] o
      shows_prec_term A_ B_ zero_nata t)
  | shows_cc_aux A_ B_ b (CC_cond (stri, (s, t))) =
    shows_prec_term A_ B_ zero_nata s o
      (shows_prec_list show_char zero_nata
         (if stri then [#" ", #">", #" "] else [#" ", #">", #"=", #" "]) o
        shows_prec_term A_ B_ zero_nata t)
  | shows_cc_aux A_ B_ b (CC_all (x, c)) =
    let
      val s =
        shows_prec_list show_char zero_nata [#"A", #"L", #"L", #" "] o
          (shows_prec B_ zero_nata x o
            (shows_prec_list show_char zero_nata [#".", #" "] o
              shows_cc_aux A_ B_ false c));
    in
      (if b then shows_prec_list show_char zero_nata [#"("] o
                   (s o shows_prec_list show_char zero_nata [#")"])
        else s)
    end
  | shows_cc_aux A_ B_ b (CC_impl (cs, c2)) =
    shows_string [#"("] o
      (shows_list_gen (shows_cc_aux A_ B_ true) [#"T", #"r", #"u", #"e"] []
         [#" ", #"a", #"n", #"d", #" "] [] cs o
        (shows_prec_list show_char zero_nata [#" ", #"=", #">", #" "] o
          (shows_cc_aux A_ B_ true c2 o
            shows_prec_list show_char zero_nata [#")"])));

fun shows_cc A_ B_ = shows_cc_aux A_ B_ false;

fun prems_of (CC_impl (c1, c2)) = c1
  | prems_of (CC_cond (v, va)) = []
  | prems_of (CC_rewr (v, va)) = []
  | prems_of (CC_all (v, va)) = [];

fun concl_of (CC_impl (c1, c2)) = c2
  | concl_of (CC_cond (v, va)) = CC_cond (v, va)
  | concl_of (CC_rewr (v, va)) = CC_rewr (v, va)
  | concl_of (CC_all (v, va)) = CC_all (v, va);

fun normalize_cc c = CC_impl (prems_of c, concl_of c);

fun check_cc_prf (A1_, A2_, A3_, A4_, A5_) r d f m_ortho cc Final =
  (case normalize_cc cc
    of CC_cond (_, _) =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"f", #"i", #"n", #"a", #"l", #" ", #"c", #"o", #"n", #"s", #"t",
               #"r", #"a", #"i", #"n", #"t", #":", #" ", #"i", #"t", #" ", #"i",
               #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"a",
               #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ",
               #"n", #"o", #"r", #" ", #"a", #"n", #" ", #"i", #"m", #"p", #"l",
               #"i", #"f", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
               #"f", #" ", #"t", #"w", #"o", #" ", #"c", #"o", #"n", #"d", #"i",
               #"t", #"i", #"o", #"n", #"s", #",", #" ", #"b", #"u", #"t", #" ",
               #"i", #"t", #" ", #"i", #"s", #" "] o
            (shows_nl o shows_cc A5_ (show_list show_char) cc))
    | CC_rewr (_, _) =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"f", #"i", #"n", #"a", #"l", #" ", #"c", #"o", #"n", #"s", #"t",
               #"r", #"a", #"i", #"n", #"t", #":", #" ", #"i", #"t", #" ", #"i",
               #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"a",
               #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ",
               #"n", #"o", #"r", #" ", #"a", #"n", #" ", #"i", #"m", #"p", #"l",
               #"i", #"f", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
               #"f", #" ", #"t", #"w", #"o", #" ", #"c", #"o", #"n", #"d", #"i",
               #"t", #"i", #"o", #"n", #"s", #",", #" ", #"b", #"u", #"t", #" ",
               #"i", #"t", #" ", #"i", #"s", #" "] o
            (shows_nl o shows_cc A5_ (show_list show_char) cc))
    | CC_impl ([], CC_cond (stri, st)) => Inr [Unconditional_C (stri, st)]
    | CC_impl ([], CC_rewr (_, _)) =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"f", #"i", #"n", #"a", #"l", #" ", #"c", #"o", #"n", #"s", #"t",
               #"r", #"a", #"i", #"n", #"t", #":", #" ", #"i", #"t", #" ", #"i",
               #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"a",
               #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ",
               #"n", #"o", #"r", #" ", #"a", #"n", #" ", #"i", #"m", #"p", #"l",
               #"i", #"f", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
               #"f", #" ", #"t", #"w", #"o", #" ", #"c", #"o", #"n", #"d", #"i",
               #"t", #"i", #"o", #"n", #"s", #",", #" ", #"b", #"u", #"t", #" ",
               #"i", #"t", #" ", #"i", #"s", #" "] o
            (shows_nl o shows_cc A5_ (show_list show_char) cc))
    | CC_impl ([], CC_impl (_, _)) =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"f", #"i", #"n", #"a", #"l", #" ", #"c", #"o", #"n", #"s", #"t",
               #"r", #"a", #"i", #"n", #"t", #":", #" ", #"i", #"t", #" ", #"i",
               #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"a",
               #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ",
               #"n", #"o", #"r", #" ", #"a", #"n", #" ", #"i", #"m", #"p", #"l",
               #"i", #"f", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
               #"f", #" ", #"t", #"w", #"o", #" ", #"c", #"o", #"n", #"d", #"i",
               #"t", #"i", #"o", #"n", #"s", #",", #" ", #"b", #"u", #"t", #" ",
               #"i", #"t", #" ", #"i", #"s", #" "] o
            (shows_nl o shows_cc A5_ (show_list show_char) cc))
    | CC_impl ([], CC_all (_, _)) =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"f", #"i", #"n", #"a", #"l", #" ", #"c", #"o", #"n", #"s", #"t",
               #"r", #"a", #"i", #"n", #"t", #":", #" ", #"i", #"t", #" ", #"i",
               #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"a",
               #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ",
               #"n", #"o", #"r", #" ", #"a", #"n", #" ", #"i", #"m", #"p", #"l",
               #"i", #"f", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
               #"f", #" ", #"t", #"w", #"o", #" ", #"c", #"o", #"n", #"d", #"i",
               #"t", #"i", #"o", #"n", #"s", #",", #" ", #"b", #"u", #"t", #" ",
               #"i", #"t", #" ", #"i", #"s", #" "] o
            (shows_nl o shows_cc A5_ (show_list show_char) cc))
    | CC_impl ([CC_cond (stri, uv)], CC_cond (stria, st)) =>
      (if equal_boola stri stria then Inr [Conditional_C (stri, uv, st)]
        else Inl (shows_prec_list show_char zero_nata
                    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                      #" ", #"f", #"i", #"n", #"a", #"l", #" ", #"c", #"o",
                      #"n", #"s", #"t", #"r", #"a", #"i", #"n", #"t", #":",
                      #" ", #"d", #"i", #"f", #"f", #"e", #"r", #"e", #"n",
                      #"t", #" ", #"r", #"e", #"l", #"a", #"t", #"i", #"o",
                      #"n", #"s", #" ", #"f", #"o", #"r", #" ", #"f", #"i",
                      #"n", #"a", #"l", #"i", #"z", #"i", #"n", #"g", #" "] o
                   shows_cc A5_ (show_list show_char) cc))
    | CC_impl ([CC_cond (_, _)], CC_rewr (_, _)) =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"f", #"i", #"n", #"a", #"l", #" ", #"c", #"o", #"n", #"s", #"t",
               #"r", #"a", #"i", #"n", #"t", #":", #" ", #"i", #"t", #" ", #"i",
               #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"a",
               #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ",
               #"n", #"o", #"r", #" ", #"a", #"n", #" ", #"i", #"m", #"p", #"l",
               #"i", #"f", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
               #"f", #" ", #"t", #"w", #"o", #" ", #"c", #"o", #"n", #"d", #"i",
               #"t", #"i", #"o", #"n", #"s", #",", #" ", #"b", #"u", #"t", #" ",
               #"i", #"t", #" ", #"i", #"s", #" "] o
            (shows_nl o shows_cc A5_ (show_list show_char) cc))
    | CC_impl ([CC_cond (_, _)], CC_impl (_, _)) =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"f", #"i", #"n", #"a", #"l", #" ", #"c", #"o", #"n", #"s", #"t",
               #"r", #"a", #"i", #"n", #"t", #":", #" ", #"i", #"t", #" ", #"i",
               #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"a",
               #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ",
               #"n", #"o", #"r", #" ", #"a", #"n", #" ", #"i", #"m", #"p", #"l",
               #"i", #"f", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
               #"f", #" ", #"t", #"w", #"o", #" ", #"c", #"o", #"n", #"d", #"i",
               #"t", #"i", #"o", #"n", #"s", #",", #" ", #"b", #"u", #"t", #" ",
               #"i", #"t", #" ", #"i", #"s", #" "] o
            (shows_nl o shows_cc A5_ (show_list show_char) cc))
    | CC_impl ([CC_cond (_, _)], CC_all (_, _)) =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"f", #"i", #"n", #"a", #"l", #" ", #"c", #"o", #"n", #"s", #"t",
               #"r", #"a", #"i", #"n", #"t", #":", #" ", #"i", #"t", #" ", #"i",
               #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"a",
               #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ",
               #"n", #"o", #"r", #" ", #"a", #"n", #" ", #"i", #"m", #"p", #"l",
               #"i", #"f", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
               #"f", #" ", #"t", #"w", #"o", #" ", #"c", #"o", #"n", #"d", #"i",
               #"t", #"i", #"o", #"n", #"s", #",", #" ", #"b", #"u", #"t", #" ",
               #"i", #"t", #" ", #"i", #"s", #" "] o
            (shows_nl o shows_cc A5_ (show_list show_char) cc))
    | CC_impl (CC_cond (_, _) :: _ :: _, _) =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"f", #"i", #"n", #"a", #"l", #" ", #"c", #"o", #"n", #"s", #"t",
               #"r", #"a", #"i", #"n", #"t", #":", #" ", #"i", #"t", #" ", #"i",
               #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"a",
               #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ",
               #"n", #"o", #"r", #" ", #"a", #"n", #" ", #"i", #"m", #"p", #"l",
               #"i", #"f", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
               #"f", #" ", #"t", #"w", #"o", #" ", #"c", #"o", #"n", #"d", #"i",
               #"t", #"i", #"o", #"n", #"s", #",", #" ", #"b", #"u", #"t", #" ",
               #"i", #"t", #" ", #"i", #"s", #" "] o
            (shows_nl o shows_cc A5_ (show_list show_char) cc))
    | CC_impl (CC_rewr (_, _) :: _, _) =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"f", #"i", #"n", #"a", #"l", #" ", #"c", #"o", #"n", #"s", #"t",
               #"r", #"a", #"i", #"n", #"t", #":", #" ", #"i", #"t", #" ", #"i",
               #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"a",
               #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ",
               #"n", #"o", #"r", #" ", #"a", #"n", #" ", #"i", #"m", #"p", #"l",
               #"i", #"f", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
               #"f", #" ", #"t", #"w", #"o", #" ", #"c", #"o", #"n", #"d", #"i",
               #"t", #"i", #"o", #"n", #"s", #",", #" ", #"b", #"u", #"t", #" ",
               #"i", #"t", #" ", #"i", #"s", #" "] o
            (shows_nl o shows_cc A5_ (show_list show_char) cc))
    | CC_impl (CC_impl (_, _) :: _, _) =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"f", #"i", #"n", #"a", #"l", #" ", #"c", #"o", #"n", #"s", #"t",
               #"r", #"a", #"i", #"n", #"t", #":", #" ", #"i", #"t", #" ", #"i",
               #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"a",
               #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ",
               #"n", #"o", #"r", #" ", #"a", #"n", #" ", #"i", #"m", #"p", #"l",
               #"i", #"f", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
               #"f", #" ", #"t", #"w", #"o", #" ", #"c", #"o", #"n", #"d", #"i",
               #"t", #"i", #"o", #"n", #"s", #",", #" ", #"b", #"u", #"t", #" ",
               #"i", #"t", #" ", #"i", #"s", #" "] o
            (shows_nl o shows_cc A5_ (show_list show_char) cc))
    | CC_impl (CC_all (_, _) :: _, _) =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"f", #"i", #"n", #"a", #"l", #" ", #"c", #"o", #"n", #"s", #"t",
               #"r", #"a", #"i", #"n", #"t", #":", #" ", #"i", #"t", #" ", #"i",
               #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"a",
               #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ",
               #"n", #"o", #"r", #" ", #"a", #"n", #" ", #"i", #"m", #"p", #"l",
               #"i", #"f", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
               #"f", #" ", #"t", #"w", #"o", #" ", #"c", #"o", #"n", #"d", #"i",
               #"t", #"i", #"o", #"n", #"s", #",", #" ", #"b", #"u", #"t", #" ",
               #"i", #"t", #" ", #"i", #"s", #" "] o
            (shows_nl o shows_cc A5_ (show_list show_char) cc))
    | CC_all (_, _) =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"f", #"i", #"n", #"a", #"l", #" ", #"c", #"o", #"n", #"s", #"t",
               #"r", #"a", #"i", #"n", #"t", #":", #" ", #"i", #"t", #" ", #"i",
               #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"a",
               #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ",
               #"n", #"o", #"r", #" ", #"a", #"n", #" ", #"i", #"m", #"p", #"l",
               #"i", #"f", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
               #"f", #" ", #"t", #"w", #"o", #" ", #"c", #"o", #"n", #"d", #"i",
               #"t", #"i", #"o", #"n", #"s", #",", #" ", #"b", #"u", #"t", #" ",
               #"i", #"t", #" ", #"i", #"s", #" "] o
            (shows_nl o shows_cc A5_ (show_list show_char) cc)))
  | check_cc_prf (A1_, A2_, A3_, A4_, A5_) r da f m_ortho c
    (Delete_Condition (d, prf)) =
    bindb (check
            (check_subsumes (equal_list equal_char) A3_
              (fresh_string [#"x", #"x"]) d c)
            (shows_string
               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                 #" ", #"d", #"e", #"l", #"e", #"t", #"e", #" ", #"c", #"o",
                 #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s", #" ", #"w",
                 #"h", #"e", #"n", #" ", #"s", #"w", #"i", #"t", #"c", #"h",
                 #"i", #"n", #"g", #" ", #"f", #"r", #"o", #"m", #" "] o
              (shows_nl o
                (shows_cc A5_ (show_list show_char) c o
                  (shows_string [#" ", #"t", #"o", #" "] o
                    (shows_nl o shows_cc A5_ (show_list show_char) d))))))
      (fn _ => check_cc_prf (A1_, A2_, A3_, A4_, A5_) r da f m_ortho d prf)
  | check_cc_prf (A1_, A2_, A3_, A4_, A5_) r da f m_ortho c
    (Different_Constructor d) =
    let
      val CC_impl (cs, _) = normalize_cc c;
    in
      catch_errora
        (bindb
          (check
            (membera (equal_cond_constraint A3_ (equal_list equal_char)) cs d)
            (shows_cc A5_ (show_list show_char) d o
              (shows_nl o
                (shows_string
                   [#"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"p",
                     #"r", #"e", #"m", #"i", #"s", #"e", #" ", #"o", #"f",
                     #" "] o
                  shows_cc A5_ (show_list show_char) c))))
          (fn _ =>
            (case d
              of CC_cond (_, _) =>
                Inl (shows_cc A5_ (show_list show_char) d o
                      shows_prec_list show_char zero_nata
                        [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                          #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                          #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
                          #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"c",
                          #"o", #"r", #"r", #"e", #"c", #"t", #" ", #"s", #"h",
                          #"a", #"p", #"e"])
              | CC_rewr (Var _, _) =>
                Inl (shows_cc A5_ (show_list show_char) d o
                      shows_prec_list show_char zero_nata
                        [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                          #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                          #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
                          #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"c",
                          #"o", #"r", #"r", #"e", #"c", #"t", #" ", #"s", #"h",
                          #"a", #"p", #"e"])
              | CC_rewr (Fun (_, _), Var _) =>
                Inl (shows_cc A5_ (show_list show_char) d o
                      shows_prec_list show_char zero_nata
                        [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                          #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                          #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
                          #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"c",
                          #"o", #"r", #"r", #"e", #"c", #"t", #" ", #"s", #"h",
                          #"a", #"p", #"e"])
              | CC_rewr (Fun (fa, ss), Fun (g, ts)) =>
                bindb (check (not (da (fa, size_list ss)))
                        (shows_prec A5_ zero_nata fa o
                          shows_prec_list show_char zero_nata
                            [#" ", #"i", #"s", #" ", #"d", #"e", #"f", #"i",
                              #"n", #"e", #"d"]))
                  (fn _ =>
                    bindb (check
                            (not (equal_proda A3_ equal_nat (fa, size_list ss)
                                   (g, size_list ts)))
                            (shows_string
                               [#"t", #"h", #"e", #" ", #"r", #"o", #"o", #"t",
                                 #" "] o
                              (shows_prec A5_ zero_nata fa o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"i", #"s", #" ", #"i", #"d", #"e",
                                    #"n", #"t", #"i", #"c", #"a", #"l", #" ",
                                    #"o", #"n", #" ", #"b", #"o", #"t", #"h",
                                    #" ", #"s", #"i", #"d", #"e", #"s"])))
                      (fn _ => Inr []))
              | CC_impl (_, _) =>
                Inl (shows_cc A5_ (show_list show_char) d o
                      shows_prec_list show_char zero_nata
                        [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                          #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                          #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
                          #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"c",
                          #"o", #"r", #"r", #"e", #"c", #"t", #" ", #"s", #"h",
                          #"a", #"p", #"e"])
              | CC_all (_, _) =>
                Inl (shows_cc A5_ (show_list show_char) d o
                      shows_prec_list show_char zero_nata
                        [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                          #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                          #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
                          #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"c",
                          #"o", #"r", #"r", #"e", #"c", #"t", #" ", #"s", #"h",
                          #"a", #"p", #"e"]))))
        (fn x =>
          Inl (shows_string
                 [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                   #" ", #"D", #"i", #"f", #"f", #"e", #"r", #"e", #"n", #"t",
                   #" ", #"C", #"o", #"n", #"s", #"t", #"r", #"u", #"c", #"t",
                   #"o", #"r", #" ", #"w", #"i", #"t", #"h", #" ", #"r", #"e",
                   #"w", #"r", #"i", #"t", #"e", #" ", #"c", #"o", #"n", #"d",
                   #"i", #"t", #"i", #"o", #"n", #" "] o
                (shows_cc A5_ (show_list show_char) d o
                  (shows_nl o
                    (shows_string
                       [#"o", #"n", #" ", #"i", #"n", #"p", #"u", #"t", #" ",
                         #"c", #"o", #"n", #"s", #"t", #"r", #"a", #"i", #"n",
                         #"t", #" "] o
                      (shows_nl o
                        (shows_cc A5_ (show_list show_char) c o
                          (shows_nl o x))))))))
    end
  | check_cc_prf (A1_, A2_, A3_, A4_, A5_) r da f m_ortho ca
    (Same_Constructor (d, c, p)) =
    let
      val CC_impl (cs, con) = normalize_cc ca;
    in
      bindb (catch_errora
              (bindb
                (check
                  (membera (equal_cond_constraint A3_ (equal_list equal_char))
                    cs d)
                  (shows_cc A5_ (show_list show_char) d o
                    (shows_nl o
                      (shows_string
                         [#"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ",
                           #"p", #"r", #"e", #"m", #"i", #"s", #"e", #" ", #"o",
                           #"f", #" "] o
                        shows_cc A5_ (show_list show_char) ca))))
                (fn _ =>
                  (case d
                    of CC_cond (_, _) =>
                      Inl (shows_cc A5_ (show_list show_char) d o
                            shows_prec_list show_char zero_nata
                              [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                                #"a", #" ", #"r", #"e", #"w", #"r", #"i", #"t",
                                #"e", #" ", #"c", #"o", #"n", #"d", #"i", #"t",
                                #"i", #"o", #"n", #" ", #"o", #"f", #" ", #"t",
                                #"h", #"e", #" ", #"c", #"o", #"r", #"r", #"e",
                                #"c", #"t", #" ", #"s", #"h", #"a", #"p", #"e"])
                    | CC_rewr (Var _, _) =>
                      Inl (shows_cc A5_ (show_list show_char) d o
                            shows_prec_list show_char zero_nata
                              [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                                #"a", #" ", #"r", #"e", #"w", #"r", #"i", #"t",
                                #"e", #" ", #"c", #"o", #"n", #"d", #"i", #"t",
                                #"i", #"o", #"n", #" ", #"o", #"f", #" ", #"t",
                                #"h", #"e", #" ", #"c", #"o", #"r", #"r", #"e",
                                #"c", #"t", #" ", #"s", #"h", #"a", #"p", #"e"])
                    | CC_rewr (Fun (_, _), Var _) =>
                      Inl (shows_cc A5_ (show_list show_char) d o
                            shows_prec_list show_char zero_nata
                              [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                                #"a", #" ", #"r", #"e", #"w", #"r", #"i", #"t",
                                #"e", #" ", #"c", #"o", #"n", #"d", #"i", #"t",
                                #"i", #"o", #"n", #" ", #"o", #"f", #" ", #"t",
                                #"h", #"e", #" ", #"c", #"o", #"r", #"r", #"e",
                                #"c", #"t", #" ", #"s", #"h", #"a", #"p", #"e"])
                    | CC_rewr (Fun (fa, ss), Fun (g, ts)) =>
                      bindb (check (not (da (fa, size_list ss)))
                              (shows_prec A5_ zero_nata fa o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"i", #"s", #" ", #"d", #"e", #"f",
                                    #"i", #"n", #"e", #"d"]))
                        (fn _ =>
                          bindb (check
                                  (equal_proda A3_ equal_nat (fa, size_list ss)
                                    (g, size_list ts))
                                  (shows_prec A5_ zero_nata fa o
                                    (shows_string
                                       [#" ", #"a", #"n", #"d", #" "] o
                                      (shows_prec A5_ zero_nata g o
shows_prec_list show_char zero_nata
  [#" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ", #"i", #"d", #"e", #"n",
    #"t", #"i", #"c", #"a", #"l"]))))
                            (fn _ =>
                              let
                                val ds =
                                  cs @ map (fn (a, b) => CC_rewr (a, b))
 (zip ss ts);
                                val db = CC_impl (ds, con);
                              in
                                check (check_subsumes (equal_list equal_char)
A3_ (fresh_string [#"x", #"x"]) c db)
                                  (shows_string
                                     [#"n", #"e", #"w", #" ", #"c", #"o", #"n",
                                       #"s", #"t", #"r", #"a", #"i", #"n", #"t",
                                       #" ", #"i", #"s", #" "] o
                                    (shows_cc A5_ (show_list show_char) c o
                                      (shows_nl o
(shows_string
   [#"b", #"u", #"t", #" ", #"e", #"x", #"p", #"e", #"c", #"t", #"e", #"d",
     #" ", #"w", #"a", #"s", #" "] o
  shows_cc A5_ (show_list show_char) db))))
                              end))
                    | CC_impl (_, _) =>
                      Inl (shows_cc A5_ (show_list show_char) d o
                            shows_prec_list show_char zero_nata
                              [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                                #"a", #" ", #"r", #"e", #"w", #"r", #"i", #"t",
                                #"e", #" ", #"c", #"o", #"n", #"d", #"i", #"t",
                                #"i", #"o", #"n", #" ", #"o", #"f", #" ", #"t",
                                #"h", #"e", #" ", #"c", #"o", #"r", #"r", #"e",
                                #"c", #"t", #" ", #"s", #"h", #"a", #"p", #"e"])
                    | CC_all (_, _) =>
                      Inl (shows_cc A5_ (show_list show_char) d o
                            shows_prec_list show_char zero_nata
                              [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                                #"a", #" ", #"r", #"e", #"w", #"r", #"i", #"t",
                                #"e", #" ", #"c", #"o", #"n", #"d", #"i", #"t",
                                #"i", #"o", #"n", #" ", #"o", #"f", #" ", #"t",
                                #"h", #"e", #" ", #"c", #"o", #"r", #"r", #"e",
                                #"c", #"t", #" ", #"s", #"h", #"a", #"p",
                                #"e"]))))
              (fn x =>
                Inl (shows_prec_list show_char zero_nata
                       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i",
                         #"n", #" ", #"S", #"a", #"m", #"e", #" ", #"C", #"o",
                         #"n", #"s", #"t", #"r", #"u", #"c", #"t", #"o", #"r",
                         #" ", #"w", #"i", #"t", #"h", #" ", #"r", #"e", #"w",
                         #"r", #"i", #"t", #"e", #" ", #"c", #"o", #"n", #"d",
                         #"i", #"t", #"i", #"o", #"n", #" "] o
                      (shows_cc A5_ (show_list show_char) d o
                        (shows_nl o
                          (shows_string
                             [#" ", #"w", #"h", #"e", #"n", #" ", #"s", #"w",
                               #"i", #"t", #"c", #"h", #"i", #"n", #"g", #" ",
                               #"f", #"r", #"o", #"m", #" "] o
                            (shows_nl o
                              (shows_cc A5_ (show_list show_char) ca o
                                (shows_string [#" ", #"t", #"o", #" "] o
                                  (shows_nl o
                                    (shows_cc A5_ (show_list show_char) c o
                                      (shows_nl o x))))))))))))
        (fn _ => check_cc_prf (A1_, A2_, A3_, A4_, A5_) r da f m_ortho c p)
    end
  | check_cc_prf (A1_, A2_, A3_, A4_, A5_) r da f m_ortho c
    (Variable_Equation (x, t, d, p)) =
    let
      val CC_impl (cs, _) = normalize_cc c;
    in
      bindb (catch_errora
              (bindb
                (check
                  (membera (equal_cond_constraint A3_ (equal_list equal_char))
                     cs (CC_rewr (Var x, t)) orelse
                    membera (equal_cond_constraint A3_ (equal_list equal_char))
                      cs (CC_rewr (t, Var x)) andalso
                      ball (ceq_prod A1_ ceq_nat,
                             ccompare_prod A2_ ccompare_nat)
                        (funas_term (A1_, A2_, A4_) t) (fn fa => not (da fa)))
                  (shows_string
                     [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                       #" ", #"f", #"i", #"n", #"d", #" "] o
                    (shows_cc A5_ (show_list show_char) (CC_rewr (Var x, t)) o
                      (shows_string
                         [#" ", #"o", #"r", #" ", #"r", #"e", #"v", #"e", #"r",
                           #"s", #"e", #"d", #" ", #"a", #"s", #" ", #"a", #" ",
                           #"p", #"r", #"e", #"m", #"i", #"s", #"e", #" ", #"o",
                           #"f", #" "] o
                        (shows_nl o shows_cc A5_ (show_list show_char) c)))))
                (fn _ =>
                  let
                    val ca =
                      cc_subst_apply (equal_list equal_char)
                        (fresh_string [#"x", #"x"]) c
                        (fun_upd (equal_list equal_char) Var x t,
                          vars_term_list t);
                  in
                    check (check_subsumes (equal_list equal_char) A3_
                            (fresh_string [#"x", #"x"]) d ca)
                      (shows_string
                         [#"n", #"e", #"w", #" ", #"c", #"o", #"n", #"s", #"t",
                           #"r", #"a", #"i", #"n", #"t", #" ", #"i", #"s",
                           #" "] o
                        (shows_cc A5_ (show_list show_char) d o
                          (shows_nl o
                            (shows_string
                               [#"b", #"u", #"t", #" ", #"e", #"x", #"p", #"e",
                                 #"c", #"t", #"e", #"d", #" ", #"w", #"a", #"s",
                                 #" "] o
                              shows_cc A5_ (show_list show_char) ca))))
                  end))
              (fn xa =>
                Inl (shows_prec_list show_char zero_nata
                       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i",
                         #"n", #" ", #"V", #"a", #"r", #"i", #"a", #"b", #"l",
                         #"e", #" ", #"E", #"q", #"u", #"a", #"t", #"i", #"o",
                         #"n", #" ", #"w", #"i", #"t", #"h", #" ", #"s", #"u",
                         #"b", #"s", #"t", #"i", #"t", #"u", #"t", #"i", #"o",
                         #"n", #" "] o
                      (shows_prec_list show_char zero_nata x o
                        (shows_prec_list show_char zero_nata [#"/"] o
                          (shows_prec_term A5_ (show_list show_char) zero_nata
                             t o
                            (shows_string
                               [#" ", #"t", #"o", #" ", #"s", #"w", #"i", #"t",
                                 #"c", #"h", #" ", #"f", #"r", #"o", #"m"] o
                              (shows_nl o
                                (shows_cc A5_ (show_list show_char) c o
                                  (shows_nl o
                                    (shows_string [#"t", #"o"] o
                                      (shows_nl o
(shows_cc A5_ (show_list show_char) d o (shows_nl o xa))))))))))))))
        (fn _ => check_cc_prf (A1_, A2_, A3_, A4_, A5_) r da f m_ortho d p)
    end
  | check_cc_prf (A1_, A2_, A3_, A4_, A5_) r da f m_ortho ca
    (Funarg_Into_Var (c, i, x, d, p)) =
    let
      val CC_impl (cs, con) = normalize_cc ca;
    in
      bindb (catch_errora
              (bindb
                (check
                  (membera (equal_cond_constraint A3_ (equal_list equal_char))
                    cs c)
                  (shows_cc A5_ (show_list show_char) c o
                    (shows_nl o
                      (shows_string
                         [#"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ",
                           #"p", #"r", #"e", #"m", #"i", #"s", #"e", #" ", #"o",
                           #"f", #" "] o
                        shows_cc A5_ (show_list show_char) ca))))
                (fn _ =>
                  bindb (check
                          (not (membera (equal_list equal_char)
                                 (vars_cc_list (equal_list equal_char) ca) x))
                          (shows_string
                             [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e",
                               #" "] o
                            (shows_prec_list show_char zero_nata x o
                              shows_prec_list show_char zero_nata
                                [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                                  #"f", #"r", #"e", #"s", #"h"])))
                    (fn _ =>
                      (case c
                        of CC_cond (_, _) =>
                          Inl (shows_cc A5_ (show_list show_char) c o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
                                    #" ", #"a", #" ", #"r", #"e", #"w", #"r",
                                    #"i", #"t", #"e", #" ", #"c", #"o", #"n",
                                    #"d", #"i", #"t", #"i", #"o", #"n", #" ",
                                    #"o", #"f", #" ", #"t", #"h", #"e", #" ",
                                    #"c", #"o", #"r", #"r", #"e", #"c", #"t",
                                    #" ", #"s", #"h", #"a", #"p", #"e"])
                        | CC_rewr (Var _, _) =>
                          Inl (shows_cc A5_ (show_list show_char) c o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
                                    #" ", #"a", #" ", #"r", #"e", #"w", #"r",
                                    #"i", #"t", #"e", #" ", #"c", #"o", #"n",
                                    #"d", #"i", #"t", #"i", #"o", #"n", #" ",
                                    #"o", #"f", #" ", #"t", #"h", #"e", #" ",
                                    #"c", #"o", #"r", #"r", #"e", #"c", #"t",
                                    #" ", #"s", #"h", #"a", #"p", #"e"])
                        | CC_rewr (Fun (fa, ss), q) =>
                          bindb (check (less_nat i (size_list ss))
                                  (shows_prec_list show_char zero_nata
                                    [#"i", #"n", #"v", #"a", #"l", #"i", #"d",
                                      #" ", #"p", #"o", #"s", #"i", #"t", #"i",
                                      #"o", #"n"]))
                            (fn _ =>
                              let
                                val (bef, (pa, aft)) =
                                  (take i ss, (nth ss i, drop (suc i) ss));
                              in
                                bindb (catch_errora
(check_subseteq (equal_prod A3_ equal_nat) (funas_term_list pa) f)
(fn xa =>
  Inl (shows_string
         [#"f", #"u", #"n", #"c", #"t", #"i", #"o", #"n", #" ", #"s", #"y",
           #"m", #"b", #"o", #"l", #" "] o
        (shows_prec_prod A5_ show_nat zero_nata xa o
          shows_prec_list show_char zero_nata
            [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l",
              #"o", #"w", #"e", #"d", #" ", #"i", #"n", #" ", #"a", #"r", #"g",
              #"u", #"m", #"e", #"n", #"t"]))))
                                  (fn _ =>
                                    let
                                      val px = CC_rewr (pa, Var x);
                                      val fq =
CC_rewr (Fun (fa, bef @ Var x :: aft), q);
                                      val ds = px :: fq :: cs;
                                      val daa = CC_impl (ds, con);
                                    in
                                      check
(check_subsumes (equal_list equal_char) A3_ (fresh_string [#"x", #"x"]) d daa)
(shows_string
   [#"n", #"e", #"w", #" ", #"c", #"o", #"n", #"s", #"t", #"r", #"a", #"i",
     #"n", #"t", #" ", #"i", #"s", #" "] o
  (shows_cc A5_ (show_list show_char) d o
    (shows_nl o
      (shows_string
         [#"b", #"u", #"t", #" ", #"e", #"x", #"p", #"e", #"c", #"t", #"e",
           #"d", #" ", #"w", #"a", #"s", #" "] o
        shows_cc A5_ (show_list show_char) daa))))
                                    end)
                              end)
                        | CC_impl (_, _) =>
                          Inl (shows_cc A5_ (show_list show_char) c o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
                                    #" ", #"a", #" ", #"r", #"e", #"w", #"r",
                                    #"i", #"t", #"e", #" ", #"c", #"o", #"n",
                                    #"d", #"i", #"t", #"i", #"o", #"n", #" ",
                                    #"o", #"f", #" ", #"t", #"h", #"e", #" ",
                                    #"c", #"o", #"r", #"r", #"e", #"c", #"t",
                                    #" ", #"s", #"h", #"a", #"p", #"e"])
                        | CC_all (_, _) =>
                          Inl (shows_cc A5_ (show_list show_char) c o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
                                    #" ", #"a", #" ", #"r", #"e", #"w", #"r",
                                    #"i", #"t", #"e", #" ", #"c", #"o", #"n",
                                    #"d", #"i", #"t", #"i", #"o", #"n", #" ",
                                    #"o", #"f", #" ", #"t", #"h", #"e", #" ",
                                    #"c", #"o", #"r", #"r", #"e", #"c", #"t",
                                    #" ", #"s", #"h", #"a", #"p", #"e"])))))
              (fn xa =>
                Inl (shows_prec_list show_char zero_nata
                       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i",
                         #"n", #" ", #"i", #"n", #"t", #"r", #"o", #"d", #"u",
                         #"c", #"i", #"n", #"g", #" ", #"f", #"r", #"e", #"s",
                         #"h", #" ", #"v", #"a", #"r", #"i", #"a", #"b", #"l",
                         #"e", #" "] o
                      (shows_prec_list show_char zero_nata x o
                        (shows_string [#" ", #"o", #"n", #" "] o
                          (shows_prec_nat zero_nata (suc i) o
                            (shows_string
                               [#"-", #"t", #"h", #" ", #"a", #"r", #"g", #"u",
                                 #"m", #"e", #"n", #"t", #" ", #"o", #"f", #" ",
                                 #"l", #"h", #"s", #" ", #"o", #"f", #" "] o
                              (shows_cc A5_ (show_list show_char) c o
                                (shows_string
                                   [#" ", #"t", #"o", #" ", #"s", #"w", #"i",
                                     #"t", #"c", #"h", #" ", #"f", #"r", #"o",
                                     #"m", #" "] o
                                  (shows_cc A5_ (show_list show_char) ca o
                                    (shows_string [#"t", #"o"] o
                                      (shows_nl o
(shows_cc A5_ (show_list show_char) d o (shows_nl o xa))))))))))))))
        (fn _ => check_cc_prf (A1_, A2_, A3_, A4_, A5_) r da f m_ortho d p)
    end
  | check_cc_prf (A1_, A2_, A3_, A4_, A5_) r da f m_ortho c
    (Simplify_Condition (bc, sigma, d, p)) =
    let
      val CC_impl (cs, psi) = normalize_cc c;
    in
      bindb (catch_errora
              (bindb
                (check
                  (membera (equal_cond_constraint A3_ (equal_list equal_char))
                    cs bc)
                  (shows_cc A5_ (show_list show_char) bc o
                    (shows_nl o
                      (shows_string
                         [#"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ",
                           #"p", #"r", #"e", #"m", #"i", #"s", #"e", #" ", #"o",
                           #"f", #" "] o
                        shows_cc A5_ (show_list show_char) c))))
                (fn _ =>
                  let
                    val (ys, cc) = cc_unbound bc;
                    val (phi, psia) = let
val CC_impl (a, b) = normalize_cc cc;
                                      in
(a, b)
                                      end;
                    val dom_ran =
                      mk_subst_domain (equal_list equal_char) A3_ sigma;
                  in
                    bindb (catch_errora
                            (check_subseteq (equal_list equal_char)
                              (map fst dom_ran) ys)
                            (fn x =>
                              Inl (shows_prec_list show_char zero_nata x o
                                    shows_prec_list show_char zero_nata
                                      [#" ", #"i", #"s", #" ", #"i", #"n", #" ",
#"t", #"h", #"e", #" ", #"d", #"o", #"m", #"a", #"i", #"n", #" ", #"o", #"f",
#" ", #"s", #"i", #"g", #"m", #"a", #",", #" ", #"b", #"u", #"t", #" ", #"n",
#"o", #"t", #" ", #"a", #" ", #"b", #"o", #"u", #"n", #"d", #" ", #"v", #"a",
#"r", #"i", #"a", #"b", #"l", #"e", #" "])))
                      (fn _ =>
                        bindb (catch_errora
                                (forallM
                                  (fn fna =>
                                    bindb (check (not (da fna))
    (shows_string [#"s", #"y", #"m", #"b", #"o", #"l", #" "] o
      (shows_prec_prod A5_ show_nat zero_nata fna o
        shows_prec_list show_char zero_nata
          [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l",
            #"o", #"w", #"e", #"d", #" ", #"i", #"n", #" ", #"r", #"a", #"n",
            #"g", #"e", #" ", #"o", #"f", #" ", #"s", #"i", #"g", #"m", #"a",
            #",", #" ", #"a", #"s", #" ", #"i", #"t", #" ", #"i", #"s", #" ",
            #"d", #"e", #"f", #"i", #"n", #"e", #"d"])))
                                      (fn _ =>
check (membera (equal_prod A3_ equal_nat) f fna)
  (shows_string [#"s", #"y", #"m", #"b", #"o", #"l", #" "] o
    (shows_prec_prod A5_ show_nat zero_nata fna o
      shows_prec_list show_char zero_nata
        [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o",
          #"w", #"e", #"d", #" ", #"i", #"n", #" ", #"r", #"a", #"n", #"g",
          #"e", #" ", #"o", #"f", #" ", #"s", #"i", #"g", #"m", #"a", #",",
          #" ", #"a", #"s", #" ", #"i", #"t", #" ", #"i", #"s", #" ", #"n",
          #"o", #"t", #" ", #"i", #"n", #" ", #"F"]))))
                                  (maps (fn x_t => funas_term_list (snd x_t))
                                    dom_ran))
                                (fn x => Inl (snd x)))
                          (fn _ =>
                            let
                              val vs =
                                remdups (equal_list equal_char)
                                  (maps (fn x_t => vars_term_list (snd x_t))
                                    dom_ran);
                              val sigmaa =
                                (fn ca =>
                                  cc_subst_apply (equal_list equal_char)
                                    (fresh_string [#"x", #"x"]) ca
                                    (mk_subst (equal_list equal_char) Var sigma,
                                      vs));
                            in
                              bindb (catch_errora
                                      (forallM
(fn ca =>
  check (list_ex
          (fn caa =>
            check_subsumes (equal_list equal_char) A3_
              (fresh_string [#"x", #"x"]) caa (sigmaa ca))
          cs)
    (shows_cc A5_ (show_list show_char) (sigmaa ca) o
      (shows_nl o
        shows_prec_list show_char zero_nata
          [#"i", #"s", #" ", #"n", #"o", #"t", #" ", #"c", #"o", #"n", #"t",
            #"a", #"i", #"n", #"e", #"d", #" ", #"a", #"s", #" ", #"p", #"r",
            #"e", #"m", #"i", #"s", #"e", #" ", #"o", #"f", #" ", #"t", #"h",
            #"e", #" ", #"i", #"n", #"p", #"u", #"t", #" ", #"i", #"m", #"p",
            #"l", #"i", #"c", #"a", #"t", #"i", #"o", #"n"])))
phi)
                                      (fn x => Inl (snd x)))
                                (fn _ =>
                                  let
                                    val daa = CC_impl (sigmaa psia :: cs, psi);
                                  in
                                    check (check_subsumes
    (equal_list equal_char) A3_ (fresh_string [#"x", #"x"]) d daa)
                                      (shows_string
 [#"n", #"e", #"w", #" ", #"c", #"o", #"n", #"s", #"t", #"r", #"a", #"i", #"n",
   #"t", #" ", #"i", #"s", #" "] o
(shows_cc A5_ (show_list show_char) d o
  (shows_nl o
    (shows_string
       [#"b", #"u", #"t", #" ", #"e", #"x", #"p", #"e", #"c", #"t", #"e", #"d",
         #" ", #"w", #"a", #"s", #" "] o
      shows_cc A5_ (show_list show_char) daa))))
                                  end)
                            end))
                  end))
              (fn x =>
                Inl (shows_prec_list show_char zero_nata
                       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i",
                         #"n", #" ", #"S", #"i", #"m", #"p", #"l", #"i", #"f",
                         #"y", #" ", #"C", #"o", #"n", #"d", #"i", #"t", #"i",
                         #"o", #"n", #" ", #"w", #"i", #"t", #"h", #" ", #"s",
                         #"u", #"b", #"s", #"t", #"i", #"t", #"u", #"t", #"i",
                         #"o", #"n", #" "] o
                      (shows_prec_list
                         (show_prod (show_list show_char)
                           (show_term A5_ (show_list show_char)))
                         zero_nata sigma o
                        (shows_string [#" ", #"o", #"n", #" ", #"I", #"H"] o
                          (shows_nl o
                            (shows_cc A5_ (show_list show_char) bc o
                              (shows_nl o
                                (shows_string
                                   [#"t", #"o", #" ", #"s", #"w", #"i", #"t",
                                     #"c", #"h", #" ", #"f", #"r", #"o", #"m"] o
                                  (shows_nl o
                                    (shows_cc A5_ (show_list show_char) c o
                                      (shows_nl o
(shows_string [#"t", #"o"] o
  (shows_nl o
    (shows_cc A5_ (show_list show_char) d o (shows_nl o x))))))))))))))))
        (fn _ => check_cc_prf (A1_, A2_, A3_, A4_, A5_) r da f m_ortho d p)
    end
  | check_cc_prf (A1_, A2_, A3_, A4_, A5_) r da f m_ortho c
    (Induction (d, ccs, ihs)) =
    let
      val CC_impl (cs, ca) = normalize_cc c;
    in
      bindb (catch_errora
              (bindb
                (check m_ortho
                  (shows_prec_list show_char zero_nata
                    [#"C", #"R", #" ", #"o", #"r", #" ", #"m", #"i", #"n", #"i",
                      #"m", #"a", #"l", #"i", #"t", #"y", #" ", #"r", #"e",
                      #"q", #"u", #"i", #"r", #"e", #"d"]))
                (fn _ =>
                  bindb (catch_errora
                          (forallM
                            (fn cc =>
                              check (membera
                                      (equal_cond_constraint A3_
(equal_list equal_char))
                                      cs cc)
                                (shows_cc A5_ (show_list show_char) cc o
                                  (shows_nl o
                                    (shows_string
                                       [#"i", #"s", #" ", #"n", #"o", #"t",
 #" ", #"a", #" ", #"p", #"r", #"e", #"m", #"i", #"s", #"e", #" ", #"o", #"f",
 #" "] o
                                      shows_cc A5_ (show_list show_char) c))))
                            (d :: ccs))
                          (fn x => Inl (snd x)))
                    (fn _ =>
                      (case d
                        of CC_cond (_, _) =>
                          Inl (shows_cc A5_ (show_list show_char) d o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
                                    #" ", #"a", #" ", #"r", #"e", #"w", #"r",
                                    #"i", #"t", #"e", #" ", #"c", #"o", #"n",
                                    #"d", #"i", #"t", #"i", #"o", #"n", #" ",
                                    #"o", #"f", #" ", #"t", #"h", #"e", #" ",
                                    #"c", #"o", #"r", #"r", #"e", #"c", #"t",
                                    #" ", #"s", #"h", #"a", #"p", #"e"])
                        | CC_rewr (Var _, _) =>
                          Inl (shows_cc A5_ (show_list show_char) d o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
                                    #" ", #"a", #" ", #"r", #"e", #"w", #"r",
                                    #"i", #"t", #"e", #" ", #"c", #"o", #"n",
                                    #"d", #"i", #"t", #"i", #"o", #"n", #" ",
                                    #"o", #"f", #" ", #"t", #"h", #"e", #" ",
                                    #"c", #"o", #"r", #"r", #"e", #"c", #"t",
                                    #" ", #"s", #"h", #"a", #"p", #"e"])
                        | CC_rewr (Fun (fa, xs), q) =>
                          let
                            val csa =
                              vars_cc_list (equal_list equal_char)
                                (CC_impl
                                  (CC_rewr (Fun (fa, xs), q) :: ccs, ca));
                          in
                            bindb (check
                                    (list_all is_Var xs andalso
                                      distinct (equal_list equal_char)
(map the_Var xs))
                                    (shows_prec_list show_char zero_nata
                                       [#"a", #"r", #"g", #"u", #"m", #"e",
 #"n", #"t", #"s", #" ", #"o", #"f", #" "] o
                                      (shows_prec_term A5_ (show_list show_char)
 zero_nata (Fun (fa, xs)) o
shows_prec_list show_char zero_nata
  [#" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ", #"d", #"i", #"f", #"f",
    #"e", #"r", #"e", #"n", #"t", #" ", #"v", #"a", #"r", #"i", #"a", #"b",
    #"l", #"e", #"s"])))
                              (fn _ =>
                                let
                                  val xsa = map the_Var xs;
                                  val rt = root (Fun (fa, xs));
                                in
                                  bindb (check
  (is_none (mgu A3_ (equal_list equal_char) (Fun (fa, xs)) q))
  (shows_prec_list show_char zero_nata
    [#"l", #"h", #"s", #" ", #"a", #"n", #"d", #" ", #"r", #"h", #"s", #" ",
      #"u", #"n", #"i", #"f", #"y"]))
                                    (fn _ =>
                                      bindb
(catch_errora
  (forallM
    (fn lr =>
      check (if equal_optiona (equal_prod A3_ equal_nat) (root (fst lr)) rt
              then list_ex
                     (fn lra =>
                       eq_rule_mod_vars A3_
                         (ccompare_list ccompare_char, equal_list equal_char,
                           mapping_impl_list)
                         lr lra andalso
                         isOK (check_disjoint (equal_list equal_char) csa
                                (vars_rule_list lra)))
                     (map (fn (ra, _) => ra) ihs)
              else true)
        (shows_prec_list show_char zero_nata
           [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"f",
             #"i", #"n", #"d", #" ", #"v", #"a", #"r", #"i", #"a", #"b", #"l",
             #"e", #" ", #"r", #"e", #"n", #"a", #"m", #"e", #"d", #" ", #"v",
             #"e", #"r", #"s", #"i", #"o", #"n", #" ", #"o", #"f", #" ", #"r",
             #"u", #"l", #"e", #" "] o
          shows_rule (shows_prec A5_ zero_nata)
            (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] lr))
    r)
  (fn x => Inl (snd x)))
(fn _ =>
  catch_errora
    (forallM
      (fn (a, b) =>
        let
          val (l, ra) = a;
        in
          (fn (rys, (cc, _)) =>
            catch_errora
              let
                val cca =
                  cc_rule_constraint (equal_list equal_char) A3_
                    (fresh_string [#"x", #"x"]) fa (args l) ra q xsa ccs ca rys;
              in
                bindb (catch_errora
                        (forallM
                          (check_rys (A3_, A5_)
                            (equal_list equal_char, show_list show_char) da rt
                            ra)
                          rys)
                        (fn x => Inl (snd x)))
                  (fn _ =>
                    check (check_subsumes (equal_list equal_char) A3_
                            (fresh_string [#"x", #"x"]) cc cca)
                      (shows_string
                         [#"n", #"e", #"w", #" ", #"c", #"o", #"n", #"s", #"t",
                           #"r", #"a", #"i", #"n", #"t", #" ", #"i", #"s",
                           #" "] o
                        (shows_cc A5_ (show_list show_char) cc o
                          (shows_nl o
                            (shows_string
                               [#"b", #"u", #"t", #" ", #"e", #"x", #"p", #"e",
                                 #"c", #"t", #"e", #"d", #" ", #"w", #"a", #"s",
                                 #" "] o
                              shows_cc A5_ (show_list show_char) cca)))))
              end
              (fn x =>
                Inl (shows_string
                       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i",
                         #"n", #" ", #"c", #"o", #"n", #"s", #"t", #"r", #"a",
                         #"i", #"n", #"t", #" ", #"f", #"o", #"r", #" ", #"r",
                         #"u", #"l", #"e", #" "] o
                      (shows_rule (shows_prec A5_ zero_nata)
                         (shows_prec_list show_char zero_nata)
                         [#" ", #"-", #">", #" "] (l, ra) o
                        (shows_nl o x)))))
        end
          b)
      ihs)
    (fn x => Inl (snd x))))
                                end)
                          end
                        | CC_impl (_, _) =>
                          Inl (shows_cc A5_ (show_list show_char) d o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
                                    #" ", #"a", #" ", #"r", #"e", #"w", #"r",
                                    #"i", #"t", #"e", #" ", #"c", #"o", #"n",
                                    #"d", #"i", #"t", #"i", #"o", #"n", #" ",
                                    #"o", #"f", #" ", #"t", #"h", #"e", #" ",
                                    #"c", #"o", #"r", #"r", #"e", #"c", #"t",
                                    #" ", #"s", #"h", #"a", #"p", #"e"])
                        | CC_all (_, _) =>
                          Inl (shows_cc A5_ (show_list show_char) d o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
                                    #" ", #"a", #" ", #"r", #"e", #"w", #"r",
                                    #"i", #"t", #"e", #" ", #"c", #"o", #"n",
                                    #"d", #"i", #"t", #"i", #"o", #"n", #" ",
                                    #"o", #"f", #" ", #"t", #"h", #"e", #" ",
                                    #"c", #"o", #"r", #"r", #"e", #"c", #"t",
                                    #" ", #"s", #"h", #"a", #"p", #"e"])))))
              (fn x =>
                Inl (shows_prec_list show_char zero_nata
                       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i",
                         #"n", #" ", #"I", #"n", #"d", #"u", #"c", #"t", #"i",
                         #"o", #"n", #" ", #"r", #"u", #"l", #"e", #" ", #"w",
                         #"i", #"t", #"h", #" ", #"r", #"e", #"w", #"r", #"i",
                         #"t", #"e", #" ", #"c", #"o", #"n", #"d", #"i", #"t",
                         #"i", #"o", #"n", #" "] o
                      (shows_cc A5_ (show_list show_char) d o
                        (shows_string
                           [#" ", #"t", #"o", #" ", #"s", #"w", #"i", #"t",
                             #"c", #"h", #" ", #"f", #"r", #"o", #"m"] o
                          (shows_nl o
                            (shows_cc A5_ (show_list show_char) c o
                              (shows_nl o
                                (shows_string [#"t", #"o"] o
                                  (shows_nl o
                                    (shows_list_gen
                                       (fn (_, (_, (cb, _))) =>
 shows_cc A5_ (show_list show_char) cb o shows_nl)
                                       [] [] [] [] ihs o
                                      x)))))))))))
        (fn _ =>
          bindb (mapM (fn (_, a) =>
                        let
                          val (_, aa) = a;
                          val (ab, b) = aa;
                        in
                          check_cc_prf (A1_, A2_, A3_, A4_, A5_) r da f m_ortho
                            ab b
                        end)
                  ihs)
            (fn fcss => Inr (concat fcss)))
    end;

fun check_cc_prfs (A1_, A2_, A3_, A4_, A5_) r d f m_ortho [] = Inr []
  | check_cc_prfs (A1_, A2_, A3_, A4_, A5_) r d f m_ortho
    ((c, (uu, prf)) :: cpfs) =
    bindb (check_cc_prf (A1_, A2_, A3_, A4_, A5_) r d f m_ortho c prf)
      (fn l1 =>
        bindb (check_cc_prfs (A1_, A2_, A3_, A4_, A5_) r d f m_ortho cpfs)
          (fn l2 => Inr (l1 @ l2)));

fun conditional_general_reduction_pair_proc (B1_, B2_, B3_, B4_, B5_, B6_) i grp
  pstrict pbound prof merge dpp =
  let
    val Cond_Red_Pair_Prf (c, ccs, bef, aft) = prof;
    val p = pairsb i dpp;
    val r = rulese i dpp;
    val f =
      remdups (equal_prod B3_ equal_nat)
        (funas_trs_list r @
          funas_args_trs_list p @ maps funas_term_list (qc i dpp));
    val rp = grp f;
  in
    (case catch_errora
            (bindb (validc rp)
              (fn _ =>
                bindb (check (wwf_rulesa i dpp)
                        (shows_prec_list show_char zero_nata
                          [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"w",
                            #"e", #"l", #"l", #"-", #"f", #"o", #"r", #"m",
                            #"e", #"d", #"n", #"e", #"s", #"s", #" ", #"o",
                            #"f", #" ", #"T", #"R", #"S"]))
                  (fn _ =>
                    let
                      val is_def =
                        (fn fna => not (null (rules_mapc i dpp fna)));
                    in
                      bindb (check_varcond_subset B6_
                              (equal_list equal_char, show_list show_char) p)
                        (fn _ =>
                          bindb (catch_errora
                                  (forallM
                                    (fn (l, ra) =>
                                      bindb
(check_no_var B6_ (show_list show_char) l)
(fn _ =>
  bindb (check_no_var B6_ (show_list show_char) ra)
    (fn _ => check_no_defined_root B6_ (show_list show_char) is_def ra)))
                                    p)
                                  (fn x => Inl (snd x)))
                            (fn _ =>
                              let
                                val ccsa =
                                  map (fn (ca, (uvs, _)) => (ca, uvs)) ccs;
                                val check_present =
                                  check_constraint_present (B3_, B4_, B6_) i dpp
                                    c p bef aft ccsa;
                                val (ps, pns) = split_pairsa i dpp pstrict;
                                val (pb, _) = split_pairsa i dpp pbound;
                                val pi = afb rp;
                                val us =
                                  usable_rules_gen B3_ (equal_list equal_char)
                                    pi r p;
                              in
                                bindb (catch_errora
(forallM (check_present Strict) ps) (fn x => Inl (snd x)))
                                  (fn _ =>
                                    bindb (catch_errora
    (forallM (check_present Non_Strict) pns) (fn x => Inl (snd x)))
                                      (fn _ =>
bindb (catch_errora (forallM (check_present Bound) pb) (fn x => Inl (snd x)))
  (fn _ =>
    bindb (check (nFQ_subset_NF_rulesc i dpp)
            (shows_prec_list show_char zero_nata
              [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"r",
                #"e", #"q", #"u", #"i", #"r", #"e", #"d"]))
      (fn _ =>
        bindb (catch_errora
                (catch_errora (forallM (nsb rp) us) (fn x => Inl (snd x)))
                (fn x =>
                  Inl (shows_string
                         [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w",
                           #"h", #"e", #"n", #" ", #"o", #"r", #"i", #"e", #"n",
                           #"t", #"i", #"n", #"g", #" ", #"u", #"s", #"a", #"b",
                           #"l", #"e", #" ", #"r", #"u", #"l", #"e", #"s"] o
                        (shows_nl o x))))
          (fn _ =>
            let
              val m = minimal i dpp;
              val ortho = isOK (check_weakly_orthogonal (B3_, B6_) r);
            in
              bindb (catch_errora
                      (check_cc_prfs (B1_, B2_, B3_, B5_, B6_) r
                        (fn fna => not (null (rules_mapc i dpp fna))) f
                        (m orelse ortho) ccs)
                      (fn x =>
                        Inl (shows_string
                               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                                 #"w", #"h", #"e", #"n", #" ", #"s", #"i", #"m",
                                 #"p", #"l", #"i", #"f", #"y", #"i", #"n", #"g",
                                 #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i",
                                 #"o", #"n", #"a", #"l", #" ", #"c", #"o", #"n",
                                 #"s", #"t", #"r", #"a", #"i", #"n", #"t",
                                 #"s"] o
                              (shows_nl o x))))
                (fn fcs =>
                  catch_errora
                    (catch_errora (forallM (cc rp) fcs) (fn x => Inl (snd x)))
                    (fn x =>
                      Inl (shows_string
                             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                               #"w", #"h", #"e", #"n", #" ", #"o", #"r", #"i",
                               #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"f",
                               #"i", #"n", #"a", #"l", #" ", #"(", #"c", #"o",
                               #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a",
                               #"l", #")", #" ", #"c", #"o", #"n", #"s", #"t",
                               #"r", #"a", #"i", #"n", #"t", #"s", #" ", #"f",
                               #"o", #"r", #" ", #"p", #"a", #"i", #"r", #"s"] o
                            (shows_nl o x))))
            end)))))
                              end))
                    end)))
            (fn x =>
              Inl (shows_string
                     [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                       #" ", #"a", #"p", #"p", #"l", #"y", #" ", #"t", #"h",
                       #"e", #" ", #"b", #"o", #"u", #"n", #"d", #"e", #"d",
                       #" ", #"i", #"n", #"c", #"r", #"e", #"a", #"s", #"e",
                       #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o",
                       #"r", #" ", #"w", #"i", #"t", #"h", #" ", #"t", #"h",
                       #"e", #" ", #"f", #"o", #"l", #"l", #"o", #"w", #"i",
                       #"n", #"g"] o
                    (shows_nl o (descc rp o (shows_nl o x)))))
      of Inl a => Inl a
      | Inr _ =>
        Inr (if merge
              then [delete_P_Pwa i dpp
                      (list_inter
                        (equal_prod (equal_term B3_ (equal_list equal_char))
                          (equal_term B3_ (equal_list equal_char)))
                        pstrict pbound)
                      (list_inter
                        (equal_prod (equal_term B3_ (equal_list equal_char))
                          (equal_term B3_ (equal_list equal_char)))
                        pstrict pbound)]
              else [delete_P_Pwa i dpp pstrict pstrict,
                     delete_P_Pwa i dpp pbound pbound]))
  end;

fun critical_pairs_top_impl A_ p r =
  maps (fn (l, ra) =>
         (if is_Var l then []
           else maps (fn (la, rb) =>
                       (case mgu_var_disjoint_generic (equal_list equal_char) A_
                               (fn a => #"x" :: a) (fn a => #"y" :: a) l la
                         of NONE => []
                         | SOME (sigma, tau) =>
                           [(subst_apply_term ra sigma,
                              subst_apply_term rb tau)]))
                  r))
    p;

fun show_crit_pair A_ B_ lr =
  shows_prec_list show_char zero_nata [#"("] o
    (shows_prec_term A_ B_ zero_nata (fst lr) o
      (shows_prec_list show_char zero_nata [#",", #" "] o
        (shows_prec_term A_ B_ zero_nata (snd lr) o
          shows_prec_list show_char zero_nata [#")"])));

fun check_critical_pairs_innermost (A1_, A2_) r =
  catch_errora
    (forallM
      (fn (l, ra) =>
        check (equal_terma A1_ (equal_list equal_char) l ra)
          (shows_prec_list show_char zero_nata
             [#"t", #"h", #"e", #"r", #"e", #" ", #"i", #"s", #" ", #"a", #" ",
               #"n", #"o", #"n", #"-", #"t", #"r", #"i", #"v", #"i", #"a", #"l",
               #" ", #"c", #"r", #"i", #"t", #"i", #"c", #"a", #"l", #" ", #"p",
               #"a", #"i", #"r", #" "] o
            show_crit_pair A2_ (show_list show_char) (l, ra)))
      (critical_pairs_top_impl A1_ r r))
    (fn x => Inl (snd x));

fun extract_fresh_var sts =
  (case (case sts of [] => NONE | (_, (Var _, _)) :: _ => NONE
          | (_, (Fun (_, ss), _)) :: _ =>
            (if null ss then NONE
              else (case last ss of Var a => SOME a | Fun (_, _) => NONE)))
    of NONE =>
      Inl (shows_prec_list show_char zero_nata
            [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"e",
              #"x", #"t", #"r", #"a", #"c", #"t", #" ", #"f", #"r", #"e", #"s",
              #"h", #" ", #"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #" ",
              #"(", #"a", #"s", #" ", #"l", #"a", #"s", #"t", #" ", #"a", #"r",
              #"g", #"u", #"m", #"e", #"n", #"t", #" ", #"f", #"r", #"o", #"m",
              #" ", #"s", #"o", #"m", #"e", #" ", #"l", #"h", #"s", #" ", #"o",
              #"f", #" ", #"n", #"e", #"w", #" ", #"p", #"a", #"i", #"r", #"s",
              #")"])
    | SOME a => Inr a);

fun extract_ren A_ ps_ps =
  bindb (check
          (list_all
            (fn (a, b) =>
              let
                val (s, t) = a;
              in
                (fn (sa, ta) =>
                  not (is_Var s) andalso
                    (not (is_Var t) andalso
                      (not (is_Var sa) andalso not (is_Var ta))))
              end
                b)
            ps_ps)
          (shows_prec_list show_char zero_nata
            [#"a", #"l", #"l", #" ", #"l", #"h", #"s", #"s", #" ", #"a", #"n",
              #"d", #" ", #"r", #"h", #"s", #"s", #" ", #"o", #"f", #" ", #"p",
              #"a", #"i", #"r", #"s", #" ", #"m", #"u", #"s", #"t", #" ", #"b",
              #"e", #" ", #"n", #"o", #"n", #"-", #"v", #"a", #"r", #"i", #"a",
              #"b", #"l", #"e", #"s"]))
    (fn _ =>
      let
        val rt = (fn t => the (root t));
        val pair = (fn s => fn sa => (rt s, fst (rt sa)));
        val pairs =
          (fn (st, sta) => [pair (fst st) (fst sta), pair (snd st) (snd sta)]);
        val ren =
          map_of (equal_prod A_ equal_nat)
            (remdups (equal_prod (equal_prod A_ equal_nat) A_)
              (maps pairs ps_ps));
        val a = (fn fna => (case ren fna of NONE => fst fna | SOME f => f));
      in
        Inr a
      end);

fun check_drop (A1_, A2_) (B1_, B2_) x c ren st_st =
  let
    val ((s, t), (sa, ta)) = st_st;
    val Fun (f, ss) = s;
    val Fun (g, ts) = t;
  in
    bindb (check
            (equal_terma B1_ A1_ sa (Fun (ren (f, size_list ss), ss @ [Var x])))
            (shows_prec_list show_char zero_nata
               [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                 #"r", #"e", #"l", #"a", #"t", #"e", #" "] o
              (shows_prec_term B2_ A2_ zero_nata s o
                (shows_prec_list show_char zero_nata
                   [#" ", #"w", #"i", #"t", #"h", #" "] o
                  shows_prec_term B2_ A2_ zero_nata sa))))
      (fn _ =>
        let
          val tsa = args ta;
          val tsaa = take (minus_nata (size_list tsa) one_nata) tsa;
        in
          check (equal_terma B1_ A1_ ta
                   (Fun (ren (g, size_list ts), tsaa @ [Var x])) andalso
                  equal_lista (equal_term B1_ A1_) ts
                    (map (fn tb => subst_apply_term tb (subst A1_ x c)) tsaa))
            (shows_prec_list show_char zero_nata
               [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                 #"r", #"e", #"l", #"a", #"t", #"e", #" "] o
              (shows_prec_term B2_ A2_ zero_nata t o
                (shows_prec_list show_char zero_nata
                   [#" ", #"w", #"i", #"t", #"h", #" "] o
                  shows_prec_term B2_ A2_ zero_nata ta)))
        end)
  end;

fun rwd
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = rw;

fun pwb
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = pw;

fun rd
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = r;

fun pb
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = p;

fun complex_constant_removal_proc (B1_, B2_, B3_) i
  (Complex_Constant_Removal_Proof (c, ps)) dpp =
  catch_errora
    let
      val p = pb i dpp;
      val pw = pwb i dpp;
      val r = rwd i dpp;
      val q = qc i dpp;
      val pairs = pairsb i dpp;
    in
      bindb (extract_fresh_var ps)
        (fn x =>
          bindb (extract_ren B1_ ps)
            (fn ren =>
              let
                val is_def = (fn fna => not (null (rules_mapc i dpp fna)));
                val rQs =
                  remdups (equal_option (equal_prod B1_ equal_nat))
                    (map root q);
              in
                bindb (catch_errora
                        (forallM
                          (fn (s, t) =>
                            bindb (check_no_var B3_ (show_list show_char) s)
                              (fn _ =>
                                bindb (check_no_var B3_ (show_list show_char) t)
                                  (fn _ =>
                                    bindb (check_no_defined_root B3_
    (show_list show_char) is_def t)
                                      (fn _ =>
bindb (check (not (membera (equal_list equal_char) (vars_rule_list (s, t)) x))
        (shows_prec_list show_char zero_nata x o
          (shows_prec_list show_char zero_nata
             [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"f", #"r", #"e",
               #"s", #"h", #" ", #"f", #"o", #"r", #" ", #"p", #"a", #"i", #"r",
               #" "] o
            shows_rule (shows_prec B3_ zero_nata)
              (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "]
              (s, t))))
  (fn _ =>
    let
      val f = the (root s);
      val fa = (ren f, suc (snd f));
    in
      bindb (check
              (not (membera (equal_option (equal_prod B1_ equal_nat)) rQs
                     (SOME fa)))
              (shows_prec_list show_char zero_nata
                [#"r", #"e", #"n", #"a", #"m", #"i", #"n", #"g", #" ", #"d",
                  #"e", #"l", #"i", #"v", #"e", #"r", #"s", #" ", #"d", #"e",
                  #"f", #"i", #"n", #"e", #"d", #" ", #"s", #"y", #"m", #"b",
                  #"o", #"l", #" ", #"o", #"f", #" ", #"Q"]))
        (fn _ =>
          check (not (is_def fa))
            (shows_prec_list show_char zero_nata
              [#"r", #"e", #"n", #"a", #"m", #"i", #"n", #"g", #" ", #"d", #"e",
                #"l", #"i", #"v", #"e", #"r", #"s", #" ", #"d", #"e", #"f",
                #"i", #"n", #"e", #"d", #" ", #"s", #"y", #"m", #"b", #"o",
                #"l", #" ", #"o", #"f", #" ", #"R"]))
    end)))))
                          pairs)
                        (fn xa => Inl (snd xa)))
                  (fn _ =>
                    let
                      val pps =
                        filtera
                          (fn st_st =>
                            membera
                              (equal_prod
                                (equal_term B1_ (equal_list equal_char))
                                (equal_term B1_ (equal_list equal_char)))
                              p (fst st_st))
                          ps;
                      val pwps =
                        filtera
                          (fn st_st =>
                            membera
                              (equal_prod
                                (equal_term B1_ (equal_list equal_char))
                                (equal_term B1_ (equal_list equal_char)))
                              pw (fst st_st))
                          ps;
                    in
                      bindb (catch_errora
                              (forallM
                                (fn st =>
                                  check (membera
  (equal_prod (equal_term B1_ (equal_list equal_char))
    (equal_term B1_ (equal_list equal_char)))
  (map fst pps) st)
                                    (shows_prec_list show_char zero_nata
                                       [#"c", #"o", #"u", #"l", #"d", #" ",
 #"n", #"o", #"t", #" ", #"f", #"i", #"n", #"d", #" ", #"e", #"n", #"t", #"r",
 #"y", #" ", #"f", #"o", #"r", #" ", #"p", #"a", #"i", #"r", #" "] o
                                      shows_rule (shows_prec B3_ zero_nata)
(shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] st))
                                p)
                              (fn xa => Inl (snd xa)))
                        (fn _ =>
                          bindb (catch_errora
                                  (forallM
                                    (fn st =>
                                      check
(membera
  (equal_prod (equal_term B1_ (equal_list equal_char))
    (equal_term B1_ (equal_list equal_char)))
  (map fst pwps) st)
(shows_prec_list show_char zero_nata
   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"f", #"i",
     #"n", #"d", #" ", #"e", #"n", #"t", #"r", #"y", #" ", #"f", #"o", #"r",
     #" ", #"p", #"a", #"i", #"r", #" "] o
  shows_rule (shows_prec B3_ zero_nata) (shows_prec_list show_char zero_nata)
    [#" ", #"-", #">", #" "] st))
                                    pw)
                                  (fn xa => Inl (snd xa)))
                            (fn _ =>
                              bindb (check (ground c)
                                      (shows_prec_list show_char zero_nata
 [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #" "] o
(shows_prec_term B3_ (show_list show_char) zero_nata c o
  shows_prec_list show_char zero_nata
    [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"g", #"r", #"o", #"u",
      #"n", #"d"])))
                                (fn _ =>
                                  bindb (check (nFQ_subset_NF_rulesc i dpp)
  (shows_prec_list show_char zero_nata
    [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"r", #"e",
      #"q", #"u", #"i", #"r", #"e", #"d"]))
                                    (fn _ =>
                                      bindb
(check (null (rd i dpp))
  (shows_prec_list show_char zero_nata
    [#"s", #"t", #"r", #"i", #"c", #"t", #" ", #"r", #"u", #"l", #"e", #"s",
      #" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o", #"w", #"e", #"d"]))
(fn _ =>
  bindb (check (rules_no_left_vara i dpp)
          (shows_prec_list show_char zero_nata
            [#"r", #"u", #"l", #"e", #"s", #" ", #"m", #"a", #"y", #" ", #"n",
              #"o", #"t", #" ", #"h", #"a", #"v", #"e", #" ", #"v", #"a", #"r",
              #"i", #"a", #"b", #"l", #"e", #"s", #" ", #"a", #"s", #" ", #"l",
              #"h", #"s", #"s"]))
    (fn _ =>
      bindb (if is_NF_trs (B1_, B2_)
                  (ccompare_list ccompare_char, equal_list equal_char,
                    mapping_impl_list)
                  r c
              then Inr ()
              else catch_errora (check_critical_pairs_innermost (B1_, B3_) r)
                     (fn xa =>
                       Inl (shows_prec_list show_char zero_nata
                              [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
                                #"t", #" ", #"e", #"n", #"s", #"u", #"r", #"e",
                                #" ", #"c", #"o", #"n", #"f", #"l", #"u", #"e",
                                #"n", #"c", #"e"] o
                             (shows_nl o xa))))
        (fn _ =>
          bindb (catch_errora
                  (forallM
                    (fn st_st =>
                      catch_errora
                        (check_drop (equal_list equal_char, show_list show_char)
                          (B1_, B3_) x c ren st_st)
                        (fn xa =>
                          Inl (shows_prec_list show_char zero_nata
                                 [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                   #" ", #"i", #"n", #" ", #"f", #"i", #"n",
                                   #"d", #"i", #"n", #"g", #" ", #"c", #"o",
                                   #"r", #"r", #"e", #"s", #"p", #"o", #"n",
                                   #"d", #"e", #"n", #"c", #"e", #" ", #"b",
                                   #"e", #"t", #"w", #"e", #"e", #"n", #" ",
                                   #"r", #"u", #"l", #"e", #" "] o
                                (shows_rule (shows_prec B3_ zero_nata)
                                   (shows_prec_list show_char zero_nata)
                                   [#" ", #"-", #">", #" "] (fst st_st) o
                                  (shows_prec_list show_char zero_nata
                                     [#" ", #"a", #"n", #"d", #" ", #"r", #"u",
                                       #"l", #"e", #" "] o
                                    (shows_rule (shows_prec B3_ zero_nata)
                                       (shows_prec_list show_char zero_nata)
                                       [#" ", #"-", #">", #" "] (snd st_st) o
                                      (shows_nl o xa)))))))
                    ps)
                  (fn xa => Inl (snd xa)))
            (fn _ =>
              Inr (mkd i (nfsc i dpp) (minimal i dpp) (map snd pps)
                    (map snd pwps) q [] r)))))))))
                    end)
              end))
    end
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"c", #"o", #"m", #"p", #"l", #"e", #"x", #" ", #"c", #"o", #"n",
               #"s", #"t", #"a", #"n", #"t", #" ", #"r", #"e", #"m", #"o", #"v",
               #"a", #"l", #" ", #"p", #"r", #"o", #"c", #":", #" "] o
            (shows_nl o x)));

fun fun_of_default A_ m d = let
                              val mm = map_of A_ m;
                            in
                              (fn i => (case mm i of NONE => d | SOME e => e))
                            end;

fun get_arg t n =
  (if equal_nata n zero_nata then t else nth (args t) (minus_nata n one_nata));

fun iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops A_ s =
  (fn c => fn f => rm_iterateoi (impl_of A_ s) c (f o fst));

fun g_ball_dflt_basic_oops_rm_basic_ops A_ s p =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops A_ s (fn c => c)
    (fn x => fn _ => p x) true;

fun subtract_list_sorted (A1_, A2_) (x :: xs) (y :: ys) =
  (if eq A1_ x y then subtract_list_sorted (A1_, A2_) xs (y :: ys)
    else (if less ((ord_preorder o preorder_order o order_linorder) A2_) x y
           then x :: subtract_list_sorted (A1_, A2_) xs (y :: ys)
           else subtract_list_sorted (A1_, A2_) (x :: xs) ys))
  | subtract_list_sorted (A1_, A2_) [] ys = []
  | subtract_list_sorted (A1_, A2_) (v :: va) [] = v :: va;

fun remdups_sort (A1_, A2_) xs = remdups_adj A1_ (sort_key A2_ (fn x => x) xs);

fun comp (A1_, A2_) esa es =
  remdups_sort (equal_prod A1_ A1_, linorder_prod A2_ A2_)
    (maps (fn (x, y) =>
            maps (fn (ya, z) => (if eq A1_ y ya then [(x, z)] else [])) es)
      esa);

fun scg_comp (B1_, B2_) conn (Scg (pa, qa, stra, wka)) (Scg (p, q, str, wk)) =
  (if not (conn qa p) then Null
    else let
           val strs =
             remdups_sort (equal_prod B1_ B1_, linorder_prod B2_ B2_)
               (comp (B1_, B2_) stra str @
                 comp (B1_, B2_) stra wk @ comp (B1_, B2_) wka str);
           val a =
             subtract_list_sorted (equal_prod B1_ B1_, linorder_prod B2_ B2_)
               (remdups_sort (equal_prod B1_ B1_, linorder_prod B2_ B2_)
                 (comp (B1_, B2_) wka wk))
               strs;
         in
           Scg (pa, q, strs, a)
         end)
  | scg_comp (B1_, B2_) conn Null g = Null
  | scg_comp (B1_, B2_) conn (Scg (v, va, vb, vc)) Null = Null;

fun generate_scgs A_ (B1_, B2_) conn base g =
  filtera (fn ga => not (equal_scga A_ B1_ ga Null))
    (map (scg_comp (B1_, B2_) conn g) base);

fun subsumes A_ B_ (Scg (pa, qa, stra, wka)) (Scg (p, q, str, wk)) =
  eq A_ pa p andalso
    (eq A_ qa q andalso
      (list_all (membera (equal_prod B_ B_) str) stra andalso
        list_all (membera (equal_prod B_ B_) (str @ wk)) wka))
  | subsumes A_ B_ g Null = true
  | subsumes A_ B_ Null (Scg (v, va, vb, vc)) = false;

fun in_situ B_ Null = true
  | in_situ B_ (Scg (p, q, str, wk)) = list_ex (fn (a, b) => eq B_ a b) str;

fun union_list_sorted (A1_, A2_) (x :: xs) (y :: ys) =
  (if eq A1_ x y then x :: union_list_sorted (A1_, A2_) xs ys
    else (if less A2_ x y then x :: union_list_sorted (A1_, A2_) xs (y :: ys)
           else y :: union_list_sorted (A1_, A2_) (x :: xs) ys))
  | union_list_sorted (A1_, A2_) [] ys = ys
  | union_list_sorted (A1_, A2_) (v :: va) [] = v :: va;

fun combinea (B1_, B2_) (Scg (pa, qa, stra, wka)) (Scg (p, q, str, wk)) =
  Scg (pa, qa,
        union_list_sorted
          (equal_prod B1_ B1_,
            ord_prod ((ord_preorder o preorder_order o order_linorder) B2_)
              ((ord_preorder o preorder_order o order_linorder) B2_))
          stra str,
        union_list_sorted
          (equal_prod B1_ B1_,
            ord_prod ((ord_preorder o preorder_order o order_linorder) B2_)
              ((ord_preorder o preorder_order o order_linorder) B2_))
          wka wk)
  | combinea (B1_, B2_) Null s = Null
  | combinea (B1_, B2_) (Scg (v, va, vb, vc)) Null = Null;

fun sagiv A_ (B1_, B2_) conn g =
  (if in_situ B1_ g then true
    else let
           val gg = scg_comp (B1_, B2_) conn g g;
         in
           (if subsumes A_ B1_ gg g then false
             else sagiv A_ (B1_, B2_) conn (combinea (B1_, B2_) g gg))
         end);

fun check_SCT (A1_, A2_) (B1_, B2_) conn gs =
  g_ball_dflt_basic_oops_rm_basic_ops
    (linorder_scg (compare_compare_order A1_) (compare_compare_order B1_))
    (mk_rtrancl_set
      (compare_order_scg (compare_compare_order A1_)
        (compare_compare_order B1_))
      (generate_scgs A2_ (B2_, linorder_compare_order B1_) conn gs) gs)
    (sagiv A2_ (B2_, linorder_compare_order B1_) conn);

fun sct_subterm_precise_proc (B1_, B2_, B3_) i gs dpp =
  catch_errora
    let
      val p = pairsb i dpp;
      val is_def = (fn fna => not (null (rules_mapc i dpp fna)));
      val eidg = is_iedg_edge_dpp (B1_, B2_, B3_) i dpp;
    in
      bindb (catch_errora
              (check_subseteq
                (equal_prod (equal_term B1_ (equal_list equal_char))
                  (equal_term B1_ (equal_list equal_char)))
                p (map fst gs))
              (fn x =>
                Inl (shows_string
                       [#"t", #"h", #"e", #"r", #"e", #" ", #"i", #"s", #" ",
                         #"n", #"o", #" ", #"s", #"i", #"z", #"e", #"-", #"c",
                         #"h", #"a", #"n", #"g", #"e", #" ", #"g", #"r", #"a",
                         #"p", #"h", #" ", #"f", #"o", #"r", #" ", #"t", #"h",
                         #"e", #" ", #"p", #"a", #"i", #"r", #" "] o
                      shows_rule (shows_prec B3_ zero_nata)
                        (shows_prec_list show_char zero_nata)
                        [#" ", #"-", #">", #" "] x)))
        (fn _ =>
          let
            val gGs =
              filtera
                (fn g =>
                  membera
                    (equal_prod (equal_term B1_ (equal_list equal_char))
                      (equal_term B1_ (equal_list equal_char)))
                    p (fst g))
                gs;
          in
            bindb (check (minimal i dpp orelse nFQ_subset_NF_rulesc i dpp)
                    (shows_prec_list show_char zero_nata
                      [#"m", #"i", #"n", #"i", #"m", #"a", #"l", #"i", #"t",
                        #"y", #" ", #"o", #"r", #" ", #"i", #"n", #"n", #"e",
                        #"r", #"m", #"o", #"s", #"t", #" ", #"r", #"e", #"q",
                        #"u", #"i", #"r", #"e", #"d"]))
              (fn _ =>
                bindb (catch_errora
                        (forallM
                          (fn (l, _) =>
                            check_no_var B3_ (show_list show_char) l)
                          (rulese i dpp))
                        (fn x => Inl (snd x)))
                  (fn _ =>
                    bindb (catch_errora
                            (forallM
                              (fn (a, b) =>
                                let
                                  val (s, t) = a;
                                in
                                  (fn (stri, nstri) =>
                                    catch_errora
                                      (bindb
(check_no_var B3_ (show_list show_char) s)
(fn _ =>
  bindb (check_no_var B3_ (show_list show_char) t)
    (fn _ =>
      bindb (check_no_defined_root B3_ (show_list show_char) is_def t)
        (fn _ =>
          let
            val m = size_list (args t);
            val n = size_list (args s);
          in
            bindb (catch_errora
                    (forallM
                      (fn (ia, j) =>
                        check (less_eq_nat ia n andalso
                                (less_eq_nat j m andalso
                                  isOK (check_supt (B1_, B3_)
 (equal_list equal_char, show_list show_char) (get_arg s ia) (get_arg t j))))
                          (shows_string
                             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                               #"w", #"i", #"t", #"h", #" ", #"e", #"d", #"g",
                               #"e", #" "] o
                            (shows_prec_nat zero_nata ia o
                              (shows_string [#" ", #"|", #">", #" "] o
                                (shows_prec_nat zero_nata j o shows_nl)))))
                      stri)
                    (fn x => Inl (snd x)))
              (fn _ =>
                catch_errora
                  (forallM
                    (fn (ia, j) =>
                      check (less_eq_nat ia n andalso
                              (less_eq_nat j m andalso
                                isOK (check_supteq (B1_, B3_)
                                       (equal_list equal_char,
 show_list show_char)
                                       (get_arg s ia) (get_arg t j))))
                        (shows_string
                           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                             #"w", #"i", #"t", #"h", #" ", #"e", #"d", #"g",
                             #"e", #" "] o
                          (shows_prec_nat zero_nata ia o
                            (shows_string [#" ", #"|", #">", #"=", #" "] o
                              (shows_prec_nat zero_nata j o shows_nl)))))
                    nstri)
                  (fn x => Inl (snd x)))
          end))))
                                      (fn x =>
Inl (shows_string
       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"i", #"t", #"h",
         #" ", #"p", #"a", #"i", #"r", #" "] o
      (shows_rule (shows_prec B3_ zero_nata)
         (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] (s, t) o
        (shows_nl o x)))))
                                end
                                  b)
                              gGs)
                            (fn x => Inl (snd x)))
                      (fn _ =>
                        let
                          val n = size_list p;
                          val nums = upt zero_nata n;
                          val numPs = zip p nums;
                          val num_of =
                            fun_of_default
                              (equal_prod
                                (equal_term B1_ (equal_list equal_char))
                                (equal_term B1_ (equal_list equal_char)))
                              numPs n;
                        in
                          check (check_SCT
                                  (compare_order_prod compare_order_nat
                                     (compare_order_list
                                       (compare_order_nat, equal_nat)),
                                    equal_prod equal_nat (equal_list equal_nat))
                                  (compare_order_nat, equal_nat)
                                  (fn (_, succs) => fn (uv, _) =>
                                    membera equal_nat succs uv)
                                  (map (fn (st, (stri, nstri)) =>
 let
   val eidg_st = eidg st;
   val ia = num_of st;
   val e =
     (ia, map_filter
            (fn x => (if (eidg_st o fst o fst) x then SOME (snd x) else NONE))
            numPs);
 in
   Scg (e, e,
         remdups_sort
           (equal_prod equal_nat equal_nat,
             linorder_prod linorder_nat linorder_nat)
           stri,
         remdups_sort
           (equal_prod equal_nat equal_nat,
             linorder_prod linorder_nat linorder_nat)
           nstri)
 end)
                                    gGs))
                            (shows_string
                               [#"s", #"i", #"z", #"e", #"-", #"c", #"h", #"a",
                                 #"n", #"g", #"e", #" ", #"a", #"n", #"a", #"l",
                                 #"y", #"s", #"i", #"s", #" ", #"f", #"a", #"i",
                                 #"l", #"e", #"d"] o
                              shows_nl)
                        end)))
          end)
    end
    (fn x =>
      Inl (shows_string
             [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"a",
               #"p", #"p", #"l", #"y", #" ", #"t", #"h", #"e", #" ", #"s", #"i",
               #"z", #"e", #"-", #"c", #"h", #"a", #"n", #"g", #"e", #" ", #"p",
               #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r", #" ", #"b", #"a",
               #"s", #"e", #"d", #" ", #"o", #"n", #" ", #"t", #"h", #"e", #" ",
               #"s", #"u", #"b", #"t", #"e", #"r", #"m", #"-", #"r", #"e", #"l",
               #"a", #"t", #"i", #"o", #"n"] o
            (shows_nl o x)));

fun sct_subterm_approx_proc (B1_, B2_, B3_) i gs dpp =
  catch_errora
    let
      val p = pairsb i dpp;
      val is_def = (fn fna => not (null (rules_mapc i dpp fna)));
    in
      bindb (catch_errora
              (check_subseteq
                (equal_prod (equal_term B1_ (equal_list equal_char))
                  (equal_term B1_ (equal_list equal_char)))
                p (map fst gs))
              (fn x =>
                Inl (shows_string
                       [#"t", #"h", #"e", #"r", #"e", #" ", #"i", #"s", #" ",
                         #"n", #"o", #" ", #"s", #"i", #"z", #"e", #"-", #"c",
                         #"h", #"a", #"n", #"g", #"e", #" ", #"g", #"r", #"a",
                         #"p", #"h", #" ", #"f", #"o", #"r", #" ", #"t", #"h",
                         #"e", #" ", #"p", #"a", #"i", #"r", #" "] o
                      shows_rule (shows_prec B3_ zero_nata)
                        (shows_prec_list show_char zero_nata)
                        [#" ", #"-", #">", #" "] x)))
        (fn _ =>
          let
            val gGs =
              filtera
                (fn g =>
                  membera
                    (equal_prod (equal_term B1_ (equal_list equal_char))
                      (equal_term B1_ (equal_list equal_char)))
                    p (fst g))
                gs;
          in
            bindb (check (minimal i dpp orelse nFQ_subset_NF_rulesc i dpp)
                    (shows_prec_list show_char zero_nata
                      [#"m", #"i", #"n", #"i", #"m", #"a", #"l", #"i", #"t",
                        #"y", #" ", #"o", #"r", #" ", #"i", #"n", #"n", #"e",
                        #"r", #"m", #"o", #"s", #"t", #" ", #"r", #"e", #"q",
                        #"u", #"i", #"r", #"e", #"d"]))
              (fn _ =>
                bindb (catch_errora
                        (forallM
                          (fn (l, _) =>
                            check_no_var B3_ (show_list show_char) l)
                          (rulese i dpp))
                        (fn x => Inl (snd x)))
                  (fn _ =>
                    bindb (catch_errora
                            (forallM
                              (fn (a, b) =>
                                let
                                  val (s, t) = a;
                                in
                                  (fn (stri, nstri) =>
                                    catch_errora
                                      (bindb
(check_no_var B3_ (show_list show_char) s)
(fn _ =>
  bindb (check_no_var B3_ (show_list show_char) t)
    (fn _ =>
      bindb (check_no_defined_root B3_ (show_list show_char) is_def t)
        (fn _ =>
          let
            val m = size_list (args t);
            val n = size_list (args s);
          in
            bindb (catch_errora
                    (forallM
                      (fn (ia, j) =>
                        check (less_eq_nat ia n andalso
                                (less_eq_nat j m andalso
                                  isOK (check_supt (B1_, B3_)
 (equal_list equal_char, show_list show_char) (get_arg s ia) (get_arg t j))))
                          (shows_string
                             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                               #"w", #"i", #"t", #"h", #" ", #"e", #"d", #"g",
                               #"e", #" "] o
                            (shows_prec_nat zero_nata ia o
                              (shows_string [#" ", #"|", #">", #" "] o
                                (shows_prec_nat zero_nata j o shows_nl)))))
                      stri)
                    (fn x => Inl (snd x)))
              (fn _ =>
                catch_errora
                  (forallM
                    (fn (ia, j) =>
                      check (less_eq_nat ia n andalso
                              (less_eq_nat j m andalso
                                isOK (check_supteq (B1_, B3_)
                                       (equal_list equal_char,
 show_list show_char)
                                       (get_arg s ia) (get_arg t j))))
                        (shows_string
                           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                             #"w", #"i", #"t", #"h", #" ", #"e", #"d", #"g",
                             #"e", #" "] o
                          (shows_prec_nat zero_nata ia o
                            (shows_string [#" ", #"|", #">", #"=", #" "] o
                              (shows_prec_nat zero_nata j o shows_nl)))))
                    nstri)
                  (fn x => Inl (snd x)))
          end))))
                                      (fn x =>
Inl (shows_string
       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"i", #"t", #"h",
         #" ", #"p", #"a", #"i", #"r", #" "] o
      (shows_rule (shows_prec B3_ zero_nata)
         (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] (s, t) o
        (shows_nl o x)))))
                                end
                                  b)
                              gGs)
                            (fn x => Inl (snd x)))
                      (fn _ =>
                        check (check_SCT
                                (compare_order_prod
                                   (compare_order_prod (compare_order_key B2_)
                                     compare_order_nat)
                                   (compare_order_prod (compare_order_key B2_)
                                     compare_order_nat),
                                  equal_prod (equal_prod B1_ equal_nat)
                                    (equal_prod B1_ equal_nat))
                                (compare_order_nat, equal_nat)
                                (fn (_, g) => fn (h, _) =>
                                  equal_proda B1_ equal_nat g h)
                                (remdups
                                  (equal_scg
                                    (equal_prod (equal_prod B1_ equal_nat)
                                      (equal_prod B1_ equal_nat))
                                    equal_nat)
                                  (map (fn (st, (stri, nstri)) =>
 let
   val e = (the (root (fst st)), the (root (snd st)));
 in
   Scg (e, e,
         remdups_sort
           (equal_prod equal_nat equal_nat,
             linorder_prod linorder_nat linorder_nat)
           stri,
         remdups_sort
           (equal_prod equal_nat equal_nat,
             linorder_prod linorder_nat linorder_nat)
           nstri)
 end)
                                    gGs)))
                          (shows_string
                             [#"s", #"i", #"z", #"e", #"-", #"c", #"h", #"a",
                               #"n", #"g", #"e", #" ", #"a", #"n", #"a", #"l",
                               #"y", #"s", #"i", #"s", #" ", #"f", #"a", #"i",
                               #"l", #"e", #"d"] o
                            shows_nl))))
          end)
    end
    (fn x =>
      Inl (shows_string
             [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"a",
               #"p", #"p", #"l", #"y", #" ", #"t", #"h", #"e", #" ", #"s", #"i",
               #"z", #"e", #"-", #"c", #"h", #"a", #"n", #"g", #"e", #" ", #"p",
               #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r", #" ", #"b", #"a",
               #"s", #"e", #"d", #" ", #"o", #"n", #" ", #"t", #"h", #"e", #" ",
               #"s", #"u", #"b", #"t", #"e", #"r", #"m", #"-", #"r", #"e", #"l",
               #"a", #"t", #"i", #"o", #"n"] o
            (shows_nl o x)));

fun sct_subterm_proc (B1_, B2_, B3_) i gs dpp =
  (if isOK (sct_subterm_approx_proc (B1_, B2_, B3_) i gs dpp) then Inr ()
    else sct_subterm_precise_proc (B1_, B2_, B3_) i gs dpp);

fun sct_entry_to_sts s t stri nstri =
  let
    val a = remdups equal_nat (map snd (stri @ nstri));
  in
    map (fn j => (s, get_arg t j)) a
  end;

fun check_sct_entry A_ B_ is_def sa nst s t stri nstri =
  catch_errora
    (bindb (check_no_var A_ B_ s)
      (fn _ =>
        bindb (check_no_var A_ B_ t)
          (fn _ =>
            bindb (check_no_defined_root A_ B_ is_def t)
              (fn _ =>
                let
                  val m = size_list (args t);
                  val n = size_list (args s);
                in
                  bindb (catch_errora
                          (forallM
                            (fn i =>
                              check (less_eq_nat i n)
                                (shows_string
                                   [#"l", #"e", #"f", #"t", #"-", #"i", #"n",
                                     #"d", #"e", #"x", #" ", #"t", #"o", #" ",
                                     #"l", #"a", #"r", #"g", #"e"] o
                                  (shows_prec_nat zero_nata i o shows_nl)))
                            (remdups equal_nat (map fst (stri @ nstri))))
                          (fn x => Inl (snd x)))
                    (fn _ =>
                      bindb (catch_errora
                              (forallM
                                (fn j =>
                                  check (less_eq_nat j m)
                                    (shows_string
                                       [#"r", #"i", #"g", #"h", #"t", #"-",
 #"i", #"n", #"d", #"e", #"x", #" ", #"t", #"o", #" ", #"l", #"a", #"r", #"g",
 #"e", #" ", #"o", #"r", #" ", #"a", #"r", #"g", #"u", #"m", #"e", #"n", #"t",
 #" ", #"v", #"i", #"o", #"l", #"a", #"t", #"e", #"s", #" ", #"u", #"s", #"a",
 #"b", #"l", #"e", #"-", #"r", #"u", #"l", #"e", #"s", #" ", #"c", #"o", #"n",
 #"d", #"i", #"t", #"i", #"o", #"n"] o
                                      shows_prec_nat zero_nata j))
                                (remdups equal_nat (map snd (stri @ nstri))))
                              (fn x => Inl (snd x)))
                        (fn _ =>
                          let
                            val _ = args s;
                            val _ = args t;
                          in
                            bindb (catch_errora
                                    (forallM
                                      (fn (i, j) =>
check (isOK (sa (get_arg s i, get_arg t j)))
  (shows_string
     [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"i", #"t", #"h",
       #" ", #"e", #"d", #"g", #"e", #" "] o
    (shows_prec_nat zero_nata i o
      (shows_string [#" ", #"-", #"S", #"-", #">", #" "] o
        shows_prec_nat zero_nata j))))
                                      stri)
                                    (fn x => Inl (snd x)))
                              (fn _ =>
                                catch_errora
                                  (forallM
                                    (fn (i, j) =>
                                      check
(isOK (nst (get_arg s i, get_arg t j)))
(shows_string
   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"i", #"t", #"h",
     #" ", #"e", #"d", #"g", #"e", #" "] o
  (shows_prec_nat zero_nata i o
    (shows_string [#" ", #"-", #"N", #"S", #"-", #">", #" "] o
      shows_prec_nat zero_nata j))))
                                    nstri)
                                  (fn x => Inl (snd x)))
                          end))
                end))))
    (fn x =>
      Inl (shows_string
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #"s", #" ", #"w", #"i",
               #"t", #"h", #" ", #"D", #"P", #" "] o
            (shows_rule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata)
               [#" ", #"-", #">", #" "] (s, t) o
              (shows_nl o x))));

fun sct_ur_af_proc (B1_, B2_, B3_) i rp gs u_opt dpp =
  catch_errora
    (bindb (valid rp)
      (fn _ =>
        let
          val is_def = (fn fna => not (null (rules_mapc i dpp fna)));
          val pi = af rp;
          val sa = s rp;
          val nsa = ns rp;
          val nsta = nst rp;
          val p = pairsb i dpp;
          val gGs =
            filtera
              (fn g =>
                membera
                  (equal_prod (equal_term B1_ (equal_list equal_char))
                    (equal_term B1_ (equal_list equal_char)))
                  p (fst g))
              gs;
        in
          bindb (catch_errora
                  (forallM
                    (fn (l, _) => check_no_var B3_ (show_list show_char) l)
                    (rulese i dpp))
                  (fn x => Inl (snd x)))
            (fn _ =>
              bindb (catch_errora
                      (forallM
                        (fn (a, b) =>
                          let
                            val (saa, t) = a;
                          in
                            (fn (aa, ba) =>
                              check_sct_entry B3_ (show_list show_char) is_def
                                sa nsta saa t aa ba)
                          end
                            b)
                        gGs)
                      (fn x => Inl (snd x)))
                (fn _ =>
                  let
                    val sts =
                      maps (fn (a, b) =>
                             let
                               val (sb, t) = a;
                             in
                               (fn (aa, ba) => sct_entry_to_sts sb t aa ba)
                             end
                               b)
                        gGs;
                  in
                    bindb (smart_usable_rules_checker_impl (B1_, B2_, B3_) i dpp
                            pi u_opt sts)
                      (fn u =>
                        bindb (catch_errora
                                (catch_errora (forallM nsa u)
                                  (fn x => Inl (snd x)))
                                (fn x =>
                                  Inl (shows_string
 [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n", #" ",
   #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"u", #"s", #"a",
   #"b", #"l", #"e", #" ", #"r", #"u", #"l", #"e", #"s"] o
(shows_nl o x))))
                          (fn _ =>
                            let
                              val eidg = is_iedg_edge_dpp (B1_, B2_, B3_) i dpp;
                            in
                              bindb (catch_errora
                                      (check_subseteq
(equal_prod (equal_term B1_ (equal_list equal_char))
  (equal_term B1_ (equal_list equal_char)))
p (map fst gs))
                                      (fn x =>
Inl (shows_string
       [#"t", #"h", #"e", #"r", #"e", #" ", #"i", #"s", #" ", #"n", #"o", #" ",
         #"s", #"i", #"z", #"e", #"-", #"c", #"h", #"a", #"n", #"g", #"e", #" ",
         #"g", #"r", #"a", #"p", #"h", #" ", #"f", #"o", #"r", #" ", #"D", #"P",
         #" "] o
      shows_rule (shows_prec B3_ zero_nata)
        (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] x)))
                                (fn _ =>
                                  let
                                    val n = size_list p;
                                    val nums = upt zero_nata n;
                                    val numPs = zip p nums;
                                    val num_of =
                                      fun_of_default
(equal_prod (equal_term B1_ (equal_list equal_char))
  (equal_term B1_ (equal_list equal_char)))
numPs n;
                                  in
                                    check (check_SCT
    (compare_order_prod compare_order_nat
       (compare_order_list (compare_order_nat, equal_nat)),
      equal_prod equal_nat (equal_list equal_nat))
    (compare_order_nat, equal_nat)
    (fn (_, succs) => fn (uv, _) => membera equal_nat succs uv)
    (map (fn (st, (stri, nstri)) =>
           let
             val eidg_st = eidg st;
             val ia = num_of st;
             val e =
               (ia, map_filter
                      (fn x =>
                        (if (eidg_st o fst o fst) x then SOME (snd x)
                          else NONE))
                      numPs);
           in
             Scg (e, e, stri, nstri)
           end)
      gGs))
                                      (shows_string
 [#"s", #"i", #"z", #"e", #"-", #"c", #"h", #"a", #"n", #"g", #"e", #" ", #"a",
   #"n", #"a", #"l", #"y", #"s", #"i", #"s", #" ", #"f", #"a", #"i", #"l", #"e",
   #"d"] o
shows_nl)
                                  end)
                            end))
                  end))
        end))
    (fn x =>
      Inl (shows_string
             [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"a",
               #"p", #"p", #"l", #"y", #" ", #"t", #"h", #"e", #" ", #"s", #"i",
               #"z", #"e", #"-", #"c", #"h", #"a", #"n", #"g", #"e", #" ", #"p",
               #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r", #" ", #"w", #"i",
               #"t", #"h", #" ", #"t", #"h", #"e", #" ", #"f", #"o", #"l", #"l",
               #"o", #"w", #"i", #"n", #"g", #" "] o
            (shows_nl o
              (desc rp o
                (shows_nl o
                  (shows_string
                     [#"f", #"o", #"r", #" ", #"t", #"h", #"e", #" ", #"f",
                       #"o", #"l", #"l", #"o", #"w", #"i", #"n", #"g", #" ",
                       #"r", #"e", #"a", #"s", #"o", #"n"] o
                    (shows_nl o x)))))));

fun proj_terma (A1_, A2_, A3_) B_ proj f (Var x) =
  add_mset (equal_term A3_ B_) (Var x) zero_multiseta
  | proj_terma (A1_, A2_, A3_) B_ proj fa (Fun (f, ts)) =
    (if member (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat)
          (f, size_list ts) fa
      then sum_mset (comm_monoid_add_multiset (equal_term A3_ B_))
             (mset (equal_multiset (equal_term A3_ B_))
               (map (fn i => proj_terma (A1_, A2_, A3_) B_ proj fa (nth ts i))
                 (status proj (f, size_list ts))))
      else add_mset (equal_term A3_ B_) (Fun (f, ts)) zero_multiseta);

fun weak_supt_mul (A1_, A2_, A3_, A4_) (B1_, B2_) =
  (fn proj => fn f => fn s => fn t =>
    multeqp
      (ceq_term A4_ B2_, ccompare_term A3_ B1_, equal_term A4_ B2_,
        set_impl_term)
      (fn x => fn y => supt_impl A4_ B2_ y x)
      (proj_terma (A1_, A2_, A4_) B2_ proj f t)
      (proj_terma (A1_, A2_, A4_) B2_ proj f s));

fun check_supteqproj_pred (A1_, A2_, A3_, A4_, A5_) (B1_, B2_, B3_) pi f lr =
  check let
          val (a, b) = lr;
        in
          weak_supt_mul (A1_, A2_, A3_, A4_) (B1_, B2_) pi f a b
        end
    (shows_prec_list show_char zero_nata
       [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"o", #"r",
         #"i", #"e", #"n", #"t", #" ", #"r", #"u", #"l", #"e", #" "] o
       shows_rule (shows_prec A5_ zero_nata) (shows_prec B3_ zero_nata)
         [#" ", #"-", #">", #" "] lr o
      shows_prec_list show_char zero_nata
        [#" ", #"b", #"y", #" ", #"s", #"u", #"p", #"t", #"e", #"q", #"^", #"m",
          #"u", #"l"]);

fun strict_supt_mul (A1_, A2_, A3_, A4_) (B1_, B2_) =
  (fn proj => fn f => fn s => fn t =>
    multeqp
      (ceq_term A4_ B2_, ccompare_term A3_ B1_, equal_term A4_ B2_,
        set_impl_term)
      (fn x => fn y => supt_impl A4_ B2_ y x)
      (proj_terma (A1_, A2_, A4_) B2_ proj f t)
      (proj_terma (A1_, A2_, A4_) B2_ proj f s) andalso
      not (equal_multiseta (equal_term A4_ B2_)
            (proj_terma (A1_, A2_, A4_) B2_ proj f s)
            (proj_terma (A1_, A2_, A4_) B2_ proj f t)));

fun check_suptproj_pred (A1_, A2_, A3_, A4_, A5_) (B1_, B2_, B3_) pi f lr =
  check let
          val (a, b) = lr;
        in
          strict_supt_mul (A1_, A2_, A3_, A4_) (B1_, B2_) pi f a b
        end
    (shows_prec_list show_char zero_nata
       [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"o", #"r",
         #"i", #"e", #"n", #"t", #" ", #"r", #"u", #"l", #"e", #" "] o
       shows_rule (shows_prec A5_ zero_nata) (shows_prec B3_ zero_nata)
         [#" ", #"-", #">", #" "] lr o
      shows_prec_list show_char zero_nata
        [#" ", #"b", #"y", #" ", #"s", #"u", #"p", #"t", #"^", #"m", #"u",
          #"l"]);

fun generalized_subterm_proc (B1_, B2_, B3_, B4_, B5_, B6_) (C1_, C2_, C3_) i pi
  p_remove dpp =
  (case catch_errora
          let
            val p = pairsb i dpp;
            val r = rulese i dpp;
            val f = map fst pi;
            val ff =
              set (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat,
                    set_impl_prod B5_ set_impl_nat)
                f;
            val pi_opt = status_of B4_ pi;
          in
            bindb (check (null (qc i dpp))
                    (shows_prec_list show_char zero_nata
                      [#"c", #"u", #"r", #"r", #"e", #"n", #"t", #"l", #"y",
                        #" ", #"g", #"e", #"n", #"e", #"r", #"a", #"l", #"i",
                        #"z", #"e", #"d", #" ", #"s", #"u", #"b", #"t", #"e",
                        #"r", #"m", #" ", #"c", #"r", #"i", #"t", #"e", #"r",
                        #"i", #"o", #"n", #" ", #"d", #"o", #"e", #"s", #" ",
                        #"n", #"o", #"t", #" ", #"s", #"u", #"p", #"p", #"o",
                        #"r", #"t", #" ", #"s", #"t", #"r", #"a", #"t", #"e",
                        #"g", #"i", #"e", #"s"]))
              (fn _ =>
                bindb (check (minimal i dpp)
                        (shows_prec_list show_char zero_nata
                          [#"m", #"i", #"n", #"i", #"m", #"a", #"l", #"i", #"t",
                            #"y", #" ", #"r", #"e", #"q", #"u", #"i", #"r",
                            #"e", #"d"]))
                  (fn _ =>
                    bindb (check (not (is_none pi_opt))
                            (shows_prec_list show_char zero_nata
                              [#"a", #"r", #"g", #"u", #"m", #"e", #"n", #"t",
                                #" ", #"f", #"i", #"l", #"t", #"e", #"r", #" ",
                                #"l", #"i", #"s", #"t", #"s", #" ", #"i", #"n",
                                #"v", #"a", #"l", #"i", #"d", #" ", #"p", #"o",
                                #"s", #"i", #"t", #"i", #"o", #"n", #"s"]))
                      (fn _ =>
                        let
                          val pia = the pi_opt;
                          val premove =
                            set (ceq_prod (ceq_term B4_ C2_) (ceq_term B4_ C2_),
                                  ccompare_prod (ccompare_term B3_ C1_)
                                    (ccompare_term B3_ C1_),
                                  set_impl_prod set_impl_term set_impl_term)
                              p_remove;
                          val (ps, pns) =
                            partition
                              (fn lr =>
                                member
                                  (ceq_prod (ceq_term B4_ C2_)
                                     (ceq_term B4_ C2_),
                                    ccompare_prod (ccompare_term B3_ C1_)
                                      (ccompare_term B3_ C1_))
                                  lr premove)
                              p;
                        in
                          bindb (catch_errora
                                  (forallM
                                    (fn fa =>
                                      check (not (null (status pia fa)))
(shows_prec_list show_char zero_nata
   [#"s", #"t", #"a", #"t", #"u", #"s", #" ", #"o", #"f", #" ", #"s", #"y",
     #"m", #"b", #"o", #"l", #" "] o
   shows_prec_prod B6_ show_nat zero_nata fa o
  shows_prec_list show_char zero_nata
    [#" ", #"i", #"n", #" ", #"F", #" ", #"m", #"u", #"s", #"t", #" ", #"b",
      #"e", #" ", #"n", #"o", #"n", #"-", #"e", #"m", #"p", #"t", #"y"]))
                                    f)
                                  (fn x => Inl (snd x)))
                            (fn _ =>
                              bindb (catch_errora
                                      (forallM
(fn (l, _) =>
  check (not (is_Var l))
    (shows_prec_list show_char zero_nata
      [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #"s", #" ", #"a", #"s",
        #" ", #"l", #"h", #"s", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l",
        #"l", #"o", #"w", #"e", #"d"]))
r)
                                      (fn x => Inl (snd x)))
                                (fn _ =>
                                  bindb (catch_errora
  (catch_errora
    (forallM
      (check_supteqproj_pred (B1_, B2_, B3_, B4_, B6_) (C1_, C2_, C3_) pia ff)
      (filtera
        (fn lr =>
          member (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat)
            (the (root (fst lr))) ff)
        r))
    (fn x => Inl (snd x)))
  (fn x =>
    Inl (shows_prec_list show_char zero_nata
           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
             #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g",
             #" ", #"r", #"u", #"l", #"e", #"s", #" ", #"w", #"i", #"t", #"h",
             #" ", #"r", #"o", #"o", #"t", #" ", #"i", #"n", #" ", #"F",
             #"\n"] o
          x)))
                                    (fn _ =>
                                      bindb
(catch_errora
  (catch_errora
    (forallM
      (check_supteqproj_pred (B1_, B2_, B3_, B4_, B6_) (C1_, C2_, C3_) pia ff)
      pns)
    (fn x => Inl (snd x)))
  (fn x =>
    Inl (shows_prec_list show_char zero_nata
           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
             #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g",
             #" ", #"D", #"P", #"s", #"\n"] o
          x)))
(fn _ =>
  catch_errora
    (catch_errora
      (forallM
        (check_suptproj_pred (B1_, B2_, B3_, B4_, B6_) (C1_, C2_, C3_) pia ff)
        ps)
      (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
               #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g",
               #" ", #"D", #"P", #"s", #"\n"] o
            x))))))
                        end)))
          end
          (fn x =>
            Inl (shows_prec_list show_char zero_nata
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"a", #"p", #"p", #"l", #"y", #" ", #"t", #"h", #"e", #" ",
                     #"s", #"u", #"b", #"t", #"e", #"r", #"m", #" ", #"p", #"r",
                     #"o", #"c", #"e", #"s", #"s", #"o", #"r", #"\n"] o
                  x))
    of Inl a => Inl a | Inr _ => Inr (delete_P_Pwa i dpp p_remove p_remove));

fun simplifya A_ (Var x) = Var x
  | simplifya A_ (Fun (ConstFa n, ss)) = Fun (ConstFa n, [])
  | simplifya A_ (Fun (SumFa, ss)) =
    let
      val ssa =
        filtera
          (fn s =>
            not (equal_terma equal_siga A_ s (Fun (ConstFa zero_nata, []))))
          (map (simplifya A_) ss);
    in
      (case ssa of [] => Fun (ConstFa zero_nata, []) | [s] => s
        | _ :: _ :: _ => Fun (SumFa, ssa))
    end
  | simplifya A_ (Fun (ProdFa, ss)) =
    let
      val ssa =
        filtera
          (fn s =>
            not (equal_terma equal_siga A_ s (Fun (ConstFa one_nata, []))))
          (map (simplifya A_) ss);
    in
      (if membera (equal_term equal_siga A_) ssa (Fun (ConstFa zero_nata, []))
        then Fun (ConstFa zero_nata, [])
        else (case ssa of [] => Fun (ConstFa one_nata, []) | [s] => s
               | _ :: _ :: _ => Fun (ProdFa, ssa)))
    end
  | simplifya A_ (Fun (MaxF, ss)) =
    let
      val ssa =
        filtera
          (fn s =>
            not (equal_terma equal_siga A_ s (Fun (ConstFa zero_nata, []))))
          (map (simplifya A_) ss);
    in
      (case ssa of [] => Fun (ConstFa zero_nata, []) | [s] => s
        | _ :: _ :: _ => Fun (MaxF, ssa))
    end;

fun simplified_alist A_ alist = map (map_prod id (simplifya equal_nat)) alist;

fun to_IA (Var x) = [Var (x, IntT)]
  | to_IA (Fun (f, ss)) =
    (case f of ConstFa n => [Fun (ConstF (int_of_nat n), [])]
      | SumFa =>
        (if null ss then [Fun (SumF zero_nata, [])]
          else map (fn a => Fun (SumF (size_list ss), a))
                 (product_lists (map to_IA ss)))
      | ProdFa =>
        (if null ss then [Fun (ProdF zero_nata, [])]
          else map (fn a => Fun (ProdF (size_list ss), a))
                 (product_lists (map to_IA ss)))
      | MaxF =>
        (if null ss then [Fun (ConstF zero_inta, [])] else maps to_IA ss));

fun le_via_IA s t =
  Conjunction
    (map (fn sa =>
           Disjunction
             (map Atom (map (fn ta => Fun (LeF, [sa, ta])) (to_IA t))))
      (to_IA s));

fun iA_exp_to_tpoly (Var (a, ty)) = PVar a
  | iA_exp_to_tpoly (Fun (SumF uu, asa)) = PSum (map iA_exp_to_tpoly asa)
  | iA_exp_to_tpoly (Fun (ConstF a, [])) = PNum a
  | iA_exp_to_tpoly (Fun (ProdF uv, asa)) = PMult (map iA_exp_to_tpoly asa);

fun iA_exp_to_poly (A1_, A2_) =
  poly_of (A1_, A2_) (equal_int, comm_semiring_1_int) o iA_exp_to_tpoly;

fun show_IA_exp (A1_, A2_, A3_) (Fun (LessF, [s, t])) =
  show_IA_exp (A1_, A2_, A3_) s o
    shows_prec_list show_char zero_nata [#" ", #"<", #" "] o
    show_IA_exp (A1_, A2_, A3_) t
  | show_IA_exp (A1_, A2_, A3_) (Fun (LeF, [s, t])) =
    show_IA_exp (A1_, A2_, A3_) s o
      shows_prec_list show_char zero_nata [#" ", #"<", #"=", #" "] o
      show_IA_exp (A1_, A2_, A3_) t
  | show_IA_exp (A1_, A2_, A3_) (Fun (EqF, [s, t])) =
    show_IA_exp (A1_, A2_, A3_) s o
      shows_prec_list show_char zero_nata [#" ", #"=", #" "] o
      show_IA_exp (A1_, A2_, A3_) t
  | show_IA_exp (A1_, A2_, A3_) (Var v) =
    shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int)
      (iA_exp_to_poly (A1_, A2_) (Var v))
  | show_IA_exp (A1_, A2_, A3_) (Fun (LeF, [])) =
    shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int)
      (iA_exp_to_poly (A1_, A2_) (Fun (LeF, [])))
  | show_IA_exp (A1_, A2_, A3_) (Fun (LeF, [v])) =
    shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int)
      (iA_exp_to_poly (A1_, A2_) (Fun (LeF, [v])))
  | show_IA_exp (A1_, A2_, A3_) (Fun (LeF, v :: vc :: ve :: vf)) =
    shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int)
      (iA_exp_to_poly (A1_, A2_) (Fun (LeF, v :: vc :: ve :: vf)))
  | show_IA_exp (A1_, A2_, A3_) (Fun (SumF vb, va)) =
    shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int)
      (iA_exp_to_poly (A1_, A2_) (Fun (SumF vb, va)))
  | show_IA_exp (A1_, A2_, A3_) (Fun (ConstF vb, va)) =
    shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int)
      (iA_exp_to_poly (A1_, A2_) (Fun (ConstF vb, va)))
  | show_IA_exp (A1_, A2_, A3_) (Fun (ProdF vb, va)) =
    shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int)
      (iA_exp_to_poly (A1_, A2_) (Fun (ProdF vb, va)))
  | show_IA_exp (A1_, A2_, A3_) (Fun (EqF, [])) =
    shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int)
      (iA_exp_to_poly (A1_, A2_) (Fun (EqF, [])))
  | show_IA_exp (A1_, A2_, A3_) (Fun (EqF, [v])) =
    shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int)
      (iA_exp_to_poly (A1_, A2_) (Fun (EqF, [v])))
  | show_IA_exp (A1_, A2_, A3_) (Fun (EqF, v :: vc :: ve :: vf)) =
    shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int)
      (iA_exp_to_poly (A1_, A2_) (Fun (EqF, v :: vc :: ve :: vf)))
  | show_IA_exp (A1_, A2_, A3_) (Fun (v, [])) =
    shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int)
      (iA_exp_to_poly (A1_, A2_) (Fun (v, [])))
  | show_IA_exp (A1_, A2_, A3_) (Fun (v, [vb])) =
    shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int)
      (iA_exp_to_poly (A1_, A2_) (Fun (v, [vb])))
  | show_IA_exp (A1_, A2_, A3_) (Fun (v, vb :: vd :: vf :: vg)) =
    shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int)
      (iA_exp_to_poly (A1_, A2_) (Fun (v, vb :: vd :: vf :: vg)));

fun is_or_and_shape (Disjunction (va :: vc :: ve :: vf)) = false
  | is_or_and_shape (Disjunction (va :: Disjunction ve :: vd)) = false
  | is_or_and_shape
    (Disjunction (va :: Conjunction (vf :: vh :: vj :: vk) :: vd)) = false
  | is_or_and_shape (Disjunction (va :: Conjunction [vf] :: vd)) = false
  | is_or_and_shape (Disjunction (va :: Conjunction [] :: vd)) = false
  | is_or_and_shape (Disjunction (va :: NegAtom ve :: vd)) = false
  | is_or_and_shape (Disjunction (va :: Atom ve :: vd)) = false
  | is_or_and_shape (Disjunction [va]) = false
  | is_or_and_shape (Disjunction []) = false
  | is_or_and_shape (Conjunction v) = false
  | is_or_and_shape (NegAtom v) = false
  | is_or_and_shape (Atom v) = false
  | is_or_and_shape (Disjunction [phi_1, Conjunction [phi_2, phi_3]]) = true;

fun shows_formula shows_atom (Disjunction fs) =
  let
    val a = map (shows_formula shows_atom) fs;
  in
    shows_list_gen id [#"F", #"a", #"l", #"s", #"e"]
      [#"D", #"i", #"s", #"j", #"["] [#",", #" "] [#"]"] a
  end
  | shows_formula shows_atom (Conjunction fs) =
    let
      val a = map (shows_formula shows_atom) fs;
    in
      shows_list_gen id [#"T", #"r", #"u", #"e"] [#"C", #"o", #"n", #"j", #"["]
        [#",", #" "] [#"]"] a
    end
  | shows_formula shows_atom (NegAtom a) =
    shows_prec_list show_char zero_nata [#"!", #" ", #"("] o shows_atom a o
      shows_prec_list show_char zero_nata [#")"]
  | shows_formula shows_atom (Atom a) = shows_atom a;

fun remove_Atom B_ negate_atom (Atom phi) = form_not (negate_atom phi)
  | remove_Atom B_ negate_atom (NegAtom phi) = NegAtom phi
  | remove_Atom B_ negate_atom (Disjunction phi_s) =
    Disjunction (map (remove_Atom B_ negate_atom) phi_s)
  | remove_Atom B_ negate_atom (Conjunction phi_s) =
    Conjunction (map (remove_Atom B_ negate_atom) phi_s);

fun trivial_clause_checker A_ f = let
                                    val Disjunction a = f;
                                  in
                                    trivial_checker A_ a
                                  end;

fun check_valid_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
  negate_atom phi =
  catch_errora
    let
      val Conjunction phi_s = flatten phi;
    in
      catch_errora
        (forallM
          (fn phia =>
            catch_errora
              (check
                (trivial_clause_checker (equal_term A_ (equal_prod B1_ C_))
                  phia)
                [#"t", #"r", #"i", #"v", #"i", #"a", #"l", #" ", #"c", #"l",
                  #"a", #"u", #"s", #"e", #" ", #"c", #"h", #"e", #"c", #"k",
                  #"e", #"r", #" ", #"f", #"a", #"i", #"l", #"e", #"d"])
              (fn _ =>
                let
                  val Conjunction phi_sa =
                    flatten (remove_Atom B2_ negate_atom phia);
                in
                  catch_errora (forallM (logic_checker (default D1_)) phi_sa)
                    (fn x => Inl (snd x))
                end))
          phi_s)
        (fn x => Inl (snd x))
    end
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ", #"v", #"a",
               #"l", #"i", #"d", #"i", #"t", #"y", #" ", #"o", #"f", #" ", #"f",
               #"o", #"r", #"m", #"u", #"l", #"a", #" "] o
             shows_formula shows_atom phi o
             shows_nl o
            x));

fun is_disj_shape uu (Disjunction (va :: vc :: ve :: vf)) = false
  | is_disj_shape uu (Disjunction (va :: Disjunction ve :: vd)) = false
  | is_disj_shape uu
    (Disjunction (va :: Conjunction (vf :: vh :: vj :: vk) :: vd)) = false
  | is_disj_shape uu (Disjunction (va :: Conjunction [vf] :: vd)) = false
  | is_disj_shape uu (Disjunction (va :: Conjunction [] :: vd)) = false
  | is_disj_shape uu (Disjunction (va :: NegAtom ve :: vd)) = false
  | is_disj_shape uu (Disjunction (va :: Atom ve :: vd)) = false
  | is_disj_shape uu (Disjunction [va]) = false
  | is_disj_shape uu (Disjunction (Disjunction vc :: vb)) = false
  | is_disj_shape uu (Disjunction (Conjunction (vd :: vf :: vh :: vi) :: vb)) =
    false
  | is_disj_shape uu (Disjunction (Conjunction [vd] :: vb)) = false
  | is_disj_shape uu (Disjunction (Conjunction [] :: vb)) = false
  | is_disj_shape uu (Disjunction (NegAtom vc :: vb)) = false
  | is_disj_shape uu (Disjunction (Atom vc :: vb)) = false
  | is_disj_shape uu (Disjunction []) = false
  | is_disj_shape uu (Conjunction v) = false
  | is_disj_shape uu (NegAtom v) = false
  | is_disj_shape uu (Atom v) = false
  | is_disj_shape [] uv = false
  | is_disj_shape (hint1 :: hints)
    (Disjunction [Conjunction [phi_1, phi_2], Conjunction [phi_3, phi_4]]) =
    true;

fun is_conj_shape uu (Disjunction v) = false
  | is_conj_shape uu (Conjunction (va :: vc :: ve :: vf)) = false
  | is_conj_shape uu (Conjunction [va]) = false
  | is_conj_shape uu (Conjunction []) = false
  | is_conj_shape uu (NegAtom v) = false
  | is_conj_shape uu (Atom v) = false
  | is_conj_shape (v :: vb :: vd :: ve) uv = false
  | is_conj_shape [v] uv = false
  | is_conj_shape [] uv = false
  | is_conj_shape [hint1, hint2] (Conjunction [phi_1, phi_2]) = true;

fun is_neg_atom_clause (NegAtom a) = false
  | is_neg_atom_clause (Atom a) = false
  | is_neg_atom_clause (Conjunction xs) = false
  | is_neg_atom_clause (Disjunction ls) = list_all is_neg_atom ls;

fun check_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
  negate_atom (LexStrict hints) psi =
  (case psi
    of Atom _ =>
      Inl (shows_prec_list show_char zero_nata
             [#"L", #"e", #"x", #"S", #"t", #"r", #"i", #"c", #"t", #" ", #"h",
               #"i", #"n", #"t", #" ", #"a", #"p", #"p", #"l", #"i", #"e", #"d",
               #" ", #"o", #"n", #" "] o
            shows_formula shows_atom psi)
    | NegAtom _ =>
      Inl (shows_prec_list show_char zero_nata
             [#"L", #"e", #"x", #"S", #"t", #"r", #"i", #"c", #"t", #" ", #"h",
               #"i", #"n", #"t", #" ", #"a", #"p", #"p", #"l", #"i", #"e", #"d",
               #" ", #"o", #"n", #" "] o
            shows_formula shows_atom psi)
    | Conjunction _ =>
      Inl (shows_prec_list show_char zero_nata
             [#"L", #"e", #"x", #"S", #"t", #"r", #"i", #"c", #"t", #" ", #"h",
               #"i", #"n", #"t", #" ", #"a", #"p", #"p", #"l", #"i", #"e", #"d",
               #" ", #"o", #"n", #" "] o
            shows_formula shows_atom psi)
    | Disjunction a =>
      (case a
        of [] =>
          Inl (shows_prec_list show_char zero_nata
                 [#"L", #"e", #"x", #"S", #"t", #"r", #"i", #"c", #"t", #" ",
                   #"h", #"i", #"n", #"t", #" ", #"a", #"p", #"p", #"l", #"i",
                   #"e", #"d", #" ", #"o", #"n", #" "] o
                shows_formula shows_atom psi)
        | aa :: b =>
          check_formula_lex A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
            negate_atom hints aa b))
  | check_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
    negate_atom (LexWeak hints) psi =
    (case psi
      of Atom _ =>
        Inl (shows_prec_list show_char zero_nata
               [#"L", #"e", #"x", #"W", #"e", #"a", #"k", #" ", #"h", #"i",
                 #"n", #"t", #" ", #"a", #"p", #"p", #"l", #"i", #"e", #"d",
                 #" ", #"o", #"n", #" "] o
              shows_formula shows_atom psi)
      | NegAtom _ =>
        Inl (shows_prec_list show_char zero_nata
               [#"L", #"e", #"x", #"W", #"e", #"a", #"k", #" ", #"h", #"i",
                 #"n", #"t", #" ", #"a", #"p", #"p", #"l", #"i", #"e", #"d",
                 #" ", #"o", #"n", #" "] o
              shows_formula shows_atom psi)
      | Conjunction _ =>
        Inl (shows_prec_list show_char zero_nata
               [#"L", #"e", #"x", #"W", #"e", #"a", #"k", #" ", #"h", #"i",
                 #"n", #"t", #" ", #"a", #"p", #"p", #"l", #"i", #"e", #"d",
                 #" ", #"o", #"n", #" "] o
              shows_formula shows_atom psi)
      | Disjunction a =>
        (case a
          of [] =>
            Inl (shows_prec_list show_char zero_nata
                   [#"L", #"e", #"x", #"W", #"e", #"a", #"k", #" ", #"h", #"i",
                     #"n", #"t", #" ", #"a", #"p", #"p", #"l", #"i", #"e", #"d",
                     #" ", #"o", #"n", #" "] o
                  shows_formula shows_atom psi)
          | aa :: b =>
            check_formula_lex_weak A_ (B1_, B2_) C_ (D1_, D2_) shows_atom
              logic_checker negate_atom hints aa b))
  | check_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
    negate_atom (Distribute (n, hints)) phi =
    (case phi
      of Atom _ =>
        Inl (shows_prec_list show_char zero_nata
               [#"D", #"i", #"s", #"t", #"r", #"i", #"b", #"u", #"t", #"e",
                 #" ", #"h", #"i", #"n", #"t", #" ", #"f", #"o", #"r", #" ",
                 #"n", #"o", #"n", #" ", #"D", #"i", #"s", #"j", #"u", #"n",
                 #"c", #"t", #"i", #"o", #"n", #" "] o
              shows_formula shows_atom phi)
      | NegAtom _ =>
        Inl (shows_prec_list show_char zero_nata
               [#"D", #"i", #"s", #"t", #"r", #"i", #"b", #"u", #"t", #"e",
                 #" ", #"h", #"i", #"n", #"t", #" ", #"f", #"o", #"r", #" ",
                 #"n", #"o", #"n", #" ", #"D", #"i", #"s", #"j", #"u", #"n",
                 #"c", #"t", #"i", #"o", #"n", #" "] o
              shows_formula shows_atom phi)
      | Conjunction _ =>
        Inl (shows_prec_list show_char zero_nata
               [#"D", #"i", #"s", #"t", #"r", #"i", #"b", #"u", #"t", #"e",
                 #" ", #"h", #"i", #"n", #"t", #" ", #"f", #"o", #"r", #" ",
                 #"n", #"o", #"n", #" ", #"D", #"i", #"s", #"j", #"u", #"n",
                 #"c", #"t", #"i", #"o", #"n", #" "] o
              shows_formula shows_atom phi)
      | Disjunction phi_s =>
        let
          val l = size_list phi_s;
        in
          bindb (check (less_nat n l)
                  (shows_prec_list show_char zero_nata
                     [#"d", #"i", #"s", #"t", #"r", #"i", #"b", #"u", #"t",
                       #"e", #" ", #"h", #"i", #"n", #"t", #" ", #"a", #"t",
                       #" ", #"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n",
                       #" "] o
                     shows_prec_nat zero_nata n o
                     shows_prec_list show_char zero_nata
                       [#" ", #"w", #"h", #"i", #"l", #"e", #" ", #"g", #"o",
                         #"a", #"l", #" ", #"i", #"s", #" ", #"l", #"e", #"n",
                         #"g", #"t", #"h", #" "] o
                    shows_prec_nat zero_nata l))
            (fn _ =>
              let
                val pre = take n phi_s;
                val post = drop (suc n) phi_s;
              in
                (case nth phi_s n
                  of Atom _ =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"D", #"i", #"s", #"t", #"r", #"i", #"b", #"u",
                             #"t", #"e", #" ", #"h", #"i", #"n", #"t", #" ",
                             #"i", #"n", #":", #" ", #"\n"] o
                           shows_formula shows_atom phi o
                           shows_prec_list show_char zero_nata
                             [#"\n", #" ", #"a", #"t", #" ", #"n", #"o", #"n",
                               #"-", #"C", #"o", #"n", #"j", #"u", #"n", #"c",
                               #"t", #"i", #"o", #"n", #" ", #"p", #"o", #"s",
                               #"i", #"t", #"i", #"o", #"n", #":", #"\n"] o
                          shows_formula shows_atom (nth phi_s n))
                  | NegAtom _ =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"D", #"i", #"s", #"t", #"r", #"i", #"b", #"u",
                             #"t", #"e", #" ", #"h", #"i", #"n", #"t", #" ",
                             #"i", #"n", #":", #" ", #"\n"] o
                           shows_formula shows_atom phi o
                           shows_prec_list show_char zero_nata
                             [#"\n", #" ", #"a", #"t", #" ", #"n", #"o", #"n",
                               #"-", #"C", #"o", #"n", #"j", #"u", #"n", #"c",
                               #"t", #"i", #"o", #"n", #" ", #"p", #"o", #"s",
                               #"i", #"t", #"i", #"o", #"n", #":", #"\n"] o
                          shows_formula shows_atom (nth phi_s n))
                  | Conjunction a =>
                    check_formula_dist A_ (B1_, B2_) C_ (D1_, D2_) shows_atom
                      logic_checker negate_atom hints pre post a
                  | Disjunction _ =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"D", #"i", #"s", #"t", #"r", #"i", #"b", #"u",
                             #"t", #"e", #" ", #"h", #"i", #"n", #"t", #" ",
                             #"i", #"n", #":", #" ", #"\n"] o
                           shows_formula shows_atom phi o
                           shows_prec_list show_char zero_nata
                             [#"\n", #" ", #"a", #"t", #" ", #"n", #"o", #"n",
                               #"-", #"C", #"o", #"n", #"j", #"u", #"n", #"c",
                               #"t", #"i", #"o", #"n", #" ", #"p", #"o", #"s",
                               #"i", #"t", #"i", #"o", #"n", #":", #"\n"] o
                          shows_formula shows_atom (nth phi_s n)))
              end)
        end)
  | check_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
    negate_atom (Erase (n, hint)) phi =
    (case phi
      of Atom _ =>
        Inl (shows_prec_list show_char zero_nata
              [#"E", #"r", #"a", #"s", #"e", #" ", #"h", #"i", #"n", #"t", #" ",
                #"t", #"o", #" ", #"n", #"o", #"n", #"-", #"D", #"i", #"s",
                #"j", #"u", #"n", #"c", #"t", #"i", #"o", #"n"])
      | NegAtom _ =>
        Inl (shows_prec_list show_char zero_nata
              [#"E", #"r", #"a", #"s", #"e", #" ", #"h", #"i", #"n", #"t", #" ",
                #"t", #"o", #" ", #"n", #"o", #"n", #"-", #"D", #"i", #"s",
                #"j", #"u", #"n", #"c", #"t", #"i", #"o", #"n"])
      | Conjunction _ =>
        Inl (shows_prec_list show_char zero_nata
              [#"E", #"r", #"a", #"s", #"e", #" ", #"h", #"i", #"n", #"t", #" ",
                #"t", #"o", #" ", #"n", #"o", #"n", #"-", #"D", #"i", #"s",
                #"j", #"u", #"n", #"c", #"t", #"i", #"o", #"n"])
      | Disjunction phi_s =>
        let
          val l = size_list phi_s;
        in
          bindb (check (less_nat n l)
                  (shows_prec_list show_char zero_nata
                     [#"e", #"r", #"a", #"s", #"e", #" ", #"h", #"i", #"n",
                       #"t", #" ", #"a", #"t", #" ", #"p", #"o", #"s", #"i",
                       #"t", #"i", #"o", #"n", #" "] o
                     shows_prec_nat zero_nata n o
                     shows_prec_list show_char zero_nata
                       [#" ", #"w", #"h", #"i", #"l", #"e", #" ", #"g", #"o",
                         #"a", #"l", #" ", #"i", #"s", #" ", #"l", #"e", #"n",
                         #"g", #"t", #"h", #" "] o
                    shows_prec_nat zero_nata l))
            (fn _ =>
              let
                val pre = take n phi_s;
                val post = drop (suc n) phi_s;
              in
                check_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom
                  logic_checker negate_atom hint
                  (Disjunction (pre @ Disjunction [] :: post))
              end)
        end)
  | check_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
    negate_atom (Base h) phi =
    let
      val psi = remove_Atom B2_ negate_atom (simplify phi);
    in
      bindb (check (is_neg_atom_clause psi)
              (shows_prec_list show_char zero_nata
                 [#"b", #"a", #"s", #"e", #" ", #"h", #"i", #"n", #"t", #" ",
                   #"g", #"i", #"v", #"e", #"n", #" ", #"t", #"o", #" "] o
                shows_formula shows_atom psi))
        (fn _ =>
          catch_errora (logic_checker h psi)
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i",
                       #"n", #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n",
                       #"g", #" "] o
                     shows_formula shows_atom phi o
                     shows_nl o
                    x)))
    end
  | check_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
    negate_atom Default phi =
    check_valid_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
      negate_atom phi
and check_formula_lex A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
  negate_atom hints phi phi_s =
  (if is_conj_shape hints phi
    then let
           val [hint1, hint2] = hints;
           val Conjunction [phi_1, phi_2] = phi;
         in
           bindb (check_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom
                   logic_checker negate_atom hint1
                   (Disjunction (phi_1 :: phi_s)))
             (fn _ =>
               check_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom
                 logic_checker negate_atom hint2 (Disjunction (phi_2 :: phi_s)))
         end
    else (if is_disj_shape hints phi
           then let
                  val hint1 :: hints2 = hints;
                  val Disjunction
                        [Conjunction [phi_1, phi_2], Conjunction [phi_3, phi_4]]
                    = phi;
                in
                  (case hints2
                    of [] =>
                      bindb (check_formula A_ (B1_, B2_) C_ (D1_, D2_)
                              shows_atom logic_checker negate_atom hint1
                              (Disjunction (phi_3 :: phi_s)))
                        (fn _ =>
                          check_formula_lex A_ (B1_, B2_) C_ (D1_, D2_)
                            shows_atom logic_checker negate_atom hints2 phi_4
                            phi_s)
                    | [hint2] =>
                      bindb (check_formula A_ (B1_, B2_) C_ (D1_, D2_)
                              shows_atom logic_checker negate_atom hint1
                              (Disjunction (phi_1 :: phi_s)))
                        (fn _ =>
                          check_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom
                            logic_checker negate_atom hint2
                            (Disjunction (phi_2 :: phi_s)))
                    | _ :: _ :: _ =>
                      bindb (check_formula A_ (B1_, B2_) C_ (D1_, D2_)
                              shows_atom logic_checker negate_atom hint1
                              (Disjunction (phi_3 :: phi_s)))
                        (fn _ =>
                          check_formula_lex A_ (B1_, B2_) C_ (D1_, D2_)
                            shows_atom logic_checker negate_atom hints2 phi_4
                            phi_s))
                end
           else Inl (shows_prec_list show_char zero_nata
                       [#"L", #"e", #"x", #"S", #"t", #"r", #"i", #"c", #"t",
                         #" ", #"h", #"i", #"n", #"t", #" ", #"a", #"p", #"p",
                         #"l", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ",
                         #"e", #"r", #"r", #"o", #"r", #":", #" "] o
                       shows_prec_list show_char zero_nata
                         (show_hint D2_ (LexStrict hints)) o
                       shows_prec_list show_char zero_nata
                         [#"\n", #"a", #"p", #"p", #"l", #"i", #"e", #"d", #" ",
                           #"o", #"n", #" "] o
                      shows_formula shows_atom phi)))
and check_formula_dist A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
  negate_atom [] uv uw (v :: va) =
  Inl (shows_prec_list show_char zero_nata
        [#"L", #"e", #"n", #"g", #"t", #"h", #" ", #"m", #"i", #"s", #"m", #"a",
          #"t", #"c", #"h", #" ", #"i", #"n", #" ", #"D", #"i", #"s", #"t",
          #"r", #"i", #"b", #"u", #"t", #"e", #" ", #"h", #"i", #"n", #"t",
          #"s"])
  | check_formula_dist A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
    negate_atom (v :: va) uv uw [] =
    Inl (shows_prec_list show_char zero_nata
          [#"L", #"e", #"n", #"g", #"t", #"h", #" ", #"m", #"i", #"s", #"m",
            #"a", #"t", #"c", #"h", #" ", #"i", #"n", #" ", #"D", #"i", #"s",
            #"t", #"r", #"i", #"b", #"u", #"t", #"e", #" ", #"h", #"i", #"n",
            #"t", #"s"])
  | check_formula_dist A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
    negate_atom (h :: hs) pre post (phi :: phi_s) =
    bindb (check_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
            negate_atom h (Disjunction (pre @ phi :: post)))
      (fn _ =>
        check_formula_dist A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
          negate_atom hs pre post phi_s)
  | check_formula_dist A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
    negate_atom [] pre post [] = Inr ()
and check_formula_lex_weak A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
  negate_atom (hint :: hints) phi phi_s =
  (if is_or_and_shape phi
    then let
           val Disjunction [_, Conjunction [phi_2, phi_3]] = phi;
         in
           bindb (check_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom
                   logic_checker negate_atom hint
                   (Disjunction (phi_2 :: phi_s)))
             (fn _ =>
               check_formula_lex_weak A_ (B1_, B2_) C_ (D1_, D2_) shows_atom
                 logic_checker negate_atom hints phi_3 phi_s)
         end
    else (case hints
           of [] =>
             check_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
               negate_atom hint (Disjunction (phi :: phi_s))
           | _ :: _ =>
             Inl (shows_prec_list show_char zero_nata
                   [#"L", #"e", #"x", #"W", #"e", #"a", #"k", #" ", #"h", #"i",
                     #"n", #"t", #" ", #"a", #"p", #"p", #"l", #"i", #"c", #"a",
                     #"t", #"i", #"o", #"n", #" ", #"e", #"r", #"r", #"o",
                     #"r"])))
  | check_formula_lex_weak A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
    negate_atom [] phi phi_s =
    check (trivial_formula phi)
      (shows_prec_list show_char zero_nata
         [#"L", #"e", #"x", #"W", #"e", #"a", #"k", #" ", #"b", #"a", #"s",
           #"e", #" ", #"c", #"a", #"s", #"e", #" ", #"e", #"r", #"r", #"o",
           #"r", #":", #" "] o
        shows_formula shows_atom phi);

fun ea (A1_, A2_) alist default_fun =
  curry (fun_of_map_fun (map_of (equal_prod A1_ equal_nat) alist)
          (fn (_, n) => Fun (default_fun n, map Var (upt zero_nata n))));

fun poly_const (A1_, A2_) B_ a =
  (if eq A2_ a (zerob A1_) then [] else [(one_monom B_, a)]);

fun poly_minus (A1_, A2_) (B1_, B2_) f g =
  poly_add (A1_, A2_)
    (B1_, (semiring_0_semiring_1 o semiring_1_semiring_1_cancel o
            semiring_1_cancel_ring_1)
            B2_)
    f (poly_mult (A1_, A2_)
        (B1_, (semiring_0_semiring_1 o semiring_1_semiring_1_cancel o
                semiring_1_cancel_ring_1)
                B2_)
        (poly_const
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_semiring_1_cancel o semiring_1_cancel_ring_1)
             B2_,
            B1_)
          A2_ (uminus
                ((uminus_group_add o group_add_neg_numeral o neg_numeral_ring_1)
                  B2_)
                (onea ((one_numeral o numeral_neg_numeral o neg_numeral_ring_1)
                        B2_))))
        g);

fun iA_exp_to_poly_constraint (A1_, A2_) (Fun (LeF, [a, b])) =
  Poly_Ge
    (poly_minus (A1_, A2_) (equal_int, ring_1_int) (iA_exp_to_poly (A1_, A2_) b)
      (iA_exp_to_poly (A1_, A2_) a))
  | iA_exp_to_poly_constraint (A1_, A2_) (Fun (EqF, [a, b])) =
    Poly_Eq
      (poly_minus (A1_, A2_) (equal_int, ring_1_int)
        (iA_exp_to_poly (A1_, A2_) b) (iA_exp_to_poly (A1_, A2_) a))
  | iA_exp_to_poly_constraint (A1_, A2_) (Fun (LessF, [a, b])) =
    Poly_Ge
      (poly_minus (A1_, A2_) (equal_int, ring_1_int)
        (poly_minus (A1_, A2_) (equal_int, ring_1_int)
          (iA_exp_to_poly (A1_, A2_) b) (iA_exp_to_poly (A1_, A2_) a))
        (one_polya A2_ semiring_1_int));

fun shows_poly_constraint (A1_, A2_, A3_) (Poly_Ge p) =
  shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int) p o
    shows_prec_list show_char zero_nata [#" ", #">", #"=", #" ", #"0"]
  | shows_poly_constraint (A1_, A2_, A3_) (Poly_Eq p) =
    shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int) p o
      shows_prec_list show_char zero_nata [#" ", #"=", #" ", #"0"];

fun translate_atom (Atom e) = e;

fun translate_atoms x = map translate_atom x;

fun translate_conj (Conjunction phi_s) = translate_atoms phi_s;

fun poly_is_negative_constant (A1_, A2_, A3_) f =
  catch_errora
    (bindb
      (check (null (poly_vars_list (A1_, A2_) f))
        (shows_prec_list show_char zero_nata
          [#"p", #"o", #"l", #"y", #"n", #"o", #"m", #"i", #"a", #"l", #" ",
            #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"c", #"o",
            #"n", #"s", #"t", #"a", #"n", #"t"]))
      (fn _ =>
        check (less_int
                (eval_poly A2_ comm_semiring_1_int (fn _ => zero_inta) f)
                zero_inta)
          (shows_prec_list show_char zero_nata
            [#"p", #"o", #"l", #"y", #"n", #"o", #"m", #"i", #"a", #"l", #" ",
              #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"n", #"e",
              #"g", #"a", #"t", #"i", #"v", #"e", #" ", #"c", #"o", #"n", #"s",
              #"t", #"a", #"n", #"t"])))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"t",
               #"h", #"a", #"t", #" "] o
             shows_poly (A1_, A2_, A3_) (one_int, equal_int, show_int) f o
             shows_prec_list show_char zero_nata
               [#" ", #"i", #"s", #" ", #"a", #" ", #"n", #"e", #"g", #"a",
                 #"t", #"i", #"v", #"e", #" ", #"c", #"o", #"n", #"s", #"t",
                 #"a", #"n", #"t"] o
             shows_nl o
            x));

fun vars_poly_constraint_list (A1_, A2_) (Poly_Ge p) =
  poly_vars_list (A1_, A2_) p
  | vars_poly_constraint_list (A1_, A2_) (Poly_Eq p) =
    poly_vars_list (A1_, A2_) p;

val zero_linear_poly : linear_poly = LinearPoly zeroa;

fun monom_list_linearity [] = Onea
  | monom_list_linearity [(x, n)] =
    (if equal_nata n one_nata then Variable x else Non_Linear)
  | monom_list_linearity (v :: vb :: vc) = Non_Linear;

fun monom_linearity A_ xa = monom_list_linearity (rep_monom A_ xa);

fun ipoly_to_linear_poly A_ rho [] = SOME (zero_linear_poly, zero_inta)
  | ipoly_to_linear_poly A_ rho ((mon, c) :: rest) =
    bind (ipoly_to_linear_poly A_ rho rest)
      (fn (p, d) =>
        (case monom_linearity A_ mon of Non_Linear => NONE
          | Onea => SOME (p, plus_inta c d)
          | Variable x =>
            SOME (plus_linear_poly (lp_monom (of_int c) (rho x)) p, d)));

fun to_simplex_constraint A_ rho (Poly_Ge p) =
  (case ipoly_to_linear_poly A_ rho p of NONE => []
    | SOME (q, c) => [GEQ (q, of_int (uminus_inta c))])
  | to_simplex_constraint A_ rho (Poly_Eq p) =
    (case ipoly_to_linear_poly A_ rho p of NONE => []
      | SOME (q, c) => [EQa (q, of_int (uminus_inta c))]);

fun unsat_via_simplex (A1_, A2_, A3_, A4_, A5_) les =
  let
    val vs = remdups A2_ (maps (vars_poly_constraint_list (A2_, A4_)) les);
    val ren_map =
      of_alist (A1_, A2_, A3_) (zip vs (upt zero_nata (size_list vs)));
    val ren_fun =
      (fn v =>
        (case lookupb (A1_, A2_) ren_map v of NONE => zero_nata | SOME n => n));
    val cs = maps (to_simplex_constraint A4_ ren_fun) les;
  in
    is_none (simplex cs)
  end;

fun apply_hint (A1_, A2_) (n :: ns) (Poly_Ge a :: asa) =
  poly_add (A1_, A2_) (equal_int, semiring_0_int)
    (poly_mult (A1_, A2_) (equal_int, semiring_0_int)
      (poly_const (zero_int, equal_int) A2_ (abs_inta n)) a)
    (apply_hint (A1_, A2_) ns asa)
  | apply_hint (A1_, A2_) (n :: ns) (Poly_Eq a :: asa) =
    poly_add (A1_, A2_) (equal_int, semiring_0_int)
      (poly_mult (A1_, A2_) (equal_int, semiring_0_int)
        (poly_const (zero_int, equal_int) A2_ n) a)
      (apply_hint (A1_, A2_) ns asa)
  | apply_hint (A1_, A2_) [] (Poly_Ge a :: asa) =
    poly_add (A1_, A2_) (equal_int, semiring_0_int) a
      (apply_hint (A1_, A2_) [] asa)
  | apply_hint (A1_, A2_) [] (Poly_Eq a :: asa) =
    poly_add (A1_, A2_) (equal_int, semiring_0_int) a
      (apply_hint (A1_, A2_) [] asa)
  | apply_hint (A1_, A2_) uu [] =
    poly_const (zero_int, equal_int) A2_ zero_inta;

fun unsat_checker (A1_, A2_, A3_, A4_, A5_) hints cnjs =
  catch_errora
    (case hints
      of Hints coeffs =>
        or_ok (poly_is_negative_constant (A2_, A4_, A5_)
                (apply_hint (A2_, A4_) (zero_inta :: coeffs) cnjs))
          (poly_is_negative_constant (A2_, A4_, A5_)
            (apply_hint (A2_, A4_) (one_inta :: coeffs) cnjs))
      | Simplex =>
        check (unsat_via_simplex (A1_, A2_, A3_, A4_, A5_) cnjs)
          (shows_prec_list show_char zero_nata
            [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"u",
              #"s", #"e", #" ", #"s", #"i", #"m", #"p", #"l", #"e", #"x", #" ",
              #"a", #"l", #"g", #"o", #"r", #"i", #"t", #"h", #"m", #" ", #"t",
              #"o", #" ", #"p", #"r", #"o", #"v", #"e", #" ", #"u", #"n", #"s",
              #"a", #"t", #"i", #"s", #"f", #"i", #"a", #"b", #"i", #"l", #"i",
              #"t", #"y"]))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"T", #"h", #"e", #" ", #"l", #"i", #"n", #"e", #"a", #"r", #" ",
               #"i", #"n", #"e", #"q", #"u", #"a", #"l", #"i", #"t", #"i", #"e",
               #"s", #"\n", #" ", #" "] o
             shows_sep (shows_poly_constraint (A2_, A4_, A5_))
               (shows_prec_list show_char zero_nata [#"\n", #" ", #" "]) cnjs o
             shows_prec_list show_char zero_nata
               [#"\n", #"c", #"a", #"n", #"n", #"o", #"t", #" ", #"b", #"e",
                 #" ", #"p", #"r", #"o", #"v", #"e", #"d", #" ", #"u", #"n",
                 #"s", #"a", #"t", #"i", #"s", #"f", #"i", #"a", #"b", #"l",
                 #"e", #" ", #"v", #"i", #"a", #" ", #"h", #"i", #"n", #"t",
                 #"s", #"\n", #" ", #" "] o
             shows_prec_hints zero_nata hints o
             shows_nl o
            x));

fun check_clause (A1_, A2_, A3_, A4_, A5_) hints phi =
  let
    val es =
      map (iA_exp_to_poly_constraint (A2_, A4_))
        (translate_conj (form_not phi));
  in
    catch_errora (unsat_checker (A1_, A2_, A3_, A4_, A5_) hints es)
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"C", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                 #"p", #"r", #"o", #"v", #"e", #" ", #"u", #"n", #"s", #"a",
                 #"t", #"i", #"s", #"f", #"i", #"a", #"b", #"i", #"l", #"i",
                 #"t", #"y", #" ", #"o", #"f", #" ", #"I", #"A", #" ", #"c",
                 #"o", #"n", #"j", #"u", #"n", #"c", #"t", #"i", #"o", #"n",
                 #" "] o
               shows_nl o
               shows_list_gen (shows_poly_constraint (A2_, A4_, A5_))
                 [#"F", #"a", #"l", #"s", #"e"] [] [#" ", #"&", #"&", #" "] []
                 es o
               shows_nl o
              x))
  end;

fun evala i (Fun (f, ss)) alpha = i f (map (fn s => evala i s alpha) ss)
  | evala i (Var x) alpha = alpha x;

fun negate A_ (Fun (LessF, [a, b])) = Atom (Fun (LeF, [b, a]))
  | negate A_ (Fun (LeF, [a, b])) = Atom (Fun (LessF, [b, a]))
  | negate A_ (Fun (EqF, [a, b])) =
    Disjunction [Atom (Fun (LessF, [a, b])), Atom (Fun (LessF, [b, a]))]
  | negate A_ (Var v) = Conjunction []
  | negate A_ (Fun (LeF, [])) = Conjunction []
  | negate A_ (Fun (LeF, [v])) = Conjunction []
  | negate A_ (Fun (LeF, v :: vc :: ve :: vf)) = Conjunction []
  | negate A_ (Fun (SumF vb, va)) = Conjunction []
  | negate A_ (Fun (ConstF vb, va)) = Conjunction []
  | negate A_ (Fun (ProdF vb, va)) = Conjunction []
  | negate A_ (Fun (EqF, [])) = Conjunction []
  | negate A_ (Fun (EqF, [v])) = Conjunction []
  | negate A_ (Fun (EqF, v :: vc :: ve :: vf)) = Conjunction []
  | negate A_ (Fun (v, [])) = Conjunction []
  | negate A_ (Fun (v, [vb])) = Conjunction []
  | negate A_ (Fun (v, vb :: vd :: vf :: vg)) = Conjunction [];

fun check_less_eq_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_) alist h s t =
  check_formula equal_sig (B2_, B5_) equal_ty (default_hints, show_hints)
    (show_IA_exp (B2_, B4_, B5_)) (check_clause (B1_, B2_, B3_, B4_, B5_))
    (negate B5_) h
    (le_via_IA
      (evala
        (fn f => fn ss =>
          subst_apply_term
            (ea (A1_, A2_) (simplified_alist A2_ alist) (fn _ => MaxF) f
              (size_list ss))
            (nth ss))
        s Var)
      (evala
        (fn f => fn ss =>
          subst_apply_term
            (ea (A1_, A2_) (simplified_alist A2_ alist) (fn _ => MaxF) f
              (size_list ss))
            (nth ss))
        t Var));

fun less_via_IA s t =
  Conjunction
    (map (fn sa =>
           Disjunction
             (map Atom (map (fn ta => Fun (LessF, [sa, ta])) (to_IA t))))
      (to_IA s));

fun check_less_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_) alist h s t =
  check_formula equal_sig (B2_, B5_) equal_ty (default_hints, show_hints)
    (show_IA_exp (B2_, B4_, B5_)) (check_clause (B1_, B2_, B3_, B4_, B5_))
    (negate B5_) h
    (less_via_IA
      (evala
        (fn f => fn ss =>
          subst_apply_term
            (ea (A1_, A2_) (simplified_alist A2_ alist) (fn _ => MaxF) f
              (size_list ss))
            (nth ss))
        s Var)
      (evala
        (fn f => fn ss =>
          subst_apply_term
            (ea (A1_, A2_) (simplified_alist A2_ alist) (fn _ => MaxF) f
              (size_list ss))
            (nth ss))
        t Var));

fun constant_positions e f n =
  filtera (fn i => not (contains_var_term equal_nat i (e f n)))
    (upt zero_nata n);

fun check_encoding A_ (B1_, B2_) alist =
  catch_errora
    (forallM
      (fn (a, b) =>
        let
          val (f, n) = a;
        in
          (fn t =>
            check (subset (card_UNIV_nat, cenum_nat, ceq_nat, ccompare_nat)
                    (vars_term (B1_, B2_)
                      (finite_UNIV_nat, cenum_nat, ceq_nat,
                        cproper_interval_nat, compare_nat, equal_nat,
                        set_impl_nat)
                      t)
                    (set (ceq_nat, ccompare_nat, set_impl_nat)
                      (upt zero_nata n)))
              (shows_prec_list show_char zero_nata
                 [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t", #"a",
                   #"t", #"i", #"o", #"n", #" ", #"o", #"f", #" "] o
                 shows_prec A_ zero_nata f o
                 shows_prec_list show_char zero_nata
                   [#" ", #"a", #"r", #"i", #"t", #"y", #" "] o
                 shows_prec_nat zero_nata n o
                shows_prec_list show_char zero_nata
                  [#" ", #"h", #"a", #"s", #" ", #"e", #"x", #"t", #"r", #"a",
                    #" ", #"p", #"a", #"r", #"a", #"m", #"e", #"t", #"e",
                    #"r"]))
        end
          b)
      alist)
    (fn x => Inl (snd x));

fun create_max_poly_redtriple (A1_, A2_) (B1_, B2_, B3_, B4_, B5_) alist =
  Redtriple_ext
    (check_encoding A2_ (compare_sig, equal_siga) (simplified_alist A2_ alist),
      (fn (s, t) =>
        check_less_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_) alist
          (default_hinta default_hints) t s),
      (fn (s, t) =>
        check_less_eq_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_) alist
          (default_hinta default_hints) t s),
      (fn (s, t) =>
        check_less_eq_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_) alist
          (default_hinta default_hints) t s),
      (fn (f, n) =>
        minus_set (ceq_nat, ccompare_nat)
          (set (ceq_nat, ccompare_nat, set_impl_nat) (upt zero_nata n))
          (set (ceq_nat, ccompare_nat, set_impl_nat)
            (constant_positions
              (ea (A1_, A2_) (simplified_alist A2_ alist) (fn _ => MaxF)) f
              n))),
      empty_af,
      (fn _ =>
        Inl (shows_prec_list show_char zero_nata
              [#"m", #"o", #"n", #"o", #"t", #"o", #"n", #"i", #"c", #"i", #"t",
                #"y", #" ", #"o", #"f", #" ", #"m", #"a", #"x", #"-", #"p",
                #"o", #"l", #"y", #" ", #"i", #"s", #" ", #"n", #"o", #"t",
                #" ", #"y", #"e", #"t", #" ", #"s", #"u", #"p", #"p", #"o",
                #"r", #"t", #"e", #"d"])),
      shows_prec_list show_char zero_nata
        [#"a", #" ", #"m", #"a", #"x", #" ", #"p", #"o", #"l", #"y", #"n", #"o",
          #"m", #"i", #"a", #"l", #" ", #"i", #"n", #"t", #"e", #"r", #"p",
          #"r", #"e", #"t", #"a", #"t", #"i", #"o", #"n"],
      SOME (map fst (simplified_alist A2_ alist)), no_complexity_check, ());

fun filter_prec_weight_repr pi (prw, w0) =
  let
    val fprw =
      filtera
        (fn (fna, _) => (case pi fna of Collapse _ => false | AFList _ => true))
        prw;
    val mprw =
      map (fn (a, b) =>
            let
              val (f, n) = a;
            in
              (fn aa =>
                ((FPair (f, n),
                   (case pi (f, n) of Collapse _ => zero_nata
                     | AFList ab => size_list ab)),
                  aa))
            end
              b)
        fprw;
  in
    (mprw, w0)
  end;

fun prec_repr_to_status A_ prs =
  let
    val m = ceta_map_of (key_prod A_ key_nat) prs;
  in
    (fn (FPair (f, a), _) => (case m (f, a) of NONE => Lex | SOME aa => snd aa))
  end;

fun prec_repr_to_pr A_ prs =
  let
    val m = ceta_map_of (key_prod A_ key_nat) prs;
  in
    (fn (FPair (f, a), _) =>
      (case m (f, a) of NONE => zero_nata | SOME aa => fst aa))
  end;

fun plus_single_mono
  (Partial_object_ext
    (carrier,
      Monoid_ext
        (mult, one,
          Ring_ext
            (zero, add,
              Ordered_semiring_ext
                (geq, gt, max,
                  Lpoly_order_semiring_ext
                    (plus_single_mono, default, arcpos, checkmono, bound,
                      check_complexity, description, more))))))
  = plus_single_mono;

fun check_complexity
  (Partial_object_ext
    (carrier,
      Monoid_ext
        (mult, one,
          Ring_ext
            (zero, add,
              Ordered_semiring_ext
                (geq, gt, max,
                  Lpoly_order_semiring_ext
                    (plus_single_mono, default, arcpos, checkmono, bound,
                      check_complexity, description, more))))))
  = check_complexity;

fun maxb
  (Partial_object_ext
    (carrier,
      Monoid_ext
        (mult, one,
          Ring_ext (zero, add, Ordered_semiring_ext (geq, gt, max, more)))))
  = max;

fun poly_c_max_inter_bcoeff_strict r f pi =
  foldr (maxb r) (maps (fn fna => snd (pi fna)) f) (zero r);

fun geq
  (Partial_object_ext
    (carrier,
      Monoid_ext
        (mult, one,
          Ring_ext (zero, add, Ordered_semiring_ext (geq, gt, max, more)))))
  = geq;

fun poly_c_max_inter_bcoeff r f pi =
  foldr (maxb r)
    (maps (fn fna => filtera (fn b => not (geq r (one r) b)) (snd (pi fna))) f)
    (zero r);

fun convert_lpoly_complexity A_ r pi cm (Comp_Poly deg) =
  let
    val f =
      (case cm of Derivational_Complexity f => f
        | Runtime_Complexity (c, _) => c);
    val bc = poly_c_max_inter_bcoeff r f pi;
    val bca = poly_c_max_inter_bcoeff_strict r f pi;
  in
    bindb (check (less_nat zero_nata deg orelse eq A_ bca (zero r))
            (shows_prec_list show_char zero_nata
              [#"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t", #" ", #"c", #"o",
                #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y", #" ", #"n",
                #"o", #"t", #" ", #"f", #"u", #"l", #"l", #"y", #" ", #"s",
                #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d", #" ", #"f",
                #"o", #"r", #" ", #"l", #"i", #"n", #"e", #"a", #"r", #" ",
                #"(", #"p", #"o", #"l", #"y", #"/", #"m", #"a", #"t", #"r",
                #"i", #"x", #")", #"-", #"i", #"n", #"t", #"e", #"r", #"p",
                #"r", #"e", #"t", #"a", #"t", #"i", #"o", #"n", #"s"]))
      (fn _ => check_complexity r bc (minus_nata deg one_nata))
  end;

fun check_poly_mono_npsm (A1_, A2_) (C1_, C2_) r f pi =
  bindb (catch_errora
          (forallM
            (fn (a, b) =>
              let
                val (fa, n) = a;
              in
                (fn (c, cs) =>
                  catch_errora
                    (bindb
                      (check
                        (if equal_nata n (suc zero_nata) then eq A1_ c (zero r)
                          else true)
                        (shows_string
                           [#"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t",
                             #" ", #"p", #"a", #"r", #"t", #" "] o
                          (shows_prec A2_ zero_nata c o
                            (shows_string
                               [#" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e",
                                 #" ", #"0", #" "] o
                              shows_nl))))
                      (fn _ =>
                        bindb (check (equal_nata n (size_list cs))
                                (shows_string
                                   [#"t", #"h", #"e", #" ", #"a", #"r", #"i",
                                     #"t", #"y", #" ", #"i", #"s", #" ", #"n",
                                     #"o", #"t", #" ", #"t", #"h", #"e", #" ",
                                     #"s", #"a", #"m", #"e", #" ", #"a", #"s",
                                     #" ", #"t", #"h", #"e", #" ", #"n", #"u",
                                     #"m", #"b", #"e", #"r", #" ", #"o", #"f",
                                     #" ", #"a", #"r", #"g", #"u", #"m", #"e",
                                     #"n", #"t", #"s"] o
                                  shows_nl))
                          (fn _ =>
                            check (less_eq_nat n (suc zero_nata))
                              (shows_string
                                 [#"s", #"y", #"m", #"b", #"o", #"l", #" ",
                                   #"h", #"a", #"s", #" ", #"a", #"r", #"i",
                                   #"t", #"y", #" ", #"l", #"a", #"r", #"g",
                                   #"e", #"r", #" ", #"t", #"h", #"a", #"n",
                                   #" ", #"1"] o
                                shows_nl))))
                    (fn x =>
                      Inl (shows_string
                             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                               #"w", #"i", #"t", #"h", #" ", #"m", #"o", #"n",
                               #"o", #"t", #"o", #"n", #"i", #"c", #"i", #"t",
                               #"y", #" ", #"d", #"u", #"e", #" ", #"t", #"o",
                               #" ", #"i", #"n", #"t", #"e", #"r", #"p", #"r",
                               #"e", #"t", #"a", #"t", #"i", #"o", #"n", #" ",
                               #"o", #"f", #" "] o
                            (shows_prec C2_ zero_nata fa o
                              (shows_string [#"/"] o
                                (shows_prec_nat zero_nata n o
                                  (shows_nl o x)))))))
              end
                b)
            pi)
          (fn x => Inl (snd x)))
    (fn _ =>
      catch_errora (check_subseteq (equal_prod C1_ equal_nat) f (map fst pi))
        (fn x =>
          Inl (shows_string
                 [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"i", #"n",
                   #"t", #"e", #"r", #"p", #"r", #"e", #"t", #"a", #"t", #"i",
                   #"o", #"n", #" ", #"f", #"o", #"r", #" "] o
                (shows_prec_prod C2_ show_nat zero_nata x o shows_nl))));

fun arcpos
  (Partial_object_ext
    (carrier,
      Monoid_ext
        (mult, one,
          Ring_ext
            (zero, add,
              Ordered_semiring_ext
                (geq, gt, max,
                  Lpoly_order_semiring_ext
                    (plus_single_mono, default, arcpos, checkmono, bound,
                      check_complexity, description, more))))))
  = arcpos;

fun carrier (Partial_object_ext (carrier, more)) = carrier;

fun check_lpoly_coeffs (A1_, A2_, A3_) C_ r i =
  catch_errora
    (forallM
      (fn (a, b) =>
        let
          val (f, n) = a;
        in
          (fn (c, cs) =>
            catch_errora
              (bindb
                (check (member (A1_, A2_) c (carrier r))
                  (shows_string
                     [#"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t", #" ",
                       #"p", #"a", #"r", #"t", #" "] o
                    (shows_prec A3_ zero_nata c o
                      (shows_string
                         [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"w",
                           #"e", #"l", #"l", #"-", #"f", #"o", #"r", #"m", #"e",
                           #"d"] o
                        shows_nl))))
                (fn _ =>
                  bindb (check (less_eq_nat (size_list cs) n)
                          (shows_string
                             [#"n", #"u", #"m", #"b", #"e", #"r", #" ", #"o",
                               #"f", #" ", #"c", #"o", #"e", #"f", #"f", #"i",
                               #"c", #"i", #"e", #"n", #"t", #"s", #" ", #"e",
                               #"x", #"c", #"e", #"e", #"d", #"s", #" ", #"a",
                               #"r", #"i", #"t", #"y", #" ", #"o", #"f", #" ",
                               #"s", #"y", #"m", #"b", #"o", #"l", #" "] o
                            shows_prec C_ zero_nata f))
                    (fn _ =>
                      bindb (check (arcpos r c orelse list_ex (arcpos r) cs)
                              (shows_string
                                 [#"c", #"o", #"u", #"l", #"d", #" ", #"n",
                                   #"o", #"t", #" ", #"f", #"i", #"n", #"d",
                                   #" ", #"p", #"o", #"s", #"i", #"t", #"i",
                                   #"v", #"e", #" ", #"e", #"n", #"t", #"r",
                                   #"y", #" ", #"w", #"h", #"i", #"c", #"h",
                                   #" ", #"i", #"s", #" ", #"r", #"e", #"q",
                                   #"u", #"i", #"r", #"e", #"d", #" ", #"f",
                                   #"o", #"r", #" ", #"a", #"r", #"c", #"t",
                                   #"i", #"c", #" ", #"i", #"n", #"t", #"e",
                                   #"r", #"p", #"r", #"e", #"t", #"a", #"t",
                                   #"i", #"o", #"n", #"s"] o
                                shows_nl))
                        (fn _ =>
                          catch_errora
                            (forallM
                              (fn aa =>
                                check (geq r aa (zero r) andalso
member (A1_, A2_) aa (carrier r))
                                  (shows_string
                                     [#"c", #"o", #"e", #"f", #"f", #"i", #"c",
                                       #"i", #"e", #"n", #"t", #" "] o
                                    (shows_prec A3_ zero_nata aa o
                                      (shows_string
 [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o", #"w",
   #"e", #"d"] o
shows_nl))))
                              cs)
                            (fn x => Inl (snd x))))))
              (fn x =>
                Inl (shows_string
                       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w",
                         #"i", #"t", #"h", #" ", #"i", #"n", #"t", #"e", #"r",
                         #"p", #"r", #"e", #"t", #"a", #"t", #"i", #"o", #"n",
                         #" ", #"o", #"f", #" "] o
                      (shows_prec C_ zero_nata f o
                        (shows_string [#"/"] o
                          (shows_prec_nat zero_nata n o (shows_nl o x)))))))
        end
          b)
      i)
    (fn x => Inl (snd x));

fun description
  (Partial_object_ext
    (carrier,
      Monoid_ext
        (mult, one,
          Ring_ext
            (zero, add,
              Ordered_semiring_ext
                (geq, gt, max,
                  Lpoly_order_semiring_ext
                    (plus_single_mono, default, arcpos, checkmono, bound,
                      check_complexity, description, more))))))
  = description;

fun defaulta
  (Partial_object_ext
    (carrier,
      Monoid_ext
        (mult, one,
          Ring_ext
            (zero, add,
              Ordered_semiring_ext
                (geq, gt, max,
                  Lpoly_order_semiring_ext
                    (plus_single_mono, default, arcpos, checkmono, bound,
                      check_complexity, description, more))))))
  = default;

fun to_lpoly_inter C_ r i =
  fun_of_map_fun (ceta_map_of (key_prod C_ key_nat) i)
    (fn fna => (defaulta r, replicate (snd fna) (one r)));

fun show_pvars (A1_, A2_) C_ r [] = []
  | show_pvars (A1_, A2_) C_ r ((x, c) :: vas) =
    (if eq A1_ c (one r) then id else shows_prec A2_ zero_nata c)
      (shows_prec C_ zero_nata x []) ::
      show_pvars (A1_, A2_) C_ r vas;

fun shows_lpoly (A1_, A2_) C_ r (LPoly (c, cs)) =
  (case show_pvars (A1_, A2_) C_ r cs of [] => shows_prec A2_ zero_nata c
    | a :: lista =>
      (if eq A1_ c (zero r) then id
        else shows_prec A2_ zero_nata c o shows_string [#" ", #"+", #" "]) o
        shows_list_gen (shows_prec_list show_char zero_nata) [] []
          [#" ", #"+", #" "] [] (a :: lista));

fun add_var A_ C_ r x a [] = [(x, a)]
  | add_var A_ C_ r x a ((y, b) :: vas) =
    (if eq C_ x y then let
                         val s = add r a b;
                       in
                         (if eq A_ s (zero r) then vas else (x, s) :: vas)
                       end
      else (y, b) :: add_var A_ C_ r x a vas);

fun sum_pvars A_ C_ r [] vbs = vbs
  | sum_pvars A_ C_ r ((x, a) :: vas) vbs =
    (if eq A_ a (zero r) then sum_pvars A_ C_ r vas vbs
      else sum_pvars A_ C_ r vas (add_var A_ C_ r x a vbs));

fun sum_lpolya A_ C_ r (LPoly (a, vas)) (LPoly (b, vbs)) =
  LPoly (add r a b, sum_pvars A_ C_ r vas vbs);

fun mul_pvars A_ r a [] = []
  | mul_pvars A_ r a ((x, b) :: vas) =
    let
      val p = mult r a b;
      val res = mul_pvars A_ r a vas;
    in
      (if eq A_ p (zero r) then res else (x, p) :: res)
    end;

fun mul_lpoly A_ r a (LPoly (b, vas)) =
  LPoly (mult r a b, mul_pvars A_ r a vas);

fun list_prod r [] = one r
  | list_prod r (x :: xs) = mult r x (list_prod r xs);

fun wf_pvars (A1_, A2_, A3_, A4_) r vas =
  less_eq_set (A1_, A2_, A3_) (set (A2_, A3_, A4_) (map snd vas)) (carrier r);

fun wf_lpoly (A1_, A2_, A3_, A4_) r (LPoly (a, vas)) =
  member (A2_, A3_) a (carrier r) andalso wf_pvars (A1_, A2_, A3_, A4_) r vas;

fun pleftI (A1_, A2_, A3_, A4_, A5_) D_ r pi (Var x) =
  LPoly (zero r, [(x, one r)])
  | pleftI (A1_, A2_, A3_, A4_, A5_) D_ r pi (Fun (f, ts)) =
    let
      val (c, asa) = pi (f, size_list ts);
    in
      (case sum_lpolya A4_ D_ r (LPoly (c, []))
              (list_prod
                (Partial_object_ext
                  (collect cenum_l_poly (wf_lpoly (A1_, A2_, A3_, A5_) r),
                    Monoid_ext (sum_lpolya A4_ D_ r, LPoly (zero r, []), ())))
                (map (fn at =>
                       mul_lpoly A4_ r (fst at)
                         (pleftI (A1_, A2_, A3_, A4_, A5_) D_ r pi (snd at)))
                  (zip asa ts)))
        of LPoly (d, []) => LPoly (maxb r (zero r) d, [])
        | LPoly (d, ab :: lista) => LPoly (d, ab :: lista))
    end;

fun create_lpoly_repr (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_) c i =
  let
    val pi = to_lpoly_inter B2_ c i;
  in
    shows_string
      [#"p", #"o", #"l", #"y", #"n", #"o", #"m", #"i", #"a", #"l", #" ", #"i",
        #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t", #"r", #"a", #"t", #"i",
        #"o", #"n", #" ", #"o", #"v", #"e", #"r", #" "] o
      (shows_string (description c) o
        (shows_nl o
          shows_sep
            (fn (f, n) =>
              let
                val t =
                  Fun (f, map Var
                            (fresh_strings_list [#"x", #"_"] one_nata [] n));
              in
                shows_string [#"P", #"o", #"l", #"("] o
                  (shows_prec_term B3_ (show_list show_char) zero_nata t o
                    (shows_string [#")", #" ", #"=", #" "] o
                      shows_lpoly (A4_, A6_) (show_list show_char) c
                        (pleftI (A1_, A2_, A3_, A4_, A5_)
                          (equal_list equal_char) c pi t)))
              end)
            shows_nl (remdups (equal_prod B1_ equal_nat) (map fst i))))
  end;

fun checkmono
  (Partial_object_ext
    (carrier,
      Monoid_ext
        (mult, one,
          Ring_ext
            (zero, add,
              Ordered_semiring_ext
                (geq, gt, max,
                  Lpoly_order_semiring_ext
                    (plus_single_mono, default, arcpos, checkmono, bound,
                      check_complexity, description, more))))))
  = checkmono;

fun check_poly_mono A_ C_ r =
  (fn xs =>
    catch_errora
      (forallM
        (fn (a, b) =>
          let
            val (f, n) = a;
          in
            (fn (c, cs) =>
              catch_errora
                (bindb
                  (check (geq r c (zero r))
                    (shows_string
                       [#"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t", #" ",
                         #"p", #"a", #"r", #"t", #" "] o
                      (shows_prec A_ zero_nata c o
                        (shows_string
                           [#" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e",
                             #" ", #"a", #"t", #" ", #"l", #"e", #"a", #"s",
                             #"t", #" "] o
                          (shows_prec A_ zero_nata (zero r) o shows_nl)))))
                  (fn _ =>
                    bindb (check (less_eq_nat n (size_list cs))
                            (shows_string
                               [#"t", #"h", #"e", #" ", #"l", #"a", #"s", #"t",
                                 #" ", #"a", #"r", #"g", #"u", #"m", #"e", #"n",
                                 #"t", #" ", #"i", #"s", #" ", #"i", #"g", #"n",
                                 #"o", #"r", #"e", #"d"] o
                              shows_nl))
                      (fn _ =>
                        catch_errora
                          (forallM
                            (fn d =>
                              check (checkmono r d)
                                (shows_string
                                   [#"c", #"o", #"e", #"f", #"f", #"i", #"c",
                                     #"i", #"e", #"n", #"t", #" "] o
                                  (shows_prec A_ zero_nata d o
                                    (shows_string
                                       [#" ", #"i", #"s", #" ", #"n", #"o",
 #"t", #" ", #"a", #"l", #"l", #"o", #"w", #"e", #"d"] o
                                      shows_nl))))
                            cs)
                          (fn x => Inl (snd x)))))
                (fn x =>
                  Inl (shows_string
                         [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w",
                           #"i", #"t", #"h", #" ", #"m", #"o", #"n", #"o", #"t",
                           #"o", #"n", #"i", #"c", #"i", #"t", #"y", #" ", #"d",
                           #"u", #"e", #" ", #"t", #"o", #" ", #"i", #"n", #"t",
                           #"e", #"r", #"p", #"r", #"e", #"t", #"a", #"t", #"i",
                           #"o", #"n", #" ", #"o", #"f", #" "] o
                        (shows_prec C_ zero_nata f o
                          (shows_string [#"/"] o
                            (shows_prec_nat zero_nata n o (shows_nl o x)))))))
          end
            b)
        xs)
      (fn x => Inl (snd x)));

fun create_mono_af A_ C_ r i =
  (if plus_single_mono r
    then fun_of_map_funa (ceta_map_of (key_prod C_ key_nat) i)
           (fn (_, n) =>
             set (ceq_nat, ccompare_nat, set_impl_nat) (upt zero_nata n))
           (fn (c, coeffs) =>
             set (ceq_nat, ccompare_nat, set_impl_nat)
               (if geq r c (zero r)
                 then maps (fn (ca, ia) =>
                             (if eq A_ ca (one r) orelse checkmono r ca
                               then [ia] else []))
                        (zip coeffs (upt zero_nata (size_list coeffs)))
                 else []))
    else empty_af);

fun lookup_rest A_ x [] = NONE
  | lookup_rest A_ x ((y, c) :: ycs) =
    (if eq A_ x y then SOME (c, ycs)
      else (case lookup_rest A_ x ycs of NONE => NONE
             | SOME (d, yccs) => SOME (d, (y, c) :: yccs)));

fun check_pvars A_ C_ r rel vas [] =
  catch_errora (forallM (fn va => check (rel (snd va) (zero r)) (fst va)) vas)
    (fn x => Inl (snd x))
  | check_pvars A_ C_ r rel vas ((x, b) :: vbs) =
    let
      val a =
        (case lookup_rest C_ x vas of NONE => (zero r, vas)
          | SOME a => let
                        val (aa, ba) = a;
                      in
                        (aa, ba)
                      end);
      val (aa, vasa) = a;
    in
      bindb (check (rel aa b) x) (fn _ => check_pvars A_ C_ r rel vasa vbs)
    end;

fun check_lpoly_ns (A1_, A2_) (C1_, C2_) r (LPoly (a, vas)) (LPoly (b, vbs)) =
  catch_errora
    (bindb
      (check (geq r a b)
        (shows_string
          [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
            #"n", #" ", #"c", #"o", #"m", #"p", #"a", #"r", #"i", #"n", #"g",
            #" ", #"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t", #" ", #"p",
            #"a", #"r", #"t", #"s"]))
      (fn _ =>
        catch_errora (check_pvars A2_ C1_ r (geq r) vas vbs)
          (fn x =>
            Inl (shows_string
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h",
                     #"e", #"n", #" ", #"c", #"o", #"m", #"p", #"a", #"r", #"i",
                     #"n", #"g", #" ", #"c", #"o", #"e", #"f", #"f", #"i", #"c",
                     #"i", #"e", #"n", #"t", #"s", #" ", #"o", #"f", #" ", #"v",
                     #"a", #"r", #"i", #"a", #"b", #"l", #"e", #" "] o
                  shows_prec C2_ zero_nata x))))
    (fn x =>
      Inl (shows_string
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
               #"n", #" ", #"c", #"o", #"m", #"p", #"a", #"r", #"i", #"n", #"g",
               #" "] o
            (shows_lpoly (A1_, A2_) C2_ r (LPoly (a, vas)) o
              (shows_string [#" ", #">", #"=", #" "] o
                (shows_lpoly (A1_, A2_) C2_ r (LPoly (b, vbs)) o
                  (shows_nl o x))))));

fun prightI (A1_, A2_, A3_, A4_, A5_) D_ r pi (Var x) =
  LPoly (zero r, [(x, one r)])
  | prightI (A1_, A2_, A3_, A4_, A5_) D_ r pi (Fun (f, ts)) =
    let
      val (c, asa) = pi (f, size_list ts);
      val LPoly (d, a) =
        sum_lpolya A4_ D_ r (LPoly (c, []))
          (list_prod
            (Partial_object_ext
              (collect cenum_l_poly (wf_lpoly (A1_, A2_, A3_, A5_) r),
                Monoid_ext (sum_lpolya A4_ D_ r, LPoly (zero r, []), ())))
            (map (fn at =>
                   mul_lpoly A4_ r (fst at)
                     (prightI (A1_, A2_, A3_, A4_, A5_) D_ r pi (snd at)))
              (zip asa ts)));
    in
      LPoly (maxb r (zero r) d, a)
    end;

fun check_polo_ns (A1_, A2_, A3_, A4_, A5_, A6_) C_ (D1_, D2_) r pi (s, t) =
  let
    val left = pleftI (A1_, A2_, A3_, A4_, A5_) D1_ r pi s;
    val right = prightI (A1_, A2_, A3_, A4_, A5_) D1_ r pi t;
  in
    catch_errora (check_lpoly_ns (A4_, A6_) (D1_, D2_) r left right)
      (fn x =>
        Inl (shows_string
               [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                 #"e", #"n", #"s", #"u", #"r", #"e", #" "] o
              (shows_prec_term C_ D2_ zero_nata s o
                (shows_string [#" ", #">", #"=", #" "] o
                  (shows_prec_term C_ D2_ zero_nata t o (shows_nl o x))))))
  end;

fun gt
  (Partial_object_ext
    (carrier,
      Monoid_ext
        (mult, one,
          Ring_ext (zero, add, Ordered_semiring_ext (geq, gt, max, more)))))
  = gt;

fun check_lpoly_s (A1_, A2_) (C1_, C2_) r (LPoly (a, vas)) (LPoly (b, vbs)) =
  catch_errora
    (bindb
      (check (gt r a b)
        (shows_string
          [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
            #"n", #" ", #"c", #"o", #"m", #"p", #"a", #"r", #"i", #"n", #"g",
            #" ", #"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t", #" ", #"p",
            #"a", #"r", #"t"]))
      (fn _ =>
        catch_errora
          (check_pvars A2_ C1_ r (if plus_single_mono r then geq r else gt r)
            vas vbs)
          (fn x =>
            Inl (shows_string
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h",
                     #"e", #"n", #" ", #"c", #"o", #"m", #"p", #"a", #"r", #"i",
                     #"n", #"g", #" ", #"c", #"o", #"e", #"f", #"f", #"i", #"c",
                     #"i", #"e", #"n", #"t", #"s", #" ", #"o", #"f", #" ", #"v",
                     #"a", #"r", #"i", #"a", #"b", #"l", #"e", #" "] o
                  shows_prec C2_ zero_nata x))))
    (fn x =>
      Inl (shows_string
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
               #"n", #" ", #"c", #"o", #"m", #"p", #"a", #"r", #"i", #"n", #"g",
               #" "] o
            (shows_lpoly (A1_, A2_) C2_ r (LPoly (a, vas)) o
              (shows_string [#" ", #">", #" "] o
                (shows_lpoly (A1_, A2_) C2_ r (LPoly (b, vbs)) o
                  (shows_nl o x))))));

fun check_polo_s (A1_, A2_, A3_, A4_, A5_, A6_) C_ (D1_, D2_) r pi (s, t) =
  let
    val left = pleftI (A1_, A2_, A3_, A4_, A5_) D1_ r pi s;
    val right = prightI (A1_, A2_, A3_, A4_, A5_) D1_ r pi t;
  in
    catch_errora (check_lpoly_s (A4_, A6_) (D1_, D2_) r left right)
      (fn x =>
        Inl (shows_string
               [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                 #"e", #"n", #"s", #"u", #"r", #"e", #" "] o
              (shows_prec_term C_ D2_ zero_nata s o
                (shows_string [#" ", #">", #" "] o
                  (shows_prec_term C_ D2_ zero_nata t o (shows_nl o x))))))
  end;

fun create_af A_ C_ r i =
  fun_of_map_funa (ceta_map_of (key_prod C_ key_nat) i)
    (fn (_, n) => set (ceq_nat, ccompare_nat, set_impl_nat) (upt zero_nata n))
    (fn (_, coeffs) =>
      set (ceq_nat, ccompare_nat, set_impl_nat)
        (maps (fn (c, ia) => (if not (eq A_ c (zero r)) then [ia] else []))
          (zip coeffs (upt zero_nata (size_list coeffs)))));

fun create_poly_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_)
  (C1_, C2_) c cI i =
  let
    val pi = to_lpoly_inter B2_ c i;
    val ns = check_polo_ns (A1_, A2_, A3_, A4_, A5_, A6_) B3_ (C1_, C2_) c pi;
  in
    Redtriple_ext
      (bindb cI (fn _ => check_lpoly_coeffs (A2_, A3_, A6_) B3_ c i),
        check_polo_s (A1_, A2_, A3_, A4_, A5_, A6_) B3_ (C1_, C2_) c pi, ns, ns,
        create_af A4_ B2_ c i, create_mono_af A4_ B2_ c i,
        (fn s_ns_nst =>
          (if plus_single_mono c then check_poly_mono A6_ B3_ c i
            else check_poly_mono_npsm (A4_, A6_) (B1_, B3_) c
                   (funas_trs_list s_ns_nst) i)),
        create_lpoly_repr (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_) c i,
        SOME (map fst i),
        (if plus_single_mono c then convert_lpoly_complexity A4_ c pi
          else no_complexity_check),
        ())
  end;

fun weak_gt_arctic_delta A_ uu MinInfty_delta = true
  | weak_gt_arctic_delta A_ MinInfty_delta (Num_arc_delta uv) = false
  | weak_gt_arctic_delta A_ (Num_arc_delta x) (Num_arc_delta y) =
    less ((ord_abs_if o abs_if_linordered_ring o
            linordered_ring_linordered_ring_strict o
            linordered_ring_strict_linordered_idom o
            linordered_idom_linordered_field o
            linordered_field_archimedean_field o
            archimedean_field_floor_ceiling)
           A_)
      y x;

fun check_poly_strict_mono_discrete (A1_, A2_) (B1_, B2_) gt p v =
  check_poly_gt
    ((ordered_semiring_0_ordered_semiring_1 o ordered_semiring_1_poly_carrier)
      A2_)
    (B1_, B2_) gt
    (poly_subst B2_ (B1_, B2_) (A1_, comm_semiring_1_poly_carrier A2_)
      (fn w =>
        poly_of (B1_, B2_) (A1_, comm_semiring_1_poly_carrier A2_)
          (if eq B1_ w v
            then PSum [PNum (onea ((one_numeral o numeral_semiring_numeral o
                                     semiring_numeral_semiring_1 o
                                     semiring_1_comm_semiring_1 o
                                     comm_semiring_1_poly_carrier)
                                    A2_)),
                        PVar v]
            else PVar w))
      p)
    p;

fun univariate_power_list A_ x [(y, n)] = (if eq A_ x y then SOME n else NONE)
  | univariate_power_list A_ uu [] = NONE
  | univariate_power_list A_ uu (v :: vb :: vc) = NONE;

fun univariate_power (A1_, A2_) x xc =
  univariate_power_list A1_ x (rep_monom A2_ xc);

fun check_monom_strict_mono (A1_, A2_) pm m v =
  (case univariate_power (A1_, A2_) v m of NONE => false
    | SOME p => pm orelse equal_nata p one_nata);

fun check_poly_strict_mono (A1_, A2_) B_ pm p v =
  list_ex
    (fn (m, c) =>
      less_eq
        ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
           ordered_ab_semigroup_ordered_semiring_0 o
           ordered_semiring_0_ordered_semiring_1 o
           ordered_semiring_1_poly_carrier)
          B_)
        (onea ((one_numeral o numeral_semiring_numeral o
                 semiring_numeral_semiring_1 o semiring_1_comm_semiring_1 o
                 comm_semiring_1_poly_carrier)
                B_))
        c andalso
        check_monom_strict_mono (A1_, A2_) pm m v)
    p;

fun check_poly_strict_mono_smart (A1_, A2_) (B1_, B2_) discrete pm gt p v =
  (if discrete then check_poly_strict_mono_discrete (A1_, A2_) (B1_, B2_) gt p v
    else check_poly_strict_mono (B1_, B2_) A2_ pm p v);

fun check_poly_weak_mono_all B_ p =
  list_all
    (fn (_, a) =>
      less_eq
        ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
           ordered_ab_semigroup_ordered_semiring_0)
          B_)
        (zerob
          ((zero_mult_zero o mult_zero_semiring_0 o
             semiring_0_ordered_semiring_0a)
            B_))
        a)
    p;

fun check_poly_weak_mono_and_pos (A1_, A2_) (B1_, B2_) discrete p =
  (if discrete
    then list_all (check_poly_weak_mono_discrete (A1_, A2_) (B1_, B2_) p)
           (poly_vars_list (A1_, A2_) p) andalso
           less_eq
             ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
                ordered_ab_semigroup_ordered_semiring_0 o
                ordered_semiring_0_ordered_semiring_1 o
                ordered_semiring_1_poly_carrier)
               B2_)
             (zerob
               ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
                  semiring_1_comm_semiring_1 o comm_semiring_1_poly_carrier)
                 B2_))
             (eval_poly A2_ (comm_semiring_1_poly_carrier B2_)
               (fn _ =>
                 zerob ((zero_mult_zero o mult_zero_semiring_0 o
                          semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                          comm_semiring_1_poly_carrier)
                         B2_))
               p)
    else check_poly_weak_mono_all
           ((ordered_semiring_0_ordered_semiring_1 o
              ordered_semiring_1_poly_carrier)
             B2_)
           p);

fun poly_inter_to_mono_af (A1_, A2_) B_ discrete power_mono gt i =
  fun_of_map_fun
    (ceta_map_of (key_prod B_ key_nat)
      (map (fn (a, b) =>
             let
               val (f, n) = a;
             in
               (fn e =>
                 ((f, n),
                   set (ceq_nat, ccompare_nat, set_impl_nat)
                     (filtera
                       (fn ia =>
                         check_poly_weak_mono_and_pos (equal_nat, linorder_nat)
                           (A1_, A2_) discrete e andalso
                           check_poly_strict_mono_smart (A1_, A2_)
                             (equal_nat, linorder_nat) discrete power_mono gt e
                             ia)
                       (upt zero_nata n))))
             end
               b)
        i))
    (fn fna =>
      set (ceq_nat, ccompare_nat, set_impl_nat) (upt zero_nata (snd fna)));

fun check_poly_inter_list A_ (B1_, B2_) discrete i =
  bindb (check (distinct (equal_prod A_ equal_nat) (map fst i))
          (Inl (shows_prec_list show_char zero_nata
                 [#"s", #"o", #"m", #"e", #" ", #"s", #"y", #"m", #"b", #"o",
                   #"l", #" ", #"h", #"a", #"s", #" ", #"t", #"w", #"o", #" ",
                   #"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t", #"a",
                   #"t", #"i", #"o", #"n", #"s"])))
    (fn _ =>
      catch_errora
        (catch_errora
          (forallM
            (fn x =>
              (if let
                    val (_, a) = x;
                  in
                    check_poly_weak_mono_and_pos (equal_nat, linorder_nat)
                      (B1_, B2_) discrete a
                  end
                then Inr () else Inl x))
            i)
          (fn x => Inl (snd x)))
        (fn x => Inl let
                       val (a, b) = x;
                     in
                       let
                         val (f, _) = a;
                       in
                         (fn p => Inr (f, p))
                       end
                         b
                     end));

fun less_eq_complexity_class x y = less_eq_nat (degree x) (degree y);

fun strongly_linear A_ x p v =
  (if equal_nata x zero_nata then check_ge_v A_ v p
    else let
           val a =
             poly_split (equal_nat, linorder_nat)
               ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
                  semiring_1_comm_semiring_1 o comm_semiring_1_poly_carrier)
                 A_)
               (var_monom linorder_nat (minus_nata x one_nata)) p;
           val (aa, pa) = a;
         in
           less_eq
             ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
                ordered_ab_semigroup_ordered_semiring_0 o
                ordered_semiring_0_ordered_semiring_1 o
                ordered_semiring_1_poly_carrier)
               A_)
             aa (onea ((one_numeral o numeral_semiring_numeral o
                         semiring_numeral_semiring_1 o
                         semiring_1_comm_semiring_1 o
                         comm_semiring_1_poly_carrier)
                        A_)) andalso
             strongly_linear A_ (minus_nata x one_nata) pa v
         end);

fun sl_complexity_sig_check B_ i v f =
  catch_errora
    (forallM (fn (fa, n) => check (strongly_linear B_ n (i (fa, n)) v) (fa, n))
      f)
    (fn x => Inl (snd x));

fun sl_complexity_check A_ B_ v i f =
  let
    val w =
      max_v ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
               semiring_1_comm_semiring_1 o comm_semiring_1_poly_carrier)
               A_,
              (ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
                ordered_ab_semigroup_ordered_semiring_0 o
                ordered_semiring_0_ordered_semiring_1 o
                ordered_semiring_1_poly_carrier)
                A_)
        v i f;
  in
    catch_errora (sl_complexity_sig_check A_ i w f)
      (fn x =>
        Inl let
              val (fa, _) = x;
            in
              shows_string [#"s", #"y", #"m", #"b", #"o", #"l", #" "] o
                (shows_prec B_ zero_nata fa o
                  shows_prec_list show_char zero_nata
                    [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ",
                      #"p", #"o", #"s", #"s", #"e", #"s", #"s", #" ", #"a",
                      #" ", #"s", #"t", #"r", #"o", #"n", #"g", #"l", #"y",
                      #" ", #"l", #"i", #"n", #"e", #"a", #"r", #" ", #"i",
                      #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t", #"a",
                      #"t", #"i", #"o", #"n"])
            end)
  end;

fun nl_complexity_check A_ B_ i (Derivational_Complexity f) cc =
  bindb (sl_complexity_check B_ A_
          (zerob
            ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
               semiring_1_comm_semiring_1 o comm_semiring_1_poly_carrier)
              B_))
          i f)
    (fn _ =>
      check (less_eq_complexity_class (Comp_Poly one_nata) cc)
        (shows_prec_list show_char zero_nata
          [#"c", #"a", #"n", #"n", #"o", #"t", #" ", #"d", #"e", #"d", #"u",
            #"c", #"e", #" ", #"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t",
            #" ", #"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y",
            #" ", #"f", #"o", #"r", #" ", #"d", #"e", #"r", #"i", #"v", #"a",
            #"t", #"i", #"o", #"n", #"a", #"l", #" ", #"c", #"o", #"m", #"p",
            #"l", #"e", #"x", #"i", #"t", #"y"]))
  | nl_complexity_check A_ B_ i (Runtime_Complexity (c, d)) (Comp_Poly deg) =
    bindb (sl_complexity_check B_ A_
            (onea ((one_numeral o numeral_semiring_numeral o
                     semiring_numeral_semiring_1 o semiring_1_comm_semiring_1 o
                     comm_semiring_1_poly_carrier)
                    B_))
            i c)
      (fn _ =>
        catch_errora
          (forallM
            (fn f =>
              check (less_eq_nat (poly_degree linorder_nat (i f)) deg)
                (shows_prec_list show_char zero_nata
                   [#"d", #"e", #"g", #"r", #"e", #"e", #" ", #"o", #"f", #" ",
                     #"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t", #"a",
                     #"t", #"i", #"o", #"n", #" ", #"f", #"o", #"r", #" "] o
                   shows_prec_prod A_ show_nat zero_nata f o
                  shows_prec_list show_char zero_nata
                    [#" ", #"e", #"x", #"c", #"e", #"e", #"d", #"s", #" ", #"b",
                      #"o", #"u", #"n", #"d", #" "]))
            d)
          (fn x => Inl (snd x)));

fun poly_inter_to_af A_ i =
  fun_of_map_fun
    (ceta_map_of (key_prod A_ key_nat)
      (map (fn (fna, e) =>
             (fna, poly_vars (ceq_nat, ccompare_nat, linorder_nat, set_impl_nat)
                     e))
        i))
    (fn fna =>
      set (ceq_nat, ccompare_nat, set_impl_nat) (upt zero_nata (snd fna)));

fun create_nlpoly_redtriple (A1_, A2_, A3_) (B1_, B2_, B3_) (C1_, C2_, C3_) cI
  def gt power_mono discrete i =
  let
    val j = poly_inter_list_to_inter A2_ B2_ def i;
    val x =
      poly_subst linorder_nat
        (equal_list equal_char, linorder_list (equal_char, linorder_char))
        (A1_, comm_semiring_1_poly_carrier A2_)
        (fn n =>
          poly_of
            (equal_list equal_char, linorder_list (equal_char, linorder_char))
            (A1_, comm_semiring_1_poly_carrier A2_)
            (PVar ([#"x", #"_"] @ shows_prec_nat zero_nata n [])));
  in
    Redtriple_ext
      (bindb cI
         (fn _ =>
           catch_errora (check_poly_inter_list B1_ (A1_, A2_) discrete i)
             (fn xa =>
               Inl (case xa of Inl a => id a
                     | Inr (f, p) =>
                       shows_string
                         [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t",
                           #"a", #"t", #"i", #"o", #"n", #" "] o
                         (shows_poly
                            (equal_list equal_char,
                              linorder_list (equal_char, linorder_char),
                              show_list show_char)
                            ((one_numeral o numeral_semiring_numeral o
                               semiring_numeral_semiring_1 o
                               semiring_1_comm_semiring_1 o
                               comm_semiring_1_poly_carrier)
                               A2_,
                              A1_, A3_)
                            (x p) o
                           (shows_string [#" ", #"o", #"f", #" "] o
                             (shows_prec B3_ zero_nata f o
                               shows_string
                                 [#" ", #"i", #"n", #"v", #"a", #"l", #"i",
                                   #"d", #" "])))))),
        check_s (A1_, A2_, A3_) B3_ (C1_, C2_, C3_) gt j,
        check_ns B3_ (A1_, A2_, A3_) (C1_, C2_, C3_) j,
        check_ns B3_ (A1_, A2_, A3_) (C1_, C2_, C3_) j, poly_inter_to_af B2_ i,
        poly_inter_to_mono_af (A1_, A2_) B2_ discrete power_mono gt i,
        (fn _ =>
          catch_errora
            (catch_errora
              (forallM
                (fn xa =>
                  (if let
                        val (a, b) = xa;
                      in
                        let
                          val (_, n) = a;
                        in
                          (fn p =>
                            all_interval_nat
                              (check_poly_strict_mono_smart (A1_, A2_)
                                (equal_nat, linorder_nat) discrete power_mono gt
                                p)
                              zero_nata n)
                        end
                          b
                      end
                    then Inr () else Inl xa))
                i)
              (fn xa => Inl (snd xa)))
            (fn xa =>
              Inl let
                    val (a, b) = xa;
                  in
                    let
                      val (f, _) = a;
                    in
                      (fn p =>
                        shows_string
                          [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                            #" ", #"e", #"n", #"s", #"u", #"r", #"e", #" ",
                            #"m", #"o", #"n", #"o", #"t", #"o", #"n", #"i",
                            #"c", #"t", #"y", #" ", #"o", #"f", #" "] o
                          (shows_poly
                             (equal_list equal_char,
                               linorder_list (equal_char, linorder_char),
                               show_list show_char)
                             ((one_numeral o numeral_semiring_numeral o
                                semiring_numeral_semiring_1 o
                                semiring_1_comm_semiring_1 o
                                comm_semiring_1_poly_carrier)
                                A2_,
                               A1_, A3_)
                             (x p) o
                            (shows_string
                               [#" ", #"a", #"s", #" ", #"i", #"n", #"t", #"e",
                                 #"r", #"p", #"r", #"e", #"t", #"a", #"t", #"i",
                                 #"o", #"n", #" ", #"o", #"f", #" "] o
                              shows_prec B3_ zero_nata f)))
                    end
                      b
                  end)),
        shows_string
          [#"p", #"o", #"l", #"y", #"n", #"o", #"m", #"i", #"a", #"l", #" ",
            #"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t", #"a", #"t",
            #"i", #"o", #"n"] o
          (shows_nl o
            shows_sep
              (fn (a, b) =>
                let
                  val (f, n) = a;
                in
                  (fn p =>
                    shows_string [#"P", #"o", #"l", #"("] o
                      (shows_prec B3_ zero_nata f o
                        (shows_string [#"/"] o
                          (shows_prec_nat zero_nata n o
                            (shows_string [#")", #" ", #"=", #" "] o
                              shows_poly
                                (equal_list equal_char,
                                  linorder_list (equal_char, linorder_char),
                                  show_list show_char)
                                ((one_numeral o numeral_semiring_numeral o
                                   semiring_numeral_semiring_1 o
                                   semiring_1_comm_semiring_1 o
                                   comm_semiring_1_poly_carrier)
                                   A2_,
                                  A1_, A3_)
                                (x p))))))
                end
                  b)
              shows_nl i),
        SOME (map fst i), nl_complexity_check B3_ A2_ j, ())
  end;

fun pos_arctic_delta A_ MinInfty_delta = false
  | pos_arctic_delta A_ (Num_arc_delta n) =
    less_eq
      ((ord_abs_if o abs_if_linordered_ring o
         linordered_ring_linordered_ring_strict o
         linordered_ring_strict_linordered_idom o
         linordered_idom_linordered_field o linordered_field_archimedean_field o
         archimedean_field_floor_ceiling)
        A_)
      (zerob
        ((zero_abs_if o abs_if_linordered_ring o
           linordered_ring_linordered_ring_strict o
           linordered_ring_strict_linordered_idom o
           linordered_idom_linordered_field o
           linordered_field_archimedean_field o archimedean_field_floor_ceiling)
          A_))
      n;

fun class_ordered_semiring (A1_, A2_, A3_, A4_) a gt b =
  class_semiring
    (A1_, A2_,
      (one_numeral o numeral_semiring_numeral o semiring_numeral_semiring_1 o
        semiring_1_ordered_semiring_1)
        A3_,
      (plus_semigroup_add o semigroup_add_numeral o numeral_semiring_numeral o
        semiring_numeral_semiring_1 o semiring_1_ordered_semiring_1)
        A3_,
      (times_power o power_monoid_mult o monoid_mult_semiring_numeral o
        semiring_numeral_semiring_1 o semiring_1_ordered_semiring_1)
        A3_,
      (zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
        semiring_1_ordered_semiring_1)
        A3_,
      A4_)
    a (Ordered_semiring_ext
        ((fn x => fn y =>
           less_eq
             ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
                ordered_ab_semigroup_ordered_semiring_0 o
                ordered_semiring_0_ordered_semiring_1)
               A3_)
             y x),
          gt, max ((ord_non_strict_order o
                     non_strict_order_ordered_ab_semigroup o
                     ordered_ab_semigroup_ordered_semiring_0 o
                     ordered_semiring_0_ordered_semiring_1)
                    A3_),
          b));

fun class_arc_complexity a deg =
  Inl (shows_prec_list show_char zero_nata
        [#"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y", #" ", #"f",
          #"o", #"r", #" ", #"a", #"r", #"c", #"t", #"i", #"c", #" ", #"s",
          #"e", #"m", #"i", #"r", #"i", #"n", #"g", #"s", #" ", #"n", #"o",
          #"t", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d"]);

fun class_arc_lpoly_order (A1_, A2_, A3_, A4_) def apos gtt =
  class_ordered_semiring (A1_, A2_, A3_, A4_) Type gtt
    (Lpoly_order_semiring_ext
      (false, def, apos, (fn _ => false), (fn _ => zero_nata),
        class_arc_complexity,
        [#"p", #"o", #"l", #"y", #"n", #"o", #"m", #"i", #"a", #"l", #" ", #"i",
          #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t", #"a", #"t", #"i",
          #"o", #"n", #" ", #"o", #"v", #"e", #"r", #" ", #"a", #"r", #"c",
          #"t", #"i", #"c", #" ", #"s", #"e", #"m", #"i", #"r", #"i", #"n",
          #"g"],
        ()));

fun mat_max A_ a b =
  mat (dim_row a) (dim_col a)
    (fn ij => max A_ (index_mat a ij) (index_mat b ij));

fun mat_ge A_ a b =
  all_interval_nat
    (fn i =>
      all_interval_nat
        (fn j => less_eq A_ (index_mat b (i, j)) (index_mat a (i, j))) zero_nata
        (dim_col a))
    zero_nata (dim_row a);

fun mat_comp_all r a b =
  all_interval_nat
    (fn i =>
      all_interval_nat (fn j => r (index_mat a (i, j)) (index_mat b (i, j)))
        zero_nata (dim_col a))
    zero_nata (dim_row a);

fun mat_both_ordered_semiring A_ n gt b =
  ring_mat (semiring_1_ordered_semiring_1 A_) Type n
    (Ordered_semiring_ext
      (mat_ge
         ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
            ordered_ab_semigroup_ordered_semiring_0 o
            ordered_semiring_0_ordered_semiring_1)
           A_),
        mat_comp_all gt,
        mat_max
          ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
             ordered_ab_semigroup_ordered_semiring_0 o
             ordered_semiring_0_ordered_semiring_1)
            A_),
        b));

fun mat_default A_ d n =
  mat n n (fn (i, j) => (if equal_nata i j then d else zerob A_));

fun mat_arc_complexity m deg =
  Inl (shows_prec_list show_char zero_nata
        [#"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y", #" ", #"f",
          #"o", #"r", #" ", #"a", #"r", #"c", #"t", #"i", #"c", #" ", #"m",
          #"a", #"t", #"r", #"i", #"c", #"e", #"s", #" ", #"n", #"o", #"t",
          #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d"]);

fun mat_arc_posI ap a = ap (index_mat a (zero_nata, zero_nata));

fun mat_arc_lpoly_order A_ n def apos gtt =
  mat_both_ordered_semiring A_ n gtt
    (Lpoly_order_semiring_ext
      (false,
        mat_default
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_ordered_semiring_1)
            A_)
          def n,
        mat_arc_posI apos, (fn _ => false), (fn _ => zero_nata),
        mat_arc_complexity,
        [#"a", #"r", #"c", #"t", #"i", #"c", #" ", #"m", #"a", #"t", #"r", #"i",
          #"x", #" ", #"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t",
          #"a", #"t", #"i", #"o", #"n"],
        ()));

fun check_arc_dimension n =
  check (less_nat zero_nata n)
    (shows_prec_list show_char zero_nata
      [#"d", #"i", #"m", #"e", #"n", #"s", #"i", #"o", #"n", #" ", #"m", #"u",
        #"s", #"t", #" ", #"b", #"e", #" ", #"a", #"t", #" ", #"l", #"e", #"a",
        #"s", #"t", #" ", #"1"]);

fun class_complexity A_ a deg =
  check (less_eq
          ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
             ordered_ab_semigroup_ordered_semiring_0 o
             ordered_semiring_0_ordered_semiring_1)
            A_)
          a (onea ((one_numeral o numeral_semiring_numeral o
                     semiring_numeral_semiring_1 o
                     semiring_1_ordered_semiring_1)
                    A_)))
    (shows_prec_list show_char zero_nata
      [#"v", #"a", #"l", #"u", #"e", #" ", #"i", #"s", #" ", #"l", #"a", #"r",
        #"g", #"e", #"r", #" ", #"t", #"h", #"a", #"n", #" ", #"1"]);

fun class_lpoly_order (A1_, A2_, A3_, A4_) def mon gtt =
  class_ordered_semiring (A1_, A2_, A3_, A4_) Type gtt
    (Lpoly_order_semiring_ext
      (true, def, (fn _ => true), mon, (fn _ => zero_nata),
        class_complexity A3_,
        [#"p", #"o", #"l", #"y", #"n", #"o", #"m", #"i", #"a", #"l", #" ", #"i",
          #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t", #"a", #"t", #"i",
          #"o", #"n"],
        ()));

fun prec_weight_repr_to_prec_weight_funs (A1_, A2_) prw_w0 =
  let
    val (prw, w0) = prw_w0;
    val prwm = ceta_map_of (key_prod A2_ key_nat) prw;
    val w_fun = fun_of_map_funa prwm (fn _ => suc w0) (fst o snd);
    val p_fun = prec_ext (equal_prod A1_ equal_nat) prwm;
    val scf_fun = fun_of_map_funa prwm (fn _ => NONE) (snd o snd);
    val fs = map fst prw;
    val cs =
      filtera
        (fn fna =>
          equal_nata (snd fna) zero_nata andalso equal_nata (w_fun fna) w0)
        fs;
    val lcs =
      map_filter
        (fn x =>
          (if list_all (fn c => snd (p_fun c x)) cs then SOME (fst x)
            else NONE))
        cs;
  in
    (p_fun, (w_fun, (w0, (lcs, scf_fun))))
  end;

fun scf_repr_to_scf scf fna i =
  (case scf fna of NONE => one_nata | SOME xs => nth xs i);

fun check_scf_entry A_ fna NONE = Inr ()
  | check_scf_entry A_ (f, n) (SOME es) =
    catch_errora
      (bindb
        (check (equal_nata (size_list es) n)
          (shows_prec_list show_char zero_nata
             [#"n", #"r", #" ", #"o", #"f", #" ", #"e", #"n", #"t", #"r", #"i",
               #"e", #"s", #" ", #"s", #"h", #"o", #"u", #"l", #"d", #" ", #"b",
               #"e", #" "] o
            shows_prec_nat zero_nata n))
        (fn _ =>
          check (list_all (less_nat zero_nata) es)
            (shows_prec_list show_char zero_nata
              [#"a", #"l", #"l", #" ", #"e", #"n", #"t", #"r", #"i", #"e", #"s",
                #" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e", #" ", #"n",
                #"o", #"n", #"-", #"z", #"e", #"r", #"o"])))
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"i",
                 #"t", #"h", #" ", #"s", #"u", #"b", #"t", #"e", #"r", #"m",
                 #" ", #"c", #"o", #"e", #"f", #"f", #"i", #"c", #"i", #"e",
                 #"n", #"t", #"s", #" ", #"f", #"o", #"r", #" "] o
              (shows_prec_prod A_ show_nat zero_nata (f, n) o
                (shows_prec_list show_char zero_nata [#":", #" "] o
                  (x o shows_nl)))));

fun prec_weight_repr_to_prec_weight (A1_, A2_, A3_) prw_w0 =
  let
    val (p_fun, (w_fun, (_, (lcs, scf_fun)))) =
      prec_weight_repr_to_prec_weight_funs (A1_, A2_) prw_w0;
    val (prw, w0) = prw_w0;
    val fs = map fst prw;
    val cw_okay =
      catch_errora
        (forallM
          (fn fna =>
            check (if equal_nata (snd fna) zero_nata
                    then less_eq_nat w0 (w_fun fna) else true)
              (shows_prec_list show_char zero_nata
                 [#"w", #"e", #"i", #"g", #"h", #"t", #" ", #"o", #"f", #" ",
                   #"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t", #" "] o
                (shows_prec A3_ zero_nata (fst fna) o
                  shows_prec_list show_char zero_nata
                    [#" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e", #" ", #"a",
                      #"t", #" ", #"l", #"e", #"a", #"s", #"t", #" ", #"w",
                      #"0"])))
          (map fst prw))
        (fn x => Inl (snd x));
    val adm =
      catch_errora
        (forallM
          (fn fna =>
            check (if equal_nata (snd fna) one_nata
                    then (if equal_nata (w_fun fna) zero_nata
                           then list_all (snd o p_fun fna) fs else true)
                    else true)
              (shows_prec_list show_char zero_nata
                 [#"u", #"n", #"a", #"r", #"y", #" ", #"s", #"y", #"m", #"b",
                   #"o", #"l", #" "] o
                (shows_prec A3_ zero_nata (fst fna) o
                  shows_prec_list show_char zero_nata
                    [#" ", #"w", #"i", #"t", #"h", #" ", #"w", #"e", #"i", #"g",
                      #"h", #"t", #" ", #"0", #" ", #"d", #"o", #"e", #"s",
                      #" ", #"n", #"o", #"t", #" ", #"h", #"a", #"v", #"e",
                      #" ", #"m", #"a", #"x", #"i", #"m", #"a", #"l", #" ",
                      #"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n", #"c",
                      #"e"])))
          (map fst prw))
        (fn x => Inl (snd x));
    val scf_ok =
      catch_errora
        (forallM (fn fna => check_scf_entry A3_ fna (scf_fun fna))
          (map fst prw))
        (fn x => Inl (snd x));
    val ok =
      bindb (check (less_nat zero_nata w0)
              (shows_prec_list show_char zero_nata
                [#"w", #"0", #" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e",
                  #" ", #"l", #"a", #"r", #"g", #"e", #"r", #" ", #"t", #"h",
                  #"a", #"n", #" ", #"0"]))
        (fn _ => bindb adm (fn _ => bindb cw_okay (fn _ => scf_ok)));
  in
    (ok, (p_fun, (w_fun, (w0, (lcs, scf_repr_to_scf scf_fun)))))
  end;

fun create_KBO_redtriple A_ (B1_, B2_, B3_) (C1_, C2_) f_to_g pr =
  let
    val (ch, (p, (w, (w0, (lcs, scf))))) =
      prec_weight_repr_to_prec_weight (B1_, B2_, B3_) (f_to_g pr);
    val ns = kbo_nstrict B3_ (C1_, C2_) p w w0 (membera B1_ lcs) scf;
    val s = kbo_strict B3_ (C1_, C2_) p w w0 (membera B1_ lcs) scf;
  in
    Redtriple_ext
      (ch, s, ns, ns, full_af, full_af, (fn _ => Inr ()), shows_kbo_repr A_ pr,
        SOME [], no_complexity_check, ())
  end;

fun check_dimensions n sd c =
  bindb c
    (fn _ =>
      check (less_eq_nat sd n andalso less_nat zero_nata sd)
        (shows_prec_list show_char zero_nata
          [#"s", #"t", #"r", #"i", #"c", #"t", #" ", #"d", #"i", #"m", #"e",
            #"n", #"s", #"i", #"o", #"n", #" ", #"m", #"u", #"s", #"t", #" ",
            #"b", #"e", #" ", #"a", #"t", #" ", #"l", #"e", #"a", #"s", #"t",
            #" ", #"1", #" ", #"a", #"n", #"d", #" ", #"l", #"e", #"s", #"s",
            #" ", #"t", #"h", #"a", #"n", #" ", #"t", #"o", #"t", #"a", #"l",
            #" ", #"d", #"i", #"m", #"e", #"n", #"s", #"i", #"o", #"n"]));

fun fpair_f (FPair (x1, x2)) = x1;

fun check_mono_afs (A1_, A2_) pi =
  check (mono_afs (A1_, A2_) pi)
    (shows_prec_list show_char zero_nata
      [#"a", #"r", #"g", #"u", #"m", #"e", #"n", #"t", #" ", #"f", #"i", #"l",
        #"t", #"e", #"r", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"m",
        #"o", #"n", #"o", #"t", #"o", #"n", #"e"]);

fun shows_afs A_ af =
  foldr (fn (a, b) =>
          let
            val (f, n) = a;
          in
            (fn e =>
              shows_prec_list show_char zero_nata [#"p", #"i", #"("] o
                shows_prec A_ zero_nata f o
                shows_prec_list show_char zero_nata [#"/"] o
                shows_prec_nat zero_nata n o
                shows_prec_list show_char zero_nata [#")", #" ", #"=", #" "] o
                (case e of Collapse i => shows_prec_nat zero_nata (suc i)
                  | AFList ids =>
                    shows_prec_list show_nat zero_nata (map suc ids)) o
                shows_nl)
          end
            b)
    af;

fun afs_to_af A_ pi fna =
  (case afsa pi fna
    of Collapse j =>
      inserta (ceq_nat, ccompare_nat) j
        (set_empty (ceq_nat, ccompare_nat) (of_phantom set_impl_nata))
    | AFList a => set (ceq_nat, ccompare_nat, set_impl_nat) a);

fun afs_check A_ B_ r pi g lr =
  let
    val pl = afs_term pi (fst lr);
    val pr = afs_term pi (snd lr);
  in
    catch_errora (g (pl, pr))
      (fn x =>
        Inl (shows_string
               [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                 #"o", #"r", #"i", #"e", #"n", #"t", #" "] o
              (shows_prec_term A_ B_ zero_nata (fst lr) o
                (shows_string [#" "] o
                  (r o (shows_string [#" "] o
                         (shows_prec_term A_ B_ zero_nata (snd lr) o
                           (shows_nl o
                             (shows_string [#"p", #"i", #"(", #" "] o
                               (shows_prec_term A_ B_ zero_nata (fst lr) o
                                 (shows_string [#" ", #")", #" ", #"=", #" "] o
                                   (shows_prec_term (show_filtered A_) B_
                                      zero_nata pl o
                                     (shows_nl o
                                       (shows_string [#"p", #"i", #"(", #" "] o
 (shows_prec_term A_ B_ zero_nata (snd lr) o
   (shows_string [#" ", #")", #" ", #"=", #" "] o
     (shows_prec_term (show_filtered A_) B_ zero_nata pr o
       (shows_nl o x))))))))))))))))))
  end;

fun af_redtriple (A1_, A2_, A3_, A4_, A5_) B_ pi rp =
  let
    val afso = afs_of (A1_, A2_, A3_, A4_) pi;
    val afs = the afso;
    val af = afs_to_af A3_ afs;
  in
    Redtriple_ext
      (bindb (check (not (is_none afso))
               (shows_prec_list show_char zero_nata
                 [#"i", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"p", #"o",
                   #"s", #"i", #"t", #"i", #"o", #"n", #"s", #" ", #"i", #"n",
                   #" ", #"a", #"r", #"g", #"u", #"m", #"e", #"n", #"t", #" ",
                   #"f", #"i", #"l", #"t", #"e", #"r"]))
         (fn _ => valid rp),
        afs_check A5_ B_ (shows_prec_list show_char zero_nata [#">"]) afs
          (s rp),
        afs_check A5_ B_ (shows_prec_list show_char zero_nata [#">", #"="]) afs
          (ns rp),
        afs_check A5_ B_ (shows_prec_list show_char zero_nata [#">", #"="]) afs
          (nst rp),
        af, empty_af,
        (fn cs =>
          bindb (check_mono_afs (A1_, A2_) afs)
            (fn _ => mono rp (map (afs_rule afs) cs))),
        shows_prec_list show_char zero_nata
          [#"A", #"r", #"g", #"u", #"m", #"e", #"n", #"t", #" ", #"F", #"i",
            #"l", #"t", #"e", #"r", #":", #" "] o
          shows_nl o
          shows_afs A5_ pi o
          shows_nl o
          desc rp,
        map_option (fn fs => map fst pi @ map (fn (f, a) => (fpair_f f, a)) fs)
          (not_ws_ns rp),
        no_complexity_check, ())
  end;

fun pos_arctic MinInfty = false
  | pos_arctic (Num_arc n) = less_eq_int zero_inta n;

fun delta_mono A_ x =
  less_eq
    ((ord_abs_if o abs_if_linordered_ring o
       linordered_ring_linordered_ring_strict o
       linordered_ring_strict_linordered_idom o
       linordered_idom_linordered_field o linordered_field_archimedean_field o
       archimedean_field_floor_ceiling)
      A_)
    (onea ((one_numeral o numeral_neg_numeral o neg_numeral_ring_1 o
             ring_1_ring_char_0 o ring_char_0_field_char_0 o
             field_char_0_linordered_field o
             linordered_field_archimedean_field o
             archimedean_field_floor_ceiling)
            A_))
    x;

fun mat_gt A_ gt sd a b =
  mat_ge A_ a b andalso
    not (all_interval_nat
          (not o
            (fn i =>
              not (all_interval_nat
                    (not o
                      (fn j => gt (index_mat a (i, j)) (index_mat b (i, j))))
                    zero_nata sd)))
          zero_nata sd);

fun mat_ordered_semiring A_ n sd gt b =
  ring_mat (semiring_1_ordered_semiring_1 A_) Type n
    (Ordered_semiring_ext
      (mat_ge
         ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
            ordered_ab_semigroup_ordered_semiring_0 o
            ordered_semiring_0_ordered_semiring_1)
           A_),
        mat_gt
          ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
             ordered_ab_semigroup_ordered_semiring_0 o
             ordered_semiring_0_ordered_semiring_1)
            A_)
          gt sd,
        mat_max
          ((ord_non_strict_order o non_strict_order_ordered_ab_semigroup o
             ordered_ab_semigroup_ordered_semiring_0 o
             ordered_semiring_0_ordered_semiring_1)
            A_),
        b));

val poly_2i : int poly =
  pCons (zero_int, equal_int) (Int_of_integer (4 : IntInf.int))
    (pCons (zero_int, equal_int) zero_inta
      (pCons (zero_int, equal_int) one_inta (zero_polyb zero_int)));

fun root_poly_Im p =
  let
    val fs =
      factors_of_int_poly
        (poly_adda (factorial_ring_gcd_int, equal_int) p
          (poly_uminus (equal_int, ring_1_int) p));
  in
    remdups (equal_poly (zero_int, equal_int))
      (if list_ex
            (fn f =>
              equal_inta
                (case coeffs zero_int f of [] => zero_inta | x :: _ => x)
                zero_inta)
            fs
        then [pCons (zero_int, equal_int) zero_inta
                (pCons (zero_int, equal_int) one_inta (zero_polyb zero_int))]
        else []) @
      maps (fn f =>
             (if not (equal_inta
                       (case coeffs zero_int f of [] => zero_inta | x :: _ => x)
                       zero_inta)
               then [cf_pos_poly
                       (poly_div (factorial_ring_gcd_int, equal_int) f poly_2i)]
               else []))
        fs
  end;

fun remdups_gen eq [] = []
  | remdups_gen eq (x :: xs) =
    (if list_ex (eq x) xs then remdups_gen eq xs else x :: remdups_gen eq xs);

fun pos_imaginary_parts_3 p =
  remdups_gen equal_3
    (filtera (fn x => equal_rata (sgn_3 x) one_rata)
      (maps roots_of_3 (root_poly_Im p)));

fun filter_list_length f p n xs =
  let
    val ys = filtera p xs;
  in
    (if equal_nata (size_list ys) n then ys
      else filter_list_length f p n (map f ys))
  end;

fun times_interval (A1_, A2_) (Interval (lx, ux)) (Interval (ly, uy)) =
  let
    val x1 = times A1_ lx ly;
    val x2 = times A1_ lx uy;
    val x3 = times A1_ ux ly;
    val x4 = times A1_ ux uy;
  in
    Interval
      (min A2_ x1 (min A2_ x2 (min A2_ x3 x4)),
        max A2_ x1 (max A2_ x2 (max A2_ x3 x4)))
  end;

fun minus_interval A_ (Interval (lx, ux)) (Interval (ly, uy)) =
  Interval (minus A_ lx uy, minus A_ ux ly);

fun plus_interval A_ (Interval (lx, ux)) (Interval (ly, uy)) =
  Interval (plus A_ lx ly, plus A_ ux uy);

fun times_complex_interval (Complex_Interval (rx, ix))
  (Complex_Interval (ry, iy)) =
  Complex_Interval
    (minus_interval minus_real (times_interval (times_real, ord_real) rx ry)
       (times_interval (times_real, ord_real) ix iy),
      plus_interval plus_real (times_interval (times_real, ord_real) rx iy)
        (times_interval (times_real, ord_real) ix ry));

fun zero_interval A_ = Interval (zerob A_, zerob A_);

val zero_complex_interval : complex_interval =
  Complex_Interval (zero_interval zero_real, zero_interval zero_real);

fun plus_complex_interval (Complex_Interval (rx, ix))
  (Complex_Interval (ry, iy)) =
  Complex_Interval
    (plus_interval plus_real rx ry, plus_interval plus_real ix iy);

fun to_interval a = Interval (a, a);

fun of_int_complex_interval x =
  Complex_Interval (to_interval (ratreal (of_int x)), zero_interval zero_real);

fun ipoly_complex_interval p x =
  fold_coeffs zero_int
    (fn a => fn b =>
      plus_complex_interval (of_int_complex_interval a)
        (times_complex_interval x b))
    p zero_complex_interval;

fun tighten_bounds_2 (Irrational (n, (p, (l, r)))) =
  let
    val (la, (ra, _)) =
      tighten_poly_bounds p l r
        (sgn_rata
          (fold_coeffs zero_int
            (fn a => fn b => plus_rata (of_int a) (times_rata r b)) p
            zero_rata));
  in
    Irrational (n, (p, (la, ra)))
  end
  | tighten_bounds_2 (Rationala r) = Rationala r;

fun tighten_bounds_3 xa =
  Real_Alg_Invariant (tighten_bounds_2 (rep_real_alg_3 xa));

fun real_of_3 x = Real_of (Real_Alg_Quotient x);

fun pair_to_complex ri = let
                           val (r, i) = ri;
                         in
                           Complex (real_of_3 r, real_of_3 i)
                         end;

fun in_interval A_ y (Interval (lx, ux)) =
  less_eq ((ord_preorder o preorder_order) A_) lx y andalso
    less_eq ((ord_preorder o preorder_order) A_) y ux;

fun in_complex_interval y x =
  let
    val Complex_Interval (r, i) = x;
  in
    in_interval order_real (re y) r andalso in_interval order_real (im y) i
  end;

fun root_poly_Re p =
  let
    val fs =
      coeffs zero_int (poly_adda (factorial_ring_gcd_int, equal_int) p p);
    val k = size_list fs;
  in
    cf_pos_poly
      (poly_of_list (comm_monoid_add_int, equal_int)
        (map (fn (fi, i) =>
               times_inta fi
                 (binary_power monoid_mult_int (Int_of_integer (2 : IntInf.int))
                   i))
          (zip fs (upt zero_nata k))))
  end;

fun real_parts_3 p = roots_of_3 (root_poly_Re p);

fun get_itvl_2 (Irrational (n, (p, (l, r)))) = Interval (ratreal l, ratreal r)
  | get_itvl_2 (Rationala r) = let
                                 val rr = ratreal r;
                               in
                                 Interval (rr, rr)
                               end;

fun get_itvl_3 xa = get_itvl_2 (rep_real_alg_3 xa);

fun roots_of_real_alg x = map Real_Alg_Quotient (roots_of_3 x);

fun real_roots_of_int_poly p = map Real_of (roots_of_real_alg p);

fun divmod_poly_one_main_list (A1_, A2_) q r d n =
  (if equal_nata n zero_nata then (q, r)
    else let
           val a = hda r;
           val qqq =
             cCons ((zero_mult_zero o mult_zero_semiring_0 o
                      semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                      comm_semiring_1_comm_semiring_1_cancel o
                      comm_semiring_1_cancel_comm_ring_1)
                      A2_,
                     A1_)
               a q;
           val rr =
             tla (if eq A1_ a
                       (zerob
                         ((zero_mult_zero o mult_zero_semiring_0 o
                            semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                            comm_semiring_1_comm_semiring_1_cancel o
                            comm_semiring_1_cancel_comm_ring_1)
                           A2_))
                   then r
                   else minus_poly_rev_list
                          ((group_add_neg_numeral o neg_numeral_ring_1 o
                             ring_1_comm_ring_1)
                            A2_)
                          r (map (times
                                   ((times_dvd o dvd_comm_monoid_mult o
                                      comm_monoid_mult_comm_semiring_1 o
                                      comm_semiring_1_comm_semiring_1_cancel o
                                      comm_semiring_1_cancel_comm_ring_1)
                                     A2_)
                                   a)
                              d));
         in
           divmod_poly_one_main_list (A1_, A2_) qqq rr d (minus_nata n one_nata)
         end);

fun div_field_poly_impl (A1_, A2_) f g =
  let
    val cg =
      coeffs
        ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
           semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
           comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
           idom_divide_field)
          A1_)
        g;
  in
    (if null cg
      then zero_polyb
             ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
                semiring_1_comm_semiring_1 o
                comm_semiring_1_comm_semiring_1_cancel o
                comm_semiring_1_cancel_semidom o semidom_idom o
                idom_idom_divide o idom_divide_field)
               A1_)
      else let
             val cf =
               coeffs
                 ((zero_mult_zero o mult_zero_semiring_0 o
                    semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                    comm_semiring_1_comm_semiring_1_cancel o
                    comm_semiring_1_cancel_semidom o semidom_idom o
                    idom_idom_divide o idom_divide_field)
                   A1_)
                 f;
             val ilc =
               inverse ((inverse_division_ring o division_ring_field) A1_)
                 (last cg);
             val ch =
               map (times
                     ((times_dvd o dvd_comm_monoid_mult o
                        comm_monoid_mult_comm_semiring_1 o
                        comm_semiring_1_comm_semiring_1_cancel o
                        comm_semiring_1_cancel_semidom o semidom_idom o
                        idom_idom_divide o idom_divide_field)
                       A1_)
                     ilc)
                 cg;
             val q =
               fst (divmod_poly_one_main_list
                     (A2_, (comm_ring_1_idom o idom_idom_divide o
                             idom_divide_field)
                             A1_)
                     [] (rev cf) (rev ch)
                     (minus_nata (plus_nata one_nata (size_list cf))
                       (size_list cg)));
           in
             poly_of_list
               ((comm_monoid_add_semiring_0 o semiring_0_semiring_1 o
                  semiring_1_comm_semiring_1 o
                  comm_semiring_1_comm_semiring_1_cancel o
                  comm_semiring_1_cancel_semidom o semidom_idom o
                  idom_idom_divide o idom_divide_field)
                  A1_,
                 A2_)
               (map (times
                      ((times_dvd o dvd_comm_monoid_mult o
                         comm_monoid_mult_comm_semiring_1 o
                         comm_semiring_1_comm_semiring_1_cancel o
                         comm_semiring_1_cancel_semidom o semidom_idom o
                         idom_idom_divide o idom_divide_field)
                        A1_)
                      ilc)
                 q)
           end)
  end;

fun complex_roots_of_int_poly3 p =
  let
    val n = degreea zero_int p;
    val rrts = real_roots_of_int_poly p;
    val nr = size_list rrts;
    val crts = map (fn r => Complex (r, zero_reala)) rrts;
  in
    (if equal_nata n nr then crts
      else let
             val nr_crts = minus_nata n nr;
           in
             (if equal_nata nr_crts (nat_of_integer (2 : IntInf.int))
               then let
                      val pp =
                        div_field_poly_impl (field_real, equal_real)
                          (map_poly zero_int (zero_real, equal_real)
                            (of_inta ring_1_real) p)
                          (prod_list
                            (monoid_mult_poly
                              (equal_real, comm_semiring_1_real,
                                semiring_no_zero_divisors_real))
                            (map (fn x =>
                                   pCons (zero_real, equal_real)
                                     (uminus_reala x)
                                     (pCons (zero_real, equal_real) one_reala
                                       (zero_polyb zero_real)))
                              rrts));
                      val cpp =
                        map_poly zero_real (zero_complex, equal_complex)
                          (fn r => Complex (r, zero_reala)) pp;
                    in
                      crts @ croots2 cpp
                    end
               else let
                      val nr_pos_crts =
                        divide_nata nr_crts (nat_of_integer (2 : IntInf.int));
                      val rxs = real_parts_3 p;
                      val ixs = pos_imaginary_parts_3 p;
                      val rts = maps (fn rx => map (fn a => (rx, a)) ixs) rxs;
                      val crtsa =
                        map pair_to_complex
                          (filter_list_length
                            (map_prod tighten_bounds_3 tighten_bounds_3)
                            (fn (r, i) =>
                              in_complex_interval zero_complexa
                                (ipoly_complex_interval p
                                  (Complex_Interval
                                    (get_itvl_3 r, get_itvl_3 i))))
                            nr_pos_crts rts);
                    in
                      crts @ maps (fn x => [x, cnj x]) crtsa
                    end)
           end)
  end;

fun complex_roots_of_int_poly_all p =
  let
    val n = degreea zero_int p;
  in
    (if less_eq_nat (nat_of_integer (3 : IntInf.int)) n
      then complex_roots_of_int_poly3 p
      else (if equal_nata n one_nata
             then [roots1 field_complex
                     (map_poly zero_int (zero_complex, equal_complex)
                       (of_inta ring_1_complex) p)]
             else (if equal_nata n (nat_of_integer (2 : IntInf.int))
                    then croots2
                           (map_poly zero_int (zero_complex, equal_complex)
                             (of_inta ring_1_complex) p)
                    else [])))
  end;

fun complex_roots_of_int_poly p =
  let
    val a =
      (if less_eq_nat (nat_of_integer (3 : IntInf.int)) (degreea zero_int p)
        then factors_of_int_poly p else [p]);
  in
    maps complex_roots_of_int_poly_all a
  end;

fun prim_root_unity_list k =
  (if equal_nata k zero_nata then []
    else (if equal_nata k one_nata then [one_complexa]
           else (if equal_nata k (nat_of_integer (2 : IntInf.int))
                  then [uminus_complexa one_complexa]
                  else (if equal_nata k (nat_of_integer (3 : IntInf.int))
                         then [Complex
                                 (divide_reala (uminus_reala one_reala)
                                    (ratreal
                                      (of_int
(Int_of_integer (2 : IntInf.int)))),
                                   divide_reala
                                     (sqrt (ratreal
     (of_int (Int_of_integer (3 : IntInf.int)))))
                                     (ratreal
                                       (of_int
 (Int_of_integer (2 : IntInf.int))))),
                                Complex
                                  (divide_reala (uminus_reala one_reala)
                                     (ratreal
                                       (of_int
 (Int_of_integer (2 : IntInf.int)))),
                                    divide_reala
                                      (uminus_reala
(sqrt (ratreal (of_int (Int_of_integer (3 : IntInf.int))))))
                                      (ratreal
(of_int (Int_of_integer (2 : IntInf.int)))))]
                         else (if equal_nata k (nat_of_integer (4 : IntInf.int))
                                then [imaginary_unit,
                                       uminus_complexa imaginary_unit]
                                else complex_roots_of_int_poly
                                       (minus_polya
 (ab_group_add_int, equal_int) (monom (zero_int, equal_int) one_inta k)
 (one_polyb comm_semiring_1_int)))))));

fun eliminate_entries_gen minus times v a i j =
  mat (dim_row a) (dim_col a)
    (fn (ia, ja) =>
      (if not (equal_nata ia i)
        then minus (index_mat a (ia, ja)) (times (v ia) (index_mat a (i, ja)))
        else index_mat a (ia, ja)));

fun gauss_jordan_main (A1_, A2_) a b i j =
  let
    val nr = dim_row a;
    val nc = dim_col a;
  in
    (if less_nat i nr andalso less_nat j nc
      then let
             val aij = index_mat a (i, j);
           in
             (if eq A2_ aij
                   (zerob
                     ((zero_mult_zero o mult_zero_semiring_0 o
                        semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                        comm_semiring_1_comm_semiring_1_cancel o
                        comm_semiring_1_cancel_semidom o semidom_idom o
                        idom_idom_divide o idom_divide_field)
                       A1_))
               then (case maps (fn ia =>
                                 (if not (eq A2_ (index_mat a (ia, j))
   (zerob
     ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
        semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
        comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
        idom_divide_field)
       A1_)))
                                   then [ia] else []))
                            (upt (suc i) nr)
                      of [] => gauss_jordan_main (A1_, A2_) a b i (suc j)
                      | ia :: _ =>
                        gauss_jordan_main (A1_, A2_) (mat_swaprows i ia a)
                          (mat_swaprows i ia b) i j)
               else (if eq A2_ aij
                          (onea ((one_numeral o numeral_neg_numeral o
                                   neg_numeral_ring_1 o ring_1_comm_ring_1 o
                                   comm_ring_1_idom o idom_idom_divide o
                                   idom_divide_field)
                                  A1_))
                      then let
                             val v = (fn ia => index_mat a (ia, j));
                           in
                             gauss_jordan_main (A1_, A2_)
                               (eliminate_entries_gen
                                 (minus
                                   ((minus_group_add o group_add_neg_numeral o
                                      neg_numeral_ring_1 o ring_1_comm_ring_1 o
                                      comm_ring_1_idom o idom_idom_divide o
                                      idom_divide_field)
                                     A1_))
                                 (times
                                   ((times_dvd o dvd_comm_monoid_mult o
                                      comm_monoid_mult_comm_semiring_1 o
                                      comm_semiring_1_comm_semiring_1_cancel o
                                      comm_semiring_1_cancel_semidom o
                                      semidom_idom o idom_idom_divide o
                                      idom_divide_field)
                                     A1_))
                                 v a i j)
                               (eliminate_entries_gen
                                 (minus
                                   ((minus_group_add o group_add_neg_numeral o
                                      neg_numeral_ring_1 o ring_1_comm_ring_1 o
                                      comm_ring_1_idom o idom_idom_divide o
                                      idom_divide_field)
                                     A1_))
                                 (times
                                   ((times_dvd o dvd_comm_monoid_mult o
                                      comm_monoid_mult_comm_semiring_1 o
                                      comm_semiring_1_comm_semiring_1_cancel o
                                      comm_semiring_1_cancel_semidom o
                                      semidom_idom o idom_idom_divide o
                                      idom_divide_field)
                                     A1_))
                                 v b i j)
                               (suc i) (suc j)
                           end
                      else let
                             val iaij =
                               inverse
                                 ((inverse_division_ring o division_ring_field)
                                   A1_)
                                 aij;
                             val aa =
                               mat_multrow_gen
                                 (times
                                   ((times_dvd o dvd_comm_monoid_mult o
                                      comm_monoid_mult_comm_semiring_1 o
                                      comm_semiring_1_comm_semiring_1_cancel o
                                      comm_semiring_1_cancel_semidom o
                                      semidom_idom o idom_idom_divide o
                                      idom_divide_field)
                                     A1_))
                                 i iaij a;
                             val ba =
                               mat_multrow_gen
                                 (times
                                   ((times_dvd o dvd_comm_monoid_mult o
                                      comm_monoid_mult_comm_semiring_1 o
                                      comm_semiring_1_comm_semiring_1_cancel o
                                      comm_semiring_1_cancel_semidom o
                                      semidom_idom o idom_idom_divide o
                                      idom_divide_field)
                                     A1_))
                                 i iaij b;
                             val v = (fn ia => index_mat aa (ia, j));
                           in
                             gauss_jordan_main (A1_, A2_)
                               (eliminate_entries_gen
                                 (minus
                                   ((minus_group_add o group_add_neg_numeral o
                                      neg_numeral_ring_1 o ring_1_comm_ring_1 o
                                      comm_ring_1_idom o idom_idom_divide o
                                      idom_divide_field)
                                     A1_))
                                 (times
                                   ((times_dvd o dvd_comm_monoid_mult o
                                      comm_monoid_mult_comm_semiring_1 o
                                      comm_semiring_1_comm_semiring_1_cancel o
                                      comm_semiring_1_cancel_semidom o
                                      semidom_idom o idom_idom_divide o
                                      idom_divide_field)
                                     A1_))
                                 v aa i j)
                               (eliminate_entries_gen
                                 (minus
                                   ((minus_group_add o group_add_neg_numeral o
                                      neg_numeral_ring_1 o ring_1_comm_ring_1 o
                                      comm_ring_1_idom o idom_idom_divide o
                                      idom_divide_field)
                                     A1_))
                                 (times
                                   ((times_dvd o dvd_comm_monoid_mult o
                                      comm_monoid_mult_comm_semiring_1 o
                                      comm_semiring_1_comm_semiring_1_cancel o
                                      comm_semiring_1_cancel_semidom o
                                      semidom_idom o idom_idom_divide o
                                      idom_divide_field)
                                     A1_))
                                 v ba i j)
                               (suc i) (suc j)
                           end))
           end
      else (a, b))
  end;

fun gauss_jordan (A1_, A2_) a b =
  gauss_jordan_main (A1_, A2_) a b zero_nata zero_nata;

fun gauss_jordan_single (A1_, A2_) a =
  fst (gauss_jordan (A1_, A2_) a
        (zero_mat
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_comm_semiring_1 o
             comm_semiring_1_comm_semiring_1_cancel o
             comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
             idom_divide_field)
            A1_)
          (dim_row a) zero_nata));

fun kernel_dim (A1_, A2_) a =
  minus_nata (dim_col a)
    (size_list
      (pivot_positions_gen A2_
        (zerob
          ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
             semiring_1_comm_semiring_1 o
             comm_semiring_1_comm_semiring_1_cancel o
             comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
             idom_divide_field)
            A1_))
        (gauss_jordan_single (A1_, A2_) a)));

fun dim_gen_eigenspace (A1_, A2_) a ev k =
  kernel_dim (A1_, A2_)
    (pow_mat
      ((semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
         comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
         idom_divide_field)
        A1_)
      (char_matrix A1_ a ev) k);

fun compute_set_of_jordan_blocks_order (A1_, A2_) a ev k =
  let
    val asa =
      map (dim_gen_eigenspace (A1_, A2_) a ev) (upt zero_nata (suc (suc k)));
    val aa =
      map (fn ka =>
            (ka, minus_nata
                   (minus_nata
                     (times_nata (nat_of_integer (2 : IntInf.int)) (nth asa ka))
                     (nth asa (minus_nata ka one_nata)))
                   (nth asa (suc ka))))
        (upt one_nata (suc k));
  in
    map_filter
      (fn x =>
        (if let
              val (_, c) = x;
            in
              not (equal_nata c zero_nata)
            end
          then SOME let
                      val (ka, _) = x;
                    in
                      (ka, ev)
                    end
          else NONE))
      aa
  end;

fun check_jordan_block (A1_, A2_, A3_, A4_, A5_) a d x or =
  ball (ceq_nat, ccompare_nat)
    (image (ceq_prod ceq_nat A1_, ccompare_prod ccompare_nat A2_)
      (ceq_nat, ccompare_nat, set_impl_nat) fst
      (set (ceq_prod ceq_nat A1_, ccompare_prod ccompare_nat A2_,
             set_impl_prod set_impl_nat A5_)
        (compute_set_of_jordan_blocks_order (A3_, A4_) a x or)))
    (fn bsize => less_eq_nat bsize (plus_nata d one_nata));

fun decompose_prod_root_unity_main (A1_, A2_) p k =
  (if equal_nata k zero_nata then ([], p)
    else let
           val q =
             root_unity
               (A2_, (comm_ring_1_idom o idom_idom_divide o idom_divide_field)
                       A1_)
               k;
         in
           (if dvd (semidom_modulo_poly (A1_, A2_),
                     equal_poly
                       ((zero_mult_zero o mult_zero_semiring_0 o
                          semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                          comm_semiring_1_comm_semiring_1_cancel o
                          comm_semiring_1_cancel_semidom o semidom_idom o
                          idom_idom_divide o idom_divide_field)
                          A1_,
                         A2_))
                 q p
             then (if is_zero
                        ((zero_mult_zero o mult_zero_semiring_0 o
                           semiring_0_semiring_1 o semiring_1_comm_semiring_1 o
                           comm_semiring_1_comm_semiring_1_cancel o
                           comm_semiring_1_cancel_semidom o semidom_idom o
                           idom_idom_divide o idom_divide_field)
                          A1_)
                        p
                    then ([], zero_polyb
                                ((zero_mult_zero o mult_zero_semiring_0 o
                                   semiring_0_semiring_1 o
                                   semiring_1_comm_semiring_1 o
                                   comm_semiring_1_comm_semiring_1_cancel o
                                   comm_semiring_1_cancel_semidom o
                                   semidom_idom o idom_idom_divide o
                                   idom_divide_field)
                                  A1_))
                    else map_prod (fn a => k :: a) id
                           (decompose_prod_root_unity_main (A1_, A2_)
                             (div_field_poly_impl (A1_, A2_) p q) k))
             else decompose_prod_root_unity_main (A1_, A2_) p
                    (minus_nata k one_nata))
         end);

fun decompose_prod_root_unity (A1_, A2_) p =
  decompose_prod_root_unity_main (A1_, A2_) p
    (degreea
      ((zero_mult_zero o mult_zero_semiring_0 o semiring_0_semiring_1 o
         semiring_1_comm_semiring_1 o comm_semiring_1_comm_semiring_1_cancel o
         comm_semiring_1_cancel_semidom o semidom_idom o idom_idom_divide o
         idom_divide_field)
        A1_)
      p);

fun sturm_squarefree p =
  sturm (div_field_poly_impl (field_real, equal_real) p
          (gcd_polyc (factorial_ring_gcd_real, equal_real) p
            (pderiv
              (equal_real, comm_semiring_1_real, semiring_no_zero_divisors_real)
              p)));

fun poly_inf A_ p =
  sgn ((sgn_sgn_div_norm o sgn_div_norm_real_normed_vector) A_)
    (coeff
      ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add o
         ab_group_add_real_vector o real_vector_real_normed_vector)
        A_)
      p (degreea
          ((zero_monoid_add o monoid_add_group_add o group_add_ab_group_add o
             ab_group_add_real_vector o real_vector_real_normed_vector)
            A_)
          p));

fun sign_changes_inf (A1_, A2_) ps =
  minus_nata
    (size_list
      (remdups_adj A1_
        (filtera
          (fn x =>
            not (eq A1_ x
                  (zerob
                    ((zero_monoid_add o monoid_add_group_add o
                       group_add_ab_group_add o ab_group_add_real_vector o
                       real_vector_real_normed_vector)
                      A2_))))
          (map (poly_inf A2_) ps))))
    one_nata;

fun sign_changes ps x =
  minus_nata
    (size_list
      (remdups_adj equal_real
        (filtera (fn xa => not (equal_reala xa zero_reala))
          (map (fn p => sgn_reala (polya comm_semiring_0_real p x)) ps))))
    one_nata;

fun count_roots_above p a =
  let
    val q =
      pderiv (equal_real, comm_semiring_1_real, semiring_no_zero_divisors_real)
        p;
  in
    (if equal_polya (zero_real, equal_real) p (zero_polyb zero_real)
      then zero_nata
      else (if not (equal_reala (polya comm_semiring_0_real p a)
                     zero_reala) orelse
                 not (equal_reala (polya comm_semiring_0_real q a) zero_reala)
             then let
                    val ps = sturm p;
                  in
                    minus_nata (sign_changes ps a)
                      (sign_changes_inf (equal_real, real_normed_vector_real)
                        ps)
                  end
             else let
                    val ps = sturm_squarefree p;
                  in
                    minus_nata (sign_changes ps a)
                      (sign_changes_inf (equal_real, real_normed_vector_real)
                        ps)
                  end))
  end;

fun of_real A_ r =
  scaleR
    ((scaleR_real_vector o real_vector_real_algebra o
       real_algebra_real_algebra_1)
      A_)
    r (onea ((one_numeral o numeral_neg_numeral o neg_numeral_ring_1 o
               ring_1_ring_char_0 o ring_char_0_real_algebra_1)
              A_));

fun check_matrix_complexity a cp d =
  let
    val ks = fst (decompose_prod_root_unity (field_real, equal_real) cp);
    val n = dim_row a;
    val lks = size_list ks;
    val m = max_list ks;
  in
    equal_nata (count_roots_above cp one_reala) zero_nata andalso
      (if less_nat (plus_nata d one_nata) lks
        then check_jordan_block
               (ceq_real, ccompare_real, field_real, equal_real, set_impl_real)
               a d one_reala lks andalso
               (if less_nat (nat_of_integer (4 : IntInf.int)) n
                 then (if less_eq_nat (nat_of_integer (2 : IntInf.int)) m
                        then let
                               val lks2 =
                                 size_list
                                   (filtera
                                     (dvd (semidom_modulo_nat, equal_nat)
                                       (nat_of_integer (2 : IntInf.int)))
                                     ks);
                             in
                               (if less_nat (plus_nata d one_nata) lks2
                                 then check_jordan_block
(ceq_real, ccompare_real, field_real, equal_real, set_impl_real) a d
(uminus_reala one_reala) lks2
                                 else true)
                             end
                        else true) andalso
                        all_interval_nat
                          (fn k =>
                            let
                              val lksk =
                                size_list
                                  (filtera
                                    (dvd (semidom_modulo_nat, equal_nat) k) ks);
                            in
                              (if less_nat (plus_nata d one_nata) lksk
                                then list_all
                                       (fn x =>
 check_jordan_block
   (ceq_complex, ccompare_complex, field_complex, equal_complex,
     set_impl_complex)
   (map_mat (of_real real_algebra_1_complex) a) d x lksk)
                                       (prim_root_unity_list k)
                                else true)
                            end)
                          (nat_of_integer (3 : IntInf.int))
                          (plus_nata m one_nata)
                 else true)
        else true)
  end;

fun nonneg_mat (A1_, A2_, A3_, A4_) a =
  ball (A1_, A2_) (elements_mat (A1_, A2_, A4_) a)
    (less_eq
      ((ord_abs_if o abs_if_linordered_ring o
         linordered_ring_linordered_ring_strict o
         linordered_ring_strict_linordered_idom)
        A3_)
      (zerob
        ((zero_abs_if o abs_if_linordered_ring o
           linordered_ring_linordered_ring_strict o
           linordered_ring_strict_linordered_idom)
          A3_)));

fun complexity_via_perron_frobenius d cp a =
  nonneg_mat (ceq_real, ccompare_real, linordered_idom_real, set_impl_real)
    a andalso
    check_matrix_complexity a cp (minus_nata d one_nata);

fun count_ones_check diag d =
  list_all
    (fn a =>
      let
        val aa = abs_reala a;
      in
        less_eq_real aa one_reala andalso
          (if equal_reala aa one_reala
            then less_eq_nat (size_list (filtera (equal_reala a) diag)) d
            else true)
      end)
    diag;

fun combined_growth_check_real_mat d a =
  catch_errora
    (if upper_triangular (zero_real, equal_real) a andalso
          count_ones_check (diag_mat a) d
      then Inr ()
      else (if complexity_via_perron_frobenius d
                 (char_poly (equal_real, idom_divide_real) a) a
             then Inr ()
             else Inl (if nonneg_mat
                            (ceq_real, ccompare_real, linordered_idom_real,
                              set_impl_real)
                            a
                        then shows_prec_list show_char zero_nata
                               [#"m", #"a", #"t", #"r", #"i", #"x", #" ", #"d",
                                 #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ",
                                 #"h", #"a", #"v", #"e", #" ", #"i", #"n", #"t",
                                 #"e", #"n", #"d", #"e", #"d", #" ", #"g", #"r",
                                 #"o", #"w", #"t", #"h", #" ", #"r", #"a", #"t",
                                 #"e"]
                        else shows_prec_list show_char zero_nata
                               [#"o", #"n", #"l", #"y", #" ", #"n", #"o", #"n",
                                 #"-", #"n", #"e", #"g", #"a", #"t", #"i", #"v",
                                 #"e", #" ", #"m", #"a", #"t", #"r", #"i", #"c",
                                 #"e", #"s", #" ", #"s", #"u", #"p", #"p", #"o",
                                 #"r", #"t", #"e", #"d"])))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"d",
               #"e", #"d", #"u", #"c", #"e", #" ", #"t", #"h", #"a", #"t",
               #" "] o
             shows_prec_mat show_real zero_nata a o
             shows_prec_list show_char zero_nata
               [#" ", #"i", #"n", #" ", #"O", #"(", #"n", #"^"] o
             shows_prec_nat zero_nata (minus_nata d one_nata) o
             shows_prec_list show_char zero_nata [#")", #"\n"] o
            x));

fun mat_estimate_complexity_jb A_ d a =
  let
    val b =
      map_mat (real_of (real_embedding_large_real_ordered_semiring_1 A_)) a;
  in
    bindb (check (equal_nata (dim_row a) (dim_col a))
            (shows_prec_list show_char zero_nata
               [#"e", #"x", #"p", #"e", #"c", #"t", #"e", #"d", #" ", #"s",
                 #"q", #"u", #"a", #"r", #"e", #" ", #"m", #"a", #"t", #"r",
                 #"i", #"x", #" ", #"b", #"u", #"t", #" ", #"g", #"o", #"t",
                 #" ", #"\n"] o
              shows_prec_mat show_real zero_nata b))
      (fn _ => combined_growth_check_real_mat d b)
  end;

fun mat_complexity A_ n m d = mat_estimate_complexity_jb A_ (suc d) m;

fun mat_mono mon sd a =
  all_interval_nat
    (fn j =>
      not (all_interval_nat (not o (fn i => mon (index_mat a (i, j)))) zero_nata
            sd))
    zero_nata sd;

fun mat_lpoly_order A_ n sd def mon gtt =
  mat_ordered_semiring
    ((ordered_semiring_1_poly_carrier o poly_carrier_large_ordered_semiring_1 o
       large_ordered_semiring_1_large_real_ordered_semiring_1)
      A_)
    n sd gtt
    (Lpoly_order_semiring_ext
      (true,
        mat_default
          ((zero_abs_if o abs_if_linordered_ring o
             linordered_ring_linordered_ring_strict o
             linordered_ring_strict_linordered_idom o
             linordered_idom_real_embedding o
             real_embedding_large_real_ordered_semiring_1)
            A_)
          def n,
        (fn _ => true), mat_mono mon sd, (fn _ => zero_nata),
        mat_complexity A_ n,
        [#"m", #"a", #"t", #"r", #"i", #"x", #" ", #"i", #"n", #"t", #"e", #"r",
          #"p", #"r", #"e", #"t", #"a", #"t", #"i", #"o", #"n"],
        ()));

fun int_mono x = less_eq_int one_inta x;

fun delta_gt A_ delta =
  (fn x => fn y =>
    less_eq
      ((ord_abs_if o abs_if_linordered_ring o
         linordered_ring_linordered_ring_strict o
         linordered_ring_strict_linordered_idom o
         linordered_idom_linordered_field o linordered_field_archimedean_field o
         archimedean_field_floor_ceiling)
        A_)
      delta
      (minus
        ((minus_abs_if o abs_if_linordered_ring o
           linordered_ring_linordered_ring_strict o
           linordered_ring_strict_linordered_idom o
           linordered_idom_linordered_field o
           linordered_field_archimedean_field o archimedean_field_floor_ceiling)
          A_)
        x y));

fun check_def_pos (A1_, A2_) d =
  check (less A2_ (zerob A1_) d)
    (shows_prec_list show_char zero_nata
      [#"d", #"e", #"f", #"a", #"u", #"l", #"t", #" ", #"v", #"a", #"l", #"u",
        #"e", #" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e", #" ", #"p", #"o",
        #"s", #"i", #"t", #"i", #"v", #"e"]);

fun rpo_nstrict_unbounded (A1_, A2_) (B1_, B2_) pr c =
  (fn (s, t) =>
    check (snd (rpo_unbounded A1_ B1_ pr c s t))
      (shows_string
         [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"o",
           #"r", #"i", #"e", #"n", #"t", #" "] o
        (shows_prec_term A2_ B2_ zero_nata s o
          (shows_string [#" ", #">", #"=", #"R", #"P", #"O", #" "] o
            (shows_prec_term A2_ B2_ zero_nata t o shows_nl)))));

fun rpo_strict_unbounded (A1_, A2_) (B1_, B2_) pr c =
  (fn (s, t) =>
    check (fst (rpo_unbounded A1_ B1_ pr c s t))
      (shows_string
         [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"o",
           #"r", #"i", #"e", #"n", #"t", #" "] o
        (shows_prec_term A2_ B2_ zero_nata s o
          (shows_string [#" ", #">", #"R", #"P", #"O", #" "] o
            (shows_prec_term A2_ B2_ zero_nata t o shows_nl)))));

fun create_RPO_redtriple A_ (B1_, B2_) (C1_, C2_) prec_repr_to_pr pr =
  let
    val (p, tau) = prec_repr_to_pr pr;
    val ns =
      rpo_nstrict_unbounded (B1_, B2_) (C1_, C2_) (prc_nat p, prl_nat p) tau;
  in
    Redtriple_ext
      (Inr (),
        rpo_strict_unbounded (B1_, B2_) (C1_, C2_) (prc_nat p, prl_nat p) tau,
        ns, ns, full_af, full_af, (fn _ => Inr ()), shows_rpo_repr A_ pr,
        SOME [], no_complexity_check, ())
  end;

fun get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (Int_carrier i) =
  create_poly_redtriple
    (cenum_int, ceq_int, ccompare_int, equal_int, set_impl_int, show_int)
    (A3_, A4_, A6_) (equal_list equal_char, show_list show_char)
    (class_lpoly_order
      (ceq_int, ccompare_int, ordered_semiring_1_int, set_impl_int) one_inta
      int_mono (fn x => fn y => less_int y x))
    (Inr ()) i
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (Int_nl_carrier i) =
    create_nlpoly_redtriple (equal_int, poly_carrier_int, show_int)
      (A3_, A4_, A6_)
      (equal_list equal_char, linorder_list (equal_char, linorder_char),
        show_list show_char)
      (Inr ()) one_inta (fn x => fn y => less_int y x) true true i
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (Rat_carrier i) =
    create_poly_redtriple
      (cenum_rat, ceq_rat, ccompare_rat, equal_rat, set_impl_rat, show_rat)
      (A3_, A4_, A6_) (equal_list equal_char, show_list show_char)
      (class_lpoly_order
        (ceq_rat, ccompare_rat, ordered_semiring_1_rat, set_impl_rat) one_rata
        (delta_mono floor_ceiling_rat) (fn x => fn y => less_rat y x))
      (check_def_pos (zero_rat, ord_rat) one_rata) i
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (Rat_nl_carrier (d, i)) =
    create_nlpoly_redtriple (equal_rat, poly_carrier_rat, show_rat)
      (A3_, A4_, A6_)
      (equal_list equal_char, linorder_list (equal_char, linorder_char),
        show_list show_char)
      (check_def_pos (zero_rat, ord_rat) d) d (delta_gt floor_ceiling_rat d)
      (less_eq_rat one_rata d) false i
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (Real_carrier i) =
    create_poly_redtriple
      (cenum_real, ceq_real, ccompare_real, equal_real, set_impl_real,
        show_real)
      (A3_, A4_, A6_) (equal_list equal_char, show_list show_char)
      (class_lpoly_order
        (ceq_real, ccompare_real, ordered_semiring_1_real, set_impl_real)
        one_reala (delta_mono floor_ceiling_real)
        (fn x => fn y => less_real y x))
      (check_def_pos (zero_real, ord_real) one_reala) i
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (Real_nl_carrier (d, i)) =
    create_nlpoly_redtriple (equal_real, poly_carrier_real, show_real)
      (A3_, A4_, A6_)
      (equal_list equal_char, linorder_list (equal_char, linorder_char),
        show_list show_char)
      (check_def_pos (zero_real, ord_real) d) d (delta_gt floor_ceiling_real d)
      (less_eq_real one_reala d) false i
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (Arctic_carrier i) =
    create_poly_redtriple
      (cenum_arctic, ceq_arctic, ccompare_arctic, equal_arctic, set_impl_arctic,
        show_arctic)
      (A3_, A4_, A6_) (equal_list equal_char, show_list show_char)
      (class_arc_lpoly_order
        (ceq_arctic, ccompare_arctic, ordered_semiring_1_arctic,
          set_impl_arctic)
        one_arctica pos_arctic (fn x => fn y => less_arctic y x))
      (Inr ()) i
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (Arctic_rat_carrier i) =
    create_poly_redtriple
      (cenum_arctic_delta, ceq_arctic_delta equal_rat,
        ccompare_arctic_delta compare_rat, equal_arctic_delta equal_rat,
        set_impl_arctic_delta, show_arctic_delta show_rat)
      (A3_, A4_, A6_) (equal_list equal_char, show_list show_char)
      (class_arc_lpoly_order
        (ceq_arctic_delta equal_rat, ccompare_arctic_delta compare_rat,
          ordered_semiring_1_arctic_delta linordered_field_rat,
          set_impl_arctic_delta)
        (one_arctic_deltaa linordered_field_rat)
        (pos_arctic_delta floor_ceiling_rat)
        (weak_gt_arctic_delta floor_ceiling_rat))
      (Inr ()) i
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (Int_mat_carrier (n, sd, i)) =
    create_poly_redtriple
      (cenum_mat, ceq_mat equal_int, ccompare_mat, equal_mat equal_int,
        set_impl_mat, show_mat show_int)
      (A3_, A4_, A6_) (equal_list equal_char, show_list show_char)
      (mat_lpoly_order large_real_ordered_semiring_1_int n sd one_inta int_mono
        (fn x => fn y => less_int y x))
      (check_dimensions n sd (Inr ())) i
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (Rat_mat_carrier (n, sd, i)) =
    create_poly_redtriple
      (cenum_mat, ceq_mat equal_rat, ccompare_mat, equal_mat equal_rat,
        set_impl_mat, show_mat show_rat)
      (A3_, A4_, A6_) (equal_list equal_char, show_list show_char)
      (mat_lpoly_order large_real_ordered_semiring_1_rat n sd one_rata
        (delta_mono floor_ceiling_rat) (fn x => fn y => less_rat y x))
      (check_dimensions n sd (check_def_pos (zero_rat, ord_rat) one_rata)) i
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (Real_mat_carrier (n, sd, i)) =
    create_poly_redtriple
      (cenum_mat, ceq_mat equal_real, ccompare_mat, equal_mat equal_real,
        set_impl_mat, show_mat show_real)
      (A3_, A4_, A6_) (equal_list equal_char, show_list show_char)
      (mat_lpoly_order large_real_ordered_semiring_1_real n sd one_reala
        (delta_mono floor_ceiling_real) (fn x => fn y => less_real y x))
      (check_dimensions n sd (check_def_pos (zero_real, ord_real) one_reala)) i
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (Arctic_mat_carrier (n, i)) =
    create_poly_redtriple
      (cenum_mat, ceq_mat equal_arctic, ccompare_mat, equal_mat equal_arctic,
        set_impl_mat, show_mat show_arctic)
      (A3_, A4_, A6_) (equal_list equal_char, show_list show_char)
      (mat_arc_lpoly_order ordered_semiring_1_arctic n one_arctica pos_arctic
        (fn x => fn y => less_arctic y x))
      (check_arc_dimension n) i
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (Arctic_rat_mat_carrier (n, i))
    = create_poly_redtriple
        (cenum_mat, ceq_mat (equal_arctic_delta equal_rat), ccompare_mat,
          equal_mat (equal_arctic_delta equal_rat), set_impl_mat,
          show_mat (show_arctic_delta show_rat))
        (A3_, A4_, A6_) (equal_list equal_char, show_list show_char)
        (mat_arc_lpoly_order
          (ordered_semiring_1_arctic_delta linordered_field_rat) n
          (one_arctic_deltaa linordered_field_rat)
          (pos_arctic_delta floor_ceiling_rat)
          (weak_gt_arctic_delta floor_ceiling_rat))
        (check_arc_dimension n) i
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (RPO (prec_tau, pi)) =
    af_redtriple (A1_, A2_, A4_, A5_, A6_) (show_list show_char) pi
      (create_RPO_redtriple A6_ (equal_filtered A3_, show_filtered A6_)
        (equal_list equal_char, show_list show_char)
        (fn pr => (prec_repr_to_pr A4_ pr, prec_repr_to_status A4_ pr))
        prec_tau)
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (KBO (precw, pi)) =
    af_redtriple (A1_, A2_, A4_, A5_, A6_) (show_list show_char) pi
      (create_KBO_redtriple A6_
        (equal_filtered A3_, key_filtered A4_, show_filtered A6_)
        (equal_list equal_char, show_list show_char)
        (filter_prec_weight_repr
          (fun_of_map_fun (ceta_map_of (key_prod A4_ key_nat) pi)
            (fn fna => default_af_entry (snd fna))))
        precw)
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (WPO (params, rp)) =
    wpo_redtriple (A3_, A4_, A6_)
      (get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) rp) params
  | get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (Max_poly alist) =
    create_max_poly_redtriple (A3_, A6_)
      (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list,
        linorder_list (equal_char, linorder_char), show_list show_char)
      alist;

fun list_ext_name MS_Ext = [#"M", #"S"]
  | list_ext_name Dms_Ext = [#"D", #"M", #"S"]
  | list_ext_name Min_Ext = [#"M", #"I", #"N"]
  | list_ext_name Max_Ext = [#"M", #"A", #"X"];

fun dms_preprocess p = map (filtera (fn (_, a) => let
            val (aa, b) = a;
          in
            aa orelse b
          end))
                         p;

fun dms_simplify stri is p =
  (if list_ex (fn i => null (nth p i)) is then [[]] else p);

fun dms_decide_singletons stri n p =
  all_interval_nat
    (fn i =>
      let
        val (j, (s, ns)) = nth p i;
      in
        s andalso
          not (membera (equal_prod equal_nat (equal_prod equal_bool equal_bool))
                (drop (suc i) p) (j, (false, true))) orelse
          ns andalso not (membera equal_nat (map fst (drop (suc i) p)) j)
      end)
    zero_nata (size_list p) andalso
    (if stri
      then not (all_interval_nat
                 (not o
                   (fn j =>
                     not (membera
                           (equal_prod equal_nat
                             (equal_prod equal_bool equal_bool))
                           p (j, (false, true)))))
                 zero_nata n)
      else true);

fun dms_select stri p =
  snd (hda (sort_key linorder_nat fst
             (filtera (fn (l, _) => less_nat one_nata l)
               (zip (map size_list p) (upt zero_nata (size_list p))))));

fun dms_solve_or_select stri n p =
  (if list_all (fn jsns => less_eq_nat (size_list jsns) one_nata) p
    then Inl (if membera
                   (equal_list
                     (equal_prod equal_nat (equal_prod equal_bool equal_bool)))
                   p []
               then false else dms_decide_singletons stri n (map hda p))
    else Inr (dms_select stri p));

fun dms_solve stri n p =
  (case dms_solve_or_select stri n p of Inl res => res
    | Inr k =>
      let
        val ksns = nth p k;
      in
        dms_solve stri n
          (dms_simplify stri [k] (list_update p k [hda ksns])) orelse
          dms_solve stri n (dms_simplify stri [k] (list_update p k (tla ksns)))
      end);

fun dms_bool_ex_idx_impl stri n p =
  dms_solve stri n
    (dms_simplify stri (upt zero_nata (size_list p)) (dms_preprocess p));

fun dms_bool_ex_idx x = dms_bool_ex_idx_impl x;

fun dms_convert f asa bs =
  let
    val jbs = zip (upt zero_nata (size_list bs)) bs;
  in
    map (fn a => map (fn (j, b) => (j, f a b)) jbs) asa
  end;

fun dms_order_ext n f asa bs =
  let
    val p = dms_convert f asa bs;
    val lts = size_list bs;
    val len = less_eq_nat lts n orelse equal_nata (size_list asa) lts;
  in
    (len andalso dms_bool_ex_idx true lts p,
      len andalso dms_bool_ex_idx false lts p)
  end;

fun min_set_ext s_ns =
  (fn asa => fn bs =>
    (not (null bs) andalso
       list_all (fn a => list_ex (fn b => fst (s_ns a b)) bs) asa,
      list_all (fn a => list_ex (fn b => snd (s_ns a b)) bs) asa));

fun or2 a b = (fst a orelse fst b, snd a orelse snd b);

fun mul_ext_impl sns [] [] = (false, true)
  | mul_ext_impl sns [] (v :: va) = (false, false)
  | mul_ext_impl sns (v :: va) [] = (true, true)
  | mul_ext_impl sns (v :: va) (y :: ys) = mul_ex_dom sns (v :: va) [] y ys
and mul_ex_dom sns [] xs y ys = (false, false)
  | mul_ex_dom sns (x :: xsa) xs y ys =
    (case sns x y
      of (true, _) =>
        (if snd (mul_ext_impl sns (xsa @ xs)
                  (filtera (fn ya => not (fst (sns x ya))) ys))
          then (true, true) else mul_ex_dom sns xsa (x :: xs) y ys)
      | (false, true) =>
        or2 (mul_ext_impl sns (xsa @ xs) ys) (mul_ex_dom sns xsa (x :: xs) y ys)
      | (false, false) => mul_ex_dom sns xsa (x :: xs) y ys);

fun mul_ext x = mul_ext_impl x;

fun list_ext uu MS_Ext = mul_ext
  | list_ext uv Max_Ext = set_ext
  | list_ext uw Min_Ext = min_set_ext
  | list_ext n Dms_Ext = dms_order_ext n;

fun label_s_ns_impl A_ B_ cS cNS s t =
  let
    val (sa, i) = s;
    val (ta, j) = t;
  in
    (if isOK (cS (sa, ta)) then (true, true)
      else (if isOK (cNS (sa, ta)) then (less_nat j i, less_eq_nat j i)
             else (false, false)))
  end;

fun nST_label_mul_impl A_ B_ list_ext af cS cNS st =
  (case st
    of (Var _, _) =>
      Inl (shows_prec_list show_char zero_nata
             [#"r", #"o", #"o", #"t", #"s", #" ", #"o", #"f", #" "] o
            (shows_rule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata)
               [#" ", #"-", #">", #" "] st o
              shows_prec_list show_char zero_nata
                [#" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e", #" ", #"n",
                  #"o", #"n", #"-", #"v", #"a", #"r", #"i", #"a", #"b", #"l",
                  #"e"]))
    | (Fun (_, _), Var _) =>
      Inl (shows_prec_list show_char zero_nata
             [#"r", #"o", #"o", #"t", #"s", #" ", #"o", #"f", #" "] o
            (shows_rule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata)
               [#" ", #"-", #">", #" "] st o
              shows_prec_list show_char zero_nata
                [#" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e", #" ", #"n",
                  #"o", #"n", #"-", #"v", #"a", #"r", #"i", #"a", #"b", #"l",
                  #"e"]))
    | (Fun (f, ss), Fun (g, ts)) =>
      check (snd (list_ext (label_s_ns_impl A_ B_ cS cNS)
                    (lterms af (Fun (f, ss)))
                   (lterms af (Fun (g, ts)))))
        (shows_prec_list show_char zero_nata
           [#"c", #"a", #"n", #"n", #"o", #"t", #" ", #"o", #"r", #"i", #"e",
             #"n", #"t", #" ", #"p", #"a", #"i", #"r", #" "] o
          (shows_rule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata)
             [#" ", #"-", #">", #" "] st o
            (shows_prec_list show_char zero_nata
               [#" ", #"w", #"e", #"a", #"k", #"l", #"y", #":"] o
              (shows_nl o
                (shows_prec_list (show_prod (show_term A_ B_) show_nat)
                   zero_nata (lterms af (Fun (f, ss))) o
                  (shows_prec_list show_char zero_nata
                     [#" ", #">", #"=", #"m", #"u", #" "] o
                    (shows_prec_list (show_prod (show_term A_ B_) show_nat)
                       zero_nata (lterms af (Fun (g, ts))) o
                      shows_prec_list show_char zero_nata
                        [#" ", #"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
                          #"t", #" ", #"b", #"e", #" ", #"e", #"n", #"s", #"u",
                          #"r", #"e", #"d"]))))))));

fun s_label_mul_impl A_ B_ list_ext af cS cNS st =
  (case st
    of (Var _, _) =>
      Inl (shows_prec_list show_char zero_nata
             [#"r", #"o", #"o", #"t", #"s", #" ", #"o", #"f", #" "] o
            (shows_rule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata)
               [#" ", #"-", #">", #" "] st o
              shows_prec_list show_char zero_nata
                [#" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e", #" ", #"n",
                  #"o", #"n", #"-", #"v", #"a", #"r", #"i", #"a", #"b", #"l",
                  #"e"]))
    | (Fun (_, _), Var _) =>
      Inl (shows_prec_list show_char zero_nata
             [#"r", #"o", #"o", #"t", #"s", #" ", #"o", #"f", #" "] o
            (shows_rule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata)
               [#" ", #"-", #">", #" "] st o
              shows_prec_list show_char zero_nata
                [#" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e", #" ", #"n",
                  #"o", #"n", #"-", #"v", #"a", #"r", #"i", #"a", #"b", #"l",
                  #"e"]))
    | (Fun (f, ss), Fun (g, ts)) =>
      check (fst (list_ext (label_s_ns_impl A_ B_ cS cNS)
                    (lterms af (Fun (f, ss)))
                   (lterms af (Fun (g, ts)))))
        (shows_prec_list show_char zero_nata
           [#"c", #"a", #"n", #"n", #"o", #"t", #" ", #"o", #"r", #"i", #"e",
             #"n", #"t", #" ", #"p", #"a", #"i", #"r", #" "] o
          (shows_rule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata)
             [#" ", #"-", #">", #" "] st o
            (shows_prec_list show_char zero_nata
               [#" ", #"s", #"t", #"r", #"i", #"c", #"t", #"l", #"y", #":"] o
              (shows_nl o
                (shows_prec_list (show_prod (show_term A_ B_) show_nat)
                   zero_nata (lterms af (Fun (f, ss))) o
                  (shows_prec_list show_char zero_nata
                     [#" ", #">", #"m", #"u", #" "] o
                    (shows_prec_list (show_prod (show_term A_ B_) show_nat)
                       zero_nata (lterms af (Fun (g, ts))) o
                      shows_prec_list show_char zero_nata
                        [#" ", #"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
                          #"t", #" ", #"b", #"e", #" ", #"e", #"n", #"s", #"u",
                          #"r", #"e", #"d"]))))))));

fun generate_scnp_rp (A1_, A2_) B_ list_ext list_ext_name afa rti x =
  let
    val rt = rti x;
    val afaa = fun_of_map (ceta_map_of (key_prod A1_ key_nat) afa) [];
    val pi = af rt;
    val cS = s rt;
    val cNS = ns rt;
  in
    Root_redtriple_ext
      (valid rt, s_label_mul_impl A2_ B_ list_ext afaa cS cNS, ns rt,
        nST_label_mul_impl A2_ B_ list_ext afaa cS cNS, pi,
        scnp_af_to_af afaa pi, scnp_desc A2_ afa list_ext_name o desc rt, ())
  end;

fun get_root_redtriple (A1_, A2_, A3_, A4_, A5_, A6_) (SCNP (typea, af, rp)) =
  generate_scnp_rp (A4_, A6_) (show_list show_char)
    (list_ext (scnp_arity af) typea) (list_ext_name typea) af
    (get_redtriple (A1_, A2_, A3_, A4_, A5_, A6_)) rp;

fun faulty_non_inf_order B_ C_ s f =
  Non_inf_order_ext
    (Inl (shows_string s), (fn _ => Inr ()), (fn _ => Inr ()),
      (fn _ => fn _ => Wild), id, ());

fun sqrt_real x =
  (if less_eq_real zero_reala x then let
                                       val y = sqrt x;
                                     in
                                       remdups equal_real [y, uminus_reala y]
                                     end
    else []);

fun check_non_inf_poly_inter_list A_ (B1_, B2_) discrete f i =
  catch_errora
    (catch_errora
      (forallM
        (fn x =>
          (if let
                val (_, a) = x;
              in
                check_poly_weak_mono_and_pos (equal_nat, linorder_nat)
                  (B1_, B2_) discrete a
              end
            then Inr () else Inl x))
        (filtera (fn (fna, _) => membera (equal_prod A_ equal_nat) f fna) i))
      (fn x => Inl (snd x)))
    (fn x => Inl let
                   val (a, b) = x;
                 in
                   let
                     val (fa, _) = a;
                   in
                     (fn aa => (fa, aa))
                   end
                     b
                 end);

fun create_nlpoly_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_) (C1_, C2_, C3_)
  cI def gt power_mono discrete sqrt i f =
  let
    val j = poly_inter_list_to_inter A2_ B2_ def i;
    val x =
      poly_subst linorder_nat
        (equal_list equal_char, linorder_list (equal_char, linorder_char))
        (A1_, comm_semiring_1_poly_carrier A2_)
        (fn n =>
          poly_of
            (equal_list equal_char, linorder_list (equal_char, linorder_char))
            (A1_, comm_semiring_1_poly_carrier A2_)
            (PVar ([#"x", #"_"] @ shows_prec_nat zero_nata n [])));
  in
    Non_inf_order_ext
      (bindb cI
         (fn _ =>
           catch_errora
             (check_non_inf_poly_inter_list B1_ (A1_, A2_) discrete f i)
             (fn xa =>
               Inl let
                     val (fa, p) = xa;
                   in
                     shows_string
                       [#"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t",
                         #"a", #"t", #"i", #"o", #"n", #" "] o
                       (shows_poly
                          (equal_list equal_char,
                            linorder_list (equal_char, linorder_char),
                            show_list show_char)
                          ((one_numeral o numeral_semiring_numeral o
                             semiring_numeral_semiring_1 o
                             semiring_1_comm_semiring_1 o
                             comm_semiring_1_poly_carrier)
                             A2_,
                            A1_, A3_)
                          (x p) o
                         (shows_string [#" ", #"o", #"f", #" "] o
                           (shows_prec B3_ zero_nata fa o
                             shows_string
                               [#" ", #"i", #"n", #"v", #"a", #"l", #"i", #"d",
                                 #" "])))
                   end)),
        check_ns B3_ (A1_, A2_, A3_) (C1_, C2_, C3_) j,
        check_cc (A1_, A2_, A3_) B3_ (C1_, C2_, C3_) sqrt gt j,
        create_dep (A1_, A2_) (B1_, B2_) discrete def i,
        shows_string
          [#"p", #"o", #"l", #"y", #"n", #"o", #"m", #"i", #"a", #"l", #" ",
            #"i", #"n", #"t", #"e", #"r", #"p", #"r", #"e", #"t", #"a", #"t",
            #"i", #"o", #"n"] o
          (shows_nl o
            shows_sep
              (fn (a, b) =>
                let
                  val (fa, n) = a;
                in
                  (fn p =>
                    shows_string [#"P", #"o", #"l", #"("] o
                      (shows_prec B3_ zero_nata fa o
                        (shows_string [#"/"] o
                          (shows_prec_nat zero_nata n o
                            (shows_string [#")", #" ", #"=", #" "] o
                              shows_poly
                                (equal_list equal_char,
                                  linorder_list (equal_char, linorder_char),
                                  show_list show_char)
                                ((one_numeral o numeral_semiring_numeral o
                                   semiring_numeral_semiring_1 o
                                   semiring_1_comm_semiring_1 o
                                   comm_semiring_1_poly_carrier)
                                   A2_,
                                  A1_, A3_)
                                (x p))))))
                end
                  b)
              shows_nl i),
        ())
  end;

fun sqrt_int_maina x n =
  let
    val x2 = times_inta x x;
  in
    (if less_eq_int x2 n then (x, equal_inta x2 n)
      else sqrt_int_maina
             (divide_inta (plus_inta (divide_inta n x) x)
               (Int_of_integer (2 : IntInf.int)))
             n)
  end;

fun sqrt_int_main x =
  sqrt_int_maina (start_value x (nat_of_integer (2 : IntInf.int))) x;

fun sqrt_int x =
  (if less_int x zero_inta then []
    else (case sqrt_int_main x
           of (y, true) =>
             (if equal_inta y zero_inta then [zero_inta]
               else [y, uminus_inta y])
           | (_, false) => []));

fun sqrt_rat x =
  let
    val (z, n) = quotient_of x;
  in
    (case sqrt_int n of [] => []
      | sn :: _ =>
        map (fn sz => divide_rata (of_int sz) (of_int sn)) (sqrt_int z))
  end;

fun get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_) (Int_nl_carrier i) =
  create_nlpoly_non_inf_order (equal_int, poly_carrier_int, show_int)
    (A1_, A2_, A3_) (B1_, B2_, B3_) (Inr ()) one_inta
    (fn x => fn y => less_int y x) true true sqrt_int i
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_) (Rat_nl_carrier (d, i)) =
    create_nlpoly_non_inf_order (equal_rat, poly_carrier_rat, show_rat)
      (A1_, A2_, A3_) (B1_, B2_, B3_) (check_def_pos (zero_rat, ord_rat) d) d
      (delta_gt floor_ceiling_rat d) (less_eq_rat one_rata d) false sqrt_rat i
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_) (Real_nl_carrier (d, i)) =
    create_nlpoly_non_inf_order (equal_real, poly_carrier_real, show_real)
      (A1_, A2_, A3_) (B1_, B2_, B3_) (check_def_pos (zero_real, ord_real) d) d
      (delta_gt floor_ceiling_real d) (less_eq_real one_reala d) false sqrt_real
      i
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_) (Int_carrier v) =
    faulty_non_inf_order A3_ B3_
      [#"o", #"n", #"l", #"y", #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r",
        #"s", #",", #" ", #"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s",
        #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"a", #"l", #"s", #" ", #"a",
        #"r", #"e", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
        #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"i", #"n", #"f",
        #" ", #"o", #"r", #"d", #"e", #"r", #"s"]
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_) (Rat_carrier v) =
    faulty_non_inf_order A3_ B3_
      [#"o", #"n", #"l", #"y", #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r",
        #"s", #",", #" ", #"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s",
        #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"a", #"l", #"s", #" ", #"a",
        #"r", #"e", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
        #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"i", #"n", #"f",
        #" ", #"o", #"r", #"d", #"e", #"r", #"s"]
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_) (Real_carrier v) =
    faulty_non_inf_order A3_ B3_
      [#"o", #"n", #"l", #"y", #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r",
        #"s", #",", #" ", #"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s",
        #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"a", #"l", #"s", #" ", #"a",
        #"r", #"e", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
        #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"i", #"n", #"f",
        #" ", #"o", #"r", #"d", #"e", #"r", #"s"]
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_) (Arctic_carrier v) =
    faulty_non_inf_order A3_ B3_
      [#"o", #"n", #"l", #"y", #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r",
        #"s", #",", #" ", #"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s",
        #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"a", #"l", #"s", #" ", #"a",
        #"r", #"e", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
        #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"i", #"n", #"f",
        #" ", #"o", #"r", #"d", #"e", #"r", #"s"]
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_) (Arctic_rat_carrier v) =
    faulty_non_inf_order A3_ B3_
      [#"o", #"n", #"l", #"y", #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r",
        #"s", #",", #" ", #"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s",
        #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"a", #"l", #"s", #" ", #"a",
        #"r", #"e", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
        #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"i", #"n", #"f",
        #" ", #"o", #"r", #"d", #"e", #"r", #"s"]
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_)
    (Int_mat_carrier (v, va, vb)) =
    faulty_non_inf_order A3_ B3_
      [#"o", #"n", #"l", #"y", #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r",
        #"s", #",", #" ", #"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s",
        #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"a", #"l", #"s", #" ", #"a",
        #"r", #"e", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
        #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"i", #"n", #"f",
        #" ", #"o", #"r", #"d", #"e", #"r", #"s"]
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_)
    (Rat_mat_carrier (v, va, vb)) =
    faulty_non_inf_order A3_ B3_
      [#"o", #"n", #"l", #"y", #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r",
        #"s", #",", #" ", #"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s",
        #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"a", #"l", #"s", #" ", #"a",
        #"r", #"e", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
        #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"i", #"n", #"f",
        #" ", #"o", #"r", #"d", #"e", #"r", #"s"]
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_)
    (Real_mat_carrier (v, va, vb)) =
    faulty_non_inf_order A3_ B3_
      [#"o", #"n", #"l", #"y", #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r",
        #"s", #",", #" ", #"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s",
        #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"a", #"l", #"s", #" ", #"a",
        #"r", #"e", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
        #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"i", #"n", #"f",
        #" ", #"o", #"r", #"d", #"e", #"r", #"s"]
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_)
    (Arctic_mat_carrier (v, va)) =
    faulty_non_inf_order A3_ B3_
      [#"o", #"n", #"l", #"y", #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r",
        #"s", #",", #" ", #"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s",
        #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"a", #"l", #"s", #" ", #"a",
        #"r", #"e", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
        #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"i", #"n", #"f",
        #" ", #"o", #"r", #"d", #"e", #"r", #"s"]
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_)
    (Arctic_rat_mat_carrier (v, va)) =
    faulty_non_inf_order A3_ B3_
      [#"o", #"n", #"l", #"y", #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r",
        #"s", #",", #" ", #"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s",
        #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"a", #"l", #"s", #" ", #"a",
        #"r", #"e", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
        #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"i", #"n", #"f",
        #" ", #"o", #"r", #"d", #"e", #"r", #"s"]
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_) (RPO (v, va)) =
    faulty_non_inf_order A3_ B3_
      [#"o", #"n", #"l", #"y", #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r",
        #"s", #",", #" ", #"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s",
        #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"a", #"l", #"s", #" ", #"a",
        #"r", #"e", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
        #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"i", #"n", #"f",
        #" ", #"o", #"r", #"d", #"e", #"r", #"s"]
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_) (KBO (v, va)) =
    faulty_non_inf_order A3_ B3_
      [#"o", #"n", #"l", #"y", #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r",
        #"s", #",", #" ", #"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s",
        #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"a", #"l", #"s", #" ", #"a",
        #"r", #"e", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
        #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"i", #"n", #"f",
        #" ", #"o", #"r", #"d", #"e", #"r", #"s"]
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_) (WPO (v, va)) =
    faulty_non_inf_order A3_ B3_
      [#"o", #"n", #"l", #"y", #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r",
        #"s", #",", #" ", #"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s",
        #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"a", #"l", #"s", #" ", #"a",
        #"r", #"e", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
        #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"i", #"n", #"f",
        #" ", #"o", #"r", #"d", #"e", #"r", #"s"]
  | get_non_inf_order (A1_, A2_, A3_) (B1_, B2_, B3_) (Max_poly v) =
    faulty_non_inf_order A3_ B3_
      [#"o", #"n", #"l", #"y", #" ", #"i", #"n", #"t", #"e", #"g", #"e", #"r",
        #"s", #",", #" ", #"r", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"s",
        #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"a", #"l", #"s", #" ", #"a",
        #"r", #"e", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
        #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"i", #"n", #"f",
        #" ", #"o", #"r", #"d", #"e", #"r", #"s"];

fun check_strict_one_rstep (A1_, A2_) (B1_, B2_, B3_, B4_) ra rseqm p r =
  let
    val s = proj_term p (fst r);
    val t = proj_term p (snd r);
  in
    (case rseqm r of NONE => check_supt (A1_, A2_) (B2_, B4_) s t
      | SOME [] =>
        Inl (shows_string
              [#"m", #"o", #"r", #"e", #" ", #"t", #"h", #"a", #"n", #" ", #"a",
                #" ", #"s", #"i", #"n", #"g", #"l", #"e", #" ", #"r", #"e",
                #"w", #"r", #"i", #"t", #"e", #" ", #"s", #"t", #"e", #"p",
                #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l",
                #"l", #"o", #"w", #"e", #"d"])
      | SOME [(pos, (rule, u))] =>
        bindb (check_qrstep (A1_, A2_) (B1_, B2_, B3_, B4_) (fn _ => true) false
                ra pos rule s u)
          (fn _ => check_supteq (A1_, A2_) (B2_, B4_) u t)
      | SOME ((_, (_, _)) :: _ :: _) =>
        Inl (shows_string
              [#"m", #"o", #"r", #"e", #" ", #"t", #"h", #"a", #"n", #" ", #"a",
                #" ", #"s", #"i", #"n", #"g", #"l", #"e", #" ", #"r", #"e",
                #"w", #"r", #"i", #"t", #"e", #" ", #"s", #"t", #"e", #"p",
                #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l",
                #"l", #"o", #"w", #"e", #"d"]))
  end;

fun check_rsteps (A1_, A2_) (B1_, B2_, B3_, B4_) =
  check_qrsteps (A1_, A2_) (B1_, B2_, B3_, B4_) (fn _ => true) false;

fun rseq_last s steps = last (s :: map (fn (_, (_, sa)) => sa) steps);

fun check_rsteps_last (A1_, A2_) (B1_, B2_, B3_, B4_) =
  (fn r => fn s => fn steps =>
    check_rsteps (A1_, A2_) (B1_, B2_, B3_, B4_) r steps s (rseq_last s steps));

fun check_strict_rstep (A1_, A2_) (B1_, B2_, B3_, B4_) ra rseqm p r =
  let
    val s = proj_term p (fst r);
    val t = proj_term p (snd r);
  in
    (case rseqm r of NONE => check_supt (A1_, A2_) (B2_, B4_) s t
      | SOME rseq =>
        (if equal_nata (size_list rseq) zero_nata
          then check_supt (A1_, A2_) (B2_, B4_) s t
          else bindb (check_rsteps_last (A1_, A2_) (B1_, B2_, B3_, B4_) ra s
                       rseq)
                 (fn _ =>
                   check_supteq (A1_, A2_) (B2_, B4_) (rseq_last s rseq) t)))
  end;

fun create_rseq_map A_ B_ rseqs =
  ceta_map_of (key_prod (key_term A_ B_) (key_term A_ B_)) rseqs;

fun check_weak (A1_, A2_) (B1_, B2_) p r =
  catch_errora
    (check (equal_terma A1_ B1_ (proj_term p (fst r)) (proj_term p (snd r)))
      (shows_string
         [#"t", #"h", #"e", #" ", #"p", #"r", #"o", #"j", #"e", #"c", #"t",
           #"e", #"d", #" ", #"l", #"h", #"s", #" ", #"i", #"s", #" ", #"n",
           #"o", #"t", #" ", #"e", #"q", #"u", #"a", #"l", #" ", #"t", #"o",
           #" ", #"t", #"h", #"e", #" ", #"p", #"r", #"o", #"j", #"e", #"c",
           #"t", #"e", #"d", #" ", #"r", #"h", #"s"] o
        shows_nl))
    (fn x =>
      Inl (shows_string
             [#"C", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"o",
               #"r", #"i", #"e", #"n", #"t", #" ", #"r", #"u", #"l", #"e",
               #" "] o
            (shows_rule (shows_prec A2_ zero_nata) (shows_prec B2_ zero_nata)
               [#" ", #"-", #">", #" "] r o
              (shows_string [#",", #" ", #"s", #"i", #"n", #"c", #"e"] o
                (shows_nl o
                  (shows_prec_term A2_ B2_ zero_nata (proj_term p (fst r)) o
                    (shows_string [#" ", #"!", #"=", #" "] o
                      (shows_prec_term A2_ B2_ zero_nata (proj_term p (snd r)) o
                        (shows_nl o x)))))))));

fun subterm_criterion_proc (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_) i pL rseqmL
  prm dpp =
  (case let
          val p = create_proj B2_ pL;
          val rseqm = create_rseq_map B2_ C3_ rseqmL;
          val pa = pairsb i dpp;
          val _ = nfsc i dpp;
          val r = rulese i dpp;
          val pb = snd (split_pairsa i dpp prm);
          val wfR = wf_rules_impl C2_ r;
        in
          bindb (catch_errora
                  (forallM
                    (fn (l, ra) =>
                      bindb (check_no_var B3_ C5_ l)
                        (fn _ =>
                          bindb (check_no_var B3_ C5_ ra)
                            (fn _ =>
                              check_no_defined_root B3_ C5_
                                (fn fna => not (null (rules_mapc i dpp fna)))
                                ra)))
                    pa)
                  (fn x => Inl (snd x)))
            (fn _ =>
              bindb (check (minimal i dpp orelse nFQ_subset_NF_rulesc i dpp)
                      (shows_prec_list show_char zero_nata
                        [#"m", #"i", #"n", #"i", #"m", #"a", #"l", #"i", #"t",
                          #"y", #" ", #"o", #"r", #" ", #"i", #"n", #"n", #"e",
                          #"r", #"m", #"o", #"s", #"t", #" ", #"r", #"e", #"q",
                          #"u", #"i", #"r", #"e", #"d"]))
                (fn _ =>
                  bindb (catch_errora
                          (forallM (fn (l, _) => check_no_var B3_ C5_ l) r)
                          (fn x => Inl (snd x)))
                    (fn _ =>
                      bindb (if q_emptyc i dpp
                              then catch_errora
                                     (forallM
                                       (check_strict_rstep (B1_, B3_)
 (C1_, C2_, C4_, C5_) r rseqm p)
                                       prm)
                                     (fn x => Inl (snd x))
                              else catch_errora
                                     (forallM
                                       (check_strict_one_rstep (B1_, B3_)
 (C1_, C2_, C4_, C5_) wfR rseqm p)
                                       prm)
                                     (fn x => Inl (snd x)))
                        (fn _ =>
                          catch_errora
                            (forallM (check_weak (B1_, B3_) (C2_, C5_) p) pb)
                            (fn x => Inl (snd x))))))
        end
    of Inl a => Inl a | Inr _ => Inr (delete_P_Pwa i dpp prm prm));

fun replace_paira
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = replace_pair;

fun forward_instantiation_proc (B1_, B2_, B3_) i st sts u_opt dpp =
  (case let
          val isnf = is_QNFc i dpp;
          val (s, t) = st;
          val iedg = is_iedg_edge_dpp (B1_, B2_, B3_) i dpp (s, t);
          val sy = map_term (fn x => x) (fn a => #"y" :: a) s;
          val ty = map_term (fn x => x) (fn a => #"y" :: a) t;
          val u = (case u_opt of NONE => rulese i dpp | SOME u => u);
        in
          bindb (if is_none u_opt then Inr ()
                  else let
                         val urc =
                           is_ur_closed_impl_dpp_mv (B1_, B2_, B3_) i dpp u;
                         val check_urc =
                           (fn sa => fn ta =>
                             check (urc sa ta)
                               (shows_prec_list show_char zero_nata
                                  [#"t", #"e", #"r", #"m", #" "] o
                                 (shows_prec_term B3_ (show_list show_char)
                                    zero_nata ta o
                                   shows_prec_list show_char zero_nata
                                     [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
                                       #" ", #"c", #"l", #"o", #"s", #"e", #"d",
                                       #" ", #"u", #"n", #"d", #"e", #"r", #" ",
                                       #"u", #"s", #"a", #"b", #"l", #"e", #" ",
                                       #"r", #"u", #"l", #"e", #"s"])));
                       in
                         bindb (check (nfsc i dpp orelse minimal i dpp)
                                 (shows_prec_list show_char zero_nata
                                   [#"m", #"i", #"n", #"i", #"m", #"a", #"l",
                                     #"i", #"t", #"y", #" ", #"o", #"r", #" ",
                                     #"n", #"o", #"r", #"m", #"a", #"l", #" ",
                                     #"s", #"u", #"b", #"s", #"t", #" ", #"r",
                                     #"e", #"q", #"u", #"i", #"r", #"e", #"d"]))
                           (fn _ =>
                             bindb (check (nFQ_subset_NF_rulesc i dpp)
                                     (shows_prec_list show_char zero_nata
                                       [#"i", #"n", #"n", #"e", #"r", #"m",
 #"o", #"s", #"t", #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"i", #"n", #"g",
 #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]))
                               (fn _ =>
                                 bindb (catch_errora
 (forallM (fn (l, a) => check_urc (args l) a) u) (fn x => Inl (snd x)))
                                   (fn _ =>
                                     bindb (check_urc [s] t)
                                       (fn _ =>
 (if nfsc i dpp then Inr ()
   else catch_errora
          (check_subseteq (equal_list equal_char) (vars_term_list t)
            (vars_term_list s))
          (fn _ =>
            Inl (shows_prec_list show_char zero_nata
                  [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #" ", #"c",
                    #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ", #"i",
                    #"n", #" ", #"p", #"a", #"i", #"r", #" ", #"v", #"i", #"o",
                    #"l", #"a", #"t", #"e", #"d"])))))))
                       end)
            (fn _ =>
              let
                val ur = map (fn (l, r) => (r, l)) u;
                val ic =
                  icap_impl B1_
                    (is_NF_terms (B1_, B2_)
                      (ccompare_list ccompare_char, equal_list equal_char,
                        mapping_impl_list)
                      [])
                    ur [];
              in
                catch_errora
                  (forallM
                    (fn (ua, v) =>
                      (case mgu_class B1_ (ic ua) t of NONE => Inr ()
                        | SOME mu =>
                          check (not (isnf (subst_apply_term sy mu)) orelse
                                  (not (isnf
 (subst_apply_term (map_term (fn x => x) (fn a => #"x" :: a) ua) mu)) orelse
                                    list_ex
                                      (fn sta =>
instance_rule B1_ (equal_list equal_char)
  (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list) sta
  st andalso
  instance_rule B1_ (equal_list equal_char)
    (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list)
    (subst_apply_term sy mu, subst_apply_term ty mu) sta)
                                      sts))
                            (shows_prec_list show_char zero_nata
                               [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
                                 #"t", #" ", #"f", #"i", #"n", #"d", #" ", #"i",
                                 #"n", #"s", #"t", #"a", #"n", #"c", #"e", #" ",
                                 #"o", #"f", #" ", #"p", #"a", #"i", #"r",
                                 #" "] o
                              (shows_rule (shows_prec B3_ zero_nata)
                                 (shows_prec_list show_char zero_nata)
                                 [#" ", #"-", #">", #" "]
                                 (subst_apply_term sy mu,
                                   subst_apply_term ty mu) o
                                (shows_nl o
                                  (shows_prec_list show_char zero_nata
                                     [#"w", #"h", #"i", #"c", #"h", #" ", #"r",
                                       #"e", #"s", #"u", #"l", #"t", #"e", #"d",
                                       #" ", #"f", #"r", #"o", #"m", #" ", #"D",
                                       #"P", #" "] o
                                    shows_rule (shows_prec B3_ zero_nata)
                                      (shows_prec_list show_char zero_nata)
                                      [#" ", #"-", #">", #" "] (ua, v)))))))
                    (filtera (fn (ua, _) => iedg ua) (pairsb i dpp)))
                  (fn x => Inl (snd x))
              end)
        end
    of Inl a => Inl a | Inr _ => Inr (replace_paira i dpp st sts));

fun check_join (A1_, A2_) (B1_, B2_, B3_, B4_) r s sseq t tseq =
  let
    val chk = check_rsteps_last (A1_, A2_) (B1_, B2_, B3_, B4_) r;
  in
    bindb (chk s sseq)
      (fn _ =>
        bindb (chk t tseq)
          (fn _ =>
            let
              val u = rseq_last s sseq;
              val v = rseq_last t tseq;
            in
              check (equal_terma A1_ B2_ u v)
                (shows_prec_list show_char zero_nata
                   [#"t", #"h", #"e", #" ", #"r", #"e", #"w", #"r", #"i", #"t",
                     #"e", #" ", #"s", #"e", #"q", #"u", #"e", #"n", #"c", #"e",
                     #"s", #" ", #"e", #"n", #"d", #" ", #"i", #"n", #" ", #"d",
                     #"i", #"f", #"f", #"e", #"r", #"e", #"n", #"t", #" ", #"t",
                     #"e", #"r", #"m", #"s", #" "] o
                  (shows_prec_term A2_ B4_ zero_nata u o
                    (shows_prec_list show_char zero_nata
                       [#" ", #"a", #"n", #"d", #" "] o
                      shows_prec_term A2_ B4_ zero_nata v)))
            end))
  end;

fun check_critical_pairs_guided (A1_, A2_) (B1_, B2_, B3_, B4_) r cp joins =
  bindb (catch_errora
          (forallM
            (fn (s, a) =>
              let
                val (sseq, aa) = a;
                val (ab, b) = aa;
              in
                check_join (A1_, A2_) (B1_, B2_, B3_, B4_) r s sseq ab b
              end)
            joins)
          (fn x => Inl (snd x)))
    (fn _ =>
      let
        val cpa = map (fn (s, (_, (t, _))) => (s, t)) joins;
      in
        catch_errora
          (forallM
            (fn (_, (s, t)) =>
              check (equal_terma A1_ B2_ s t orelse
                      list_ex
                        (fn st =>
                          instance_rule A1_ B2_ (B1_, B2_, B3_) (s, t) st orelse
                            instance_rule A1_ B2_ (B1_, B2_, B3_) (t, s) st)
                        cpa)
                (shows_prec_list show_char zero_nata
                   [#"c", #"r", #"i", #"t", #"i", #"c", #"a", #"l", #" ", #"p",
                     #"a", #"i", #"r", #" "] o
                  (show_crit_pair A2_ B4_ (s, t) o
                    shows_prec_list show_char zero_nata
                      [#" ", #"m", #"i", #"s", #"s", #"i", #"n", #"g"])))
            cp)
          (fn x => Inl (snd x))
      end);

fun iterative_join_search_main A_ (B1_, B2_, B3_) r s t i n =
  (if less_eq_nat i n
    then not (null (list_inter (equal_term A_ B2_)
                     (reachable_terms A_ (B1_, B2_, B3_) r s i)
                     (reachable_terms A_ (B1_, B2_, B3_) r t i))) orelse
           iterative_join_search_main A_ (B1_, B2_, B3_) r s t (suc i) n
    else false);

fun iterative_join_search A_ (B1_, B2_, B3_) r s t n =
  iterative_join_search_main A_ (B1_, B2_, B3_) r s t zero_nata n;

fun check_join_BFS_limit (A1_, A2_) (B1_, B2_, B3_, B4_) n r s t =
  check (iterative_join_search A1_ (B1_, B2_, B3_) r s t n)
    (shows_prec_list show_char zero_nata
       [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"f", #"i",
         #"n", #"d", #" ", #"a", #" ", #"j", #"o", #"i", #"n", #"i", #"n", #"g",
         #" ", #"s", #"e", #"q", #"u", #"e", #"n", #"c", #"e", #" ", #"o", #"f",
         #" ", #"l", #"e", #"n", #"g", #"t", #"h", #" ", #"a", #"t", #" ", #"m",
         #"o", #"s", #"t", #" "] o
      (shows_prec_nat zero_nata n o
        (shows_prec_list show_char zero_nata
           [#" ", #"f", #"o", #"r", #" ", #"t", #"h", #"e", #" ", #"t", #"e",
             #"r", #"m", #"s", #" "] o
          (shows_prec_term A2_ B4_ zero_nata s o
            (shows_prec_list show_char zero_nata
               [#" ", #"a", #"n", #"d", #" "] o
              (shows_prec_term A2_ B4_ zero_nata t o shows_nl))))));

fun check_critical_pairs_BFS (A1_, A2_) (B1_, B2_, B3_, B4_) n r cp =
  catch_errora
    (forallM
      (fn (_, (s, t)) =>
        (if equal_terma A1_ B2_ s t then Inr ()
          else catch_errora
                 (check_join_BFS_limit (A1_, A2_) (B1_, B2_, B3_, B4_) n r s t)
                 (fn x =>
                   Inl (shows_prec_list show_char zero_nata
                          [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w",
                            #"h", #"e", #"n", #" ", #"j", #"o", #"i", #"n",
                            #"i", #"n", #"g", #" ", #"c", #"r", #"i", #"t",
                            #"i", #"c", #"a", #"l", #" ", #"p", #"a", #"i",
                            #"r", #" "] o
                         (show_crit_pair A2_ B4_ (s, t) o (shows_nl o x))))))
      cp)
    (fn x => Inl (snd x));

fun check_critical_pairs_NF (A1_, A2_) (B1_, B2_, B3_, B4_) r cp =
  catch_errora
    (forallM
      (fn (_, (s, t)) =>
        (if equal_terma A1_ B2_ s t then Inr ()
          else catch_errora
                 (check_join_NF (A1_, A2_) (B1_, B2_, B3_, B4_) r s t)
                 (fn x =>
                   Inl (shows_prec_list show_char zero_nata
                          [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w",
                            #"h", #"e", #"n", #" ", #"j", #"o", #"i", #"n",
                            #"i", #"n", #"g", #" ", #"c", #"r", #"i", #"t",
                            #"i", #"c", #"a", #"l", #" ", #"p", #"a", #"i",
                            #"r", #" "] o
                         (show_crit_pair A2_ B4_ (s, t) o (shows_nl o x))))))
      cp)
    (fn x => Inl (snd x));

fun check_critical_pairs (A1_, A2_) r cp join_info =
  (case join_info
    of Guided a =>
      check_critical_pairs_guided (A1_, A2_)
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list,
          show_list show_char)
        r cp a
    | Join_NF =>
      check_critical_pairs_NF (A1_, A2_)
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list,
          show_list show_char)
        r cp
    | Join_BFS n =>
      check_critical_pairs_BFS (A1_, A2_)
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list,
          show_list show_char)
        n r cp);

fun switch_innermost_proc (B1_, B2_) i joins_i dpp =
  let
    val r = rwd i dpp;
    val p = pb i dpp;
    val pw = pwb i dpp;
    val nfs = nfsc i dpp;
  in
    (case bindb (catch_errora
                  (forallM
                    (fn (l, _) =>
                      check (not (is_Var l))
                        (shows_prec_list show_char zero_nata
                          [#"l", #"e", #"f", #"t", #" ", #"v", #"a", #"r", #"i",
                            #"a", #"b", #"l", #"e", #"s", #" ", #"i", #"n",
                            #" ", #"R", #" ", #"f", #"o", #"r", #"b", #"i",
                            #"d", #"d", #"e", #"n"]))
                    (if nfs then r else []))
                  (fn x => Inl (snd x)))
            (fn _ =>
              bindb (check (minimal i dpp)
                      (shows_prec_list show_char zero_nata
                        [#"m", #"i", #"n", #"i", #"m", #"a", #"l", #"i", #"t",
                          #"y", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e",
                          #"d"]))
                (fn _ =>
                  bindb (check (null (qc i dpp))
                          (shows_prec_list show_char zero_nata
                            [#"n", #"o", #"n", #"-", #"e", #"m", #"p", #"t",
                              #"y", #" ", #"Q", #" ", #"n", #"o", #"t", #" ",
                              #"y", #"e", #"t", #" ", #"s", #"u", #"p", #"p",
                              #"o", #"r", #"t", #"e", #"d"]))
                    (fn _ =>
                      bindb (check (null (rd i dpp))
                              (shows_prec_list show_char zero_nata
                                [#"s", #"t", #"r", #"i", #"c", #"t", #" ", #"r",
                                  #"u", #"l", #"e", #"s", #" ", #"n", #"o",
                                  #"t", #" ", #"a", #"l", #"l", #"o", #"w",
                                  #"e", #"d"]))
                        (fn _ =>
                          bindb (check
                                  (null (critical_pairs_impl B1_ (p @ pw) r))
                                  (shows_prec_list show_char zero_nata
                                    [#"o", #"v", #"e", #"r", #"l", #"a", #"p",
                                      #"s", #" ", #"b", #"e", #"t", #"w", #"e",
                                      #"e", #"n", #" ", #"P", #" ", #"a", #"n",
                                      #"d", #" ", #"R", #" ", #"n", #"o", #"t",
                                      #" ", #"a", #"l", #"l", #"o", #"w", #"e",
                                      #"d"]))
                            (fn _ =>
                              check_critical_pairs (B1_, B2_) r
                                (critical_pairs_impl B1_ r r) joins_i)))))
      of Inl a => Inl a | Inr _ => Inr (mkd i nfs true p pw (map fst r) [] r))
  end;

fun mk_dpp i (nfs, (m, (p, (pw, (q, (r, rw)))))) = mkd i nfs m p pw q r rw;

fun check_assma (B1_, B2_, B3_) j i tp_check dp_check fptp_check unk_check
  (SN_assm_proof (t, prf)) = tp_check (mk_tp j t) prf
  | check_assma (B1_, B2_, B3_) j i tp_check dp_check fptp_check unk_check
    (Finite_assm_proof (t, prf)) = dp_check (mk_dpp i t) prf
  | check_assma (B1_, B2_, B3_) j i tp_check dp_check fptp_check unk_check
    (Unknown_assm_proof (t, prf)) = unk_check t prf
  | check_assma (B1_, B2_, B3_) j i tp_check dp_check fptp_check unk_check
    (SN_FP_assm_proof (t, prf)) = fptp_check t prf
  | check_assma (B1_, B2_, B3_) j i uu uv uw ux (Not_SN_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"t", #"e", #"r",
            #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n", #" ", #"a", #"s",
            #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #"s", #" ", #"i",
            #"n", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
            #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"])
  | check_assma (B1_, B2_, B3_) j i uu uv uw ux (Infinite_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"t", #"e", #"r",
            #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n", #" ", #"a", #"s",
            #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #"s", #" ", #"i",
            #"n", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
            #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"])
  | check_assma (B1_, B2_, B3_) j i uu uv uw ux (Not_RelSN_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"t", #"e", #"r",
            #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n", #" ", #"a", #"s",
            #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #"s", #" ", #"i",
            #"n", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
            #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"])
  | check_assma (B1_, B2_, B3_) j i uu uv uw ux (Not_SN_FP_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"t", #"e", #"r",
            #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n", #" ", #"a", #"s",
            #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #"s", #" ", #"i",
            #"n", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
            #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"])
  | check_assma (B1_, B2_, B3_) j i uu uv uw ux (Complexity_assm_proof (v, va))
    = Inl (shows_prec_list show_char zero_nata
            [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
              #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"t", #"e", #"r",
              #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n", #" ", #"a", #"s",
              #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #"s", #" ", #"i",
              #"n", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
              #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"]);

fun quasi_splitter (A1_, A2_) (C1_, C2_) ld lAll uRw =
  let
    val unlab = (fn lf => fst (ld lf));
    val la = map (fn r => (r, map_funs_rule unlab r)) lAll;
    val (d, nD) =
      partition
        (fn (r, ur) =>
          equal_terma A2_ C2_ (fst ur) (snd ur) andalso
            not (equal_terma A2_ C2_ (fst r) (snd r)))
        la;
    val (rw, r) =
      partition
        (fn (_, ur) =>
          member
            (ceq_prod (ceq_term A2_ C2_) (ceq_term A2_ C2_),
              ccompare_prod (ccompare_term A1_ C1_) (ccompare_term A1_ C1_))
            ur uRw)
        nD;
  in
    (map fst r, (map fst rw, map fst d))
  end;

fun model_splitter (A1_, A2_) (C1_, C2_) ld lAll uRw =
  let
    val unlab = (fn lf => fst (ld lf));
    val la = map (fn r => (r, map_funs_rule unlab r)) lAll;
    val (rw, r) =
      partition
        (fn (_, ur) =>
          member
            (ceq_prod (ceq_term A2_ C2_) (ceq_term A2_ C2_),
              ccompare_prod (ccompare_term A1_ C1_) (ccompare_term A1_ C1_))
            ur uRw)
        la;
  in
    (map fst r, (map fst rw, []))
  end;

fun check_sl_Q (A1_, A2_) (C1_, C2_, C3_, C4_) ld lQ q =
  let
    val u = (fn l => fst (ld l));
  in
    catch_errora
      (forallM
        (fn lq =>
          check let
                  val mlq = map_term u (fn x => x) lq;
                in
                  list_ex
                    (fn qa =>
                      matches A1_ C2_ (C1_, C2_, C3_) mlq qa andalso
                        matches A1_ C2_ (C1_, C2_, C3_) qa mlq)
                    q
                end
            (shows_prec_list show_char zero_nata
               [#"u", #"n", #"l", #"a", #"b", #"e", #"l", #"i", #"n", #"g",
                 #" "] o
              (shows_term (shows_prec A2_ zero_nata) (shows_prec C4_ zero_nata)
                 lq o
                shows_prec_list show_char zero_nata
                  [#" ", #"y", #"i", #"e", #"l", #"d", #"s", #" ", #"a", #" ",
                    #"t", #"e", #"r", #"m", #" ", #"n", #"o", #"t", #" ", #"i",
                    #"n", #" ", #"Q"])))
        lQ)
      (fn x => Inl (snd x))
  end;

fun sem_lab_quasi_root_proc (A1_, A2_, A3_) (D1_, D2_, D3_, D4_, D5_, D6_, D7_)
  ld i valid check_decra check_decr check_lhss_more check_lab_all
  check_lab_all_trs check_model_lab lPAll lQ lRAll dpp =
  let
    val r = rd i dpp;
    val rw = rwd i dpp;
    val pw = pwb i dpp;
    val p = pb i dpp;
    val nfs = nfsc i dpp;
    val m = minimal i dpp;
    val (lP, (lPw, _)) =
      model_splitter (A1_, A2_) (D3_, D4_) ld lPAll
        (set (ceq_prod (ceq_term A2_ D4_) (ceq_term A2_ D4_),
               ccompare_prod (ccompare_term A1_ D3_) (ccompare_term A1_ D3_),
               set_impl_prod set_impl_term set_impl_term)
          pw);
    val (lR, (lRw, d)) =
      quasi_splitter (A1_, A2_) (D3_, D4_) ld lRAll
        (set (ceq_prod (ceq_term A2_ D4_) (ceq_term A2_ D4_),
               ccompare_prod (ccompare_term A1_ D3_) (ccompare_term A1_ D3_),
               set_impl_prod set_impl_term set_impl_term)
          rw);
    val qempty = q_emptyc i dpp;
  in
    (case bindb valid
            (fn _ =>
              bindb (check
                      (if nfs
                        then (if not qempty then wwf_rulesa i dpp else true)
                        else true)
                      (shows_prec_list show_char zero_nata
                        [#"w", #"e", #"l", #"l", #" ", #"f", #"o", #"r", #"m",
                          #"e", #"d", #"n", #"e", #"s", #"s", #" ", #"r", #"e",
                          #"q", #"u", #"i", #"r", #"e", #"d"]))
                (fn _ =>
                  bindb (catch_errora
                          (forallM
                            (fn (l, ra) =>
                              bindb (check_no_var A3_ D7_ l)
                                (fn _ =>
                                  bindb (check_no_var A3_ D7_ ra)
                                    (fn _ =>
                                      check_no_defined_root A3_ D7_
(fn fna => not (null (rules_mapc i dpp fna))) ra)))
                            (pairsb i dpp))
                          (fn x => Inl (snd x)))
                    (fn _ =>
                      bindb (catch_errora
                              (forallM (fn (l, _) => check_no_var A3_ D7_ l)
                                (rulese i dpp))
                              (fn x => Inl (snd x)))
                        (fn _ =>
                          let
                            val q = qc i dpp;
                          in
                            bindb (if nfs andalso not qempty
                                    then check_wf_trs A3_ (D4_, D7_) d
                                    else Inr ())
                              (fn _ =>
                                bindb (check_decra d)
                                  (fn _ =>
                                    bindb (check_decr d)
                                      (fn _ =>
bindb (catch_errora
        (forallM
          (fn qa =>
            check (linear_term (D1_, D2_, D6_) qa)
              (shows_prec_list show_char zero_nata
                [#"Q", #" ", #"m", #"u", #"s", #"t", #" ", #"n", #"o", #"t",
                  #" ", #"c", #"o", #"n", #"t", #"a", #"i", #"n", #" ", #"n",
                  #"o", #"n", #"-", #"l", #"i", #"n", #"e", #"a", #"r", #" ",
                  #"t", #"e", #"r", #"m", #"s"]))
          q)
        (fn x => Inl (snd x)))
  (fn _ =>
    catch_errora
      (bindb (check_lhss_more lQ q)
        (fn _ =>
          bindb (check_sl_Q (A2_, A3_) (D2_, D4_, D5_, D7_) ld lQ q)
            (fn _ =>
              bindb (check_lab_all
                       (set (ceq_prod (ceq_term A2_ D4_) (ceq_term A2_ D4_),
                              ccompare_prod (ccompare_term A1_ D3_)
                                (ccompare_term A1_ D3_),
                              set_impl_prod set_impl_term set_impl_term)
                         lP)
                      p)
                (fn _ =>
                  bindb (check_lab_all
                           (set (ceq_prod (ceq_term A2_ D4_) (ceq_term A2_ D4_),
                                  ccompare_prod (ccompare_term A1_ D3_)
                                    (ccompare_term A1_ D3_),
                                  set_impl_prod set_impl_term set_impl_term)
                             lPw)
                          pw)
                    (fn _ =>
                      bindb (check_model_lab
                               (set (ceq_prod (ceq_term A2_ D4_)
                                       (ceq_term A2_ D4_),
                                      ccompare_prod (ccompare_term A1_ D3_)
(ccompare_term A1_ D3_),
                                      set_impl_prod set_impl_term set_impl_term)
                                 lR)
                              r)
                        (fn _ =>
                          bindb (check_model_lab
                                   (set (ceq_prod (ceq_term A2_ D4_)
   (ceq_term A2_ D4_),
  ccompare_prod (ccompare_term A1_ D3_) (ccompare_term A1_ D3_),
  set_impl_prod set_impl_term set_impl_term)
                                     lRw)
                                  rw)
                            (fn _ =>
                              bindb (check_lab_all_trs lR r)
                                (fn _ => check_lab_all_trs lRw rw))))))))
      (fn x =>
        Inl (shows_string
               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"d", #"u",
                 #"r", #"i", #"n", #"g", #" ", #"l", #"a", #"b", #"e", #"l",
                 #"i", #"n", #"g", #":"] o
              (shows_nl o x)))))))
                          end))))
      of Inl a => Inl a | Inr _ => Inr (mkd i nfs m lP lPw lQ lR (lRw @ d)))
  end;

fun eval_lab i l lc alpha (Var x) = (alpha x, Var x)
  | eval_lab i l lc alpha (Fun (f, ts)) =
    let
      val clts = map (eval_lab i l lc alpha) ts;
      val cs = map fst clts;
      val c = i f cs;
      val lts = map snd clts;
    in
      (c, Fun (lc f (size_list ts) (l f cs), lts))
    end;

fun check_sl_rule_ass A_ B_ (D1_, D2_, D3_) (E1_, E2_, E3_) mc i la lc cge lR
  alpha (l, r) =
  let
    val cl_ll = eval_lab i la lc alpha l;
    val cr_lr = eval_lab i la lc alpha r;
  in
    bindb (check (if mc then cge (fst cl_ll) (fst cr_lr) else true)
            (shows_string [#"r", #"u", #"l", #"e", #" "] o
              (shows_rule (shows_prec A_ zero_nata) (shows_prec E3_ zero_nata)
                 [#" ", #"-", #">", #" "] (l, r) o
                (shows_string
                   [#" ", #"v", #"i", #"o", #"l", #"a", #"t", #"e", #"s", #" ",
                     #"t", #"h", #"e", #" ", #"m", #"o", #"d", #"e", #"l", #" ",
                     #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #",",
                     #" ", #"[", #"l", #"h", #"s", #"]", #" ", #"=", #" "] o
                  (shows_prec B_ zero_nata (fst cl_ll) o
                    (shows_string
                       [#",", #" ", #"[", #"r", #"h", #"s", #"]", #" ", #"=",
                         #" "] o
                      shows_prec B_ zero_nata (fst cr_lr)))))))
      (fn _ =>
        check (member
                (ceq_prod (ceq_term D2_ E2_) (ceq_term D2_ E2_),
                  ccompare_prod (ccompare_term D1_ E1_) (ccompare_term D1_ E1_))
                (snd cl_ll, snd cr_lr) lR)
          (shows_string
             [#"l", #"a", #"b", #"e", #"l", #"e", #"d", #" ", #"r", #"u", #"l",
               #"e", #" "] o
            (shows_rule (shows_prec D3_ zero_nata) (shows_prec E3_ zero_nata)
               [#" ", #"-", #">", #" "] (snd cl_ll, snd cr_lr) o
              shows_string [#" ", #"m", #"i", #"s", #"s", #"i", #"n", #"g"])))
  end;

fun check_sl_rule A_ B_ (D1_, D2_, D3_) (E1_, E2_, E3_) i l lc c cge mc lR lr =
  catch_errora
    (forallM
      (fn alpha =>
        check_sl_rule_ass A_ B_ (D1_, D2_, D3_) (E1_, E2_, E3_) mc i l lc cge lR
          alpha lr)
      (map (fun_of E2_) (enum_vectors c (insert_vars_rule E2_ lr []))))
    (fn x => Inl (snd x));

fun check_sl_model_lab_trs_set (A1_, A2_, A3_) B_ (D1_, D2_, D3_) i l c cge labl
  lR r =
  catch_errora
    (forallM
      (check_sl_rule A3_ B_ (A1_, A2_, A3_) (D1_, D2_, D3_) i l labl c cge true
        lR)
      r)
    (fn x => Inl (snd x));

fun check_sl_model_lab_trs (A1_, A2_, A3_) B_ (D1_, D2_, D3_) i l c cge labl lR
  r = check_sl_model_lab_trs_set (A1_, A2_, A3_) B_ (D1_, D2_, D3_) i l c cge
        labl lR r;

fun check_NF_vars_subset A_ (B1_, B2_, B3_) qa q =
  catch_errora
    (forallM
      (fn qaa => check (list_ex (matches A_ B2_ (B1_, B2_, B3_) qaa) q) qaa) qa)
    (fn x => Inl (snd x));

fun flatten_term_enum (Var x) = [Var x]
  | flatten_term_enum (Fun (fs, ts)) =
    let
      val lts = map flatten_term_enum ts;
      val ss = concat_lists lts;
    in
      maps (fn f => map (fn a => Fun (f, a)) ss) fs
    end;

fun lab_lhss_more_impl lc lS_gen q =
  let
    val f_all = (fn (f, n) => map (lc f n) (lS_gen f n));
  in
    maps (fn qa => flatten_term_enum (map_funs_term_wa f_all qa)) q
  end;

fun check_sl_lab_lhss_more (A1_, A2_) (C1_, C2_, C3_, C4_) lc lS_gen lQ q =
  catch_errora
    (check_NF_vars_subset A1_ (C1_, C2_, C3_) (lab_lhss_more_impl lc lS_gen q)
      lQ)
    (fn x =>
      Inl (shows_term (shows_prec A2_ zero_nata) (shows_prec C4_ zero_nata) x o
            shows_prec_list show_char zero_nata
              [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n", #"g",
                #" ", #"i", #"n", #" ", #"l", #"a", #"b", #"e", #"l", #"e",
                #"d", #" ", #"Q"]));

fun sl_check_decr
  (Sl_ops_ext
    (sl_La, sl_LSa, sl_I, sl_C, sl_c, sl_check_decr, sl_L, sl_LS, sl_lgen,
      sl_LS_gen, more))
  = sl_check_decr;

fun lab_root i la l lc alpha (Fun (f, ts)) =
  let
    val clts = map (eval_lab i la lc alpha) ts;
    val cs = map fst clts;
    val a = map snd clts;
  in
    Fun (lc f (size_list ts) (l f cs), a)
  end
  | lab_root uu uv uw ux uy (Var x) = Var x;

fun check_sl_rule_all_ass A_ B_ (D1_, D2_, D3_) (E1_, E2_, E3_) i lb la lc
  gen_smaller lR alpha (l, Fun (f, ts)) =
  let
    val ll = lab_root i lb la lc alpha l;
    val clts = map (eval_lab i lb lc alpha) ts;
    val lts = map snd clts;
    val ld = la f (map fst clts);
    val n = size_list ts;
    val small = gen_smaller ld;
  in
    catch_errora
      (forallM
        (fn le =>
          check (member
                  (ceq_prod (ceq_term D2_ E2_) (ceq_term D2_ E2_),
                    ccompare_prod (ccompare_term D1_ E1_)
                      (ccompare_term D1_ E1_))
                  (ll, Fun (lc f n le, lts)) lR)
            (shows_string
               [#"l", #"a", #"b", #"e", #"l", #"e", #"d", #" ", #"r", #"u",
                 #"l", #"e", #" "] o
              (shows_rule (shows_prec D3_ zero_nata) (shows_prec E3_ zero_nata)
                 [#" ", #"-", #">", #" "] (ll, Fun (lc f n le, lts)) o
                shows_string [#" ", #"m", #"i", #"s", #"s", #"i", #"n", #"g"])))
        small)
      (fn x => Inl (snd x))
  end
  | check_sl_rule_all_ass A_ B_ (D1_, D2_, D3_) (E1_, E2_, E3_) i lb la lc
    gen_smaller lR alpha (l, Var x) =
    let
      val ll = lab_root i lb la lc alpha l;
      val lr = lab_root i lb la lc alpha (Var x);
    in
      check (member
              (ceq_prod (ceq_term D2_ E2_) (ceq_term D2_ E2_),
                ccompare_prod (ccompare_term D1_ E1_) (ccompare_term D1_ E1_))
              (ll, lr) lR)
        (shows_string
           [#"l", #"a", #"b", #"e", #"l", #"e", #"d", #" ", #"r", #"u", #"l",
             #"e", #" "] o
          (shows_rule (shows_prec D3_ zero_nata) (shows_prec E3_ zero_nata)
             [#" ", #"-", #">", #" "] (ll, lr) o
            shows_string [#" ", #"m", #"i", #"s", #"s", #"i", #"n", #"g"]))
    end;

fun check_sl_rule_all A_ B_ (D1_, D2_, D3_) (E1_, E2_, E3_) i la l lc c
  gen_smaller lR lr =
  catch_errora
    (forallM
      (fn alpha =>
        check_sl_rule_all_ass A_ B_ (D1_, D2_, D3_) (E1_, E2_, E3_) i la l lc
          gen_smaller lR alpha lr)
      (map (fun_of E2_) (enum_vectors c (insert_vars_rule E2_ lr []))))
    (fn x => Inl (snd x));

fun check_sl_lab_all_trs A_ B_ (D1_, D2_, D3_) (E1_, E2_, E3_) i la l c gen labl
  lP p =
  catch_errora
    (forallM
      (check_sl_rule_all A_ B_ (D1_, D2_, D3_) (E1_, E2_, E3_) i la l labl c gen
        lP)
      p)
    (fn x => Inl (snd x));

fun check_wf_sym_F_all (C1_, C2_) lc ld ls =
  (fn (lf, n) =>
    let
      val (f, l) = ld lf;
    in
      check (ls f n l andalso eq C1_ lf (lc f n l))
        (shows_prec_list show_char zero_nata
           [#"l", #"a", #"b", #"e", #"l", #"e", #"d", #" ", #"s", #"y", #"m",
             #"b", #"o", #"l", #" "] o
          (shows_prec C2_ zero_nata lf o
            shows_prec_list show_char zero_nata
              [#" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o", #"w", #"e",
                #"d"]))
    end);

fun check_wf_terms_F_all (C1_, C2_) lc ld ls lt =
  let
    val lfs = insert_funas_term C1_ lt [];
  in
    catch_errora (forallM (check_wf_sym_F_all (C1_, C2_) lc ld ls) lfs)
      (fn x => Inl (snd x))
  end;

fun check_Lab_all_trs (A1_, A2_) (C1_, C2_) lc ld ls lR r =
  catch_errora
    (forallM
      (fn (l, ra) =>
        catch_errora
          (bindb (check_wf_terms_F_all (A1_, A2_) lc ld ls ra)
            (fn _ =>
              check (membera
                      (equal_prod (equal_term A1_ C1_) (equal_term A1_ C1_)) r
                      (map_funs_rule (fn lf => fst (ld lf)) (l, ra)))
                (shows_prec_list show_char zero_nata
                  [#"u", #"n", #"l", #"a", #"b", #"e", #"l", #"i", #"n", #"g",
                    #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"r", #"u",
                    #"l", #"e", #" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o",
                    #"t", #" ", #"y", #"i", #"e", #"l", #"d", #" ", #"o", #"r",
                    #"i", #"g", #"i", #"n", #"a", #"l", #" ", #"r", #"u", #"l",
                    #"e"])))
          (fn x =>
            Inl (shows_prec_list show_char zero_nata
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"i",
                     #"t", #"h", #" ", #"l", #"a", #"b", #"e", #"l", #"e", #"d",
                     #" ", #"r", #"u", #"l", #"e"] o
                  (shows_rule (shows_prec A2_ zero_nata)
                     (shows_prec C2_ zero_nata) [#" ", #"-", #">", #" "]
                     (l, ra) o
                    (shows_nl o x)))))
      lR)
    (fn x => Inl (snd x));

fun sl_LS_gen
  (Sl_ops_ext
    (sl_La, sl_LSa, sl_I, sl_C, sl_c, sl_check_decr, sl_L, sl_LS, sl_lgen,
      sl_LS_gen, more))
  = sl_LS_gen;

fun sl_lgen
  (Sl_ops_ext
    (sl_La, sl_LSa, sl_I, sl_C, sl_c, sl_check_decr, sl_L, sl_LS, sl_lgen,
      sl_LS_gen, more))
  = sl_lgen;

fun lge_to_lgr B_ lge ls f n =
  let
    val lSfn = ls f n;
    val lgefn = lge f n;
  in
    (fn l => fn la =>
      not (eq B_ l la) andalso (lSfn l andalso (lSfn la andalso lgefn l la)))
  end;

fun check_sl_decr_rule A_ B_ C_ D_ lc ld ls lge (Fun (lf, ts), Fun (lg, us)) =
  let
    val (f, l1) = ld lf;
    val (g, l2) = ld lg;
    val n = size_list ts;
  in
    eq A_ f g andalso
      (equal_lista (equal_term C_ D_) ts us andalso
        (eq C_ lf (lc f n l1) andalso
          (eq C_ lg (lc f n l2) andalso
            (ls f n l1 andalso
              (ls f n l2 andalso lge_to_lgr B_ lge ls f n l1 l2)))))
  end
  | check_sl_decr_rule A_ B_ C_ D_ uu uv uw ux (Var vb, va) = false
  | check_sl_decr_rule A_ B_ C_ D_ uu uv uw ux (v, Var vb) = false;

fun check_sl_decr A_ B_ (C1_, C2_) (D1_, D2_) lc ld ls lge d =
  catch_errora
    (forallM
      (fn lr =>
        check (check_sl_decr_rule A_ B_ C1_ D1_ lc ld ls lge lr)
          (shows_rule (shows_prec C2_ zero_nata) (shows_prec D2_ zero_nata)
             [#" ", #"-", #">", #" "] lr o
            shows_prec_list show_char zero_nata
              [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"d",
                #"e", #"c", #"r", #"e", #"a", #"s", #"i", #"n", #"g", #" ",
                #"r", #"u", #"l", #"e"]))
      d)
    (fn x => Inl (snd x));

fun sl_La
  (Sl_ops_ext
    (sl_La, sl_LSa, sl_I, sl_C, sl_c, sl_check_decr, sl_L, sl_LS, sl_lgen,
      sl_LS_gen, more))
  = sl_L;

fun sl_LS
  (Sl_ops_ext
    (sl_La, sl_LSa, sl_I, sl_C, sl_c, sl_check_decr, sl_L, sl_LS, sl_lgen,
      sl_LS_gen, more))
  = sl_LSa;

fun sl_L
  (Sl_ops_ext
    (sl_La, sl_LSa, sl_I, sl_C, sl_c, sl_check_decr, sl_L, sl_LS, sl_lgen,
      sl_LS_gen, more))
  = sl_La;

fun sl_I
  (Sl_ops_ext
    (sl_La, sl_LSa, sl_I, sl_C, sl_c, sl_check_decr, sl_L, sl_LS, sl_lgen,
      sl_LS_gen, more))
  = sl_I;

fun sl_C
  (Sl_ops_ext
    (sl_La, sl_LSa, sl_I, sl_C, sl_c, sl_check_decr, sl_L, sl_LS, sl_lgen,
      sl_LS_gen, more))
  = sl_C;

fun insert_funas_args_term A_ t fs = foldr (insert_funas_term A_) (args t) fs;

fun insert_funas_args_rule A_ r fs =
  insert_funas_args_term A_ (fst r) (insert_funas_args_term A_ (snd r) fs);

fun insert_funas_args_trs A_ trs = foldr (insert_funas_args_rule A_) trs;

fun option_to_list (SOME a) = [a]
  | option_to_list NONE = [];

fun insert_roots_rule A_ r fs =
  foldr (insertb (equal_prod A_ equal_nat))
    (option_to_list (root (fst r)) @ option_to_list (root (snd r))) fs;

fun insert_roots_trs A_ trs = foldr (insert_roots_rule A_) trs;

fun sem_lab_fin_quasi_root_proc (A1_, A2_, A3_) B_ C_
  (E1_, E2_, E3_, E4_, E5_, E6_, E7_) lc ld cge lge i gen lPAll lQ lRAll dp =
  let
    val pairs = pairsb i dp;
  in
    bindb (gen (list_union (equal_prod A2_ equal_nat)
                 (insert_funas_trs A2_ (rulese i dp) [])
                 (insert_funas_args_trs A2_ pairs []))
            (insert_roots_trs A2_ pairs []))
      (fn ops =>
        let
          val check_d = sl_check_decr ops;
          val check_da =
            check_sl_decr A2_ B_ (A2_, A3_) (E4_, E7_) lc ld (sl_LS ops) lge;
          val check_q =
            check_sl_lab_lhss_more (A2_, A3_) (E2_, E4_, E5_, E7_) lc
              (sl_LS_gen ops);
          val check_ml =
            check_sl_model_lab_trs (A1_, A2_, A3_) C_ (E3_, E4_, E7_) (sl_I ops)
              (sl_L ops) (sl_C ops) cge lc;
          val check_l =
            check_sl_lab_all_trs A3_ C_ (A1_, A2_, A3_) (E3_, E4_, E7_)
              (sl_I ops) (sl_L ops) (sl_La ops) (sl_C ops) (sl_lgen ops) lc;
          val check_la =
            check_Lab_all_trs (A2_, A3_) (E4_, E7_) lc ld (sl_LS ops);
        in
          sem_lab_quasi_root_proc (A1_, A2_, A3_)
            (E1_, E2_, E3_, E4_, E5_, E6_, E7_) ld i (Inr ()) check_d check_da
            check_q check_l check_la check_ml lPAll lQ lRAll dp
        end)
  end;

fun check_sl_rule_root A_ B_ (D1_, D2_, D3_) (E1_, E2_, E3_) i la l lc c lR lr =
  catch_errora
    (forallM
      (fn alpha =>
        let
          val laa = lab_root i la l lc alpha;
          val lb = laa (fst lr);
          val r = laa (snd lr);
        in
          check (member
                  (ceq_prod (ceq_term D2_ E2_) (ceq_term D2_ E2_),
                    ccompare_prod (ccompare_term D1_ E1_)
                      (ccompare_term D1_ E1_))
                  (lb, r) lR)
            (shows_prec_list show_char zero_nata
               [#"l", #"a", #"b", #"e", #"l", #"e", #"d", #" ", #"r", #"u",
                 #"l", #"e", #" "] o
              (shows_rule (shows_prec D3_ zero_nata) (shows_prec E3_ zero_nata)
                 [#" ", #"-", #">", #" "] (lb, r) o
                shows_prec_list show_char zero_nata
                  [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n",
                    #"g"]))
        end)
      (map (fun_of E2_) (enum_vectors c (insert_vars_rule E2_ lr []))))
    (fn x => Inl (snd x));

fun check_sl_lab_root_trs A_ B_ (D1_, D2_, D3_) (E1_, E2_, E3_) i la l c labl lP
  p = catch_errora
        (forallM
          (check_sl_rule_root A_ B_ (D1_, D2_, D3_) (E1_, E2_, E3_) i la l labl
            c lP)
          p)
        (fn x => Inl (snd x));

fun sem_lab_root_proc (A1_, A2_, A3_) (D1_, D2_, D3_, D4_, D5_) ld i valid
  check_Q check_laba check_lab check_model_lab lPAll lQ lRAll dpp =
  let
    val r = rd i dpp;
    val rw = rwd i dpp;
    val pw = pwb i dpp;
    val p = pb i dpp;
    val nfs = nfsc i dpp;
    val m = minimal i dpp;
    val (lP, (lPw, _)) =
      model_splitter (A1_, A2_) (D2_, D3_) ld lPAll
        (set (ceq_prod (ceq_term A2_ D3_) (ceq_term A2_ D3_),
               ccompare_prod (ccompare_term A1_ D2_) (ccompare_term A1_ D2_),
               set_impl_prod set_impl_term set_impl_term)
          pw);
    val (lR, (lRw, _)) =
      model_splitter (A1_, A2_) (D2_, D3_) ld lRAll
        (set (ceq_prod (ceq_term A2_ D3_) (ceq_term A2_ D3_),
               ccompare_prod (ccompare_term A1_ D2_) (ccompare_term A1_ D2_),
               set_impl_prod set_impl_term set_impl_term)
          rw);
  in
    (case bindb valid
            (fn _ =>
              bindb (catch_errora
                      (forallM
                        (fn (l, ra) =>
                          bindb (check_no_var A3_ D5_ l)
                            (fn _ =>
                              bindb (check_no_var A3_ D5_ ra)
                                (fn _ =>
                                  check_no_defined_root A3_ D5_
                                    (fn fna =>
                                      not (null (rules_mapc i dpp fna)))
                                    ra)))
                        (pairsb i dpp))
                      (fn x => Inl (snd x)))
                (fn _ =>
                  bindb (catch_errora
                          (forallM (fn (l, _) => check_no_var A3_ D5_ l)
                            (rulese i dpp))
                          (fn x => Inl (snd x)))
                    (fn _ =>
                      let
                        val q = qc i dpp;
                      in
                        catch_errora
                          (bindb
                            (check
                              (if nfs
                                then (if not (q_emptyc i dpp)
                                       then wwf_rulesa i dpp else true)
                                else true)
                              (shows_prec_list show_char zero_nata
                                [#"w", #"e", #"l", #"l", #" ", #"f", #"o", #"r",
                                  #"m", #"e", #"d", #"n", #"e", #"s", #"s",
                                  #" ", #"r", #"e", #"q", #"u", #"i", #"r",
                                  #"e", #"d"]))
                            (fn _ =>
                              bindb (check_Q lQ q)
                                (fn _ =>
                                  bindb (check_sl_Q (A2_, A3_)
  (D1_, D3_, D4_, D5_) ld lQ q)
                                    (fn _ =>
                                      bindb
(check_laba
   (set (ceq_prod (ceq_term A2_ D3_) (ceq_term A2_ D3_),
          ccompare_prod (ccompare_term A1_ D2_) (ccompare_term A1_ D2_),
          set_impl_prod set_impl_term set_impl_term)
     lP)
  p)
(fn _ =>
  bindb (check_laba
           (set (ceq_prod (ceq_term A2_ D3_) (ceq_term A2_ D3_),
                  ccompare_prod (ccompare_term A1_ D2_) (ccompare_term A1_ D2_),
                  set_impl_prod set_impl_term set_impl_term)
             lPw)
          pw)
    (fn _ =>
      bindb (check_model_lab
               (set (ceq_prod (ceq_term A2_ D3_) (ceq_term A2_ D3_),
                      ccompare_prod (ccompare_term A1_ D2_)
                        (ccompare_term A1_ D2_),
                      set_impl_prod set_impl_term set_impl_term)
                 lR)
              r)
        (fn _ =>
          bindb (check_model_lab
                   (set (ceq_prod (ceq_term A2_ D3_) (ceq_term A2_ D3_),
                          ccompare_prod (ccompare_term A1_ D2_)
                            (ccompare_term A1_ D2_),
                          set_impl_prod set_impl_term set_impl_term)
                     lRw)
                  rw)
            (fn _ => bindb (check_lab lR r) (fn _ => check_lab lRw rw)))))))))
                          (fn x =>
                            Inl (shows_string
                                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                     #" ", #"d", #"u", #"r", #"i", #"n", #"g",
                                     #" ", #"l", #"a", #"b", #"e", #"l", #"i",
                                     #"n", #"g", #":"] o
                                  (shows_nl o x)))
                      end)))
      of Inl a => Inl a | Inr _ => Inr (mkd i nfs m lP lPw lQ lR lRw))
  end;

fun lab_rule_ass i l lc alpha rule =
  (snd (eval_lab i l lc alpha (fst rule)),
    snd (eval_lab i l lc alpha (snd rule)));

fun lab_rule_list E_ i l lc c lr =
  map (fn alpha => lab_rule_ass i l lc alpha lr)
    (map (fun_of E_) (enum_vectors c (insert_vars_rule E_ lr [])));

fun lab_trs_list E_ i l lc c r = maps (lab_rule_list E_ i l lc c) r;

fun check_sl_lab (A1_, A2_) (D1_, D2_) i l lc c lR r =
  bindb (check (not (null c))
          (shows_prec_list show_char zero_nata
            [#"c", #"a", #"r", #"r", #"i", #"e", #"r", #" ", #"m", #"u", #"s",
              #"t", #" ", #"b", #"e", #" ", #"n", #"o", #"n", #"-", #"e", #"m",
              #"p", #"t", #"y"]))
    (fn _ =>
      catch_errora
        (check_subseteq (equal_prod (equal_term A1_ D1_) (equal_term A1_ D1_))
          lR (lab_trs_list D1_ i l lc c r))
        (fn x =>
          Inl (shows_prec_list show_char zero_nata
                 [#"l", #"a", #"b", #"e", #"l", #"e", #"d", #" ", #"r", #"u",
                   #"l", #"e", #" "] o
                (shows_rule (shows_prec A2_ zero_nata)
                   (shows_prec D2_ zero_nata) [#" ", #"-", #">", #" "] x o
                  shows_prec_list show_char zero_nata
                    [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l",
                      #"l", #"o", #"w", #"e", #"d"]))));

fun lab_lhs_list E_ i l lc c t =
  map (fn alpha => snd (eval_lab i l lc alpha t))
    (map (fun_of E_) (enum_vectors c (insert_vars_term E_ t [])));

fun lab_lhss_list E_ i l lc c q = maps (lab_lhs_list E_ i l lc c) q;

fun check_sl_Qa (A1_, A2_) (D1_, D2_, D3_, D4_) i l lc c lQ q =
  bindb (check (not (null c))
          (shows_prec_list show_char zero_nata
            [#"c", #"a", #"r", #"r", #"i", #"e", #"r", #" ", #"m", #"u", #"s",
              #"t", #" ", #"b", #"e", #" ", #"n", #"o", #"n", #"-", #"e", #"m",
              #"p", #"t", #"y"]))
    (fn _ =>
      catch_errora
        (check_NF_vars_subset A1_ (D1_, D2_, D3_) (lab_lhss_list D2_ i l lc c q)
          lQ)
        (fn x =>
          Inl (shows_prec_list show_char zero_nata
                 [#"l", #"a", #"b", #"e", #"l", #"e", #"d", #" ", #"t", #"e",
                   #"r", #"m", #" "] o
                (shows_term (shows_prec A2_ zero_nata)
                   (shows_prec D4_ zero_nata) x o
                  shows_prec_list show_char zero_nata
                    [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n",
                      #"g"]))));

fun sem_lab_fin_root_proc (A1_, A2_, A3_) (D1_, D2_, D3_, D4_, D5_) (E1_, E2_)
  lc ld i gen lPAll lQ lRAll dp =
  let
    val pairs = pairsb i dp;
  in
    bindb (gen (list_union (equal_prod A2_ equal_nat)
                 (insert_funas_trs A2_ (rulese i dp) [])
                 (insert_funas_args_trs A2_ pairs []))
            (insert_roots_trs A2_ pairs []))
      (fn ops =>
        let
          val check_q =
            check_sl_Qa (A2_, A3_) (D1_, D3_, D4_, D5_) (sl_I ops) (sl_L ops) lc
              (sl_C ops);
          val check_ml =
            check_sl_model_lab_trs (A1_, A2_, A3_) E2_ (D2_, D3_, D5_)
              (sl_I ops) (sl_L ops) (sl_C ops) (eq E1_) lc;
          val check_l =
            check_sl_lab_root_trs A3_ E2_ (A1_, A2_, A3_) (D2_, D3_, D5_)
              (sl_I ops) (sl_L ops) (sl_La ops) (sl_C ops) lc;
          val check_la =
            check_sl_lab (A2_, A3_) (D3_, D5_) (sl_I ops) (sl_L ops) lc
              (sl_C ops);
        in
          sem_lab_root_proc (A1_, A2_, A3_) (D1_, D2_, D3_, D4_, D5_) ld i
            (Inr ()) check_q check_l check_la check_ml lPAll lQ lRAll dp
        end)
  end;

fun slm_La (Slm_ops_ext (slm_La, slm_I, slm_C, slm_c, slm_L, more)) = slm_L;

fun slm_c (Slm_ops_ext (slm_La, slm_I, slm_C, slm_c, slm_L, more)) = slm_c;

fun slm_L (Slm_ops_ext (slm_La, slm_I, slm_C, slm_c, slm_L, more)) = slm_La;

fun slm_I (Slm_ops_ext (slm_La, slm_I, slm_C, slm_c, slm_L, more)) = slm_I;

fun slm_C (Slm_ops_ext (slm_La, slm_I, slm_C, slm_c, slm_L, more)) = slm_C;

fun slm_to_sl ops =
  Sl_ops_ext
    (slm_L ops, (fn _ => fn _ => fn _ => true), slm_I ops, slm_C ops, slm_c ops,
      (fn _ => Inr ()), slm_La ops, (fn _ => fn _ => fn _ => true),
      (fn l => [l]), (fn _ => fn _ => []), ());

fun slm_gen_to_sl_gen gen =
  (fn f => fn g => bindb (gen f g) (fn ops => Inr (slm_to_sl ops)));

fun check_sl_lab_trs_set (A1_, A2_, A3_) B_ (D1_, D2_, D3_) i l c cge labl lP p
  = catch_errora
      (forallM
        (check_sl_rule A3_ B_ (A1_, A2_, A3_) (D1_, D2_, D3_) i l labl c cge
          false lP)
        p)
      (fn x => Inl (snd x));

fun check_sl_lab_trs (A1_, A2_, A3_) B_ (D1_, D2_, D3_) i l c cge labl lP p =
  check_sl_lab_trs_set (A1_, A2_, A3_) B_ (D1_, D2_, D3_) i l c cge labl lP p;

fun sem_lab_proc (A1_, A2_, A3_) (D1_, D2_, D3_, D4_, D5_) ld i valid check_Q
  check_laba check_lab check_model_lab lPAll lQ lRAll dpp =
  let
    val r = rd i dpp;
    val rw = rwd i dpp;
    val pw = pwb i dpp;
    val p = pb i dpp;
    val nfs = nfsc i dpp;
    val m = minimal i dpp;
    val (lP, (lPw, _)) =
      model_splitter (A1_, A2_) (D2_, D3_) ld lPAll
        (set (ceq_prod (ceq_term A2_ D3_) (ceq_term A2_ D3_),
               ccompare_prod (ccompare_term A1_ D2_) (ccompare_term A1_ D2_),
               set_impl_prod set_impl_term set_impl_term)
          pw);
    val (lR, (lRw, _)) =
      model_splitter (A1_, A2_) (D2_, D3_) ld lRAll
        (set (ceq_prod (ceq_term A2_ D3_) (ceq_term A2_ D3_),
               ccompare_prod (ccompare_term A1_ D2_) (ccompare_term A1_ D2_),
               set_impl_prod set_impl_term set_impl_term)
          rw);
  in
    (case bindb valid
            (fn _ =>
              let
                val q = qc i dpp;
              in
                catch_errora
                  (bindb
                    (check
                      (if nfs
                        then (if not (q_emptyc i dpp) then wwf_rulesa i dpp
                               else true)
                        else true)
                      (shows_prec_list show_char zero_nata
                        [#"w", #"e", #"l", #"l", #" ", #"f", #"o", #"r", #"m",
                          #"e", #"d", #"n", #"e", #"s", #"s", #" ", #"r", #"e",
                          #"q", #"u", #"i", #"r", #"e", #"d"]))
                    (fn _ =>
                      bindb (check_Q lQ q)
                        (fn _ =>
                          bindb (check_sl_Q (A2_, A3_) (D1_, D3_, D4_, D5_) ld
                                  lQ q)
                            (fn _ =>
                              bindb (check_laba
                                       (set
 (ceq_prod (ceq_term A2_ D3_) (ceq_term A2_ D3_),
   ccompare_prod (ccompare_term A1_ D2_) (ccompare_term A1_ D2_),
   set_impl_prod set_impl_term set_impl_term)
 lP)
                                      p)
                                (fn _ =>
                                  bindb (check_laba
   (set (ceq_prod (ceq_term A2_ D3_) (ceq_term A2_ D3_),
          ccompare_prod (ccompare_term A1_ D2_) (ccompare_term A1_ D2_),
          set_impl_prod set_impl_term set_impl_term)
     lPw)
  pw)
                                    (fn _ =>
                                      bindb
(check_model_lab
   (set (ceq_prod (ceq_term A2_ D3_) (ceq_term A2_ D3_),
          ccompare_prod (ccompare_term A1_ D2_) (ccompare_term A1_ D2_),
          set_impl_prod set_impl_term set_impl_term)
     lR)
  r)
(fn _ =>
  bindb (check_model_lab
           (set (ceq_prod (ceq_term A2_ D3_) (ceq_term A2_ D3_),
                  ccompare_prod (ccompare_term A1_ D2_) (ccompare_term A1_ D2_),
                  set_impl_prod set_impl_term set_impl_term)
             lRw)
          rw)
    (fn _ => bindb (check_lab lR r) (fn _ => check_lab lRw rw)))))))))
                  (fn x =>
                    Inl (shows_string
                           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                             #"d", #"u", #"r", #"i", #"n", #"g", #" ", #"l",
                             #"a", #"b", #"e", #"l", #"i", #"n", #"g", #":"] o
                          (shows_nl o x)))
              end)
      of Inl a => Inl a | Inr _ => Inr (mkd i nfs m lP lPw lQ lR lRw))
  end;

fun sem_lab_fin_proc (A1_, A2_, A3_) (D1_, D2_, D3_, D4_, D5_) (E1_, E2_) lc ld
  i gen lPAll lQ lRAll dp =
  bindb (gen (list_union (equal_prod A2_ equal_nat)
               (insert_funas_trs A2_ (rulese i dp) [])
               (insert_funas_args_trs A2_ (pairsb i dp) []))
          [])
    (fn ops =>
      let
        val check_q =
          check_sl_Qa (A2_, A3_) (D1_, D3_, D4_, D5_) (sl_I ops) (sl_L ops) lc
            (sl_C ops);
        val check_ml =
          check_sl_model_lab_trs (A1_, A2_, A3_) E2_ (D2_, D3_, D5_) (sl_I ops)
            (sl_L ops) (sl_C ops) (eq E1_) lc;
        val check_l =
          check_sl_lab_trs (A1_, A2_, A3_) E2_ (D2_, D3_, D5_) (sl_I ops)
            (sl_L ops) (sl_C ops) (eq E1_) lc;
        val check_la =
          check_sl_lab (A2_, A3_) (D3_, D5_) (sl_I ops) (sl_L ops) lc
            (sl_C ops);
      in
        sem_lab_proc (A1_, A2_, A3_) (D1_, D2_, D3_, D4_, D5_) ld i (Inr ())
          check_q check_l check_la check_ml lPAll lQ lRAll dp
      end);

fun get_largest_element (SL_Inter (n, uu)) = n;

fun take_default def [] uu = def
  | take_default uv (x :: xs) i =
    (if equal_nata i zero_nata then x
      else take_default uv xs (minus_nata i one_nata));

fun eval_arithFun c nats f = modulo_nata (eval_arithFun_unbound c nats f) c
and eval_arithFun_unbound c nats (Arg i) = take_default zero_nata nats i
  | eval_arithFun_unbound c nats (Const n) = n
  | eval_arithFun_unbound c nats (Sum []) = zero_nata
  | eval_arithFun_unbound c nats (Sum (f :: fs)) =
    plus_nata (eval_arithFun c nats f) (eval_arithFun c nats (Sum fs))
  | eval_arithFun_unbound c nats (Prod []) = one_nata
  | eval_arithFun_unbound c nats (Prod (f :: fs)) =
    times_nata (eval_arithFun c nats f) (eval_arithFun c nats (Prod fs))
  | eval_arithFun_unbound c nats (Max [f]) = eval_arithFun c nats f
  | eval_arithFun_unbound c nats (Max (f :: v :: va)) =
    max ord_nat (eval_arithFun c nats f) (eval_arithFun c nats (Max (v :: va)))
  | eval_arithFun_unbound c nats (Min [f]) = eval_arithFun c nats f
  | eval_arithFun_unbound c nats (Min (f :: v :: va)) =
    min ord_nat (eval_arithFun c nats f) (eval_arithFun c nats (Min (v :: va)))
  | eval_arithFun_unbound c nats (IfEqual (f1, f2, ft, fe)) =
    (if equal_nata (eval_arithFun c nats f1) (eval_arithFun c nats f2)
      then eval_arithFun c nats ft else eval_arithFun c nats fe);

fun sl_inter_to_inter A_ (SL_Inter (c, ls)) fl cs =
  (case map_of (equal_prod A_ equal_nat) ls (fl, size_list cs)
    of NONE => zero_nata | SOME a => eval_arithFun (suc c) cs a);

fun sli_to_slm A_ sli =
  let
    val c = get_largest_element sli;
  in
    Slm_ops_ext
      ((fn _ => Inl),
        sl_inter_to_inter (equal_lab A_ (equal_list equal_nat)) sli,
        upt zero_nata (suc c), c, (fn _ => Inl), ())
  end;

fun enum_vectors_nat c n =
  (if equal_nata n zero_nata then [[]]
    else let
           val a = enum_vectors_nat c (minus_nata n one_nata);
         in
           maps (fn vec => map (fn ca => ca :: vec) c) a
         end);

fun qmodel_check_interpretation f n c =
  let
    val ca = upt zero_nata (suc c);
    val css = enum_vectors_nat ca n;
  in
    catch_errora
      (forallM
        (fn cs =>
          catch_errora
            (forallM
              (fn i =>
                catch_errora
                  (forallM
                    (fn l =>
                      check (less_eq_nat (eval_arithFun (suc c) cs f)
                              (eval_arithFun (suc c) (list_update cs i l) f))
                        (shows_prec_list show_char zero_nata
                           [#"n", #"o", #"t", #" ", #"m", #"o", #"n", #"o",
                             #"t", #"o", #"n", #"e", #" ", #"i", #"n", #" "] o
                          (shows_prec_nat zero_nata (suc i) o
                            shows_prec_list show_char zero_nata
                              [#".", #" ", #"a", #"r", #"g", #"u", #"m", #"e",
                                #"n", #"t"])))
                    (upt (nth cs i) (suc c)))
                  (fn x => Inl (snd x)))
              (upt zero_nata n))
            (fn x => Inl (snd x)))
        css)
      (fn x => Inl (snd x))
  end;

fun qmodel_check_valid A_ (SL_Inter (c, ls)) =
  catch_errora
    (forallM
      (fn (a, b) =>
        let
          val (f, n) = a;
        in
          (fn g =>
            catch_errora (qmodel_check_interpretation g n c)
              (fn x =>
                Inl (shows_prec_list show_char zero_nata
                       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i",
                         #"n", #" ", #"w", #"e", #"a", #"k", #"-", #"m", #"o",
                         #"n", #"o", #"t", #"o", #"n", #"i", #"c", #"i", #"t",
                         #"y", #" ", #"o", #"f", #" ", #"i", #"n", #"t", #"e",
                         #"r", #"p", #"r", #"e", #"t", #"a", #"t", #"i", #"o",
                         #"n", #" ", #"o", #"f", #" "] o
                      (shows_prec A_ zero_nata f o (shows_nl o x)))))
        end
          b)
      ls)
    (fn x => Inl (snd x));

fun check_decr_present_aux_1 A_ (B1_, B2_, B3_) r v f1 f2 n =
  let
    val vs = map (fn na => Var (v, na)) (upt zero_nata n);
    val rule = (Fun (f1, vs), Fun (f2, vs));
  in
    check (not (is_none
                 (find (instance_rule A_ (equal_prod B2_ equal_nat)
                         (ccompare_prod B1_ ccompare_nat,
                           equal_prod B2_ equal_nat,
                           mapping_impl_prod B3_ mapping_impl_nat)
                         rule)
                   r)))
      rule
  end;

fun check_decr_present_aux_2 A_ (B1_, B2_, B3_) r v req =
  let
    val add_nats = map_term (fn x => x) (fn va => (va, zero_nata));
    val ra = map (fn (l, ra) => (add_nats l, add_nats ra)) r;
  in
    catch_errora
      (forallM
        (fn (f1, a) =>
          let
            val (aa, b) = a;
          in
            check_decr_present_aux_1 A_ (B1_, B2_, B3_) ra v f1 aa b
          end)
        req)
      (fn x => Inl (snd x))
  end;

fun check_decr_present A_ (B1_, B2_, B3_) siga l v c r =
  let
    val ca = upt zero_nata (suc c);
    val ls =
      (fn (f, n) =>
        maps (fn cs =>
               maps (fn i =>
                      let
                        val ci = nth cs i;
                      in
                        (if less_nat ci c
                          then [(l f (list_update cs i (suc ci)), (l f cs, n))]
                          else [])
                      end)
                 (upt zero_nata n))
          (enum_vectors_nat ca n));
  in
    check_decr_present_aux_2 A_ (B1_, B2_, B3_) r v (maps ls siga)
  end;

fun qmodel_check_decr (A1_, A2_) (B1_, B2_, B3_) siga v c =
  (fn lR =>
    catch_errora
      (check_decr_present (equal_lab A1_ (equal_list equal_nat)) (B1_, B2_, B3_)
        siga (fn a => fn b => Lab (a, b)) v c lR)
      (fn x =>
        Inl let
              val display =
                map_term (fn xa => xa)
                  (fn (_, n) =>
                    (shows_prec_list show_char zero_nata [#"x"] o
                      shows_prec_nat zero_nata n)
                      []);
            in
              shows_prec_list show_char zero_nata
                [#"d", #"e", #"c", #"r", #"e", #"a", #"s", #"i", #"n", #"g",
                  #" ", #"r", #"u", #"l", #"e", #" "] o
                (shows_rule (shows_prec_lab A2_ (show_list show_nat) zero_nata)
                   (shows_prec_list show_char zero_nata)
                   [#" ", #"-", #">", #" "] (display (fst x), display (snd x)) o
                  shows_prec_list show_char zero_nata
                    [#" ", #"m", #"i", #"s", #"s", #"i", #"n", #"g"])
            end));

fun qmodel_LS_gen A_ siga ls =
  (fn f => fn n =>
    (if membera (equal_prod A_ equal_nat) siga (f, n)
      then map Inl (enum_vectors_nat ls n) else [Inl []]));

fun pointwise_lgen ns = concat_lists (map (fn n => upt zero_nata (suc n)) ns);

fun qmodel_lgen l =
  (case l of Inl ns => map Inl (pointwise_lgen ns) | Inr _ => []);

fun qmodel_LSa x =
  (fn _ => fn _ => fn a => (case a of Inl _ => true | Inr _ => false)) x;

fun qmodel_LS A_ B_ C_ siga ls =
  (fn f => fn n =>
    membera (equal_sum (equal_list B_) C_) (qmodel_LS_gen A_ siga ls f n));

fun qmodel_L A_ B_ siga =
  (fn f => fn cs =>
    (if membera (equal_prod (equal_lab A_ B_) equal_nat) siga (f, size_list cs)
      then Inl cs else Inl []));

fun qsli_to_sl_unsafe (A1_, A2_, A3_) (B1_, B2_) v f g sli =
  let
    val c = get_largest_element sli;
    val ca = upt zero_nata (suc c);
  in
    Sl_ops_ext
      (qmodel_L B1_ (equal_list equal_nat) f,
        qmodel_LS (equal_lab B1_ (equal_list equal_nat)) equal_nat
          (equal_list (equal_lab B1_ (equal_list equal_nat))) f ca,
        sl_inter_to_inter (equal_lab B1_ (equal_list equal_nat)) sli, ca, c,
        qmodel_check_decr (B1_, B2_) (A1_, A2_, A3_) f v c,
        qmodel_L B1_ (equal_list equal_nat) g, qmodel_LSa, qmodel_lgen,
        qmodel_LS_gen (equal_lab B1_ (equal_list equal_nat)) f ca, ())
  end;

fun qsli_to_sl (A1_, A2_, A3_) (B1_, B2_) v f g sli =
  bindb (qmodel_check_valid (show_lab B2_ (show_list show_nat)) sli)
    (fn _ => Inr (qsli_to_sl_unsafe (A1_, A2_, A3_) (B1_, B2_) v f g sli));

fun pointwise_ext f [] [] = (false, true)
  | pointwise_ext f (uu :: uv) [] = (false, false)
  | pointwise_ext f [] (uw :: ux) = (false, false)
  | pointwise_ext f (a :: asa) (b :: bs) =
    (case f a b
      of (stri, true) =>
        (case pointwise_ext f asa bs
          of (strir, true) => (stri orelse strir, true)
          | (_, false) => (false, false))
      | (_, false) => (false, false));

fun qmodel_lge f n =
  (fn l => fn r =>
    (case (l, r)
      of (Inl cs1, Inl cs2) =>
        snd (pointwise_ext (fn x => fn y => (less_nat y x, less_eq_nat y x)) cs1
              cs2)
      | (Inl _, Inr _) => false | (Inr _, _) => false));

fun qmodel_cge x = (fn xa => fn y => less_eq_nat y xa) x;

fun rl_slm A_ B_ delt_opt pre_fs g =
  let
    val fs =
      (if is_none delt_opt then pre_fs
        else filtera
               (fn f =>
                 not (equal_proda (equal_lab A_ B_) equal_nat f (the delt_opt)))
               pre_fs);
  in
    bindb (check (not (null fs))
            (shows_string
               [#"r", #"o", #"o", #"t", #"-", #"l", #"a", #"b", #"e", #"l",
                 #"i", #"n", #"g", #" ", #"r", #"e", #"q", #"u", #"i", #"r",
                 #"e", #"s", #" ", #"a", #"t", #" ", #"l", #"e", #"a", #"s",
                 #"t", #" ", #"o", #"n", #"e", #" ", #"f", #"u", #"n", #"c",
                 #"t", #"i", #"o", #"n", #" ", #"s", #"y", #"m", #"b", #"o",
                 #"l", #" ", #"i", #"n", #" ", #"t", #"h", #"e", #" ", #"s",
                 #"i", #"g", #"n", #"a", #"t", #"u", #"r", #"e"] o
              shows_nl))
      (fn _ =>
        let
          val f = fst (hda fs);
        in
          Inr (Slm_ops_ext
                ((fn _ => Inr),
                  (fn ga => fn cs =>
                    (if membera (equal_prod (equal_lab A_ B_) equal_nat) fs
                          (ga, size_list cs)
                      then ga else f)),
                  map fst fs, f,
                  (if is_none delt_opt then (fn _ => Inr)
                    else (fn _ => fn gs =>
                           Inr (replicate (size_list gs)
                                 (fst (the delt_opt))))),
                  ()))
        end)
  end;

fun semlab_fin_proc (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_) j
  (Rootlab NONE) =
  sem_lab_fin_proc
    (compare_lab B1_ (compare_list compare_nat),
      equal_lab B2_ (equal_list equal_nat), show_lab B3_ (show_list show_nat))
    (C2_, C3_, C4_, C5_, C7_)
    (equal_lab B2_ (equal_list equal_nat), show_lab B3_ (show_list show_nat))
    label label_decomp j
    (slm_gen_to_sl_gen (rl_slm B2_ (equal_list equal_nat) NONE))
  | semlab_fin_proc (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_) j
    (Rootlab (SOME d)) =
    sem_lab_fin_root_proc
      (compare_lab B1_ (compare_list compare_nat),
        equal_lab B2_ (equal_list equal_nat), show_lab B3_ (show_list show_nat))
      (C2_, C3_, C4_, C5_, C7_)
      (equal_lab B2_ (equal_list equal_nat), show_lab B3_ (show_list show_nat))
      label label_decomp j
      (slm_gen_to_sl_gen (rl_slm B2_ (equal_list equal_nat) (SOME d)))
  | semlab_fin_proc (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_) j
    (Finitelab sli) =
    sem_lab_fin_proc
      (compare_lab B1_ (compare_list compare_nat),
        equal_lab B2_ (equal_list equal_nat), show_lab B3_ (show_list show_nat))
      (C2_, C3_, C4_, C5_, C7_) (equal_nat, show_nat) label label_decomp j
      (slm_gen_to_sl_gen (fn _ => fn _ => Inr (sli_to_slm B2_ sli)))
  | semlab_fin_proc (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_) j
    (QuasiFinitelab (sli, v)) =
    sem_lab_fin_quasi_root_proc
      (compare_lab B1_ (compare_list compare_nat),
        equal_lab B2_ (equal_list equal_nat), show_lab B3_ (show_list show_nat))
      (equal_sum (equal_list equal_nat)
        (equal_list (equal_lab B2_ (equal_list equal_nat))))
      show_nat (C1_, C2_, C3_, C4_, C5_, C6_, C7_) label label_decomp qmodel_cge
      qmodel_lge j
      (fn f => fn g => qsli_to_sl (C2_, C4_, C5_) (B2_, B3_) v f g sli);

fun all_terms_impl (A1_, A2_) rr initt =
  remdups
    (equal_prod (equal_list (equal_term A1_ (equal_list equal_char)))
      (equal_term A1_ (equal_list equal_char)))
    (map (fn (ss, (t, _)) => (ss, t)) initt @
      map (fn (l, a) => (args l, a)) rr);

fun all_subterms_impl (A1_, A2_) rr initt =
  remdups
    (equal_prod (equal_list (equal_term A1_ (equal_list equal_char)))
      (equal_term A1_ (equal_list equal_char)))
    (maps (fn (ss, s) => map (fn a => (ss, a)) (supteq_list s))
      (all_terms_impl (A1_, A2_) rr initt));

fun everything_impl (A1_, A2_) rr initt =
  map Inl
    (maps (fn (ss, t) =>
            map (fn lr => (ss, (t, lr)))
              (remdups
                (equal_prod (equal_term A1_ (equal_list equal_char))
                  (equal_term A1_ (equal_list equal_char)))
                (map (snd o snd) initt)))
      (all_subterms_impl (A1_, A2_) rr initt)) @
    remdups
      (equal_sum
        (equal_prod (equal_list (equal_term A1_ (equal_list equal_char)))
          (equal_prod (equal_term A1_ (equal_list equal_char))
            (equal_prod (equal_term A1_ (equal_list equal_char))
              (equal_term A1_ (equal_list equal_char)))))
        (equal_prod (equal_prod A1_ equal_nat) equal_nat))
      (map Inr
        (maps (fn t =>
                (if not (is_Var t)
                  then maps (fn (f, ts) =>
                              map (fn a => ((f, size_list ts), a))
                                (upt zero_nata (size_list ts)))
                         let
                           val Fun (f, ts) = t;
                         in
                           [(f, ts)]
                         end
                  else []))
          (remdups (equal_term A1_ (equal_list equal_char))
            (map snd (all_subterms_impl (A1_, A2_) rr initt)))));

fun generate_impl (A1_, A2_) B_ C_ rr nfq e_cap uu (Inr v) = []
  | generate_impl (A1_, A2_) B_ C_ rr nfq e_cap uu (Inl (va, (Var ve, vd))) = []
  | generate_impl (A1_, A2_) B_ C_ rr nfq e_cap uu
    (Inl (ss, (Fun (f, ts), (l, r)))) =
    maps (fn i =>
           (if membera (equal_prod B_ C_) (uu ss (nth ts i)) (l, r)
             then map (fn u => u)
                    [Inl (ss, (nth ts i, (l, r))), Inr ((f, size_list ts), i)]
             else []))
      (upt zero_nata (size_list ts)) @
      maps (fn (la, ra) =>
             maps (fn mss =>
                    (if rule_match_impl A1_ nfq (e_cap mss) mss f
                          (map (map_term (fn x => x) (fn a => #"x" :: a)) ts) la
                      then (if membera (equal_prod B_ C_) (uu (args la) ra)
                                 (l, r)
                             then [Inl (args la, (ra, (l, r)))] else [])
                      else []))
               [map (map_term (fn x => x) (fn a => #"x" :: a)) ss])
        rr;

fun mu_approx_impl (A1_, A2_) rr initt u_impl nfq e_cap =
  let
    val uu =
      precompute_fun
        (key_prod
          (key_list
            (equal_term A1_ (equal_list equal_char),
              key_term A2_ (key_list (equal_char, key_char))))
          (key_term A2_ (key_list (equal_char, key_char))))
        (fn (a, b) => u_impl a b) (all_subterms_impl (A1_, A2_) rr initt);
    val uua = (fn s => fn t => uu (s, t));
    val fis =
      remdups (equal_prod (equal_prod A1_ equal_nat) equal_nat)
        (maps (fn entry =>
                map (fn fi => fi) (case entry of Inl _ => [] | Inr fi => [fi]))
          (inductive_set_impl
            (equal_sum
              (equal_prod (equal_list (equal_term A1_ (equal_list equal_char)))
                (equal_prod (equal_term A1_ (equal_list equal_char))
                  (equal_prod (equal_term A1_ (equal_list equal_char))
                    (equal_term A1_ (equal_list equal_char)))))
              (equal_prod (equal_prod A1_ equal_nat) equal_nat))
            (equal_sum
              (equal_prod (equal_list (equal_term A1_ (equal_list equal_char)))
                (equal_prod (equal_term A1_ (equal_list equal_char))
                  (equal_prod (equal_term A1_ (equal_list equal_char))
                    (equal_term A1_ (equal_list equal_char)))))
              (equal_prod (equal_prod A1_ equal_nat) equal_nat))
            (everything_impl (A1_, A2_) rr initt)
            (equal_suma
              (equal_prod (equal_list (equal_term A1_ (equal_list equal_char)))
                (equal_prod (equal_term A1_ (equal_list equal_char))
                  (equal_prod (equal_term A1_ (equal_list equal_char))
                    (equal_term A1_ (equal_list equal_char)))))
              (equal_prod (equal_prod A1_ equal_nat) equal_nat))
            (generate_impl (A1_, A2_) (equal_term A1_ (equal_list equal_char))
              (equal_term A1_ (equal_list equal_char)) rr nfq e_cap uua)
            (map Inl initt)));
    val fs = remdups (equal_prod A1_ equal_nat) (map fst fis);
    val mu =
      (fn f =>
        set (ceq_nat, ccompare_nat, set_impl_nat)
          (map_filter
            (fn x =>
              (if let
                    val (g, _) = x;
                  in
                    equal_proda A1_ equal_nat g f
                  end
                then SOME (snd x) else NONE))
            fis));
  in
    (fs, (precompute_fun (key_prod A2_ key_nat) mu fs,
           [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"U",
             #"R", #"M", #" ", #"w", #"r", #"t", #".", #" ", #"s", #"p", #"e",
             #"c", #"i", #"f", #"i", #"c", #" ", #"r", #"u", #"l", #"e", #"s"]))
  end;

fun inn_usable_rules_wf (A1_, A2_) nfq e_cap r nfs =
  (fn (ss, t) =>
    (if nfs orelse
          list_all
            (fn x => list_ex (contains_var_term (equal_list equal_char) x) ss)
            (remdups (equal_list equal_char) (vars_term_list t))
      then ur_calc_singleton (A1_, A2_) nfq e_cap r (ss, t) else r));

fun inn_usable_rules_wf_dpp (B1_, B2_) i d nfs =
  inn_usable_rules_wf (B1_, B2_) (is_QNFc i d) (icap_impl_dpp B1_ i d)
    (rulese i d) nfs;

fun get_innermost_strict_repl_map_dpp (B1_, B2_) i d s =
  let
    val r = rulese i d;
    val p = pairsb i d;
    val isNF = is_QNFc i d;
    val u = inn_usable_rules_wf_dpp (B1_, B2_) i d true;
    val a = icap_impl_dpp B1_ i d;
  in
    mu_approx_impl (B1_, B2_) r
      (maps (fn (sa, t) => map (fn lr => ([sa], (t, lr))) s) p)
      (fn ss => fn t => u (ss, t)) isNF a
  end;

fun show_position_set f s =
  shows_list_nat
    (maps (fn i => (if member (ceq_nat, ccompare_nat) i s then [suc i] else []))
      (upt zero_nata (snd f)));

fun mono_af
  (Redtriple_ext
    (valid, s, ns, nst, af, mono_af, mono, desc, not_ws_ns, cpx, more))
  = mono_af;

fun mono_urm_redpair_proc (B1_, B2_, B3_) i rp premove rremove dpp =
  (case catch_errora
          let
            val (ps, pns) = split_pairsa i dpp premove;
            val (rs, rns) = split_rulesc i dpp rremove;
            val r = rulese i dpp;
            val _ = qc i dpp;
            val p = pairsb i dpp;
          in
            bindb (check_wf_trs B3_ (equal_list equal_char, show_list show_char)
                    p)
              (fn _ =>
                bindb (check_wf_trs B3_
                        (equal_list equal_char, show_list show_char) r)
                  (fn _ =>
                    bindb (check (nFQ_subset_NF_rulesc i dpp)
                            (shows_prec_list show_char zero_nata
                              [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s",
                                #"t", #" ", #"r", #"e", #"q", #"u", #"i", #"r",
                                #"e", #"d"]))
                      (fn _ =>
                        let
                          val (fs, (mu, info)) =
                            get_innermost_strict_repl_map_dpp (B1_, B2_) i dpp
                              rs;
                        in
                          bindb (valid rp)
                            (fn _ =>
                              let
                                val mua = mono_af rp;
                              in
                                bindb (catch_errora
(catch_errora
  (forallM
    (fn f =>
      check (subset (card_UNIV_nat, cenum_nat, ceq_nat, ccompare_nat) (mu f)
              (mua f))
        (shows_string
           [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"m", #"o",
             #"n", #"o", #"t", #"o", #"n", #"i", #"c", #"i", #"t", #"y", #":",
             #" ", #"s", #"t", #"r", #"i", #"c", #"t", #" ", #"o", #"r", #"d",
             #"e", #"r", #" ", #"f", #"o", #"r", #" "] o
          (shows_prec_prod B3_ show_nat zero_nata f o
            (shows_string
               [#" ", #"e", #"n", #"s", #"u", #"r", #"e", #"s", #" ", #"m",
                 #"o", #"n", #"o", #"t", #"o", #"n", #"i", #"c", #"i", #"t",
                 #"y", #" ", #"i", #"n", #" ", #"p", #"o", #"s", #"i", #"t",
                 #"i", #"o", #"n", #"s", #" "] o
              (show_position_set f (mua f) o
                (shows_string
                   [#"\n", #"b", #"u", #"t", #" ", #"u", #"s", #"a", #"b", #"l",
                     #"e", #" ", #"r", #"e", #"p", #"l", #"a", #"c", #"e", #"m",
                     #"e", #"n", #"t", #" ", #"m", #"a", #"p", #" ", #"i", #"s",
                     #" "] o
                  show_position_set f (mu f)))))))
    fs)
  (fn x => Inl (snd x)))
(fn x =>
  Inl (x o (shows_string
              [#"\n", #"t", #"h", #"e", #" ", #"c", #"o", #"m", #"p", #"u",
                #"t", #"e", #"d", #" ", #"u", #"s", #"a", #"b", #"l", #"e",
                #" ", #"r", #"e", #"p", #"l", #"a", #"c", #"e", #"m", #"e",
                #"n", #"t", #" ", #"m", #"a", #"p", #" ", #"("] o
             (shows_string info o
               (shows_string [#")", #" ", #"i", #"s", #"\n"] o
                 (shows_sep
                    (fn f =>
                      shows_prec_list show_char zero_nata [#"m", #"u", #"("] o
                        (shows_prec_prod B3_ show_nat zero_nata f o
                          (shows_prec_list show_char zero_nata
                             [#")", #" ", #"=", #" "] o
                            show_position_set f (mu f))))
                    shows_nl fs o
                   shows_prec_list show_char zero_nata
                     [#"\n", #"a", #"n", #"d", #" ", #"m", #"u", #"(", #"f",
                       #")", #" ", #"=", #" ", #"{", #"}", #" ", #"f", #"o",
                       #"r", #" ", #"a", #"l", #"l", #" ", #"o", #"t", #"h",
                       #"e", #"r", #" ", #"s", #"y", #"m", #"b", #"o", #"l",
                       #"s", #" ", #"f"])))))))
                                  (fn _ =>
                                    bindb (catch_errora
    (catch_errora (forallM (ns rp) rns) (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_string
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
               #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g",
               #" ", #"T", #"R", #"S"] o
            (shows_nl o x))))
                                      (fn _ =>
bindb (catch_errora (catch_errora (forallM (s rp) rs) (fn x => Inl (snd x)))
        (fn x =>
          Inl (shows_string
                 [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h",
                   #"e", #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i",
                   #"n", #"g", #" ", #"T", #"R", #"S"] o
                (shows_nl o x))))
  (fn _ =>
    bindb (catch_errora
            (catch_errora (forallM (ns rp) pns) (fn x => Inl (snd x)))
            (fn x =>
              Inl (shows_string
                     [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w",
                       #"h", #"e", #"n", #" ", #"o", #"r", #"i", #"e", #"n",
                       #"t", #"i", #"n", #"g", #" ", #"D", #"P", #"s"] o
                    (shows_nl o x))))
      (fn _ =>
        catch_errora (catch_errora (forallM (s rp) ps) (fn x => Inl (snd x)))
          (fn x =>
            Inl (shows_string
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h",
                     #"e", #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i",
                     #"n", #"g", #" ", #"D", #"P", #"s"] o
                  (shows_nl o x)))))))
                              end)
                        end)))
          end
          (fn x =>
            Inl (shows_string
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"a", #"p", #"p", #"l", #"y", #" ", #"t", #"h", #"e", #" ",
                     #"r", #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n", #" ",
                     #"p", #"a", #"i", #"r", #" ", #"p", #"r", #"o", #"c", #"e",
                     #"s", #"s", #"o", #"r", #" ", #"w", #"i", #"t", #"h", #" ",
                     #"u", #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"e", #"p",
                     #"l", #".", #" ", #"m", #"a", #"p", #"s", #" ", #"a", #"n",
                     #"d", #" ", #"t", #"h", #"e", #" ", #"f", #"o", #"l", #"l",
                     #"o", #"w", #"i", #"n", #"g"] o
                  (shows_nl o (desc rp o (shows_nl o x)))))
    of Inl a => Inl a
    | Inr _ =>
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove
            rremove));

fun partition_rules A_ B_ cs r =
  partition
    (fn lr =>
      list_ex
        (fn (u, v) =>
          list_ex
            (fn c =>
              equal_proda (equal_term A_ B_) (equal_term A_ B_) lr
                (ctxt_apply_term c u, ctxt_apply_term c v))
            (Hole :: cs))
        r);

fun strip_unary_root A_ f (Fun (g, [t])) =
  (if eq A_ f g then t else Fun (g, [t]))
  | strip_unary_root A_ f (Var v) = Var v
  | strip_unary_root A_ f (Fun (v, [])) = Fun (v, [])
  | strip_unary_root A_ f (Fun (v, vb :: vd :: ve)) = Fun (v, vb :: vd :: ve);

fun has_unary_root A_ f (Fun (g, [t])) = eq A_ f g
  | has_unary_root A_ f (Var v) = false
  | has_unary_root A_ f (Fun (v, [])) = false
  | has_unary_root A_ f (Fun (v, vb :: vd :: ve)) = false;

fun unblock_term A_ f (Fun (g, ts)) =
  (if list_all (has_unary_root A_ f) ts
    then Fun (g, map (strip_unary_root A_ f) ts) else Fun (g, ts))
  | unblock_term A_ f (Var v) = Var v;

fun unblock_rule A_ f r =
  (unblock_term A_ f (fst r), unblock_term A_ f (snd r));

fun partition_pairs A_ B_ f p =
  partition
    (fn r =>
      membera (equal_prod (equal_term A_ B_) (equal_term A_ B_)) p
        (unblock_rule A_ f r));

fun check_no_defined_root_defined (A1_, A2_) B_ f t =
  check (not (membera (equal_prod A1_ equal_nat) f (the (root t))))
    (shows_string
       [#"t", #"h", #"e", #" ", #"r", #"o", #"o", #"t", #" ", #"o", #"f",
         #" "] o
      (shows_prec_term A2_ B_ zero_nata t o
        shows_string
          [#" ", #"i", #"s", #" ", #"d", #"e", #"f", #"i", #"n", #"e", #"d"]));

fun block_term f (Var x) = Var x
  | block_term f (Fun (g, ts)) = Fun (g, map (fn t => Fun (f, [t])) ts);

fun block_rule f r = (block_term f (fst r), block_term f (snd r));

fun check_superset_of_blocked (A1_, A2_) (B1_, B2_) f pa p =
  catch_errora
    (catch_errora
      (catch_errora
        (forallM
          (fn x =>
            (if membera (equal_prod (equal_term A1_ B1_) (equal_term A1_ B1_))
                  pa (block_rule f x)
              then Inr () else Inl x))
          p)
        (fn x => Inl (snd x)))
      (fn x =>
        Inl (shows_string
               [#"t", #"h", #"e", #" ", #"r", #"u", #"l", #"e", #" "] o
              (shows_rule (shows_prec A2_ zero_nata) (shows_prec B2_ zero_nata)
                 [#" ", #"-", #">", #" "] (block_rule f x) o
                (shows_string
                   [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n",
                     #"g"] o
                  shows_nl)))))
    (fn x =>
      Inl (shows_trs (shows_prec A2_ zero_nata) (shows_prec B2_ zero_nata)
             [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s", #"y", #"s",
               #"t", #"e", #"m", #":"]
             [#" ", #"-", #">", #" "] p o
            (shows_string
               [#"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"s",
                 #"u", #"b", #"s", #"e", #"t", #" ", #"o", #"f"] o
              (shows_trs (shows_prec A2_ zero_nata) (shows_prec B2_ zero_nata)
                 [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s", #"y",
                   #"s", #"t", #"e", #"m", #":"]
                 [#" ", #"-", #">", #" "] pa o
                (x o shows_nl)))));

fun hole_at A_ n i f (More (g, ss1, Hole, ss2)) =
  eq A_ g f andalso
    (equal_nata (size_list ss1) i andalso
      equal_nata (size_list ss2) (minus_nata (minus_nata n i) one_nata))
  | hole_at A_ n i f Hole = false
  | hole_at A_ n i f (More (v, va, More (vd, ve, vf, vg), vc)) = false;

fun check_flat_ctxt_complete (A1_, A2_) B_ fcs fa =
  check (all_interval_nat
          (fn i => list_ex (hole_at A1_ (snd fa) i (fst fa)) fcs) zero_nata
          (snd fa))
    (shows_string
       [#"t", #"h", #"e", #" ", #"l", #"i", #"s", #"t", #" ", #"o", #"f", #" ",
         #"f", #"l", #"a", #"t", #" ", #"c", #"o", #"n", #"t", #"e", #"x", #"t",
         #"s", #" ", #"i", #"s", #" ", #"i", #"n", #"c", #"o", #"m", #"p", #"l",
         #"e", #"t", #"e"] o
      shows_nl);

fun check_rule_reflecting (A1_, A2_) (B1_, B2_) fcs rs rule =
  check (list_ex
          (fn (l, r) =>
            list_ex
              (fn c =>
                equal_terma A1_ B1_ (fst rule) (ctxt_apply_term c l) andalso
                  equal_terma A1_ B1_ (snd rule) (ctxt_apply_term c r))
              (Hole :: fcs))
          rs)
    (shows_string [#"t", #"h", #"e", #" ", #"r", #"u", #"l", #"e", #" "] o
      (shows_rule (shows_prec A2_ zero_nata) (shows_prec B2_ zero_nata)
         [#" ", #"-", #">", #" "] rule o
        (shows_string
           [#" ", #"i", #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r",
             #" ", #"c", #"o", #"n", #"t", #"a", #"i", #"n", #"e", #"d", #" ",
             #"i", #"n", #" ", #"t", #"h", #"e", #" ", #"o", #"r", #"i", #"g",
             #"i", #"n", #"a", #"l", #" ", #"s", #"e", #"t", #" ", #"o", #"f",
             #" ", #"r", #"u", #"l", #"e", #"s", #" ", #"n", #"o", #"r", #" ",
             #"o", #"b", #"t", #"a", #"i", #"n", #"e", #"d", #" ", #"b", #"y",
             #" ", #"a", #"p", #"p", #"l", #"y", #"i", #"n", #"g", #" ", #"a",
             #" ", #"f", #"l", #"a", #"t", #" ", #"c", #"o", #"n", #"t", #"e",
             #"x", #"t"] o
          shows_nl)));

fun check_rule_preserving (A1_, A2_) (B1_, B2_, B3_, B4_) fcs rs rule =
  check (list_ex (instance_rule A1_ B2_ (B1_, B2_, B3_) rule) rs orelse
          list_all
            (fn c =>
              list_ex
                (instance_rule A1_ B2_ (B1_, B2_, B3_)
                  (ctxt_apply_term c (fst rule), ctxt_apply_term c (snd rule)))
                rs)
            fcs)
    (shows_string [#"t", #"h", #"e", #" ", #"r", #"u", #"l", #"e", #" "] o
      (shows_rule (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
         [#" ", #"-", #">", #" "] rule o
        (shows_string
           [#" ", #"i", #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r",
             #" ", #"c", #"o", #"n", #"t", #"a", #"i", #"n", #"e", #"d", #" ",
             #"i", #"n", #" ", #"t", #"h", #"e", #" ", #"r", #"e", #"s", #"u",
             #"l", #"t", #"i", #"n", #"g", #" ", #"s", #"e", #"t", #" ", #"o",
             #"f", #" ", #"r", #"u", #"l", #"e", #"s", #" ", #"n", #"o", #"r",
             #" ", #"c", #"l", #"o", #"s", #"e", #"d", #" ", #"u", #"n", #"d",
             #"e", #"r", #" ", #"a", #"l", #"l", #" ", #"f", #"l", #"a", #"t",
             #" ", #"c", #"o", #"n", #"t", #"e", #"x", #"t", #"s"] o
          shows_nl)));

fun is_flat_ctxt_list A_ B_ vs fas (More (f, ss1, Hole, ss2)) =
  let
    val ss = ss1 @ ss2;
  in
    membera (equal_prod B_ equal_nat) fas (f, suc (size_list ss)) andalso
      (list_all is_Var ss andalso
        (distinct (equal_term B_ A_) ss andalso
          null (list_inter A_ (map the_Var ss) vs)))
  end
  | is_flat_ctxt_list A_ B_ vs fas Hole = false
  | is_flat_ctxt_list A_ B_ vs fas (More (v, va, More (vd, ve, vf, vg), vc)) =
    false;

fun shows_prec_ctxt A_ B_ p c =
  shows_ctxt (shows_prec A_ zero_nata) (shows_prec B_ zero_nata) c;

fun check_is_flat_ctxt (A1_, A2_) (B1_, B2_) vs fas c =
  check (is_flat_ctxt_list A1_ B1_ vs fas c)
    (shows_prec_ctxt B2_ A2_ zero_nata c o
      (shows_string
         [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"f",
           #"l", #"a", #"t", #" ", #"c", #"o", #"n", #"t", #"e", #"x", #"t"] o
        shows_nl));

fun check_flat_ctxt (A1_, A2_) (B1_, B2_) vs c =
  (case c
    of Hole =>
      Inl (shows_prec_ctxt B2_ A2_ zero_nata c o
            (shows_string
               [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ",
                 #"f", #"l", #"a", #"t", #" ", #"c", #"o", #"n", #"t", #"e",
                 #"x", #"t"] o
              shows_nl))
    | More (_, ss1, Hole, ss2) =>
      let
        val ss = ss1 @ ss2;
      in
        bindb (check (distinct (equal_term B1_ A1_) ss)
                (shows_prec_ctxt B2_ A2_ zero_nata c o
                  (shows_string
                     [#" ", #"c", #"o", #"n", #"t", #"a", #"i", #"n", #"s",
                       #" ", #"d", #"u", #"p", #"l", #"i", #"c", #"a", #"t",
                       #"e", #" ", #"v", #"a", #"r", #"i", #"a", #"b", #"l",
                       #"e", #"s"] o
                    shows_nl)))
          (fn _ =>
            bindb (check (list_all is_Var ss)
                    (shows_prec_ctxt B2_ A2_ zero_nata c o
                      (shows_string
                         [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"f",
                           #"l", #"a", #"t", #",", #" ", #"i", #".", #"e", #".",
                           #",", #" ", #"h", #"a", #"s", #" ", #"d", #"e", #"p",
                           #"t", #"h", #" ", #"g", #"r", #"e", #"a", #"t", #"e",
                           #"r", #" ", #"t", #"h", #"a", #"n", #" ", #"o", #"n",
                           #"e"] o
                        shows_nl)))
              (fn _ =>
                check (list_all (fn t => not (membera A1_ vs (the_Var t)))
                        (ss1 @ ss2))
                  (shows_prec_ctxt B2_ A2_ zero_nata c o
                    (shows_string
                       [#" ", #"h", #"a", #"s", #" ", #"t", #"o", #" ", #"c",
                         #"o", #"n", #"t", #"a", #"i", #"n", #" ", #"o", #"n",
                         #"l", #"y", #" ", #"f", #"r", #"e", #"s", #"h", #" ",
                         #"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #"s"] o
                      shows_nl))))
      end
    | More (_, _, More (_, _, _, _), _) =>
      Inl (shows_prec_ctxt B2_ A2_ zero_nata c o
            (shows_string
               [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ",
                 #"f", #"l", #"a", #"t", #" ", #"c", #"o", #"n", #"t", #"e",
                 #"x", #"t"] o
              shows_nl)));

fun shows_terms funa var name ts =
  shows_prec_list show_char zero_nata name o shows_nl o
    shows_list_gen (shows_term funa var) [] [] [#"\n"] [] ts o
    shows_nl;

fun shows_dpp funa var i d =
  let
    val m = minimal i d;
    val nfs = nfsc i d;
    val p = pb i d;
    val pw = pwb i d;
    val r = rd i d;
    val rw = rwd i d;
    val q = qc i d;
  in
    shows_trs funa var [#"p", #"a", #"i", #"r", #"s", #":"]
      [#" ", #"-", #">", #" "] p o
      ((if null pw then id
         else shows_trs funa var
                [#"w", #"e", #"a", #"k", #" ", #"p", #"a", #"i", #"r", #"s",
                  #":"]
                [#" ", #"-", #">", #"=", #" "] pw) o
        ((if null r then id
           else shows_trs funa var
                  [#"s", #"t", #"r", #"i", #"c", #"t", #" ", #"r", #"u", #"l",
                    #"e", #"s", #":"]
                  [#" ", #"-", #">", #"!", #" "] r) o
          (shows_trs funa var [#"r", #"u", #"l", #"e", #"s", #":"]
             [#" ", #"-", #">", #" "] rw o
            ((if null q then id
               else shows_terms funa var
                      [#"Q", #"-", #"c", #"o", #"m", #"p", #"o", #"n", #"e",
                        #"n", #"t", #":"]
                      q) o
              ((if m then shows_nl o
                            shows_prec_list show_char zero_nata
                              [#"(", #"m", #"i", #"n", #"i", #"m", #"a", #"l",
                                #")"]
                 else id) o
                (if nfs andalso not (null q)
                  then shows_nl o
                         shows_prec_list show_char zero_nata
                           [#"(", #"n", #"o", #"r", #"m", #"a", #"l", #" ",
                             #"f", #"o", #"r", #"m", #" ", #"s", #"u", #"b",
                             #"s", #"t", #"i", #"t", #"u", #"t", #"i", #"o",
                             #"n", #"s", #")"]
                  else id))))))
  end;

fun fcc_proc_cond (B1_, B2_) (C1_, C2_, C3_, C4_) i f fcs p pw r rw dpp =
  let
    val pa = pb i dpp;
    val pwa = pwb i dpp;
    val ra = rd i dpp;
    val rwa = rwd i dpp;
    val nfs = nfsc i dpp;
    val m = minimal i dpp;
    val new_dpp = mkd i nfs m p pw [] r rw;
  in
    (case catch_errora
            let
              val pba =
                list_union
                  (equal_prod (equal_term B1_ C2_) (equal_term B1_ C2_)) pa pwa;
              val rb =
                list_union
                  (equal_prod (equal_term B1_ C2_) (equal_term B1_ C2_)) ra rwa;
              val rba =
                list_union
                  (equal_prod (equal_term B1_ C2_) (equal_term B1_ C2_)) r rw;
              val fa = (f, one_nata);
              val cf = More (f, [], Hole, []);
              val fcsa = cf :: fcs;
              val vs = vars_trs_list rb;
              val fs =
                list_union (equal_prod B1_ equal_nat) (funas_trs_list rb)
                  (funas_args_trs_list pba);
              val fas = fa :: fs;
              val ds = defined_list rb;
            in
              bindb (check (not (membera (equal_prod B1_ equal_nat) ds fa))
                      (shows_prec B2_ zero_nata f o
                        (shows_string
                           [#"i", #"s", #" ", #"n", #"o", #"t", #" ", #"f",
                             #"r", #"e", #"s", #"h"] o
                          shows_nl)))
                (fn _ =>
                  bindb (check_wf_trs B2_ (C2_, C4_) rb)
                    (fn _ =>
                      bindb (catch_errora
                              (forallM
                                (fn rc =>
                                  bindb (check_no_var B2_ C4_ (fst rc))
                                    (fn _ =>
                                      bindb (check_no_var B2_ C4_ (snd rc))
(fn _ => check_no_defined_root_defined (B1_, B2_) C4_ ds (snd rc))))
                                pba)
                              (fn x => Inl (snd x)))
                        (fn _ =>
                          bindb (catch_errora
                                  (forallM
                                    (check_flat_ctxt (C2_, C4_) (B1_, B2_) vs)
                                    fcsa)
                                  (fn x => Inl (snd x)))
                            (fn _ =>
                              bindb (catch_errora
                                      (forallM
(check_is_flat_ctxt (C2_, C4_) (B1_, B2_) vs fas) fcsa)
                                      (fn x => Inl (snd x)))
                                (fn _ =>
                                  bindb (catch_errora
  (forallM (check_flat_ctxt_complete (B1_, B2_) C4_ fcsa) fas)
  (fn x => Inl (snd x)))
                                    (fn _ =>
                                      bindb
(catch_errora
  (forallM (check_rule_preserving (B1_, B2_) (C1_, C2_, C3_, C4_) fcsa r) ra)
  (fn x => Inl (snd x)))
(fn _ =>
  bindb (catch_errora
          (forallM
            (check_rule_preserving (B1_, B2_) (C1_, C2_, C3_, C4_) fcsa rba)
            rwa)
          (fn x => Inl (snd x)))
    (fn _ =>
      bindb (catch_errora
              (forallM (check_rule_reflecting (B1_, B2_) (C2_, C4_) fcsa rb)
                rba)
              (fn x => Inl (snd x)))
        (fn _ =>
          bindb (check_superset_of_blocked (B1_, B2_) (C2_, C4_) f p pa)
            (fn _ =>
              check_superset_of_blocked (B1_, B2_) (C2_, C4_) f pw pwa))))))))))
            end
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w",
                       #"h", #"e", #"n", #" ", #"c", #"h", #"e", #"c", #"k",
                       #"i", #"n", #"g", #" ", #"f", #"l", #"a", #"t", #" ",
                       #"c", #"o", #"n", #"t", #"e", #"x", #"t", #" ", #"c",
                       #"l", #"o", #"s", #"u", #"r", #"e", #" ", #"c", #"o",
                       #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s", #" ",
                       #"t", #"o", #" ", #"s", #"w", #"i", #"t", #"c", #"h",
                       #" ", #"f", #"r", #"o", #"m", #" "] o
                    (shows_nl o
                      (shows_dpp (shows_prec B2_ zero_nata)
                         (shows_prec C4_ zero_nata) i dpp o
                        (shows_nl o
                          (shows_prec_list show_char zero_nata
                             [#"t", #"o", #" ", #"t", #"h", #"e", #" ", #"D",
                               #"P", #" ", #"p", #"r", #"o", #"b", #"l", #"e",
                               #"m", #" "] o
                            (shows_nl o
                              (shows_dpp (shows_prec B2_ zero_nata)
                                 (shows_prec C4_ zero_nata) i new_dpp o
                                (shows_nl o x)))))))))
      of Inl a => Inl a | Inr _ => Inr new_dpp)
  end;

fun g_to_list_dflt_basic_oops_rm_basic_ops A_ s =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops A_ s (fn _ => true)
    (fn a => fn b => a :: b) [];

fun delete_rm_basic_ops A_ x s = delete A_ x s;

fun ceta_list_diff A_ xs ys =
  g_to_list_dflt_basic_oops_rm_basic_ops
    ((linorder_compare_order o compare_order_key) A_)
    (foldl (fn a => fn b => delete_rm_basic_ops (compare_order_key A_) b a)
      (g_from_list_dflt_basic_oops_rm_basic_ops (compare_order_key A_) xs) ys);

fun fcc_split_proc (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_) i f fcs
  pba rb ps rs dpp =
  let
    val p = pb i dpp;
    val pw = pwb i dpp;
    val r = rd i dpp;
    val rw = rwd i dpp;
    val q = qc i dpp;
    val nfs = nfsc i dpp;
    val m = minimal i dpp;
    val pbaa =
      list_union (equal_prod (equal_term B1_ C3_) (equal_term B1_ C3_)) p pw;
    val rba = rw;
    val pns =
      ceta_list_diff (key_prod (key_term B2_ C4_) (key_term B2_ C4_)) pbaa ps;
    val rns =
      ceta_list_diff (key_prod (key_term B2_ C4_) (key_term B2_ C4_)) rba rs;
    val (pa, pwa) = partition_pairs B1_ C3_ f ps pba;
    val (ra, rwa) =
      partition_rules B1_ C3_ (More (f, [], Hole, []) :: fcs) rs rb;
    val two =
      mkd i nfs m
        (ceta_list_diff (key_prod (key_term B2_ C4_) (key_term B2_ C4_)) p ps)
        (ceta_list_diff (key_prod (key_term B2_ C4_) (key_term B2_ C4_)) pw ps)
        [] [] rns;
    val dpp_mid = mkd i nfs m ps pns [] rs rns;
  in
    bindb (bindb
            (catch_errora
              (check_subseteq
                (equal_prod (equal_term B1_ C3_) (equal_term B1_ C3_)) ps pbaa)
              (fn x =>
                Inl (shows_prec_list show_char zero_nata
                       [#"p", #"a", #"i", #"r", #" "] o
                      (shows_rule (shows_prec B3_ zero_nata)
                         (shows_prec C7_ zero_nata) [#" ", #"-", #">", #" "] x o
                        shows_prec_list show_char zero_nata
                          [#" ", #"s", #"h", #"o", #"u", #"l", #"d", #" ", #"b",
                            #"e", #" ", #"d", #"e", #"l", #"e", #"t", #"e",
                            #"d", #" ", #"b", #"u", #"t", #" ", #"i", #"s",
                            #" ", #"n", #"o", #"t", #" ", #"p", #"r", #"e",
                            #"s", #"e", #"n", #"t"]))))
            (fn _ =>
              bindb (catch_errora
                      (check_subseteq
                        (equal_prod (equal_term B1_ C3_) (equal_term B1_ C3_))
                        rs rba)
                      (fn x =>
                        Inl (shows_prec_list show_char zero_nata
                               [#"r", #"u", #"l", #"e", #" "] o
                              (shows_rule (shows_prec B3_ zero_nata)
                                 (shows_prec C7_ zero_nata)
                                 [#" ", #"-", #">", #" "] x o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"s", #"h", #"o", #"u", #"l", #"d",
                                    #" ", #"b", #"e", #" ", #"d", #"e", #"l",
                                    #"e", #"t", #"e", #"d", #" ", #"b", #"u",
                                    #"t", #" ", #"i", #"s", #" ", #"n", #"o",
                                    #"t", #" ", #"p", #"r", #"e", #"s", #"e",
                                    #"n", #"t"]))))
                (fn _ =>
                  bindb (check (null q)
                          (shows_string
                             [#"Q", #" ", #"i", #"s", #" ", #"n", #"o", #"t",
                               #" ", #"e", #"m", #"p", #"t", #"y"] o
                            shows_nl))
                    (fn _ =>
                      bindb (check (null r)
                              (shows_prec_list show_char zero_nata
                                [#"s", #"t", #"r", #"i", #"c", #"t", #" ", #"r",
                                  #"u", #"l", #"e", #"s", #" ", #"n", #"o",
                                  #"t", #" ", #"a", #"l", #"l", #"o", #"w",
                                  #"e", #"d"]))
                        (fn _ =>
                          bindb (check_left_linear_trs B3_ (C1_, C2_, C6_, C7_)
                                  rw)
                            (fn _ =>
                              fcc_proc_cond (B1_, B3_) (C2_, C3_, C5_, C7_) i f
                                fcs pa pwa ra rwa dpp_mid))))))
      (fn one => Inr (one, two))
  end;

fun mono_redpair_proc B_ C_ i rp premove rremove dpp =
  (case catch_errora
          let
            val (ps, pns) = split_pairsa i dpp premove;
            val (rs, rns) = split_rulesc i dpp rremove;
          in
            bindb (valid rp)
              (fn _ =>
                bindb (catch_errora (mono rp (ps @ rs @ pns @ rns))
                        (fn x =>
                          Inl (shows_string
                                 [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                   #" ", #"w", #"i", #"t", #"h", #" ", #"m",
                                   #"o", #"n", #"o", #"t", #"o", #"n", #"i",
                                   #"c", #"i", #"t", #"y", #" ", #"o", #"f",
                                   #" ", #"s", #"t", #"r", #"i", #"c", #"t",
                                   #" ", #"o", #"r", #"d", #"e", #"r"] o
                                (shows_nl o x))))
                  (fn _ =>
                    bindb (catch_errora
                            (catch_errora (forallM (ns rp) rns)
                              (fn x => Inl (snd x)))
                            (fn x =>
                              Inl (shows_string
                                     [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                       #" ", #"w", #"h", #"e", #"n", #" ", #"o",
                                       #"r", #"i", #"e", #"n", #"t", #"i", #"n",
                                       #"g", #" ", #"T", #"R", #"S"] o
                                    (shows_nl o x))))
                      (fn _ =>
                        bindb (catch_errora
                                (catch_errora (forallM (s rp) rs)
                                  (fn x => Inl (snd x)))
                                (fn x =>
                                  Inl (shows_string
 [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n", #" ",
   #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"T", #"R",
   #"S"] o
(shows_nl o x))))
                          (fn _ =>
                            bindb (catch_errora
                                    (catch_errora (forallM (ns rp) pns)
                                      (fn x => Inl (snd x)))
                                    (fn x =>
                                      Inl
(shows_string
   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n",
     #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"D",
     #"P", #"s"] o
  (shows_nl o x))))
                              (fn _ =>
                                catch_errora
                                  (catch_errora (forallM (s rp) ps)
                                    (fn x => Inl (snd x)))
                                  (fn x =>
                                    Inl (shows_string
   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n",
     #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"D",
     #"P", #"s"] o
  (shows_nl o x))))))))
          end
          (fn x =>
            Inl (shows_string
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"a", #"p", #"p", #"l", #"y", #" ", #"t", #"h", #"e", #" ",
                     #"r", #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n", #" ",
                     #"p", #"a", #"i", #"r", #" ", #"p", #"r", #"o", #"c", #"e",
                     #"s", #"s", #"o", #"r", #" ", #"w", #"i", #"t", #"h", #" ",
                     #"t", #"h", #"e", #" ", #"f", #"o", #"l", #"l", #"o", #"w",
                     #"i", #"n", #"g"] o
                  (shows_nl o (desc rp o (shows_nl o x)))))
    of Inl a => Inl a
    | Inr _ =>
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove
            rremove));

fun instantiation_proc (B1_, B2_, B3_) i st sts dpp =
  (case let
          val ic = icap_impl_dpp_mv B1_ i dpp;
          val isnf = is_QNFc i dpp;
          val (s, t) = st;
          val sy = map_term (fn x => x) (fn a => #"y" :: a) s;
          val ty = map_term (fn x => x) (fn a => #"y" :: a) t;
          val iedg = is_iedg_edge_dpp (B1_, B2_, B3_) i dpp;
        in
          catch_errora
            (forallM
              (fn (u, v) =>
                (case mgu_class B1_ (ic [u] v) s of NONE => Inr ()
                  | SOME mu =>
                    check (not (isnf (subst_apply_term sy mu)) orelse
                            (not (isnf (subst_apply_term
 (map_term (fn x => x) (fn a => #"x" :: a) u) mu)) orelse
                              list_ex
                                (fn sta =>
                                  instance_rule B1_ (equal_list equal_char)
                                    (ccompare_list ccompare_char,
                                      equal_list equal_char, mapping_impl_list)
                                    sta st andalso
                                    instance_rule B1_ (equal_list equal_char)
                                      (ccompare_list ccompare_char,
equal_list equal_char, mapping_impl_list)
                                      (subst_apply_term sy mu,
subst_apply_term ty mu)
                                      sta)
                                sts))
                      (shows_prec_list show_char zero_nata
                         [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                           #" ", #"f", #"i", #"n", #"d", #" ", #"i", #"n", #"s",
                           #"t", #"a", #"n", #"c", #"e", #" ", #"o", #"f", #" ",
                           #"p", #"a", #"i", #"r", #" "] o
                        (shows_rule (shows_prec B3_ zero_nata)
                           (shows_prec_list show_char zero_nata)
                           [#" ", #"-", #">", #" "]
                           (subst_apply_term sy mu, subst_apply_term ty mu) o
                          (shows_nl o
                            (shows_prec_list show_char zero_nata
                               [#"w", #"h", #"i", #"c", #"h", #" ", #"r", #"e",
                                 #"s", #"u", #"l", #"t", #"e", #"d", #" ", #"f",
                                 #"r", #"o", #"m", #" ", #"D", #"P", #" "] o
                              shows_rule (shows_prec B3_ zero_nata)
                                (shows_prec_list show_char zero_nata)
                                [#" ", #"-", #">", #" "] (u, v)))))))
              (filtera (fn (u, v) => iedg (u, v) s) (pairsb i dpp)))
            (fn x => Inl (snd x))
        end
    of Inl a => Inl a | Inr _ => Inr (replace_paira i dpp st sts));

fun intersect_pairsb
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = intersect_pairs;

fun graph_approx_rt_sym_main (A1_, A2_) m (GCFun (f, ts)) =
  lookupc
    (ccompare_option (ccompare_prod A1_ ccompare_nat),
      equal_option (equal_prod A2_ equal_nat))
    m NONE @
    lookupc
      (ccompare_option (ccompare_prod A1_ ccompare_nat),
        equal_option (equal_prod A2_ equal_nat))
      m (SOME (f, size_list ts))
  | graph_approx_rt_sym_main (A1_, A2_) m GCHole = valuesa m;

fun graph_approx_rt_sym (A1_, A2_) m (uu, (uv, (ct, uw))) =
  graph_approx_rt_sym_main (A1_, A2_) m ct;

fun rules_non_collapsinga
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = rules_non_collapsing;

fun reverse_rules_mapb
  (Dpp_ops_ext
    (dpp, p, pw, pairs, q, r, rw, rules, q_empty, rules_no_left_var,
      rules_non_collapsing, is_QNF, nFQ_subset_NF_rules, rules_map,
      reverse_rules_map, intersect_pairs, replace_pair, intersect_rules,
      delete_P_Pw, delete_R_Rw, split_pairs, split_rules, mk, minimal, nfs,
      wwf_rules, more))
  = reverse_rules_map;

fun reverse_tcapRM_dpp B_ C_ i dpp =
  tcapRM B_ C_ (rules_non_collapsinga i dpp) (reverse_rules_mapb i dpp);

fun check_no_back_edges ss candidates add_index g i [] = Inr ()
  | check_no_back_edges ss candidates add_index g i (asa :: cs) =
    bindb (catch_errora
            (forallM
              (fn a =>
                catch_errora (forallM (check_no_edge ss g a) (candidates i a))
                  (fn x => Inl (snd x)))
              asa)
            (fn x => Inl (snd x)))
      (fn _ =>
        check_no_back_edges ss candidates add_index g (foldr add_index asa i)
          cs);

fun check_graph_decomp ss empty_index candidates add_index g rcs =
  bindb (check_no_back_edges ss candidates add_index g empty_index
          (map snd rcs))
    (fn _ =>
      catch_errora
        (forallM (fn c => check_edges ss g c c)
          (map_filter (fn x => (if not (fst x) then SOME (snd x) else NONE))
            rcs))
        (fn x => Inl (snd x)));

fun check_dep_graph_proc (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) i dpp dps =
  let
    val c = tcapRM_dpp B4_ (equal_list equal_char) i dpp;
    val rc = reverse_tcapRM_dpp B4_ (equal_list equal_char) i dpp;
    val iedg = is_iedg_edge_dpp (B4_, B5_, B8_) i dpp;
    val p = pairsb i dpp;
    val r = rulese i dpp;
    val f = funas_trs_list r;
    val gt_fun = mk_gt_fun B4_ r;
    val rm = rules_mapc i dpp;
    val nlv = rules_no_left_vara i dpp;
  in
    bindb (catch_errora
            (check_subseteq
              (equal_prod (equal_term B4_ (equal_list equal_char))
                (equal_term B4_ (equal_list equal_char)))
              p (maps snd dps))
            (fn x =>
              Inl (shows_string
                     [#"D", #"e", #"p", #"e", #"n", #"d", #"e", #"n", #"c",
                       #"y", #" ", #"P", #"a", #"i", #"r", #" "] o
                    (shows_rule (shows_prec B8_ zero_nata)
                       (shows_prec_list show_char zero_nata)
                       [#" ", #"-", #">", #" "] x o
                      (shows_string
                         [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i",
                           #"n", #"g", #" ", #"i", #"n", #" ", #"d", #"e", #"c",
                           #"o", #"m", #"p", #"o", #"s", #"i", #"t", #"i", #"o",
                           #"n"] o
                        shows_nl)))))
      (fn _ =>
        catch_errora
          (check_graph_decomp
            (shows_prec_prod (show_term B8_ (show_list show_char))
               (show_term B8_ (show_list show_char)) zero_nata o
              fst)
            (emptyd
              (ccompare_option (ccompare_prod B3_ ccompare_nat),
                mapping_impl_option (mapping_impl_prod B6_ mapping_impl_nat))
              (root o fst o fst))
            (graph_approx_rt_sym (B3_, B4_))
            (insertd
              (ccompare_option (ccompare_prod B3_ ccompare_nat),
                equal_option (equal_prod B4_ equal_nat)))
            (fn (a, b) =>
              let
                val (aa, ba) = a;
              in
                let
                  val (_, t) = aa;
                in
                  (fn (_, (ct, ict)) => fn (ab, bb) =>
                    let
                      val (u, _) = ab;
                    in
                      (fn (cu, (_, _)) =>
                        matchb B4_ (equal_list equal_char) ct u andalso
                          (matchb B4_ (equal_list equal_char) cu t andalso
                            (ict u andalso
                              not (nonreachable_gtcapRM
                                    (B1_, B2_, B3_,
                                      (compare_compare_order o
compare_order_key)
B5_,
                                      B4_, B7_)
                                    (compare_list compare_char,
                                      equal_list equal_char)
                                    f nlv (not (null r)) gt_fun rm t u))))
                    end
                      bb)
                end
                  ba
              end
                b)
            (map (fn (real, cs) =>
                   (not (is_none real),
                     map (fn (s, t) => ((s, t), (rc s, (c t, iedg (s, t)))))
                       cs))
              dps))
          (fn x =>
            Inl (shows_string
                   [#"o", #"u", #"r", #" ", #"e", #"s", #"t", #"i", #"m", #"a",
                     #"t", #"i", #"o", #"n", #" ", #"(", #"E", #"D", #"G", #"*",
                     #"*", #"*", #" ", #"+", #" ", #"I", #"E", #"D", #"G", #"*",
                     #"*", #"*", #")", #" ", #"c", #"o", #"u", #"l", #"d", #" ",
                     #"n", #"o", #"t", #" ", #"s", #"h", #"o", #"w", #" ", #"t",
                     #"h", #"a", #"t", #" ", #"y", #"o", #"u", #" ", #"h", #"a",
                     #"v", #"e", #" ", #"a", #" ", #"v", #"a", #"l", #"i", #"d",
                     #" ", #"d", #"e", #"c", #"o", #"m", #"p", #"o", #"s", #"i",
                     #"t", #"i", #"o", #"n", #" "] o
                  (shows_string
                     [#"d", #"u", #"e", #" ", #"t", #"o", #" ", #"t", #"h",
                       #"e", #" ", #"f", #"o", #"l", #"l", #"o", #"w", #"i",
                       #"n", #"g", #" ", #"r", #"e", #"a", #"s", #"o", #"n"] o
                    (shows_nl o x)))))
  end;

fun dep_graph_proc (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) i d dps =
  (case check_dep_graph_proc (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) i d dps
    of Inl a => Inl a
    | Inr _ =>
      Inr (map_filter
            (fn x =>
              (if not (is_none (fst x))
                then SOME (the (fst x), intersect_pairsb i d (snd x))
                else NONE))
            dps));

fun check_NF_terms_subset is_Q_nf =
  (fn q =>
    catch_errora
      (forallM (fn x => (if not (is_Q_nf x) then Inr () else Inl x)) q)
      (fn x => Inl (snd x)));

fun check_NF_terms_eq (A1_, A2_) (B1_, B2_, B3_) qa q =
  bindb (check_NF_terms_subset (is_NF_terms (A1_, A2_) (B1_, B2_, B3_) qa) q)
    (fn _ =>
      check_NF_terms_subset (is_NF_terms (A1_, A2_) (B1_, B2_, B3_) q) qa);

fun check_dpp_subsumes (B1_, B2_, B3_) (C1_, C2_, C3_) (D1_, D2_, D3_, D4_) i
  (nfs, (m, (p, (pw, (q, (r, rw)))))) d =
  catch_errora
    let
      val pa = pb i d;
      val pwa = pwb i d;
      val qa = qc i d;
      val ra = rd i d;
      val rwa = rwd i d;
      val nfsa = nfsc i d;
      val ma = minimal i d;
      val pba = p @ pw;
      val rb = ra @ rwa;
      val rba = r @ rw;
    in
      bindb (check (equal_boola ma m)
              (shows_prec_list show_char zero_nata
                [#"i", #"n", #"c", #"o", #"m", #"p", #"a", #"t", #"i", #"b",
                  #"l", #"e", #" ", #"m", #"i", #"n", #"i", #"m", #"a", #"l",
                  #"i", #"t", #"y", #" ", #"f", #"l", #"a", #"g", #"s"]))
        (fn _ =>
          bindb (check (equal_boola nfsa nfs)
                  (shows_prec_list show_char zero_nata
                    [#"i", #"n", #"c", #"o", #"m", #"p", #"a", #"t", #"i", #"b",
                      #"l", #"e", #" ", #"s", #"u", #"b", #"s", #"t", #"i",
                      #"t", #"u", #"t", #"i", #"o", #"n", #"s", #"-", #"i",
                      #"n", #"-", #"n", #"o", #"r", #"m", #"a", #"l", #"-",
                      #"f", #"o", #"r", #"m", #" ", #"f", #"l", #"a", #"g",
                      #"s"]))
            (fn _ =>
              bindb (catch_errora
                      (check_subseteq
                        (equal_prod (equal_term (equal_lab B1_ C1_) D2_)
                          (equal_term (equal_lab B1_ C1_) D2_))
                        pa p)
                      (fn x =>
                        Inl (toomuch [#"p", #"a", #"i", #"r"]
                              (shows_rule (shows_prec_lab B3_ C3_ zero_nata)
                                (shows_prec D4_ zero_nata)
                                [#" ", #"-", #">", #" "] x))))
                (fn _ =>
                  bindb (catch_errora
                          (check_subseteq
                            (equal_prod (equal_term (equal_lab B1_ C1_) D2_)
                              (equal_term (equal_lab B1_ C1_) D2_))
                            pwa pba)
                          (fn x =>
                            Inl (toomuch
                                  [#"w", #"e", #"a", #"k", #" ", #"p", #"a",
                                    #"i", #"r"]
                                  (shows_rule (shows_prec_lab B3_ C3_ zero_nata)
                                    (shows_prec D4_ zero_nata)
                                    [#" ", #"-", #">", #" "] x))))
                    (fn _ =>
                      bindb (catch_errora
                              (check_NF_terms_eq
                                (equal_lab B1_ C1_, key_lab B2_ C2_)
                                (D1_, D2_, D3_) qa q)
                              (fn x =>
                                Inl (shows_prec_list show_char zero_nata
                                       [#"N", #"F", #"(", #"Q", #")", #" ",
 #"d", #"i", #"f", #"f", #"e", #"r", #"s", #" ", #"d", #"u", #"e", #" ", #"t",
 #"o", #" ", #"t", #"e", #"r", #"m", #" "] o
                                      shows_term
(shows_prec_lab B3_ C3_ zero_nata) (shows_prec D4_ zero_nata) x)))
                        (fn _ =>
                          bindb (catch_errora
                                  (check_subseteq
                                    (equal_prod
                                      (equal_term (equal_lab B1_ C1_) D2_)
                                      (equal_term (equal_lab B1_ C1_) D2_))
                                    ra r)
                                  (fn x =>
                                    Inl (toomuch
  [#"s", #"t", #"r", #"i", #"c", #"t", #" ", #"r", #"u", #"l", #"e"]
  (shows_rule (shows_prec_lab B3_ C3_ zero_nata) (shows_prec D4_ zero_nata)
    [#" ", #"-", #">", #" "] x))))
                            (fn _ =>
                              bindb (catch_errora
                                      (check_subseteq
(equal_prod (equal_term (equal_lab B1_ C1_) D2_)
  (equal_term (equal_lab B1_ C1_) D2_))
rb rba)
                                      (fn x =>
Inl (toomuch
      [#"s", #"t", #"r", #"i", #"c", #"t", #"/", #"w", #"e", #"a", #"k", #" ",
        #"r", #"u", #"l", #"e"]
      (shows_rule (shows_prec_lab B3_ C3_ zero_nata) (shows_prec D4_ zero_nata)
        [#" ", #"-", #">", #" "] x))))
                                (fn _ =>
                                  bindb (catch_errora
  (check_subseteq
    (equal_prod (equal_term (equal_lab B1_ C1_) D2_)
      (equal_term (equal_lab B1_ C1_) D2_))
    rba rb)
  (fn x =>
    Inl (missing
          [#"s", #"t", #"r", #"i", #"c", #"t", #"/", #"w", #"e", #"a", #"k",
            #" ", #"r", #"u", #"l", #"e"]
          (shows_rule (shows_prec_lab B3_ C3_ zero_nata)
            (shows_prec D4_ zero_nata) [#" ", #"-", #">", #" "] x))))
                                    (fn _ => Inr ()))))))))
    end
    (fn x =>
      Inl (shows_string
             [#"f", #"i", #"n", #"i", #"t", #"e", #"n", #"e", #"s", #"s", #" ",
               #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"p", #"r", #"o", #"b",
               #"l", #"e", #"m"] o
            (shows_nl o
              (shows_dpp (shows_prec_lab B3_ C3_ zero_nata)
                 (shows_prec D4_ zero_nata) i d o
                (shows_nl o
                  (shows_string
                     [#"m", #"a", #"y", #" ", #"n", #"o", #"t", #" ", #"b",
                       #"e", #" ", #"c", #"o", #"n", #"c", #"l", #"u", #"d",
                       #"e", #"d", #" ", #"f", #"r", #"o", #"m", #" ", #"a",
                       #"s", #"s", #"u", #"m", #"i", #"n", #"g", #" ", #"f",
                       #"i", #"n", #"i", #"t", #"e", #"n", #"e", #"s", #"s",
                       #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"p",
                       #"r", #"o", #"b", #"l", #"e", #"m"] o
                    (shows_nl o
                      (shows_dpp (shows_prec_lab B3_ C3_ zero_nata)
                         (shows_prec D4_ zero_nata) i
                         (mkd i nfs m p pw q r rw) o
                        (shows_nl o (x o shows_nl))))))))));

fun fcc_proc (B1_, B2_) (C1_, C2_, C3_, C4_, C5_, C6_) i f fcs pba rw dpp =
  let
    val p = pb i dpp;
    val q = qc i dpp;
    val r = rd i dpp;
    val (pa, pw) = partition_pairs B1_ C3_ f p pba;
  in
    bindb (check (null q)
            (shows_string
               [#"Q", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"e",
                 #"m", #"p", #"t", #"y"] o
              shows_nl))
      (fn _ =>
        bindb (check (null r)
                (shows_prec_list show_char zero_nata
                  [#"s", #"t", #"r", #"i", #"c", #"t", #" ", #"r", #"u", #"l",
                    #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l",
                    #"o", #"w", #"e", #"d"]))
          (fn _ =>
            bindb (check_left_linear_trs B2_ (C1_, C2_, C5_, C6_) (rwd i dpp))
              (fn _ =>
                fcc_proc_cond (B1_, B2_) (C2_, C3_, C4_, C6_) i f fcs pa pw []
                  rw dpp)))
  end;

fun q_reduction_proc_non_min B_ C_ i q dpp =
  (case catch_errora
          (bindb
            (catch_errora (check_NF_terms_subset (is_QNFc i dpp) q)
              (fn x =>
                Inl (shows_prec_list show_char zero_nata
                       [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #" "] o
                      (shows_prec_term B_ C_ zero_nata x o
                        shows_prec_list show_char zero_nata
                          [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                            #"l", #"l", #"o", #"w", #"e", #"d", #" ", #"i",
                            #"n", #" ", #"Q", #"'", #" "]))))
            (fn _ => Inr ()))
          (fn x =>
            Inl (shows_prec_list show_char zero_nata
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h",
                     #"e", #"n", #" ", #"r", #"e", #"d", #"u", #"c", #"i", #"n",
                     #"g", #" ", #"Q", #" ", #"i", #"n", #" ", #"t", #"h", #"e",
                     #" ", #"D", #"P", #" ", #"p", #"r", #"o", #"b", #"l", #"e",
                     #"m", #" "] o
                  (shows_nl o
                    (shows_dpp (shows_prec B_ zero_nata)
                       (shows_prec C_ zero_nata) i dpp o
                      (shows_nl o
                        (shows_prec_list show_char zero_nata
                           [#"t", #"o", #" ", #"t", #"h", #"e", #" ", #"s",
                             #"e", #"t", #" "] o
                          (shows_nl o
                            (shows_terms (shows_prec B_ zero_nata)
                               (shows_prec C_ zero_nata) [#"Q", #"'", #":"] q o
                              (shows_nl o x)))))))))
    of Inl a => Inl a
    | Inr _ =>
      Inr (mkd i (nfsc i dpp) false (pb i dpp) (pwb i dpp) q (rd i dpp)
            (rwd i dpp)));

fun q_reduction_proc_min_inn (B1_, B2_, B3_) (C1_, C2_, C3_, C4_) i q dpp =
  let
    val pba = pairsb i dpp;
    val rb = rulese i dpp;
    val f = map SOME (funas_trs_list (pba @ rb));
    val qa = qc i dpp;
    val isnf = is_QNFc i dpp;
    val qq = filtera (fn qb => list_all isnf (args qb)) qa;
    val rQ =
      filtera
        (fn qb => membera (equal_option (equal_prod B1_ equal_nat)) f (root qb))
        qq;
  in
    (case catch_errora
            (bindb
              (check (nFQ_subset_NF_rulesc i dpp)
                (shows_prec_list show_char zero_nata
                  [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ",
                    #"r", #"e", #"w", #"r", #"i", #"t", #"i", #"n", #"g", #" ",
                    #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]))
              (fn _ =>
                bindb (check_wf_trs B3_ (C2_, C4_) rb)
                  (fn _ =>
                    bindb (catch_errora
                            (check_NF_terms_subset
                              (is_NF_terms (B1_, B2_) (C1_, C2_, C3_) q) rQ)
                            (fn x =>
                              Inl (shows_prec_list show_char zero_nata
                                     [#"t", #"h", #"e", #" ", #"t", #"e", #"r",
                                       #"m", #" "] o
                                    (shows_prec_term B3_ C4_ zero_nata x o
                                      shows_prec_list show_char zero_nata
[#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n", #"g", #" ", #"i",
  #"n", #" ", #"Q", #"'", #" "]))))
                      (fn _ =>
                        bindb (catch_errora
                                (check_NF_terms_subset
                                  (is_NF_terms (B1_, B2_) (C1_, C2_, C3_) qq) q)
                                (fn x =>
                                  Inl (shows_prec_list show_char zero_nata
 [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #" "] o
(shows_prec_term B3_ C4_ zero_nata x o
  shows_prec_list show_char zero_nata
    [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o",
      #"w", #"e", #"d", #" ", #"i", #"n", #" ", #"Q", #"'", #" "]))))
                          (fn _ =>
                            (if nfsc i dpp then Inr ()
                              else check_varcond_subset B3_ (C2_, C4_) pba))))))
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w",
                       #"h", #"e", #"n", #" ", #"r", #"e", #"d", #"u", #"c",
                       #"i", #"n", #"g", #" ", #"Q", #" ", #"i", #"n", #" ",
                       #"t", #"h", #"e", #" ", #"D", #"P", #" ", #"p", #"r",
                       #"o", #"b", #"l", #"e", #"m", #" "] o
                    (shows_nl o
                      (shows_dpp (shows_prec B3_ zero_nata)
                         (shows_prec C4_ zero_nata) i dpp o
                        (shows_nl o
                          (shows_prec_list show_char zero_nata
                             [#"t", #"o", #" ", #"t", #"h", #"e", #" ", #"s",
                               #"e", #"t", #" "] o
                            (shows_nl o
                              (shows_terms (shows_prec B3_ zero_nata)
                                 (shows_prec C4_ zero_nata) [#"Q", #"'", #":"]
                                 q o
                                (shows_nl o x)))))))))
      of Inl a => Inl a
      | Inr _ =>
        Inr (mkd i (nfsc i dpp) (minimal i dpp) (pb i dpp) (pwb i dpp) q
              (rd i dpp) (rwd i dpp)))
  end;

fun q_reduction_proc (B1_, B2_, B3_) (C1_, C2_, C3_, C4_) i q dpp =
  (case q_reduction_proc_min_inn (B1_, B2_, B3_) (C1_, C2_, C3_, C4_) i q dpp
    of Inl _ => q_reduction_proc_non_min B3_ C4_ i q dpp | Inr a => Inr a);

fun get_fcc_option (Fcc_Proc (f, fcs, pb, rb, prf)) =
  SOME (f, (fcs, (pb, (rb, prf))))
  | get_fcc_option P_is_Empty = NONE
  | get_fcc_option (Subterm_Criterion_Proc (v, va, vb, vc)) = NONE
  | get_fcc_option (Gen_Subterm_Criterion_Proc (v, va, vb)) = NONE
  | get_fcc_option (Redpair_Proc (v, va, vb)) = NONE
  | get_fcc_option (Redpair_UR_Proc (v, va, vb, vc)) = NONE
  | get_fcc_option (Usable_Rules_Proc (v, va)) = NONE
  | get_fcc_option (Dep_Graph_Proc v) = NONE
  | get_fcc_option (Mono_Redpair_Proc (v, va, vb, vc)) = NONE
  | get_fcc_option (Mono_URM_Redpair_Proc (v, va, vb, vc)) = NONE
  | get_fcc_option (Mono_Redpair_UR_Proc (v, va, vb, vc, vd)) = NONE
  | get_fcc_option (Size_Change_Subterm_Proc v) = NONE
  | get_fcc_option (Size_Change_Redpair_Proc (v, va, vb)) = NONE
  | get_fcc_option (Uncurry_Proc (v, va, vb, vc, vd)) = NONE
  | get_fcc_option (Split_Proc (v, va, vb, vc)) = NONE
  | get_fcc_option (Semlab_Proc (v, va, vb, vc, vd)) = NONE
  | get_fcc_option (Switch_Innermost_Proc (v, va)) = NONE
  | get_fcc_option (Rewriting_Proc (v, va, vb, vc, vd, ve, vf)) = NONE
  | get_fcc_option (Instantiation_Proc (v, va, vb)) = NONE
  | get_fcc_option (Forward_Instantiation_Proc (v, va, vb, vc)) = NONE
  | get_fcc_option (Narrowing_Proc (v, va, vb, vc)) = NONE
  | get_fcc_option (Assume_Finite (v, va)) = NONE
  | get_fcc_option (Unlab_Proc (v, va, vb)) = NONE
  | get_fcc_option (Q_Reduction_Proc (v, va)) = NONE
  | get_fcc_option (Complex_Constant_Removal_Proc (v, va)) = NONE
  | get_fcc_option (General_Redpair_Proc (v, va, vb, vc, vd)) = NONE
  | get_fcc_option (To_Trs_Proc v) = NONE;

fun uncurry_of_top_sig_list a m sml sm =
  maps (fn (b, c) =>
         let
           val (f, n) = b;
         in
           (fn _ =>
             let
               val g = get_symbol sm f n;
             in
               map (fn i =>
                     (Fun (a, generate_f_xs (g i) (plus_nata n i) ::
                                map (fn ia => Var (generate_var ia))
                                  (upt (plus_nata n i)
                                    (plus_nata (plus_nata n i)
                                      (minus_nata m one_nata)))),
                       generate_f_xs (g (suc i))
                         (plus_nata (plus_nata n i) (minus_nata m one_nata))))
                 (upt zero_nata (aarity sm f n))
             end)
         end
           c)
    sml;

fun eta_closed_top_rules (A1_, A2_) (B1_, B2_, B3_, B4_) a n sm r p =
  catch_errora
    (forallM
      (fn (l, ra) =>
        (case l of Var _ => Inr ()
          | Fun (ff, ls) =>
            check (equal_nata (aarity sm ff (size_list ls)) zero_nata orelse
                    list_ex
                      (fn (lll, rrr) =>
                        (case (lll, rrr) of (Var _, _) => false
                          | (Fun (_, []), _) => false
                          | (Fun (_, _ :: _), Var _) => false
                          | (Fun (_, _ :: _), Fun (_, [])) => false
                          | (Fun (f, ll :: yy), Fun (g, rr :: zz)) =>
                            eq A1_ f a andalso
                              (eq A1_ g a andalso
                                (equal_lista (equal_term A1_ B2_) zz yy andalso
                                  (equal_nata (size_list yy)
                                     (minus_nata n one_nata) andalso
                                    (distinct (equal_term A1_ B2_) yy andalso
                                      (list_all is_Var yy andalso
(null (list_inter B2_ (map the_Var yy)
        (insert_vars_rule B2_ (ll, rr) [])) andalso
  instance_rule A1_ B2_ (B1_, B2_, B3_) (l, ra) (ll, rr)))))))))
                      p)
              (shows_prec_list show_char zero_nata
                 [#"e", #"t", #"a", #" ", #"e", #"x", #"p", #"a", #"n", #"s",
                   #"i", #"o", #"n", #" ", #"o", #"f", #" "] o
                 shows_rule (shows_prec A2_ zero_nata)
                   (shows_prec B4_ zero_nata) [#" ", #"-", #">", #" "] (l, ra) o
                shows_prec_list show_char zero_nata
                  [#" ", #"m", #"i", #"s", #"s", #"i", #"n", #"g"])))
      r)
    (fn x => Inl (snd x));

fun uncurry_top_rules A_ a n sm =
  map (fn (l, r) => (uncurry_top A_ a n sm l, uncurry_top A_ a n sm r));

fun map_funs_rules_wa fg r =
  map (fn (l, ra) => (map_funs_term_wa fg l, map_funs_term_wa fg ra)) r;

fun uncurry_top_proc (B1_, B2_) i info n fmap check_inj p r dpp =
  let
    val (a, (sml, (u, eb))) = info;
    val pa = pb i dpp;
    val pw = pwb i dpp;
    val ra = rd i dpp;
    val rw = rwd i dpp;
    val nfs = nfsc i dpp;
    val m = minimal i dpp;
    val (e, ew) =
      uncurry_eta_split B1_
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list)
        eb ra;
    val sm = sig_list_to_sig_map B1_ a sml fmap;
    val p_eta = e @ pa;
    val pw_eta = ew @ pw;
    val uP = uncurry_top_rules B1_ a n sm p_eta;
    val uPw = uncurry_top_rules B1_ a n sm pw_eta;
    val uR = map_funs_rules_wa (fn (f, na) => get_symbol sm f na zero_nata) ra;
    val uRw = map_funs_rules_wa (fn (f, na) => get_symbol sm f na zero_nata) rw;
  in
    (case bindb (check (null (qc i dpp))
                  (shows_prec_list show_char zero_nata
                    [#"s", #"t", #"r", #"a", #"t", #"e", #"g", #"y", #" ", #"c",
                      #"u", #"r", #"r", #"e", #"n", #"t", #"l", #"y", #" ",
                      #"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r", #"t",
                      #"e", #"d"]))
            (fn _ =>
              bindb (check (not (equal_nata n zero_nata))
                      (shows_prec_list show_char zero_nata
                        [#"t", #"h", #"e", #" ", #"a", #"r", #"i", #"t", #"y",
                          #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"u",
                          #"n", #"c", #"u", #"r", #"r", #"i", #"e", #"d", #" ",
                          #"s", #"y", #"m", #"b", #"o", #"l", #" ", #"m", #"u",
                          #"s", #"t", #" ", #"b", #"e", #" ", #"a", #"t", #" ",
                          #"l", #"e", #"a", #"s", #"t", #" ", #"1"]))
                (fn _ =>
                  bindb (check_inj a n sml)
                    (fn _ =>
                      let
                        val pba = pairsb i dpp;
                        val is_def =
                          (fn fna => not (null (rules_mapc i dpp fna)));
                        val rm = rules_mapc i dpp;
                      in
                        bindb (catch_errora
                                (forallM
                                  (fn (l, _) =>
                                    check (not (is_Var l))
                                      (shows_prec_list show_char zero_nata
[#"l", #"h", #"s", #" ", #"a", #"s", #" ", #"v", #"a", #"r", #"i", #"a", #"b",
  #"l", #"e", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l",
  #"o", #"w", #"e", #"d"]))
                                  (ra @ rw))
                                (fn x => Inl (snd x)))
                          (fn _ =>
                            bindb (catch_errora
                                    (forallM
                                      (fn (l, rb) =>
bindb (check (hvf_top B1_ a n l)
        (shows_prec_list show_char zero_nata
           [#"h", #"e", #"a", #"d", #" ", #"v", #"a", #"r", #"i", #"a", #"b",
             #"l", #"e", #" ", #"i", #"n", #" ", #"l", #"h", #"s", #" "] o
          (shows_term (shows_prec B2_ zero_nata)
             (shows_prec_list show_char zero_nata) l o
            shows_prec_list show_char zero_nata
              [#" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o", #"w", #"e",
                #"d"])))
  (fn _ => check_no_var B2_ (show_list show_char) rb))
                                      (pw_eta @ p_eta))
                                    (fn x => Inl (snd x)))
                              (fn _ =>
                                bindb (catch_errora
(forallM
  (fn (_, rb) =>
    check (not (is_def (the (root rb))))
      (shows_prec_list show_char zero_nata
         [#"r", #"o", #"o", #"t", #" ", #"o", #"f", #" "] o
        (shows_term (shows_prec B2_ zero_nata)
           (shows_prec_list show_char zero_nata) rb o
          shows_prec_list show_char zero_nata
            [#" ", #"m", #"u", #"s", #"t", #" ", #"n", #"o", #"t", #" ", #"b",
              #"e", #" ", #"d", #"e", #"f", #"i", #"n", #"e", #"d"])))
  pba)
(fn x => Inl (snd x)))
                                  (fn _ =>
                                    bindb (check (not (is_def (a, n)))
    (shows_prec_list show_char zero_nata
       [#"a", #"p", #"p", #"l", #"i", #"c", #"a", #"t", #"i", #"o", #"n", #" ",
         #"s", #"y", #"m", #"b", #"o", #"l", #" "] o
      (shows_prec B2_ zero_nata a o
        shows_prec_list show_char zero_nata
          [#" ", #"m", #"u", #"s", #"t", #" ", #"n", #"o", #"t", #" ", #"b",
            #"e", #" ", #"d", #"e", #"f", #"i", #"n", #"e", #"d", #" ", #"i",
            #"n", #" ", #"R"])))
                                      (fn _ =>
bindb (if list_ex
            (fn (_, rb) =>
              equal_proda B1_ equal_nat (the (root rb)) (a, n) andalso
                equal_gctxta B1_
                  (tcapRM2 B1_ (equal_list equal_char) rm (hda (args rb)))
                  GCHole)
            pba
        then bindb (catch_errora
                     (check_CS_subseteq B1_
                       (ccompare_list ccompare_char, equal_list equal_char,
                         mapping_impl_list)
                       (uncurry_of_top_sig_list a n sml sm) u)
                     (fn x =>
                       Inl (shows_prec_list show_char zero_nata
                              [#"u", #"n", #"c", #"u", #"r", #"r", #"y", #"i",
                                #"n", #"g", #" ", #"p", #"a", #"i", #"r",
                                #" "] o
                             (shows_rule (shows_prec B2_ zero_nata)
                                (shows_prec_list show_char zero_nata)
                                [#" ", #"-", #">", #" "] x o
                               (shows_prec_list show_char zero_nata
                                  [#" ", #"i", #"s", #" ", #"m", #"i", #"s",
                                    #"s", #"i", #"n", #"g", #" ", #"i", #"n"] o
                                 (shows_nl o
                                   shows_rules (shows_prec B2_ zero_nata)
                                     (shows_prec_list show_char zero_nata)
                                     [#" ", #"-", #">", #" "] u))))))
               (fn _ =>
                 bindb (eta_closed_top_rules (B1_, B2_)
                         (ccompare_list ccompare_char, equal_list equal_char,
                           mapping_impl_list, show_list show_char)
                         a n sm ra p_eta)
                   (fn _ =>
                     eta_closed_top_rules (B1_, B2_)
                       (ccompare_list ccompare_char, equal_list equal_char,
                         mapping_impl_list, show_list show_char)
                       a n sm rw pw_eta))
        else Inr ())
  (fn _ =>
    bindb (catch_errora
            (check_subseteq
              (equal_prod (equal_term B1_ (equal_list equal_char))
                (equal_term B1_ (equal_list equal_char)))
              uP p)
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"u", #"n", #"c", #"u", #"r", #"r", #"i", #"e", #"d",
                       #" ", #"p", #"a", #"i", #"r", #" "] o
                    (shows_rule (shows_prec B2_ zero_nata)
                       (shows_prec_list show_char zero_nata)
                       [#" ", #"-", #">", #" "] x o
                      shows_prec_list show_char zero_nata
                        [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i",
                          #"n", #"g"]))))
      (fn _ =>
        bindb (catch_errora
                (check_subseteq
                  (equal_prod (equal_term B1_ (equal_list equal_char))
                    (equal_term B1_ (equal_list equal_char)))
                  uPw p)
                (fn x =>
                  Inl (shows_prec_list show_char zero_nata
                         [#"u", #"n", #"c", #"u", #"r", #"r", #"i", #"e", #"d",
                           #" ", #"p", #"a", #"i", #"r", #" "] o
                        (shows_rule (shows_prec B2_ zero_nata)
                           (shows_prec_list show_char zero_nata)
                           [#" ", #"-", #">", #" "] x o
                          shows_prec_list show_char zero_nata
                            [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s",
                              #"i", #"n", #"g"]))))
          (fn _ =>
            bindb (catch_errora
                    (check_subseteq
                      (equal_prod (equal_term B1_ (equal_list equal_char))
                        (equal_term B1_ (equal_list equal_char)))
                      u p)
                    (fn x =>
                      Inl (shows_prec_list show_char zero_nata
                             [#"u", #"n", #"c", #"u", #"r", #"r", #"y", #"i",
                               #"n", #"g", #" ", #"p", #"a", #"i", #"r", #" "] o
                            (shows_rule (shows_prec B2_ zero_nata)
                               (shows_prec_list show_char zero_nata)
                               [#" ", #"-", #">", #" "] x o
                              shows_prec_list show_char zero_nata
                                [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s",
                                  #"i", #"n", #"g", #" ", #"i", #"n", #" ",
                                  #"n", #"e", #"w", #" ", #"p", #"a", #"i",
                                  #"r", #"s"]))))
              (fn _ =>
                bindb (catch_errora
                        (check_subseteq
                          (equal_prod (equal_term B1_ (equal_list equal_char))
                            (equal_term B1_ (equal_list equal_char)))
                          uR r)
                        (fn x =>
                          Inl (shows_prec_list show_char zero_nata
                                 [#"r", #"u", #"l", #"e", #" "] o
                                (shows_rule (shows_prec B2_ zero_nata)
                                   (shows_prec_list show_char zero_nata)
                                   [#" ", #"-", #">", #" "] x o
                                  shows_prec_list show_char zero_nata
                                    [#" ", #"i", #"s", #" ", #"m", #"i", #"s",
                                      #"s", #"i", #"n", #"g", #" ", #"i", #"n",
                                      #" ", #"n", #"e", #"w", #" ", #"r", #"u",
                                      #"l", #"e", #"s"]))))
                  (fn _ =>
                    catch_errora
                      (check_subseteq
                        (equal_prod (equal_term B1_ (equal_list equal_char))
                          (equal_term B1_ (equal_list equal_char)))
                        uRw r)
                      (fn x =>
                        Inl (shows_prec_list show_char zero_nata
                               [#"r", #"u", #"l", #"e", #" "] o
                              (shows_rule (shows_prec B2_ zero_nata)
                                 (shows_prec_list show_char zero_nata)
                                 [#" ", #"-", #">", #" "] x o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"i", #"s", #" ", #"m", #"i", #"s",
                                    #"s", #"i", #"n", #"g", #" ", #"i", #"n",
                                    #" ", #"n", #"e", #"w", #" ", #"r", #"u",
                                    #"l", #"e", #"s"]))))))))))))
                      end)))
      of Inl aa => Inl aa | Inr _ => Inr (mkd i nfs m uP (uPw @ u) [] uR uRw))
  end;

fun only_eta_rules (A1_, A2_) (B1_, B2_, B3_, B4_) e r_eta =
  catch_errora
    (forallM
      (fn (l, r) =>
        check (case (l, r) of (Var _, _) => false | (Fun (_, _), Var _) => false
                | (Fun (f, ls), Fun (g, rs)) =>
                  eq A1_ f g andalso
                    (equal_nata (size_list ls)
                       (nat_of_integer (2 : IntInf.int)) andalso
                      (equal_nata (size_list rs)
                         (nat_of_integer (2 : IntInf.int)) andalso
                        (equal_terma A1_ B2_ (nth ls one_nata)
                           (nth rs one_nata) andalso
                          list_ex
                            (fn (la, ra) =>
                              instance_rule A1_ B2_ (B1_, B2_, B3_)
                                (hda ls, hda rs) (la, ra))
                            r_eta))))
          (shows_prec_list show_char zero_nata [#"r", #"u", #"l", #"e", #" "] o
            (shows_rule (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
               [#" ", #"-", #">", #" "] (l, r) o
              shows_prec_list show_char zero_nata
                [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"n",
                  #" ", #"(", #"e", #"t", #"a", #"-", #"e", #"x", #"p", #"a",
                  #"n", #"d", #"e", #"d", #")", #" ", #"o", #"r", #"i", #"g",
                  #"i", #"n", #"a", #"l", #" ", #"r", #"u", #"l", #"e"])))
      e)
    (fn x => Inl (snd x));

fun uncurry_proc (B1_, B2_) i info fmap check_inj p r dpp =
  let
    val (a, (sml, (u, eb))) = info;
    val pa = pb i dpp;
    val pw = pwb i dpp;
    val ra = rd i dpp;
    val rw = rwd i dpp;
    val nfs = nfsc i dpp;
    val m = minimal i dpp;
    val (e, ew) =
      uncurry_eta_split B1_
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list)
        eb ra;
    val sm = sig_list_to_sig_map B1_ a sml fmap;
    val uP = uncurry_rules B1_ a sm pa;
    val uPw = uncurry_rules B1_ a sm pw;
    val r_eta = e @ ra;
    val rw_eta = ew @ rw;
    val uR = uncurry_rules B1_ a sm r_eta;
    val uRw = uncurry_rules B1_ a sm rw_eta;
  in
    (case let
            val s = uncurry_of_sig_list a sml sm;
          in
            bindb (check (null (qc i dpp))
                    (shows_prec_list show_char zero_nata
                      [#"s", #"t", #"r", #"a", #"t", #"e", #"g", #"y", #" ",
                        #"n", #"o", #"t", #" ", #"s", #"u", #"p", #"p", #"o",
                        #"r", #"t", #"e", #"d", #" ", #"f", #"o", #"r", #" ",
                        #"u", #"n", #"c", #"u", #"r", #"r", #"y", #"i", #"n",
                        #"g"]))
              (fn _ =>
                bindb (only_eta_rules (B1_, B2_)
                        (ccompare_list ccompare_char, equal_list equal_char,
                          mapping_impl_list, show_list show_char)
                        e r_eta)
                  (fn _ =>
                    bindb (only_eta_rules (B1_, B2_)
                            (ccompare_list ccompare_char, equal_list equal_char,
                              mapping_impl_list, show_list show_char)
                            ew rw_eta)
                      (fn _ =>
                        bindb (check_inj a (nat_of_integer (2 : IntInf.int))
                                sml)
                          (fn _ =>
                            bindb (catch_errora
                                    (forallM
                                      (fn (l, _) =>
check (not (is_Var l))
  (shows_prec_list show_char zero_nata
    [#"l", #"h", #"s", #" ", #"a", #"s", #" ", #"v", #"a", #"r", #"i", #"a",
      #"b", #"l", #"e", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
      #"l", #"l", #"o", #"w", #"e", #"d"]))
                                      (ra @ rw))
                                    (fn x => Inl (snd x)))
                              (fn _ =>
                                bindb (catch_errora
(forallM
  (fn (l, _) =>
    check (hvf_term B1_ a l)
      (shows_prec_list show_char zero_nata
         [#"h", #"e", #"a", #"d", #" ", #"v", #"a", #"r", #"i", #"a", #"b",
           #"l", #"e", #" ", #"i", #"n", #" ", #"l", #"h", #"s", #" "] o
        (shows_term (shows_prec B2_ zero_nata)
           (shows_prec_list show_char zero_nata) l o
          shows_prec_list show_char zero_nata
            [#" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o", #"w", #"e",
              #"d"])))
  pa)
(fn x => Inl (snd x)))
                                  (fn _ =>
                                    bindb (catch_errora
    (forallM
      (fn (l, _) =>
        check (hvf_term B1_ a l)
          (shows_prec_list show_char zero_nata
             [#"h", #"e", #"a", #"d", #" ", #"v", #"a", #"r", #"i", #"a", #"b",
               #"l", #"e", #" ", #"i", #"n", #" ", #"l", #"h", #"s", #" "] o
            (shows_term (shows_prec B2_ zero_nata)
               (shows_prec_list show_char zero_nata) l o
              shows_prec_list show_char zero_nata
                [#" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o", #"w",
                  #"e", #"d"])))
      pw)
    (fn x => Inl (snd x)))
                                      (fn _ =>
bindb (catch_errora
        (forallM
          (fn (l, _) =>
            check (hvf_term B1_ a l)
              (shows_prec_list show_char zero_nata
                 [#"h", #"e", #"a", #"d", #" ", #"v", #"a", #"r", #"i", #"a",
                   #"b", #"l", #"e", #" ", #"i", #"n", #" ", #"l", #"h", #"s",
                   #" "] o
                (shows_term (shows_prec B2_ zero_nata)
                   (shows_prec_list show_char zero_nata) l o
                  shows_prec_list show_char zero_nata
                    [#" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o", #"w",
                      #"e", #"d"])))
          r_eta)
        (fn x => Inl (snd x)))
  (fn _ =>
    bindb (catch_errora
            (forallM
              (fn (l, _) =>
                check (hvf_term B1_ a l)
                  (shows_prec_list show_char zero_nata
                     [#"h", #"e", #"a", #"d", #" ", #"v", #"a", #"r", #"i",
                       #"a", #"b", #"l", #"e", #" ", #"i", #"n", #" ", #"l",
                       #"h", #"s", #" "] o
                    (shows_term (shows_prec B2_ zero_nata)
                       (shows_prec_list show_char zero_nata) l o
                      shows_prec_list show_char zero_nata
                        [#" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o",
                          #"w", #"e", #"d"])))
              rw_eta)
            (fn x => Inl (snd x)))
      (fn _ =>
        bindb (eta_closed_rules (B1_, B2_)
                (ccompare_list ccompare_char, equal_list equal_char,
                  mapping_impl_list, show_list show_char)
                a sm r_eta r_eta)
          (fn _ =>
            bindb (eta_closed_rules (B1_, B2_)
                    (ccompare_list ccompare_char, equal_list equal_char,
                      mapping_impl_list, show_list show_char)
                    a sm rw_eta rw_eta)
              (fn _ =>
                bindb (catch_errora
                        (check_subseteq
                          (equal_prod (equal_term B1_ (equal_list equal_char))
                            (equal_term B1_ (equal_list equal_char)))
                          uP p)
                        (fn x =>
                          Inl (shows_prec_list show_char zero_nata
                                 [#"u", #"n", #"c", #"u", #"r", #"r", #"i",
                                   #"e", #"d", #" ", #"p", #"a", #"i", #"r",
                                   #" "] o
                                (shows_rule (shows_prec B2_ zero_nata)
                                   (shows_prec_list show_char zero_nata)
                                   [#" ", #"-", #">", #" "] x o
                                  shows_prec_list show_char zero_nata
                                    [#" ", #"i", #"s", #" ", #"m", #"i", #"s",
                                      #"s", #"i", #"n", #"g"]))))
                  (fn _ =>
                    bindb (catch_errora
                            (check_subseteq
                              (equal_prod
                                (equal_term B1_ (equal_list equal_char))
                                (equal_term B1_ (equal_list equal_char)))
                              uPw p)
                            (fn x =>
                              Inl (shows_prec_list show_char zero_nata
                                     [#"u", #"n", #"c", #"u", #"r", #"r", #"i",
                                       #"e", #"d", #" ", #"p", #"a", #"i", #"r",
                                       #" "] o
                                    (shows_rule (shows_prec B2_ zero_nata)
                                       (shows_prec_list show_char zero_nata)
                                       [#" ", #"-", #">", #" "] x o
                                      shows_prec_list show_char zero_nata
[#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n", #"g"]))))
                      (fn _ =>
                        bindb (catch_errora
                                (check_subseteq
                                  (equal_prod
                                    (equal_term B1_ (equal_list equal_char))
                                    (equal_term B1_ (equal_list equal_char)))
                                  uR r)
                                (fn x =>
                                  Inl (shows_prec_list show_char zero_nata
 [#"u", #"n", #"c", #"u", #"r", #"r", #"i", #"e", #"d", #" ", #"r", #"u", #"l",
   #"e", #" "] o
(shows_rule (shows_prec B2_ zero_nata) (shows_prec_list show_char zero_nata)
   [#" ", #"-", #">", #" "] x o
  shows_prec_list show_char zero_nata
    [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n", #"g"]))))
                          (fn _ =>
                            bindb (catch_errora
                                    (check_subseteq
                                      (equal_prod
(equal_term B1_ (equal_list equal_char))
(equal_term B1_ (equal_list equal_char)))
                                      uRw r)
                                    (fn x =>
                                      Inl
(shows_prec_list show_char zero_nata
   [#"u", #"n", #"c", #"u", #"r", #"r", #"i", #"e", #"d", #" ", #"r", #"u",
     #"l", #"e", #" "] o
  (shows_rule (shows_prec B2_ zero_nata) (shows_prec_list show_char zero_nata)
     [#" ", #"-", #">", #" "] x o
    shows_prec_list show_char zero_nata
      [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n", #"g"]))))
                              (fn _ =>
                                bindb (catch_errora
(check_CS_subseteq B1_
  (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list) s u)
(fn x =>
  Inl (shows_prec_list show_char zero_nata
         [#"u", #"n", #"c", #"u", #"r", #"r", #"y", #" ", #"r", #"u", #"l",
           #"e", #" "] o
        (shows_rule (shows_prec B2_ zero_nata)
           (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] x o
          shows_prec_list show_char zero_nata
            [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n",
              #"g"]))))
                                  (fn _ =>
                                    bindb (catch_errora
    (check_CS_subseteq B1_
      (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list) u
      s)
    (fn x =>
      Inl (shows_prec_list show_char zero_nata [#"r", #"u", #"l", #"e", #" "] o
            (shows_rule (shows_prec B2_ zero_nata)
               (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "]
               x o
              shows_prec_list show_char zero_nata
                [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"n",
                  #" ", #"u", #"n", #"c", #"u", #"r", #"r", #"y", #" ", #"r",
                  #"u", #"l", #"e"]))))
                                      (fn _ =>
catch_errora
  (check_subseteq
    (equal_prod (equal_term B1_ (equal_list equal_char))
      (equal_term B1_ (equal_list equal_char)))
    u r)
  (fn x =>
    Inl (shows_prec_list show_char zero_nata
           [#"u", #"n", #"c", #"u", #"r", #"r", #"y", #" ", #"r", #"u", #"l",
             #"e", #" "] o
          (shows_rule (shows_prec B2_ zero_nata)
             (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] x o
            shows_prec_list show_char zero_nata
              [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n", #"g",
                #" ", #"i", #"n", #" ", #"n", #"e", #"w", #" ", #"T", #"R",
                #"S"]))))))))))))))))))))
          end
      of Inl aa => Inl aa | Inr _ => Inr (mkd i nfs m uP uPw [] uR (uRw @ u)))
  end;

fun uncurry_proc_both (B1_, B2_) (C1_, C2_) i NONE (a, (sml, (u, eb))) =
  uncurry_proc (equal_lab B1_ C1_, show_lab B2_ C2_) i (a, (sml, (u, eb)))
    (fmap B1_ C1_ a (nat_of_integer (2 : IntInf.int)))
    (check_inj (B1_, B2_) (C1_, C2_))
  | uncurry_proc_both (B1_, B2_) (C1_, C2_) i (SOME n) (a, (sml, (u, eb))) =
    uncurry_top_proc (equal_lab B1_ C1_, show_lab B2_ C2_) i (a, (sml, (u, eb)))
      n (fmap B1_ C1_ a n) (check_inj (B1_, B2_) (C1_, C2_));

fun check_rewrite_common_preconditions (B1_, B2_, B3_) i u_opt st ss ts t lr p
  sound dpp =
  let
    val r = rulese i dpp;
    val s = fst st;
    val ta = snd st;
    val tp = subt_at ta p;
    val u =
      (case u_opt
        of NONE =>
          maps (fn tb => inn_usable_rules_pair (B1_, B2_) i dpp (s, tb)) ts
        | SOME u => u);
  in
    bindb (catch_errora
            (check_subseteq
              (equal_prod (equal_term B1_ (equal_list equal_char))
                (equal_term B1_ (equal_list equal_char)))
              u r)
            (fn x =>
              Inl (shows_rule (shows_prec B3_ zero_nata)
                     (shows_prec_list show_char zero_nata)
                     [#" ", #"-", #">", #" "] x o
                    shows_prec_list show_char zero_nata
                      [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                        #" ", #"r", #"u", #"l", #"e", #" ", #"o", #"f", #" ",
                        #"t", #"h", #"e", #" ", #"r", #"e", #"w", #"r", #"i",
                        #"t", #"e", #" ", #"s", #"y", #"s", #"t", #"e", #"m",
                        #" "])))
      (fn _ =>
        let
          val urc = is_ur_closed_impl_dpp_mv (B1_, B2_, B3_) i dpp u;
          val check_urc =
            (fn sa => fn tb =>
              check (urc sa tb)
                (shows_prec_list show_char zero_nata
                   [#"t", #"e", #"r", #"m", #" "] o
                  (shows_prec_term B3_ (show_list show_char) zero_nata tb o
                    shows_prec_list show_char zero_nata
                      [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"c",
                        #"l", #"o", #"s", #"e", #"d", #" ", #"u", #"n", #"d",
                        #"e", #"r", #" ", #"u", #"s", #"a", #"b", #"l", #"e",
                        #" ", #"r", #"u", #"l", #"e", #"s"])));
          val nfs = nfsc i dpp;
        in
          bindb (catch_errora
                  (forallM
                    (fn (l, _) =>
                      check (not (is_Var l))
                        (shows_prec_list show_char zero_nata
                          [#"l", #"h", #"s", #"s", #" ", #"m", #"u", #"s", #"t",
                            #" ", #"n", #"o", #"t", #" ", #"b", #"e", #" ",
                            #"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e",
                            #"s"]))
                    u)
                  (fn x => Inl (snd x)))
            (fn _ =>
              bindb (check (wf_rule (equal_list equal_char) lr)
                      (shows_rule (shows_prec B3_ zero_nata)
                         (shows_prec_list show_char zero_nata)
                         [#" ", #"-", #">", #" "] lr o
                        shows_prec_list show_char zero_nata
                          [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                            #" ", #"w", #"e", #"l", #"l", #" ", #"f", #"o",
                            #"r", #"m", #"e", #"d", #" ", #"r", #"u", #"l",
                            #"e"]))
                (fn _ =>
                  bindb (if nfs andalso sound then Inr ()
                          else catch_errora
                                 (check_subseteq (equal_list equal_char)
                                   (vars_term_list tp) (vars_term_list s))
                                 (fn _ =>
                                   Inl (shows_prec_list show_char zero_nata
 [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #" ", #"c", #"o", #"n", #"d",
   #"i", #"t", #"i", #"o", #"n", #" ", #"i", #"n", #" ", #"p", #"a", #"i", #"r",
   #" ", #"v", #"i", #"o", #"l", #"a", #"t", #"e", #"d"])))
                    (fn _ =>
                      bindb (catch_errora (forallM (check_urc ss) ts)
                              (fn x => Inl (snd x)))
                        (fn _ =>
                          bindb (catch_errora
                                  (forallM (fn (l, a) => check_urc (args l) a)
                                    u)
                                  (fn x => Inl (snd x)))
                            (fn _ =>
                              bindb (catch_errora
                                      (check_critical_pairs_innermost (B1_, B3_)
u)
                                      (fn x =>
Inl (shows_prec_list show_char zero_nata
       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ", #"s",
         #"h", #"o", #"w", #"i", #"n", #"g", #" ", #"U", #"N", #"F", #" ", #"o",
         #"f", #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"u", #"l",
         #"e", #"s"] o
      (shows_nl o x))))
                                (fn _ =>
                                  catch_errora
                                    (forallM
                                      (fn (_, (sa, tb)) =>
check (equal_terma B1_ (equal_list equal_char) sa tb)
  (shows_prec_list show_char zero_nata
    [#"n", #"o", #"n", #"-", #"t", #"r", #"i", #"v", #"i", #"a", #"l", #" ",
      #"c", #"r", #"i", #"t", #"i", #"c", #"a", #"l", #" ", #"p", #"a", #"i",
      #"r", #" ", #"b", #"e", #"t", #"w", #"e", #"e", #"n", #" ", #"r", #"u",
      #"l", #"e", #" ", #"t", #"o", #" ", #"r", #"e", #"w", #"r", #"i", #"t",
      #"e", #" ", #"a", #"n", #"d", #" ", #"u", #"s", #"a", #"b", #"l", #"e",
      #" ", #"r", #"u", #"l", #"e", #"s"]))
                                      (critical_pairs_impl B1_ [lr] u))
                                    (fn x => Inl (snd x))))))))
        end)
  end;

fun check_prop_rstepa (A1_, A2_) (B1_, B2_, B3_, B4_) nfs pa r p rule s t =
  bindb (check
          (membera (equal_prod (equal_term A1_ B2_) (equal_term A1_ B2_)) r
            rule)
          (shows_rule (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
             [#" ", #"-", #">", #" "] rule o
            (shows_string
               [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ",
                 #"r", #"u", #"l", #"e", #" ", #"o", #"f"] o
              (shows_nl o
                (shows_trs (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
                   [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s", #"y",
                     #"s", #"t", #"e", #"m", #":"]
                   [#" ", #"-", #">", #" "] r o
                  shows_nl)))))
    (fn _ =>
      check_prop_rstep_rule (A1_, A2_) (B1_, B2_, B3_, B4_) nfs pa p rule s t);

fun check_rstep (A1_, A2_) (B1_, B2_, B3_, B4_) =
  check_prop_rstepa (A1_, A2_) (B1_, B2_, B3_, B4_) false (fn _ => Inr ());

fun rewriting_proc (B1_, B2_, B3_) i u stb sta st lr p dpp =
  (case let
          val s = fst stb;
          val t = snd sta;
        in
          bindb (check_rstep (B1_, B3_)
                  (ccompare_list ccompare_char, equal_list equal_char,
                    mapping_impl_list, show_list show_char)
                  (rulese i dpp) p lr (snd stb) t)
            (fn _ =>
              bindb (check (nFQ_subset_NF_rulesc i dpp)
                      (shows_prec_list show_char zero_nata
                        [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t",
                          #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"i", #"n",
                          #"g", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e",
                          #"d"]))
                (fn _ =>
                  bindb (check_rewrite_common_preconditions (B1_, B2_, B3_) i u
                          stb [s] [subt_at (snd stb) p] t lr p true dpp)
                    (fn _ =>
                      bindb (check
                              (eq_rule_mod_vars B1_
                                (ccompare_list ccompare_char,
                                  equal_list equal_char, mapping_impl_list)
                                sta st)
                              (shows_prec_list show_char zero_nata
                                 [#"t", #"h", #"e", #" ", #"r", #"u", #"l",
                                   #"e", #" "] o
                                (shows_rule (shows_prec B3_ zero_nata)
                                   (shows_prec_list show_char zero_nata)
                                   [#" ", #"-", #">", #" "] sta o
                                  (shows_prec_list show_char zero_nata
                                     [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
                                       #" ", #"a", #" ", #"r", #"e", #"n", #"a",
                                       #"m", #"e", #"d", #" ", #"v", #"a", #"r",
                                       #"i", #"a", #"n", #"t", #" ", #"o", #"f",
                                       #" "] o
                                    shows_rule (shows_prec B3_ zero_nata)
                                      (shows_prec_list show_char zero_nata)
                                      [#" ", #"-", #">", #" "] st))))
                        (fn _ =>
                          bindb (check
                                  (equal_terma B1_ (equal_list equal_char) s
                                    (fst sta))
                                  (shows_prec_list show_char zero_nata
                                    [#"l", #"e", #"f", #"t", #"-", #"h", #"a",
                                      #"n", #"d", #" ", #"s", #"i", #"d", #"e",
                                      #"s", #" ", #"o", #"f", #" ", #"o", #"l",
                                      #"d", #" ", #"a", #"n", #"d", #" ", #"n",
                                      #"e", #"w", #" ", #"p", #"a", #"i", #"r",
                                      #" ", #"d", #"i", #"f", #"f", #"e",
                                      #"r"]))
                            (fn _ =>
                              bindb (check
                                      (membera
 (equal_prod (equal_term B1_ (equal_list equal_char))
   (equal_term B1_ (equal_list equal_char)))
 (pb i dpp) stb orelse
null (rd i dpp))
                                      (shows_prec_list show_char zero_nata
[#"s", #"t", #"r", #"i", #"c", #"t", #" ", #"D", #"P", #" ", #"o", #"r", #" ",
  #"n", #"o", #" ", #"s", #"t", #"r", #"i", #"c", #"t", #" ", #"r", #"u", #"l",
  #"e", #"s", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]))
                                (fn _ =>
                                  check (nfsc i dpp orelse wwf_rulesa i dpp)
                                    (shows_prec_list show_char zero_nata
                                      [#"w", #"e", #"l", #"l", #"-", #"f", #"o",
#"r", #"m", #"e", #"d", #" ", #"r", #"u", #"l", #"e", #"s", #" ", #"o", #"r",
#" ", #"n", #"o", #"r", #"m", #"a", #"l", #" ", #"s", #"u", #"b", #"s", #"t",
#".", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"])))))))
        end
    of Inl a => Inl a | Inr _ => Inr (replace_paira i dpp stb [st]));

fun nF_subst_impl nf nfs r sigma =
  (if nfs then list_all (fn x => nf (sigma x)) (vars_rule_list r) else true);

fun qnarrows_impl A_ isnf nfs r t =
  maps (fn p =>
         let
           val tp = subt_at t p;
         in
           (if not (is_Var tp)
             then maps (fn (l, ra) =>
                         maps (fn (mu_1, mu_2) =>
                                (if nF_subst_impl isnf nfs (l, ra) mu_2
                                  then (if list_all isnf
     (args (subst_apply_term l mu_2))
 then [(ctxt_apply_term (ctxt_of_pos_term p (subst_apply_term t mu_1))
          (subst_apply_term ra mu_2),
         mu_1)]
 else [])
                                  else []))
                           (option_to_list
                             (mgu_var_disjoint_generic (equal_list equal_char)
                               A_ (fn a => #"x" :: a) (fn a => #"y" :: a) tp
                               l)))
                    r
             else [])
         end)
    (poss_list t);

fun narrowing_proc (B1_, B2_, B3_) i st p sts dpp =
  (case let
          val (s, t) = st;
          val q = qc i dpp;
        in
          bindb (check
                  (nFQ_subset_NF_rulesc i dpp orelse
                    null q andalso
                      linear_term
                        (ceq_list ceq_char, ccompare_list ccompare_char,
                          set_impl_list)
                        t)
                  (shows_prec_list show_char zero_nata
                    [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ",
                      #"o", #"r", #" ", #"f", #"u", #"l", #"l", #" ", #"r",
                      #"e", #"w", #"r", #"i", #"t", #"i", #"n", #"g", #" ",
                      #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d", #" ",
                      #"(", #"a", #"n", #"d", #" ", #"l", #"i", #"n", #"e",
                      #"a", #"r", #"i", #"t", #"y", #" ", #"o", #"f", #" ",
                      #"t", #" ", #"i", #"n", #" ", #"f", #"u", #"l", #"l",
                      #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"i", #"n",
                      #"g", #" ", #"c", #"a", #"s", #"e", #")"]))
            (fn _ =>
              let
                val ic = icap_impl_dpp_mv B1_ i dpp;
                val isnf = is_QNFc i dpp;
                val pairs = pairsb i dpp;
              in
                bindb (check (membera equal_pos (poss_list t) p)
                        (shows_prec_list show_char zero_nata
                           [#"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n",
                             #" ", #"n", #"o", #"t", #" ", #"c", #"o", #"n",
                             #"t", #"a", #"i", #"n", #"e", #"d", #" ", #"i",
                             #"n", #" "] o
                          shows_prec_term B3_ (show_list show_char) zero_nata
                            t))
                  (fn _ =>
                    let
                      val tp = subt_at t p;
                      val nftp = isnf tp;
                    in
                      bindb (check
                              (membera equal_pos (poss_list (ic [s] t)) p orelse
                                not nftp)
                              (shows_prec_list show_char zero_nata
                                [#"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ",
                                  #"i", #"s", #" ", #"p", #"o", #"s", #"i",
                                  #"t", #"i", #"o", #"n", #" ", #"c", #"o",
                                  #"n", #"t", #"a", #"i", #"n", #"e", #"d",
                                  #" ", #"i", #"n", #" ", #"c", #"a", #"p",
                                  #"p", #"e", #"d", #" ", #"t", #"e", #"r",
                                  #"m", #" ", #"o", #"f", #" ", #"t", #",",
                                  #" ", #"n", #"o", #"r", #" ", #"i", #"s",
                                  #" ", #"t", #"|", #"_", #"p", #" ", #"n",
                                  #"o", #"t", #" ", #"i", #"n", #" ", #"Q",
                                  #"-", #"n", #"o", #"r", #"m", #"a", #"l",
                                  #" ", #"f", #"o", #"r", #"m"]))
                        (fn _ =>
                          let
                            val nfs = nfsc i dpp;
                            val narrows =
                              qnarrows_impl B1_ isnf nfs (rulese i dpp) tp;
                            val stsa =
                              filtera (fn (smu, _) => isnf smu)
                                (map (fn (ta, mu) =>
                                       (subst_apply_term s mu,
 ctxt_apply_term (ctxt_of_pos_term p (subst_apply_term t mu)) ta))
                                  narrows);
                          in
                            bindb (catch_errora
                                    (forallM
                                      (fn new =>
check (list_ex
        (fn sta =>
          instance_rule B1_ (equal_list equal_char)
            (ccompare_list ccompare_char, equal_list equal_char,
              mapping_impl_list)
            new sta andalso
            (not nfs orelse
              (null q orelse wf_rule (equal_list equal_char) sta)))
        sts)
  (shows_prec_list show_char zero_nata
     [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"f", #"i",
       #"n", #"d", #" ", #"n", #"a", #"r", #"r", #"o", #"w", #"e", #"d", #" ",
       #"p", #"a", #"i", #"r", #" "] o
    shows_rule (shows_prec B3_ zero_nata) (shows_prec_list show_char zero_nata)
      [#" ", #"-", #">", #" "] new))
                                      stsa)
                                    (fn x => Inl (snd x)))
                              (fn _ =>
                                let
                                  val iedg =
                                    is_iedg_edge_dpp (B1_, B2_, B3_) i dpp
                                      (s, t);
                                in
                                  bindb (catch_errora
  (check_subseteq (equal_list equal_char) (vars_term_list tp)
    (vars_term_list s))
  (fn x =>
    Inl (shows_prec_list show_char zero_nata
          ([#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #" "] @
            x @ [#" ", #"o", #"n", #"l", #"y", #" ", #"o", #"c", #"c", #"u",
                  #"r", #"s", #" ", #"o", #"n", #" ", #"r", #"h", #"s", #" ",
                  #"o", #"f", #" ", #"p", #"a", #"i", #"r"]))))
                                    (fn _ =>
                                      bindb
(check
  (membera
     (equal_prod (equal_term B1_ (equal_list equal_char))
       (equal_term B1_ (equal_list equal_char)))
     (pb i dpp) st orelse
    null (rd i dpp))
  (shows_prec_list show_char zero_nata
    [#"s", #"t", #"r", #"i", #"c", #"t", #" ", #"D", #"P", #" ", #"o", #"r",
      #" ", #"n", #"o", #" ", #"s", #"t", #"r", #"i", #"c", #"t", #" ", #"r",
      #"u", #"l", #"e", #"s", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e",
      #"d"]))
(fn _ =>
  (if nftp
    then catch_errora
           (forallM
             (fn (u, v) =>
               bindb (check (membera equal_pos (poss_list u) p)
                       (shows_prec_list show_char zero_nata
                          [#"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n", #" ",
                            #"n", #"o", #"t", #" ", #"c", #"o", #"n", #"t",
                            #"a", #"i", #"n", #"e", #"d", #" ", #"i", #"n",
                            #" ", #"l", #"h", #"s", #" ", #"o", #"f", #" ",
                            #"p", #"a", #"i", #"r", #" "] o
                         shows_rule (shows_prec B3_ zero_nata)
                           (shows_prec_list show_char zero_nata)
                           [#" ", #"-", #">", #" "] (u, v)))
                 (fn _ =>
                   (case mgu_var_disjoint_generic (equal_list equal_char) B1_
                           (fn a => #"x" :: a) (fn a => #"y" :: a) tp
                           (subt_at u p)
                     of NONE => Inr ()
                     | SOME (mu_1, mu_2) =>
                       check (not (isnf (subst_apply_term s mu_1)) orelse
                               not (isnf (subst_apply_term u mu_2)))
                         (shows_prec_list show_char zero_nata
                            [#"t", #" ", #"|", #"_", #" ", #"p", #" ", #"a",
                              #"n", #"d", #" ", #"u", #" ", #"|", #"_", #" ",
                              #"p", #" ", #"u", #"n", #"i", #"f", #"y", #" ",
                              #"a", #"n", #"d", #" ", #"s", #"a", #"t", #"i",
                              #"s", #"f", #"y", #" ", #"v", #"a", #"r", #"i",
                              #"a", #"b", #"l", #"e", #" ", #"c", #"o", #"n",
                              #"d", #"i", #"t", #"i", #"o", #"n", #" ", #"f",
                              #"o", #"r", #" ", #"p", #"a", #"i", #"r", #" ",
                              #"(", #"u", #",", #"v", #")", #" ", #"=", #" "] o
                           shows_rule (shows_prec B3_ zero_nata)
                             (shows_prec_list show_char zero_nata)
                             [#" ", #"-", #">", #" "] (u, v)))))
             (filtera (fn (u, _) => iedg u) pairs))
           (fn x => Inl (snd x))
    else Inr ())))
                                end)
                          end)
                    end)
              end)
        end
    of Inl a => Inl a | Inr _ => Inr (replace_paira i dpp st sts));

fun extract_renamings A_ old_new =
  (fun_of_map_fun (map_of A_ old_new) id,
    fun_of_map_fun (map_of A_ (map swap old_new)) id);

fun extract_components A_ mu old_new =
  let
    val (d, da) = extract_renamings A_ old_new;
    val c =
      map_filter
        (fn x => (if let
                       val (_, a) = x;
                     in
                       equal_nata a zero_nata
                     end
                   then SOME (fst x) else NONE))
        mu;
    val nu = map d c;
  in
    (d, (da, nu))
  end;

fun check_components (A1_, A2_) mu ddNU =
  let
    val (d, (da, nu)) = ddNU;
  in
    bindb (catch_errora
            (forallM
              (fn f =>
                bindb (check
                        (not (membera (equal_prod A1_ equal_nat) mu
                               (f, one_nata)))
                        (shows_prec_list show_char zero_nata
                           [#"n", #"e", #"w", #" ", #"u", #"n", #"a", #"r",
                             #"y", #" ", #"s", #"y", #"m", #"b", #"o", #"l",
                             #" "] o
                          (shows_prec A2_ zero_nata f o
                            shows_prec_list show_char zero_nata
                              [#" ", #"c", #"l", #"a", #"s", #"h", #"e", #"s",
                                #" ", #"w", #"i", #"t", #"h", #" ", #"o", #"l",
                                #"d", #" ", #"s", #"y", #"m", #"b", #"o",
                                #"l"])))
                  (fn _ =>
                    bindb (check (eq A1_ (d (da f)) f)
                            (shows_prec_list show_char zero_nata
                               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                                 #"w", #"i", #"t", #"h", #" ", #"b", #"i", #"j",
                                 #"e", #"c", #"t", #"i", #"o", #"n", #" ", #"f",
                                 #"o", #"r", #" ", #"r", #"e", #"n", #"a", #"m",
                                 #"i", #"n", #"g", #" ", #"o", #"f", #" "] o
                              shows_prec A2_ zero_nata f))
                      (fn _ =>
                        check (membera (equal_prod A1_ equal_nat) mu
                                (da f, zero_nata))
                          (shows_prec_list show_char zero_nata
                             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                               #"w", #"i", #"t", #"h", #" ", #"i", #"n", #"v",
                               #"e", #"r", #"s", #"e", #" ", #"r", #"e", #"n",
                               #"a", #"m", #"i", #"n", #"g", #" ", #"o", #"f",
                               #" "] o
                            shows_prec A2_ zero_nata f))))
              nu)
            (fn x => Inl (snd x)))
      (fn _ =>
        catch_errora
          (forallM
            (fn (f, n) =>
              bindb (check (less_eq_nat n one_nata)
                      (shows_prec_list show_char zero_nata
                         [#"a", #"r", #"i", #"t", #"y", #" ", #">", #" ", #"1",
                           #" ", #"f", #"o", #"r", #" ", #"s", #"y", #"m", #"b",
                           #"o", #"l", #" "] o
                        shows_prec A2_ zero_nata f))
                (fn _ =>
                  check (if equal_nata n zero_nata
                          then membera A1_ nu (d f) andalso eq A1_ (da (d f)) f
                          else true)
                    (shows_prec_list show_char zero_nata
                       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w",
                         #"i", #"t", #"h", #" ", #"b", #"i", #"j", #"e", #"c",
                         #"t", #"i", #"o", #"n", #" ", #"f", #"o", #"r", #" ",
                         #"r", #"e", #"n", #"a", #"m", #"i", #"n", #"g", #" ",
                         #"o", #"f", #" ", #"c", #"o", #"n", #"s", #"t", #"a",
                         #"n", #"t", #" "] o
                      shows_prec A2_ zero_nata f)))
            mu)
          (fn x => Inl (snd x)))
  end;

fun str d x (Fun (f, v :: vb :: vc)) = Fun (d f, [Var x])
  | str d x (Fun (f, [])) = Fun (d f, [Var x])
  | str d x (Fun (f, [t])) = Fun (f, [str d x t])
  | str d uu (Var x) = Var x;

fun choose_var x l = hda (vars_term_list l @ [x]);

fun check_to_srs_sound (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_) (B1_, B2_, B3_)
  v old_new r s rw sw =
  let
    val mu = funas_trs_list (r @ rw);
    val (d, (da, nu)) = extract_components B2_ mu old_new;
  in
    bindb (check_components (B2_, B3_) mu (d, (da, nu)))
      (fn _ =>
        bindb (check_varcond_subset B3_ (A6_, A8_) r)
          (fn _ =>
            bindb (check_varcond_subset B3_ (A6_, A8_) rw)
              (fn _ =>
                let
                  val checka =
                    (fn ra => fn sa =>
                      catch_errora
                        (forallM
                          (fn (l, rb) =>
                            let
                              val y = choose_var v l;
                              val stra = str d y;
                              val slr = (stra l, stra rb);
                            in
                              check (less_eq_set
                                       (A2_, A3_, ccompare_cproper_interval A4_)
                                       (vars_term (B1_, B2_)
 (A1_, A2_, A3_, A4_, A5_, A6_, A7_) l)
                                       (inserta
 (A3_, ccompare_cproper_interval A4_) y
 (bot_set (A3_, ccompare_cproper_interval A4_, A7_))) andalso
                                      membera
(equal_prod (equal_term B2_ A6_) (equal_term B2_ A6_)) sa slr)
                                (shows_prec_list show_char zero_nata
                                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                     #" ", #"w", #"i", #"t", #"h", #" ", #"n",
                                     #"e", #"w", #" ", #"r", #"u", #"l", #"e",
                                     #" "] o
                                  shows_rule (shows_prec B3_ zero_nata)
                                    (shows_prec A8_ zero_nata)
                                    [#" ", #"-", #">", #" "] slr)
                            end)
                          ra)
                        (fn x => Inl (snd x)));
                in
                  bindb (checka r s) (fn _ => checka rw sw)
                end)))
  end;

fun const_to_string_sound_tt (A1_, A2_, A3_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
  (Const_string_sound_proof (v, old_new, s, sw)) i tp =
  bindb (check_to_srs_sound (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
          (A1_, A2_, A3_) v old_new (rc i tp) s (rwc i tp) sw)
    (fn _ => Inr (mkc i false [] s sw));

fun dP_list A_ B_ shp r d_list =
  maps (fn lr =>
         let
           val l = fst lr;
           val s = sharp_term shp l;
         in
           map_filter
             (fn x =>
               (if not (supt_impl A_ B_ l x) andalso
                     (not (is_Var x) andalso
                       membera (equal_prod A_ equal_nat) d_list (the (root x)))
                 then SOME (s, sharp_term shp x) else NONE))
             (supteq_list (snd lr))
         end)
    r;

fun dependency_pairs_tt (A1_, A2_, A3_, A4_) (C1_, C2_, C3_, C4_, C5_, C6_) shp
  i j tp nfs m p =
  let
    val r = rulesd i tp;
    val q = qb i tp;
    val iQ = is_QNFb i tp;
    val u = filtera (applicable_rule_impl iQ) r;
  in
    (case catch_errora
            (bindb
              (if isOK (check_wf_trs A4_ (C3_, C6_) u) then Inr ()
                else check (nfs andalso
                             (nfsb i tp andalso
                               (nFQ_subset_NF_rulesb i tp andalso
                                 list_all (fn l => not (is_Var l))
                                   (map fst r))))
                       (shows_prec_list show_char zero_nata
                         [#"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"i",
                           #"s", #" ", #"t", #"h", #"e", #" ", #"T", #"R", #"S",
                           #" ", #"w", #"e", #"l", #"l", #"-", #"f", #"o", #"r",
                           #"m", #"e", #"d", #",", #" ", #"n", #"o", #"r", #" ",
                           #"i", #"s", #" ", #"t", #"h", #"e", #" ", #"r", #"e",
                           #"s", #"t", #"r", #"i", #"c", #"t", #"i", #"o", #"n",
                           #" ", #"t", #"o", #" ", #"i", #"n", #"n", #"e", #"r",
                           #"m", #"o", #"s", #"t", #" ", #"w", #"i", #"t", #"h",
                           #" ", #"n", #"o", #"r", #"m", #"a", #"l", #" ", #"f",
                           #"o", #"r", #"m", #" ", #"s", #"u", #"b", #"s", #"t",
                           #"i", #"t", #"u", #"t", #"i", #"o", #"n", #"s", #" ",
                           #"p", #"r", #"e", #"s", #"e", #"n", #"t"]))
              (fn _ =>
                bindb (catch_errora (forallM (check_no_var A4_ C6_) q)
                        (fn x => Inl (snd x)))
                  (fn _ =>
                    let
                      val qr = map (fn Fun (f, ss) => (f, size_list ss)) q;
                      val d = defined_list u;
                    in
                      bindb (catch_errora
                              (forallM
                                (fn (f, n) =>
                                  check (not
  (membera (equal_prod A2_ equal_nat) d (shp f, n)))
                                    (shows_string
                                       [#"s", #"h", #"a", #"r", #"p", #"i",
 #"n", #"g", #" "] o
                                      (shows_prec A4_ zero_nata f o
(shows_string
   [#" ", #"y", #"i", #"e", #"l", #"d", #"s", #" ", #"t", #"h", #"e", #" ",
     #"d", #"e", #"f", #"i", #"n", #"e", #"d", #" ", #"s", #"y", #"m", #"b",
     #"o", #"l", #" "] o
  shows_prec A4_ zero_nata (shp f)))))
                                d)
                              (fn x => Inl (snd x)))
                        (fn _ =>
                          bindb (catch_errora
                                  (forallM
                                    (fn (f, n) =>
                                      check
(not (membera (equal_prod A2_ equal_nat) qr (shp f, n)))
(shows_string [#"s", #"h", #"a", #"r", #"p", #"i", #"n", #"g", #" "] o
  (shows_prec A4_ zero_nata f o
    (shows_string
       [#" ", #"y", #"i", #"e", #"l", #"d", #"s", #" ", #"t", #"h", #"e", #" ",
         #"s", #"y", #"m", #"b", #"o", #"l", #" "] o
      (shows_prec A4_ zero_nata (shp f) o
        shows_string
          [#" ", #"w", #"h", #"i", #"c", #"h", #" ", #"i", #"s", #" ", #"a",
            #" ", #"r", #"o", #"o", #"t", #" ", #"o", #"f", #" ", #"Q"])))))
                                    d)
                                  (fn x => Inl (snd x)))
                            (fn _ =>
                              let
                                val pa =
                                  set (ceq_prod (ceq_term A2_ C3_)
 (ceq_term A2_ C3_),
ccompare_prod (ccompare_term A1_ C2_) (ccompare_term A1_ C2_),
set_impl_prod set_impl_term set_impl_term)
                                    p;
                              in
                                catch_errora
                                  (catch_errora
                                    (forallM
                                      (fn x =>
(if member
      (ceq_prod (ceq_term A2_ C3_) (ceq_term A2_ C3_),
        ccompare_prod (ccompare_term A1_ C2_) (ccompare_term A1_ C2_))
      x pa orelse
      list_ex (eq_rule_mod_vars A2_ (C1_, C3_, C4_) x) p
  then Inr () else Inl x))
                                      (dP_list A2_ C3_ shp u d))
                                    (fn x => Inl (snd x)))
                                  (fn x =>
                                    Inl (shows_string
   [#"t", #"h", #"e", #" ", #"D", #"P", #" "] o
  (shows_rule (shows_prec A4_ zero_nata) (shows_prec C6_ zero_nata)
     [#" ", #"-", #">", #" "] x o
    (shows_string
       [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"p",
         #"p", #"e", #"a", #"r", #" ", #"i", #"n", #" ", #"t", #"h", #"e", #" ",
         #"D", #"P", #" ", #"p", #"r", #"o", #"b", #"l", #"e", #"m"] o
      shows_nl))))
                              end))
                    end)))
            (fn x =>
              Inl (shows_string
                     [#"t", #"h", #"e", #" ", #"D", #"P", #"-", #"t", #"r",
                       #"a", #"n", #"s", #"f", #"o", #"r", #"m", #"a", #"t",
                       #"i", #"o", #"n", #" ", #"i", #"s", #" ", #"n", #"o",
                       #"t", #" ", #"a", #"p", #"p", #"l", #"i", #"e", #"d",
                       #" ", #"c", #"o", #"r", #"r", #"e", #"c", #"t", #"l",
                       #"y", #"."] o
                    (shows_nl o x)))
      of Inl a => Inl a | Inr _ => Inr (mkd j nfs m p [] q [] r))
  end;

fun switch_innermost_tt (B1_, B2_) i joins_i trs =
  let
    val r = rulesd i trs;
  in
    (case let
            val cp = critical_pairs_impl B1_ r r;
          in
            bindb (catch_errora
                    (forallM
                      (fn (b, _) =>
                        check b
                          (shows_prec_list show_char zero_nata
                            [#"r", #"u", #"l", #"e", #"s", #" ", #"a", #"r",
                              #"e", #" ", #"n", #"o", #"t", #" ", #"o", #"v",
                              #"e", #"r", #"l", #"a", #"y"]))
                      cp)
                    (fn x => Inl (snd x)))
              (fn _ =>
                bindb (check_critical_pairs (B1_, B2_) r cp joins_i)
                  (fn _ =>
                    check_wf_trs B2_
                      (equal_list equal_char, show_list show_char) r))
          end
      of Inl a => Inl a | Inr _ => Inr (mkc i true (map fst r) r []))
  end;

fun unary_term (Var x) = true
  | unary_term (Fun (f, [t])) = unary_term t
  | unary_term (Fun (v, [])) = false
  | unary_term (Fun (v, vb :: vd :: ve)) = false;

fun check_unary_signature A_ B_ r =
  catch_errora
    (catch_errora
      (forallM
        (fn x =>
          (if let
                val (l, ra) = x;
              in
                unary_term l andalso unary_term ra
              end
            then Inr () else Inl x))
        r)
      (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_string [#"t", #"h", #"e", #" ", #"r", #"u", #"l", #"e", #" "] o
            (shows_nl o
              (shows_rule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata)
                 [#" ", #"-", #">", #" "] x o
                (shows_nl o
                  (shows_string
                     [#"v", #"i", #"o", #"l", #"a", #"t", #"e", #"s", #" ",
                       #"t", #"h", #"e", #" ", #"c", #"o", #"n", #"d", #"i",
                       #"t", #"i", #"o", #"n", #" ", #"t", #"h", #"a", #"t",
                       #" ", #"a", #"l", #"l", #" ", #"f", #"u", #"n", #"c",
                       #"t", #"i", #"o", #"n", #" ", #"s", #"y", #"m", #"b",
                       #"o", #"l", #"s"] o
                    (shows_nl o
                      shows_prec_list show_char zero_nata
                        [#"h", #"a", #"v", #"e", #" ", #"t", #"o", #" ", #"b",
                          #"e", #" ", #"u", #"n", #"a", #"r", #"y"])))))));

fun rev_term c (Var x) = ctxt_apply_term c (Var x)
  | rev_term c (Fun (f, [t])) = rev_term (More (f, [], c, [])) t;

fun rev_rule (l, r) = (rev_term Hole l, rev_term Hole r);

fun string_reversal_tt B_ C_ i trs =
  let
    val rs = rulesd i trs;
    val r = rc i trs;
    val s = rwc i trs;
  in
    (case check_unary_signature B_ C_ rs of Inl a => Inl a
      | Inr _ =>
        Inr (mkc i default_nfs_trs [] (map rev_rule r) (map rev_rule s)))
  end;

fun q_emptyb
  (Tp_ops_ext
    (qreltrs, q, r, rw, rules, q_empty, is_QNF, nFQ_subset_NF_rules, rules_map,
      delete_R_Rw, split_rules, mk, nfs, more))
  = q_empty;

fun sem_lab_rel_tt (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_) splitter ld i valid
  check_decr check_model_lab lQ lAll tp =
  let
    val r = rc i tp;
    val rw = rwc i tp;
    val nfs = nfsb i tp;
    val (lR, (lRw, d)) =
      splitter lAll
        (set (ceq_prod (ceq_term A2_ B3_) (ceq_term A2_ B3_),
               ccompare_prod (ccompare_term A1_ B2_) (ccompare_term A1_ B2_),
               set_impl_prod set_impl_term set_impl_term)
          rw);
  in
    (case bindb valid
            (fn _ =>
              let
                val q = qb i tp;
              in
                catch_errora
                  (bindb
                    (if nfs andalso not (q_emptyb i tp)
                      then check_wf_trs A3_ (B3_, B5_) d else Inr ())
                    (fn _ =>
                      bindb (check_decr d)
                        (fn _ =>
                          bindb (check_sl_Q (A2_, A3_) (B1_, B3_, B4_, B5_) ld
                                  lQ q)
                            (fn _ =>
                              bindb (check_model_lab
                                       (set
 (ceq_prod (ceq_term A2_ B3_) (ceq_term A2_ B3_),
   ccompare_prod (ccompare_term A1_ B2_) (ccompare_term A1_ B2_),
   set_impl_prod set_impl_term set_impl_term)
 lR)
                                      r)
                                (fn _ =>
                                  check_model_lab
                                    (set (ceq_prod (ceq_term A2_ B3_)
    (ceq_term A2_ B3_),
   ccompare_prod (ccompare_term A1_ B2_) (ccompare_term A1_ B2_),
   set_impl_prod set_impl_term set_impl_term)
                                      lRw)
                                    rw)))))
                  (fn x =>
                    Inl (shows_string
                           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                             #"w", #"i", #"t", #"h", #" ", #"l", #"a", #"b",
                             #"e", #"l", #"e", #"d", #" ", #"T", #"R", #"S",
                             #":"] o
                          (shows_nl o x)))
              end)
      of Inl a => Inl a | Inr _ => Inr (mkc i nfs lQ lR (lRw @ d)))
  end;

fun sem_lab_fin_tt (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_) D_ splitter lc ld
  cge i gen lQ lAll tp =
  bindb (gen (insert_funas_trs A2_ (rulesd i tp) []) [])
    (fn ops =>
      let
        val check_ml =
          check_sl_model_lab_trs (A1_, A2_, A3_) D_ (B2_, B3_, B5_) (sl_I ops)
            (sl_L ops) (sl_C ops) cge lc;
        val check_d = sl_check_decr ops;
      in
        sem_lab_rel_tt (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_) splitter ld i
          (Inr ()) check_d check_ml lQ lAll tp
      end);

fun semlab_fin_tt (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_) j (Rootlab uu) =
  sem_lab_fin_tt
    (compare_lab B1_ (compare_list compare_nat),
      equal_lab B2_ (equal_list equal_nat), show_lab B3_ (show_list show_nat))
    (C1_, C2_, C3_, C4_, C5_) (show_lab B3_ (show_list show_nat))
    (model_splitter
      (compare_lab B1_ (compare_list compare_nat),
        equal_lab B2_ (equal_list equal_nat))
      (C2_, C3_) label_decomp)
    label label_decomp (equal_laba B2_ (equal_list equal_nat)) j
    (slm_gen_to_sl_gen (rl_slm B2_ (equal_list equal_nat) NONE))
  | semlab_fin_tt (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_) j (Finitelab sli) =
    sem_lab_fin_tt
      (compare_lab B1_ (compare_list compare_nat),
        equal_lab B2_ (equal_list equal_nat), show_lab B3_ (show_list show_nat))
      (C1_, C2_, C3_, C4_, C5_) show_nat
      (model_splitter
        (compare_lab B1_ (compare_list compare_nat),
          equal_lab B2_ (equal_list equal_nat))
        (C2_, C3_) label_decomp)
      label label_decomp equal_nata j
      (slm_gen_to_sl_gen (fn _ => fn _ => Inr (sli_to_slm B2_ sli)))
  | semlab_fin_tt (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_) j
    (QuasiFinitelab (sli, v)) =
    sem_lab_fin_tt
      (compare_lab B1_ (compare_list compare_nat),
        equal_lab B2_ (equal_list equal_nat), show_lab B3_ (show_list show_nat))
      (C1_, C2_, C3_, C4_, C5_) show_nat
      (quasi_splitter
        (compare_lab B1_ (compare_list compare_nat),
          equal_lab B2_ (equal_list equal_nat))
        (C2_, C3_) label_decomp)
      label label_decomp qmodel_cge j
      (fn f => fn g => qsli_to_sl (C1_, C3_, C4_) (B2_, B3_) v f g sli);

fun permutation_afs (A1_, A2_) pi =
  ball (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat) (afs_syms pi)
    (fn (f, n) =>
      (case afsa pi (f, n) of Collapse _ => false
        | AFList xs =>
          eq_set (card_UNIV_nat, cenum_nat, ceq_nat, ccompare_nat)
            (set (ceq_nat, ccompare_nat, set_impl_nat) xs)
            (set (ceq_nat, ccompare_nat, set_impl_nat)
              (upt zero_nata n)) andalso
            distinct equal_nat xs));

fun argument_filter_tt (B1_, B2_, B3_, B4_, B5_) i pi tp =
  (case afs_of (B1_, B2_, B3_, B4_) pi
    of NONE =>
      Inl (shows_prec_list show_char zero_nata
            [#"i", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"a", #"r", #"g",
              #"u", #"m", #"e", #"n", #"t", #" ", #"f", #"i", #"l", #"t", #"e",
              #"r"])
    | SOME af =>
      bindb (check (permutation_afs (B1_, B2_) af)
              (shows_prec_list show_char zero_nata
                [#"a", #"r", #"g", #"u", #"m", #"e", #"n", #"t", #" ", #"f",
                  #"i", #"l", #"t", #"e", #"r", #" ", #"i", #"s", #" ", #"n",
                  #"o", #"t", #" ", #"a", #" ", #"p", #"e", #"r", #"m", #"u",
                  #"t", #"a", #"t", #"i", #"o", #"n"]))
        (fn _ =>
          let
            val pia = af_rules af;
          in
            Inr (mkc i default_nfs_trs [] (pia (rc i tp)) (pia (rwc i tp)))
          end));

fun rule_removal_tt B_ C_ i rp rremove trs =
  (case catch_errora
          let
            val (rs, rns) = split_rulesb i trs rremove;
          in
            bindb (valid rp)
              (fn _ =>
                bindb (catch_errora (mono rp (rs @ rns))
                        (fn x =>
                          Inl (shows_string
                                 [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                   #" ", #"w", #"i", #"t", #"h", #" ", #"m",
                                   #"o", #"n", #"o", #"t", #"o", #"n", #"i",
                                   #"c", #"i", #"t", #"y", #" ", #"o", #"f",
                                   #" ", #"s", #"t", #"r", #"i", #"c", #"t",
                                   #" ", #"o", #"r", #"d", #"e", #"r"] o
                                (shows_nl o x))))
                  (fn _ =>
                    bindb (catch_errora
                            (catch_errora (forallM (ns rp) rns)
                              (fn x => Inl (snd x)))
                            (fn x =>
                              Inl (shows_string
                                     [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                       #" ", #"w", #"h", #"e", #"n", #" ", #"o",
                                       #"r", #"i", #"e", #"n", #"t", #"i", #"n",
                                       #"g", #" ", #"T", #"R", #"S"] o
                                    (shows_nl o x))))
                      (fn _ =>
                        catch_errora
                          (catch_errora (forallM (s rp) rs)
                            (fn x => Inl (snd x)))
                          (fn x =>
                            Inl (shows_string
                                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                     #" ", #"w", #"h", #"e", #"n", #" ", #"o",
                                     #"r", #"i", #"e", #"n", #"t", #"i", #"n",
                                     #"g", #" ", #"T", #"R", #"S"] o
                                  (shows_nl o x))))))
          end
          (fn x =>
            Inl (shows_string
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"a", #"p", #"p", #"l", #"y", #" ", #"t", #"h", #"e", #" ",
                     #"r", #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n", #" ",
                     #"p", #"a", #"i", #"r", #" ", #"p", #"r", #"o", #"c", #"e",
                     #"s", #"s", #"o", #"r", #" ", #"w", #"i", #"t", #"h", #" ",
                     #"t", #"h", #"e", #" ", #"f", #"o", #"l", #"l", #"o", #"w",
                     #"i", #"n", #"g"] o
                  (shows_nl o (desc rp o (shows_nl o x)))))
    of Inl a => Inl a | Inr _ => Inr (delete_R_Rwb i trs rremove rremove));

fun check_wwf_qtrs A_ (B1_, B2_) nf r =
  catch_errora
    (catch_errora
      (forallM
        (fn ra =>
          (if applicable_rule_impl nf ra
            then catch_errora
                   (bindb
                     (check (not (is_Var (fst ra)))
                       (shows_string
                         [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #" ",
                           #"l", #"e", #"f", #"t", #"-", #"h", #"a", #"n", #"d",
                           #" ", #"s", #"i", #"d", #"e", #" ", #"i", #"n"]))
                     (fn _ =>
                       catch_errora
                         (check_subseteq B1_ (vars_term_list (snd ra))
                           (vars_term_list (fst ra)))
                         (fn x =>
                           Inl (shows_string
                                  [#"f", #"r", #"e", #"e", #" ", #"v", #"a",
                                    #"r", #"i", #"a", #"b", #"l", #"e", #" "] o
                                 (shows_prec B2_ zero_nata x o
                                   shows_string
                                     [#" ", #"i", #"n", #" ", #"r", #"i", #"g",
                                       #"h", #"t", #"-", #"h", #"a", #"n", #"d",
                                       #" ", #"s", #"i", #"d", #"e", #" ", #"o",
                                       #"f"])))))
                   (fn x =>
                     Inl (x o (shows_string
                                 [#" ", #"r", #"u", #"l", #"e", #" "] o
                                (shows_rule (shows_prec A_ zero_nata)
                                   (shows_prec B2_ zero_nata)
                                   [#" ", #"-", #">", #" "] ra o
                                  shows_nl))))
            else Inr ()))
        r)
      (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_string
             [#"t", #"h", #"e", #" ", #"Q", #"-", #"T", #"R", #"S", #" ", #"i",
               #"s", #" ", #"n", #"o", #"t", #" ", #"w", #"e", #"a", #"k", #"l",
               #"y", #" ", #"w", #"e", #"l", #"l", #"-", #"f", #"o", #"r", #"m",
               #"e", #"d"] o
            (shows_nl o x)));

fun check_compatible_nfs A_ (B1_, B2_) nfs1 nf1 r1 nfs2 q2 =
  equal_boola nfs1 nfs2 orelse
    (null q2 orelse isOK (check_wwf_qtrs A_ (B1_, B2_) nf1 r1));

fun shows_tp funa var i t =
  let
    val nfs = nfsb i t;
    val r = rc i t;
    val rw = rwc i t;
    val q = qb i t;
  in
    shows_trs funa var [#"r", #"u", #"l", #"e", #"s", #":"]
      [#" ", #"-", #">", #" "] r o
      ((if null rw then id
         else shows_trs funa var
                [#"r", #"e", #"l", #"a", #"t", #"i", #"v", #"e", #" ", #"r",
                  #"u", #"l", #"e", #"s", #":"]
                [#" ", #"-", #">", #"=", #" "] rw) o
        ((if null q then id
           else shows_terms funa var
                  [#"Q", #"-", #"c", #"o", #"m", #"p", #"o", #"n", #"e", #"n",
                    #"t", #":"]
                  q) o
          (if nfs
            then shows_string
                   [#"s", #"u", #"b", #"s", #"t", #"i", #"t", #"u", #"t", #"i",
                     #"o", #"n", #"s", #" ", #"a", #"r", #"e", #" ", #"a", #"s",
                     #"s", #"u", #"m", #"e", #"d", #" ", #"t", #"o", #" ", #"b",
                     #"e", #" ", #"i", #"n", #" ", #"n", #"o", #"r", #"m", #"a",
                     #"l", #" ", #"f", #"o", #"r", #"m"] o
                   shows_nl
            else id)))
  end;

fun check_tp_subsumes (B1_, B2_) (C1_, C2_) (D1_, D2_) i (nfs, (q, (r, rw))) tp
  = catch_errora
      let
        val nfsa = nfsb i tp;
        val qa = is_QNFb i tp;
        val ra = rc i tp;
        val rwa = rwc i tp;
        val rb = r @ rw;
        val nf1 = is_QNFb i tp;
      in
        bindb (check
                (check_compatible_nfs (show_lab B2_ C2_) (D1_, D2_) nfsa nf1
                  (ra @ rwa) nfs q)
                (shows_prec_list show_char zero_nata
                  [#"i", #"n", #"c", #"o", #"m", #"p", #"a", #"t", #"i", #"b",
                    #"l", #"e", #" ", #"s", #"u", #"b", #"s", #"t", #"i", #"t",
                    #"u", #"t", #"i", #"o", #"n", #"s", #"-", #"i", #"n", #"-",
                    #"n", #"o", #"r", #"m", #"a", #"l", #"-", #"f", #"o", #"r",
                    #"m", #" ", #"f", #"l", #"a", #"g", #"s"]))
          (fn _ =>
            bindb (catch_errora (check_NF_terms_subset qa q)
                    (fn x =>
                      Inl (shows_prec_list show_char zero_nata
                             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                               #"w", #"i", #"t", #"h", #" ", #"i", #"n", #"n",
                               #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"s",
                               #"t", #"r", #"a", #"t", #"e", #"g", #"y", #" ",
                               #"d", #"u", #"e", #" ", #"t", #"o", #" ", #"t",
                               #"e", #"r", #"m", #" "] o
                            shows_term (shows_prec_lab B2_ C2_ zero_nata)
                              (shows_prec D2_ zero_nata) x)))
              (fn _ =>
                bindb (catch_errora
                        (check_subseteq
                          (equal_prod (equal_term (equal_lab B1_ C1_) D1_)
                            (equal_term (equal_lab B1_ C1_) D1_))
                          ra r)
                        (fn x =>
                          Inl (toomuch [#"r", #"u", #"l", #"e"]
                                (shows_rule (shows_prec_lab B2_ C2_ zero_nata)
                                  (shows_prec D2_ zero_nata)
                                  [#" ", #"-", #">", #" "] x))))
                  (fn _ =>
                    bindb (catch_errora
                            (check_subseteq
                              (equal_prod (equal_term (equal_lab B1_ C1_) D1_)
                                (equal_term (equal_lab B1_ C1_) D1_))
                              rwa rb)
                            (fn x =>
                              Inl (toomuch
                                    [#"r", #"e", #"l", #"a", #"t", #"i", #"v",
                                      #"e", #" ", #"r", #"u", #"l", #"e"]
                                    (shows_rule
                                      (shows_prec_lab B2_ C2_ zero_nata)
                                      (shows_prec D2_ zero_nata)
                                      [#" ", #"-", #">", #" "] x))))
                      (fn _ => Inr ()))))
      end
      (fn x =>
        Inl (shows_string
               [#"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o",
                 #"n", #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"p",
                 #"r", #"o", #"b", #"l", #"e", #"m"] o
              (shows_nl o
                (shows_tp (shows_prec_lab B2_ C2_ zero_nata)
                   (shows_prec D2_ zero_nata) i tp o
                  (shows_nl o
                    (shows_string
                       [#"m", #"a", #"y", #" ", #"n", #"o", #"t", #" ", #"b",
                         #"e", #" ", #"c", #"o", #"n", #"c", #"l", #"u", #"d",
                         #"e", #"d", #" ", #"f", #"r", #"o", #"m", #" ", #"a",
                         #"s", #"s", #"u", #"m", #"i", #"n", #"g", #" ", #"t",
                         #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o",
                         #"n", #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ",
                         #"p", #"r", #"o", #"b", #"l", #"e", #"m"] o
                      (shows_nl o
                        (shows_tp (shows_prec_lab B2_ C2_ zero_nata)
                           (shows_prec D2_ zero_nata) i (mkc i nfs q r rw) o
                          (shows_nl o (x o shows_nl))))))))));

fun fcc_tt (B1_, B2_) (C1_, C2_, C3_, C4_) i fcs cRb tp =
  let
    val r = rc i tp;
    val rw = rwc i tp;
    val nfs = nfsb i tp;
    val rb = r @ rw;
    val (cR, cRw) = partition_rules B1_ C2_ fcs r cRb;
    val _ = qb i tp;
    val vs = vars_trs_list rb;
    val fas = funas_trs_list rb;
  in
    (case bindb (check (not (null fcs))
                  (shows_string
                     [#"a", #"t", #" ", #"l", #"e", #"a", #"s", #"t", #" ",
                       #"o", #"n", #"e", #" ", #"f", #"l", #"a", #"t", #" ",
                       #"c", #"o", #"n", #"t", #"e", #"x", #"t", #" ", #"i",
                       #"s", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e",
                       #"d", #" ", #"f", #"o", #"r", #" ", #"f", #"l", #"a",
                       #"t", #" ", #"c", #"o", #"n", #"t", #"e", #"x", #"t",
                       #" ", #"c", #"l", #"o", #"s", #"u", #"r", #"e"] o
                    shows_nl))
            (fn _ =>
              bindb (catch_errora
                      (forallM (check_flat_ctxt (C2_, C4_) (B1_, B2_) vs) fcs)
                      (fn x => Inl (snd x)))
                (fn _ =>
                  bindb (catch_errora
                          (forallM
                            (check_is_flat_ctxt (C2_, C4_) (B1_, B2_) vs fas)
                            fcs)
                          (fn x => Inl (snd x)))
                    (fn _ =>
                      bindb (catch_errora
                              (forallM
                                (check_flat_ctxt_complete (B1_, B2_) C4_ fcs)
                                fas)
                              (fn x => Inl (snd x)))
                        (fn _ =>
                          bindb (catch_errora
                                  (forallM
                                    (check_rule_preserving (B1_, B2_)
                                      (C1_, C2_, C3_, C4_) fcs cR)
                                    r)
                                  (fn x => Inl (snd x)))
                            (fn _ =>
                              catch_errora
                                (forallM
                                  (check_rule_preserving (B1_, B2_)
                                    (C1_, C2_, C3_, C4_) fcs cRb)
                                  rw)
                                (fn x => Inl (snd x)))))))
      of Inl a => Inl a | Inr _ => Inr (mkc i nfs [] cR cRw))
  end;

fun g_isEmpty_dflt_basic_oops_rm_basic_ops A_ s =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops A_ s (fn c => c)
    (fn _ => fn _ => false) true;

fun ta_rhs_states_set (TA_Impl (x1, x2, x3, x4, x5, x6, x7)) = x4;

fun ta_rules_impl (TA_Impl (x1, x2, x3, x4, x5, x6, x7)) = x2;

fun r_lhs_states_impl (TA_rule_impl (f, qsa, q, qs)) = qsa;

fun rm_set_lookup A_ rm =
  (fn a => (case lookup A_ rm a of NONE => [] | SOME rules => rules));

fun g_union_dflt_basic_oops_rm_basic_ops A_ s1 s2 =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops
    (linorder_compare_order A_) s1 (fn _ => true) (ins_rm_basic_ops A_) s2;

fun rs_Union A_ =
  foldl (g_union_dflt_basic_oops_rm_basic_ops A_)
    (empty_rm_basic_ops (linorder_compare_order A_) ());

fun rqss_impl (TA_rule_impl (f, qsa, q, qs)) = qs;

fun ta_res_impl_all A_ B_ q ta (Var uu) = q
  | ta_res_impl_all A_ B_ q ta (Fun (f, ts)) =
    let
      val reca = map (ta_res_impl_all A_ B_ q ta) ts;
      val n = size_list ts;
      val rules =
        rm_set_lookup (compare_order_prod B_ compare_order_nat) ta (f, n);
      val arules =
        filtera
          (fn rule =>
            let
              val qs = r_lhs_states_impl rule;
            in
              all_interval_nat
                (fn i => memb_rm_basic_ops A_ (nth qs i) (nth reca i)) zero_nata
                n
            end)
          rules;
      val a = map rqss_impl arules;
    in
      rs_Union A_ a
    end;

fun rule_state_compatible_heuristic A_ B_ C_ ta l =
  g_isEmpty_dflt_basic_oops_rm_basic_ops (linorder_compare_order A_)
    (ta_res_impl_all A_ B_ (ta_rhs_states_set ta) (ta_rules_impl ta) l);

fun check_state_raise_consistent (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) ta
  rel =
  let
    val rels =
      set (ceq_prod A1_ A1_, ccompare_prod A2_ A2_, set_impl_prod A5_ A5_) rel;
    val rls = ta_rules_implb ta;
  in
    catch_errora
      (forallM
        (fn r1 =>
          let
            val TA_rule ((f1, i1), qs1, q1) = r1;
          in
            catch_errora
              (forallM
                (fn r2 =>
                  let
                    val TA_rule ((f2, i2), qs2, q2) = r2;
                  in
                    (if eq B1_ f1 f2 andalso
                          (less_nat i1 i2 andalso equal_lista A3_ qs1 qs2)
                      then check (member
                                   (ceq_prod A1_ A1_, ccompare_prod A2_ A2_)
                                   (q1, q2) rels)
                             (shows_prec_list show_char zero_nata
                                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                                  #"w", #"i", #"t", #"h", #" ", #"r", #"a",
                                  #"i", #"s", #"e", #" ", #"c", #"o", #"n",
                                  #"s", #"i", #"s", #"t", #"e", #"n", #"c",
                                  #"y", #" ", #"b", #"e", #"c", #"a", #"u",
                                  #"s", #"e", #" ", #"o", #"f", #" ", #"a",
                                  #"u", #"t", #"o", #"m", #"a", #"t", #"o",
                                  #"n", #"-", #"r", #"u", #"l", #"e", #"s",
                                  #" "] o
                               (shows_nl o
                                 (shows_prec_ta_rule A6_
                                    (show_prod B2_ show_nat) zero_nata r1 o
                                   (shows_nl o
                                     (shows_prec_ta_rule A6_
(show_prod B2_ show_nat) zero_nata r2 o
                                       (shows_nl o
 (shows_prec A6_ zero_nata q1 o
   (shows_prec_list show_char zero_nata
      [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #">", #">", #"^", #"*",
        #" "] o
     shows_prec A6_ zero_nata q2))))))))
                      else Inr ())
                  end)
                rls)
              (fn x => Inl (snd x))
          end)
        rls)
      (fn x => Inl (snd x))
  end;

fun ta_epsrs_impl (TA_Impl (x1, x2, x3, x4, x5, x6, x7)) = x7;

fun ta_epss_impl (TA_Impl (x1, x2, x3, x4, x5, x6, x7)) = x6;

fun g_inter_dflt_basic_oops_rm_basic_ops A_ s1 s2 =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops
    (linorder_compare_order A_) s1 (fn _ => true)
    (fn x => fn s =>
      (if memb_rm_basic_ops A_ x s2 then ins_dj_rm_basic_ops A_ x s else s))
    (empty_rm_basic_ops (linorder_compare_order A_) ());

fun ta_match_impl A_ (B1_, B2_) (C1_, C2_) ta qsig eps (Var x) q =
  g_from_list_dflt_basic_oops_rm_basic_ops
    (compare_order_list (compare_order_prod C1_ B1_, equal_prod C2_ B2_))
    (map (fn qa => [(x, qa)])
      (g_to_list_dflt_basic_oops_rm_basic_ops (linorder_compare_order B1_)
        (g_inter_dflt_basic_oops_rm_basic_ops B1_ (rs_Union B1_ (map eps q))
          qsig)))
  | ta_match_impl A_ (B1_, B2_) (C1_, C2_) ta qsig eps (Fun (f, ts)) q =
    let
      val n = size_list ts;
      val rules =
        rm_set_lookup (compare_order_prod A_ compare_order_nat) ta (f, n);
      val ep = rs_Union B1_ (map eps q);
      val fa =
        (fn rule =>
          g_from_list_dflt_basic_oops_rm_basic_ops
            (compare_order_list
              (compare_order_prod C1_ B1_, equal_prod C2_ B2_))
            let
              val TA_rule_impl (_, qs, qa, _) = rule;
            in
              (if memb_rm_basic_ops B1_ qa ep
                then let
                       val reca =
                         map (fn (tsi, qsi) =>
                               g_to_list_dflt_basic_oops_rm_basic_ops
                                 (linorder_list
                                   (equal_prod C2_ B2_,
                                     linorder_prod (linorder_compare_order C1_)
                                       (linorder_compare_order B1_)))
                                 (ta_match_impl A_ (B1_, B2_) (C1_, C2_) ta qsig
                                   eps tsi [qsi]))
                           (zip ts qs);
                     in
                       map concat (concat_lists reca)
                     end
                else [])
            end);
    in
      rs_Union
        (compare_order_list (compare_order_prod C1_ B1_, equal_prod C2_ B2_))
        (map fa rules)
    end;

fun ta_match_impla A_ (B1_, B2_) (C1_, C2_) ta qsig eps rhs t =
  ta_match_impl A_ (B1_, B2_) (C1_, C2_) ta qsig eps t rhs;

fun ta_res_impl A_ B_ ta eps (Var q) = eps q
  | ta_res_impl A_ B_ ta eps (Fun (f, ts)) =
    let
      val reca = map (ta_res_impl A_ B_ ta eps) ts;
      val n = size_list ts;
      val rules =
        rm_set_lookup (compare_order_prod A_ compare_order_nat) ta (f, n);
      val arules =
        filtera
          (fn rule =>
            let
              val qs = r_lhs_states_impl rule;
            in
              all_interval_nat
                (fn i => memb_rm_basic_ops B_ (nth qs i) (nth reca i)) zero_nata
                n
            end)
          rules;
      val a = map rqss_impl arules;
    in
      rs_Union B_ a
    end;

fun rule_state_compatible_eff_list (A1_, A2_) B_ (C1_, C2_) ta rel (l, r) =
  let
    val rm = ta_rules_impl ta;
    val eps = ta_epss_impl ta;
    val epsa = ta_epsrs_impl ta;
    val ta_res = ta_res_impl B_ A1_ rm eps;
    val rhs_rbt = ta_rhs_states_set ta;
    val rhs =
      g_to_list_dflt_basic_oops_rm_basic_ops (linorder_compare_order A1_)
        rhs_rbt;
  in
    catch_errora
      (forallM
        (fn sigma =>
          let
            val sigmaa = fun_of C2_ sigma;
            val l_sigma = map_term (fn x => x) sigmaa l;
            val r_sigma = map_term (fn x => x) sigmaa r;
            val qsl = ta_res l_sigma;
            val qsr = ta_res r_sigma;
          in
            (case rel qsl qsr of NONE => Inr ()
              | SOME q => Inl ((l_sigma, r_sigma), q))
          end)
        (g_to_list_dflt_basic_oops_rm_basic_ops
          (linorder_list
            (equal_prod C2_ A2_,
              linorder_prod (linorder_compare_order C1_)
                (linorder_compare_order A1_)))
          (ta_match_impla B_ (A1_, A2_) (C1_, C2_) rm rhs_rbt epsa rhs l)))
      (fn x => Inl (snd x))
  end;

fun state_compatible_eff_list (A1_, A2_) B_ (C1_, C2_) ta rel r =
  let
    val check = rule_state_compatible_eff_list (A1_, A2_) B_ (C1_, C2_) ta rel;
  in
    catch_errora
      (forallM (fn lr => catch_errora (check lr) (fn x => Inl (lr, x))) r)
      (fn x => Inl (snd x))
  end;

fun ta_final_impl (TA_Impl (x1, x2, x3, x4, x5, x6, x7)) = x1;

fun flatten_term_enum_filter f (Var x) = let
   val tx = Var x;
 in
   (if f tx then [tx] else [])
 end
  | flatten_term_enum_filter f (Fun (fs, ts)) =
    let
      val lts = map (flatten_term_enum_filter f) ts;
    in
      (if list_ex null lts then []
        else let
               val ss = concat_lists lts;
             in
               filtera f (maps (fn fa => map (fn a => Fun (fa, a)) ss) fs)
             end)
    end;

fun inverse_base_term_filter filt l c =
  let
    val hs = upt zero_nata (suc c);
  in
    flatten_term_enum_filter filt
      (map_term (fn f => map (fn h => lift h f) hs) (fn x => x) l)
  end;

fun size_multiset (Bag ms) = foldd (fn _ => plus_nata) zero_nata ms;

fun compute_height A_ B_ (Weak_TRS NONE) bl br =
  (if less_eq_nat (size_multiset (funs_term_ms A_ br))
        (size_multiset (funs_term_ms A_ bl))
    then (fn l => fn x =>
           (if equal_terma (equal_prod A_ equal_nat) B_
                 (map_term (lift x) (fn xa => xa) bl) l
             then x else suc x))
    else (fn _ => suc))
  | compute_height A_ B_ (Weak_TRS (SOME c)) bl br =
    (if less_eq_nat (size_multiset (funs_term_ms A_ br))
          (size_multiset (funs_term_ms A_ bl))
      then (fn l => fn x =>
             (if equal_terma (equal_prod A_ equal_nat) B_
                   (map_term (lift x) (fn xa => xa) bl) l
               then min ord_nat c x else min ord_nat c (suc x)))
      else (fn _ => fn x => min ord_nat c (suc x)))
  | compute_height A_ B_ Strict_TRS bl br = (fn _ => suc);

fun cover_bound_list_filter A_ B_ filt ff gg c r =
  maps (fn (l, ra) =>
         let
           val ch = compute_height A_ B_ gg l ra;
           val ee = ff (l, ra);
         in
           map (fn la =>
                 (la, map_term
                        (lift (ch la
                                (min_list linorder_nat
                                  (map height
                                    (sym_collect
                                      (fn t => ee (map_term base (fn x => x) t))
                                      la)))))
                        (fn x => x) ra))
             (inverse_base_term_filter filt l c)
         end)
    r;

fun g_bex_dflt_basic_oops_rm_basic_ops A_ s p =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops A_ s not
    (fn x => fn _ => p x) false;

fun ta_contains_aux_impl A_ (B1_, B2_, B3_, B4_) f qs ta q =
  let
    val _ = ta_final_impl ta;
    val look =
      rm_set_lookup (compare_order_prod A_ compare_order_nat)
        (ta_rules_impl ta);
    val _ = ta_epss_impl ta;
  in
    catch_errora
      (forallM
        (fn (fa, n) =>
          let
            val rules = look (fa, n);
          in
            catch_errora
              (catch_errora
                (forallM
                  (fn x =>
                    (if list_ex
                          (fn rule =>
                            equal_lista B3_ (r_lhs_states_impl rule) x andalso
                              let
                                val qq = rqss_impl rule;
                              in
                                g_bex_dflt_basic_oops_rm_basic_ops B4_ qq
                                  (fn qa => member (B1_, B2_) qa q)
                              end)
                          rules
                      then Inr () else Inl x))
                  (concat_lists (replicate n qs)))
                (fn x => Inl (snd x)))
              (fn x => Inl (Fun (fa, map Var x)))
          end)
        f)
      (fn x => Inl (snd x))
  end;

fun alpha_rm_basic_ops (A1_, A2_) s = dom A1_ (lookup A2_ s);

fun ta_contains_impl A_ (B1_, B2_, B3_, B4_, B5_, B6_) f g ta qs =
  bindb (ta_contains_aux_impl A_ (B2_, B3_, B5_, linorder_compare_order B4_) f
          qs ta (set (B2_, B3_, B6_) qs))
    (fn _ =>
      ta_contains_aux_impl A_ (B2_, B3_, B5_, linorder_compare_order B4_) g qs
        ta (alpha_rm_basic_ops (B1_, B4_) (ta_final_impl ta)));

fun check_coherent_rule (A1_, A2_, A3_) (B1_, B2_) iter rel rules
  (TA_rule (f, qs, q)) =
  catch_errora
    (forallM
      (fn i =>
        let
          val qi = nth qs i;
        in
          catch_errora
            (forallM
              (fn qia =>
                let
                  val qsa = list_update qs i qia;
                in
                  check (not (null (filtera
                                     (fn TA_rule (g, qsb, qa) =>
                                       eq B1_ f g andalso
 (equal_lista A2_ qsa qsb andalso
   memb_rm_basic_ops (compare_order_prod A1_ A1_) (q, qa) rel))
                                     rules)))
                    (shows_prec_list show_char zero_nata
                       [#"r", #"u", #"l", #"e", #" "] o
                      (shows_prec B2_ zero_nata f o
                        (shows_prec_list show_char zero_nata [#"("] o
                          (shows_prec_list A3_ zero_nata qs o
                            (shows_prec_list show_char zero_nata
                               [#")", #" ", #"-", #">", #" "] o
                              (shows_prec A3_ zero_nata q o
                                (shows_prec_list show_char zero_nata
                                   [#" ", #"w", #"i", #"t", #"h", #" "] o
                                  (shows_prec_nat zero_nata (suc i) o
                                    (shows_prec_list show_char zero_nata
                                       [#".", #" ", #"a", #"r", #"g", #"u",
 #"m", #"e", #"n", #"t", #" ", #"d", #"e", #"c", #"r", #"e", #"a", #"s", #"e",
 #"d", #" ", #"t", #"o", #" "] o
                                      (shows_prec A3_ zero_nata qia o
shows_prec_list show_char zero_nata
  [#" ", #"h", #"a", #"s", #" ", #"n", #"o", #" ", #"c", #"o", #"u", #"n", #"t",
    #"e", #"r", #"p", #"a", #"r", #"t"]))))))))))
                end)
              (iter qi))
            (fn x => Inl (snd x))
        end)
      (upt zero_nata (size_list qs)))
    (fn x => Inl (snd x));

fun ntrancl (A1_, A2_, A3_) n r =
  (if equal_nata n zero_nata then r
    else let
           val ra = ntrancl (A1_, A2_, A3_) (minus_nata n one_nata) r;
         in
           sup_seta (ceq_prod A1_ A1_, ccompare_prod A2_ A2_) ra
             (relcomp (A1_, A2_, A3_) (A1_, A2_) (A1_, A2_, A3_) ra r)
         end);

fun trancl (A1_, A2_, A3_, A4_) a =
  (if finite
        (finite_UNIV_prod (finite_UNIV_card_UNIV A1_)
           (finite_UNIV_card_UNIV A1_),
          ceq_prod A2_ A2_, ccompare_prod A3_ A3_)
        a
    then ntrancl (A2_, A3_, A4_)
           (minus_nata
             (card (card_UNIV_prod A1_ A1_, ceq_prod A2_ A2_,
                     ccompare_prod A3_ A3_, set_impl_prod A4_ A4_)
               a)
             one_nata)
           a
    else (raise Fail "trancl: infinite set")
           (fn _ => trancl (A1_, A2_, A3_, A4_) a));

fun check_coherent (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_) (B1_, B2_)
  (Tree_Automaton (fin, rules, eps)) (Some_Relation rel) =
  let
    val iter =
      (fn q =>
        map_filter (fn x => (if let
                                  val (a, _) = x;
                                in
                                  eq A6_ a q
                                end
                              then SOME (snd x) else NONE))
          rel);
    val rs =
      g_from_list_dflt_basic_oops_rm_basic_ops (compare_order_prod A5_ A5_) rel;
    val ep =
      set (ceq_prod A3_ A3_, ccompare_prod A4_ A4_, set_impl_prod A7_ A7_) eps;
    val rell =
      converse (A3_, A4_, A7_) (A3_, A4_, A7_)
        (set (ceq_prod A3_ A3_, ccompare_prod A4_ A4_, set_impl_prod A7_ A7_)
          rel);
  in
    bindb (catch_errora (check_subseteq A6_ (maps iter fin) fin)
            (fn x =>
              Inl (shows_prec A8_ zero_nata x o
                    shows_prec_list show_char zero_nata
                      [#" ", #"i", #"s", #" ", #"i", #"n", #" ", #"r", #"e",
                        #"l", #"a", #"t", #"i", #"o", #"n", #" ", #"t", #"o",
                        #" ", #"a", #" ", #"f", #"i", #"n", #"a", #"l", #" ",
                        #"s", #"t", #"a", #"t", #"e", #",", #" ", #"b", #"u",
                        #"t", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"f",
                        #"i", #"n", #"a", #"l", #" ", #"s", #"t", #"a", #"t",
                        #"e", #" ", #"i", #"t", #"s", #"e", #"l", #"f"])))
      (fn _ =>
        bindb (catch_errora
                (forallM
                  (check_coherent_rule (A5_, A6_, A8_) (B1_, B2_) iter rs rules)
                  rules)
                (fn x => Inl (snd x)))
          (fn _ =>
            check (less_eq_set
                    (cenum_prod A2_ A2_, ceq_prod A3_ A3_,
                      ccompare_prod A4_ A4_)
                    (relcomp (A3_, A4_, A7_) (A3_, A4_) (A3_, A4_, A7_) rell ep)
                    (sup_seta (ceq_prod A3_ A3_, ccompare_prod A4_ A4_)
                      (relcomp (A3_, A4_, A7_) (A3_, A4_) (A3_, A4_, A7_)
                        (trancl (A1_, A3_, A4_, A7_) ep) rell)
                      rell))
              (shows_prec_list show_char zero_nata
                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                  #" ", #"c", #"o", #"h", #"e", #"r", #"e", #"n", #"c", #"e",
                  #" ", #"o", #"f", #" ", #"e", #"p", #"s", #"i", #"l", #"o",
                  #"n", #" ", #"r", #"u", #"l", #"e", #"s"])))
  end
  | check_coherent (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_) (B1_, B2_) uu
    Decision_Proc_Old = Inr ()
  | check_coherent (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_) (B1_, B2_) uu
    Decision_Proc = Inr ()
  | check_coherent (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_) (B1_, B2_) uu
    Id_Relation = Inr ();

fun rtrancl_rbt_impl A_ =
  rtrancl_impl
    (fn r =>
      let
        val rm = elem_list_to_rm A_ fst r;
      in
        (fn asa =>
          g_to_list_dflt_basic_oops_rm_basic_ops (linorder_compare_order A_)
            (rs_Union A_
              (map (fn a =>
                     g_from_list_dflt_basic_oops_rm_basic_ops A_
                       (map snd (rm_set_lookup A_ rm a)))
                asa)))
      end)
    (fn asa => fn bs =>
      g_union_dflt_basic_oops_rm_basic_ops A_ bs
        (g_from_list_dflt_basic_oops_rm_basic_ops A_ asa))
    (memb_rm_basic_ops A_) (empty_rm_basic_ops (linorder_compare_order A_) ());

fun memo_rbt_rtrancl A_ r =
  let
    val tr = rtrancl_rbt_impl A_ r;
    val rm =
      g_list_to_map_rm_basic_ops A_
        (map (fn a => (a, tr [a]))
          ((g_to_list_dflt_basic_oops_rm_basic_ops (linorder_compare_order A_) o
              g_from_list_dflt_basic_oops_rm_basic_ops A_ o
             map fst)
            r));
  in
    (fn a =>
      (case lookup A_ rm a
        of NONE => g_from_list_dflt_basic_oops_rm_basic_ops A_ [a]
        | SOME asa => asa))
  end;

fun conv_ta_rule eps (TA_rule (f, qs, q)) = TA_rule_impl (f, qs, q, eps q);

fun r_sym_impl (TA_rule_impl (f, qsa, q, qs)) = (f, size_list qsa);

fun generate_ta A_ B_ (Tree_Automaton (fin, rules, eps)) =
  let
    val ep = memo_rbt_rtrancl A_ eps;
    val epr = memo_rbt_rtrancl A_ (map (fn (q, qa) => (qa, q)) eps);
    val rqs_rs = rs_Union A_ (map (fn rule => ep (r_rhs rule)) rules);
    val rrules = map (conv_ta_rule ep) rules;
  in
    TA_Impl
      (g_from_list_dflt_basic_oops_rm_basic_ops A_ fin,
        elem_list_to_rm (compare_order_prod B_ compare_order_nat) r_sym_impl
          rrules,
        g_to_list_dflt_basic_oops_rm_basic_ops (linorder_compare_order A_)
          rqs_rs,
        rqs_rs, eps, ep, epr)
  end;

fun generate_ta_cond (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_) (B1_, B2_, B3_) ta
  rel =
  bindb (catch_errora
          (check_coherent (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_) (B2_, B3_) ta
            rel)
          (fn x =>
            Inl (shows_prec_list show_char zero_nata
                   [#"a", #"u", #"t", #"o", #"m", #"a", #"t", #"o", #"n", #" ",
                     #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"c", #"o", #"h",
                     #"e", #"r", #"e", #"n", #"t", #" ", #"w", #".", #"r", #".",
                     #"t", #".", #" ", #"r", #"e", #"l", #"a", #"t", #"i", #"o",
                     #"n"] o
                  (shows_nl o x))))
    (fn _ => Inr (generate_ta A5_ B1_ ta));

fun relation_as_list (Some_Relation rel) = Inr rel
  | relation_as_list Id_Relation = Inr []
  | relation_as_list Decision_Proc =
    Inl (shows_prec_list show_char zero_nata
          [#"d", #"e", #"c", #"i", #"s", #"i", #"o", #"n", #" ", #"p", #"r",
            #"o", #"c", #"e", #"d", #"u", #"r", #"e", #" ", #"n", #"o", #"t",
            #" ", #"a", #"v", #"a", #"i", #"l", #"a", #"b", #"l", #"e", #" ",
            #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"l", #"e", #"f",
            #"t", #" ", #"l", #"i", #"n", #"e", #"a", #"r", #" ", #"T", #"R",
            #"S", #"s"])
  | relation_as_list Decision_Proc_Old =
    Inl (shows_prec_list show_char zero_nata
          [#"d", #"e", #"c", #"i", #"s", #"i", #"o", #"n", #" ", #"p", #"r",
            #"o", #"c", #"e", #"d", #"u", #"r", #"e", #" ", #"n", #"o", #"t",
            #" ", #"a", #"v", #"a", #"i", #"l", #"a", #"b", #"l", #"e", #" ",
            #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"l", #"e", #"f",
            #"t", #" ", #"l", #"i", #"n", #"e", #"a", #"r", #" ", #"T", #"R",
            #"S", #"s"]);

fun check_ta_bounded (B1_, B2_) ta c =
  catch_errora
    (catch_errora
      (forallM (fn x => (if let
                              val (f, _) = x;
                            in
                              less_eq_nat (height f) c
                            end
                          then Inr () else Inl x))
        (map fst
          (g_to_list_rm_basic_ops
            (linorder_prod (linorder_prod B1_ linorder_nat) linorder_nat)
            (ta_rules_impl ta))))
      (fn x => Inl (snd x)))
    (fn x =>
      Inl let
            val (f, _) = x;
          in
            shows_prec_prod B2_ show_nat zero_nata f o
              (shows_prec_list show_char zero_nata
                 [#" ", #"i", #"s", #" ", #"s", #"y", #"m", #"b", #"o", #"l",
                   #" ", #"i", #"n", #" ", #"T", #"A", #" ", #"w", #"i", #"t",
                   #"h", #" ", #"h", #"e", #"i", #"g", #"h", #"t", #" ", #"l",
                   #"a", #"r", #"g", #"e", #"r", #" ", #"t", #"h", #"a", #"n",
                   #" ", #"c", #" ", #"=", #" "] o
                shows_prec_nat zero_nata c)
          end);

fun bounds_condition A_ (B1_, B2_) Roof uu = Inr ()
  | bounds_condition A_ (B1_, B2_) Match r =
    catch_errora
      (catch_errora
        (forallM
          (fn x =>
            (if let
                  val (l, ra) = x;
                in
                  subseteq_mset B1_ (vars_term_ms B1_ ra) (vars_term_ms B1_ l)
                end
              then Inr () else Inl x))
          r)
        (fn x => Inl (snd x)))
      (fn x =>
        Inl let
              val (l, ra) = x;
            in
              shows_prec_list show_char zero_nata
                [#"r", #"u", #"l", #"e", #" "] o
                (shows_rule (shows_prec A_ zero_nata) (shows_prec B2_ zero_nata)
                   [#" ", #"-", #">", #" "] (l, ra) o
                  shows_prec_list show_char zero_nata
                    [#" ", #"i", #"s", #" ", #"d", #"u", #"p", #"l", #"i", #"c",
                      #"a", #"t", #"i", #"n", #"g"])
            end);

fun non_collapsing_impl r = list_all ((fn t => not (is_Var t)) o snd) r;

fun construct_c_opt c r = (if non_collapsing_impl r then SOME c else NONE);

fun boundstype_fun (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) Roof =
  roof (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
  | boundstype_fun (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) Match =
    matcha;

fun iteratei_set_op_list_it_rs_ops A_ s =
  (fn c => fn f => rm_iterateoi (impl_of A_ s) c (f o fst));

fun rs_subset A_ asa bs =
  iteratei_set_op_list_it_rs_ops (linorder_compare_order A_) asa
    (fn a => (case a of NONE => true | SOME _ => false))
    (fn a => fn _ => (if memb_rm_basic_ops A_ a bs then NONE else SOME a)) NONE;

fun rel_checker (A1_, A2_) (Some_Relation rel) =
  (fn lhs => fn rhs =>
    let
      val rlist =
        g_to_list_dflt_basic_oops_rm_basic_ops (linorder_compare_order A1_) rhs;
    in
      (case catch_errora
              (forallM
                (fn l =>
                  check (list_ex
                          (fn r => membera (equal_prod A2_ A2_) rel (l, r))
                          rlist)
                    l)
                (g_to_list_dflt_basic_oops_rm_basic_ops
                  (linorder_compare_order A1_) lhs))
              (fn x => Inl (snd x))
        of Inl a => SOME a | Inr _ => NONE)
    end)
  | rel_checker (A1_, A2_) Id_Relation = rs_subset A1_
  | rel_checker (A1_, A2_) Decision_Proc = rs_subset A1_
  | rel_checker (A1_, A2_) Decision_Proc_Old = rs_subset A1_;

fun check_det A_ B_ (Tree_Automaton (fin, rules, eps)) =
  catch_errora
    (bindb
      (check (null eps)
        (shows_prec_list show_char zero_nata
          [#"e", #"p", #"s", #"i", #"l", #"o", #"n", #" ", #"t", #"r", #"a",
            #"n", #"s", #"i", #"t", #"i", #"o", #"n", #"s", #" ", #"n", #"o",
            #"t", #" ", #"a", #"l", #"l", #"o", #"w", #"e", #"d"]))
      (fn _ =>
        check (distinct (equal_prod B_ (equal_list A_))
                (map (fn TA_rule (f, qs, _) => (f, qs))
                  (remdups (equal_ta_rule A_ B_) rules)))
          (shows_prec_list show_char zero_nata
            [#"s", #"o", #"m", #"e", #" ", #"l", #"h", #"s", #" ", #"o", #"c",
              #"c", #"u", #"r", #"s", #" ", #"t", #"w", #"i", #"c", #"e"])))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
               #"n", #" ", #"e", #"n", #"s", #"u", #"r", #"i", #"n", #"g", #" ",
               #"d", #"e", #"t", #"e", #"r", #"m", #"i", #"n", #"i", #"s", #"m",
               #" ", #"o", #"f", #" ", #"a", #"u", #"t", #"o", #"m", #"a", #"t",
               #"a"] o
            (shows_nl o x)));

fun check_bounds_generic (A1_, A2_, A3_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
  (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_)
  (Bounds_Info (typea, c, qfin, preTA, rel)) r s f g =
  let
    val c_opt = construct_c_opt c r;
    val rs = r @ s;
  in
    bindb (generate_ta_cond (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
            (compare_order_prod A1_ compare_order_nat, equal_prod A2_ equal_nat,
              show_prod A3_ show_nat)
            preTA rel)
      (fn ta =>
        let
          val rell = rel_checker (B5_, B6_) rel;
        in
          bindb (check_wf_trs A3_ (C6_, C8_) rs)
            (fn _ =>
              bindb (check
                      (less_eq_set (B2_, B3_, B4_) (set (B3_, B4_, B7_) qfin)
                        (alpha_rm_basic_ops (B2_, B5_) (ta_final_impl ta)))
                      (shows_prec_list show_char zero_nata
                        [#"e", #"x", #"p", #"l", #"i", #"c", #"i", #"t", #"l",
                          #"y", #" ", #"m", #"e", #"n", #"t", #"i", #"o", #"n",
                          #"e", #"d", #" ", #"f", #"i", #"n", #"a", #"l", #" ",
                          #"s", #"t", #"a", #"t", #"e", #"s", #" ", #"m", #"u",
                          #"s", #"t", #" ", #"b", #"e", #" ", #"f", #"i", #"n",
                          #"a", #"l"]))
                (fn _ =>
                  bindb (if isOK (check_left_linear_trs A3_
                                   (C3_, ccompare_cproper_interval C4_, C7_,
                                     C8_)
                                   rs)
                          then Inr ()
                          else bindb (catch_errora
                                       (check_det B6_ (equal_prod A2_ equal_nat)
 preTA)
                                       (fn x =>
 Inl (shows_prec_list show_char zero_nata
        [#"f", #"o", #"r", #" ", #"n", #"o", #"n", #" ", #"l", #"e", #"f", #"t",
          #"-", #"l", #"i", #"n", #"e", #"a", #"r", #" ", #"T", #"R", #"S",
          #" ", #"w", #"e", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e",
          #" ", #"d", #"e", #"t", #".", #" ", #"a", #"u", #"t", #"o", #"m",
          #"a", #"t", #"o", #"n"] o
       (shows_nl o x))))
                                 (fn _ =>
                                   bindb (relation_as_list rel)
                                     (check_state_raise_consistent
                                       (B3_, B4_, B6_,
 linorder_compare_order B5_, B7_, B8_)
                                       (A2_, A3_) preTA)))
                    (fn _ =>
                      bindb (bounds_condition A3_ (C6_, C8_) typea rs)
                        (fn _ =>
                          bindb (check_ta_bounded
                                  (linorder_compare_order A1_, A3_) ta c)
                            (fn _ =>
                              bindb (check
                                      (list_ex
(fn q => memb_rm_basic_ops B5_ q (ta_rhs_states_set ta)) qfin)
                                      (shows_prec_list show_char zero_nata
[#"d", #"i", #"d", #" ", #"n", #"o", #"t", #" ", #"f", #"i", #"n", #"d", #" ",
  #"m", #"e", #"n", #"t", #"i", #"o", #"n", #"e", #"d", #" ", #"f", #"i", #"n",
  #"a", #"l", #" ", #"s", #"t", #"a", #"t", #"e", #" ", #"i", #"n", #" ", #"T",
  #"A"]))
                                (fn _ =>
                                  bindb (catch_errora
  (ta_contains_impl (compare_order_prod A1_ compare_order_nat)
    (B2_, B3_, B4_, B5_, B6_, B7_)
    (map (fn (fa, a) => (lift zero_nata fa, a)) f)
    (map (fn (fa, a) => (lift zero_nata fa, a)) g) ta qfin)
  (fn x =>
    Inl (shows_prec_list show_char zero_nata
           [#"i", #"t", #" ", #"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
             #"t", #" ", #"b", #"e", #" ", #"g", #"u", #"a", #"r", #"a", #"n",
             #"t", #"e", #"e", #"d", #" ", #"t", #"h", #"a", #"t", #" ", #"l",
             #"i", #"f", #"t", #"0", #"(", #"T", #"(", #"S", #"i", #"g", #"m",
             #"a", #")", #")", #" ", #"i", #"s", #" ", #"a", #"c", #"c", #"e",
             #"p", #"t", #"e", #"d", #" ", #"b", #"y", #" ", #"T", #"A"] o
          (shows_nl o
            (shows_prec_list show_char zero_nata
               [#"t", #"h", #"e", #"r", #"e", #" ", #"i", #"s", #" ", #"n",
                 #"o", #" ", #"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i",
                 #"o", #"n", #" ", #"f", #"r", #"o", #"m", #" "] o
              (shows_prec_term (show_prod A3_ show_nat) B8_ zero_nata x o
                shows_prec_list show_char zero_nata
                  [#" ", #"t", #"o", #" ", #"a", #" ", #"f", #"i", #"n", #"a",
                    #"l", #" ", #"s", #"t", #"a", #"t", #"e"]))))))
                                    (fn _ =>
                                      bindb
(catch_errora
  (state_compatible_eff_list (B5_, B6_)
    (compare_order_prod A1_ compare_order_nat) (C5_, C6_) ta rell
    (cover_bound_list_filter A2_ C6_
      (fn l =>
        not (rule_state_compatible_heuristic B5_
              (compare_order_prod A1_ compare_order_nat)
              (linorder_compare_order C5_) ta l))
      (boundstype_fun (compare_compare_order A1_, A2_)
        (C1_, C2_, C3_, C4_, compare_compare_order C5_, C6_, C7_) typea)
      Strict_TRS c r))
  (fn x =>
    Inl let
          val (lr, (lr_rhs, q)) = x;
        in
          shows_prec_list show_char zero_nata
            [#"T", #"A", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"c",
              #"o", #"m", #"p", #"a", #"t", #"i", #"b", #"l", #"e", #" ", #"w",
              #"i", #"t", #"h", #" ", #"T", #"R", #"S"] o
            (shows_nl o
              (shows_prec_list show_char zero_nata
                 [#"f", #"o", #"r", #" ", #"r", #"u", #"l", #"e", #" "] o
                (shows_rule (shows_prec_prod A3_ show_nat zero_nata)
                   (shows_prec C8_ zero_nata) [#" ", #"-", #">", #" "] lr o
                  (shows_nl o
                    (shows_prec_list show_char zero_nata
                       [#"w", #"h", #"i", #"c", #"h", #" ", #"i", #"s", #" ",
                         #"i", #"n", #"s", #"t", #"a", #"n", #"t", #"i", #"a",
                         #"t", #"e", #"d", #" ", #"b", #"y", #" ", #"s", #"t",
                         #"a", #"t", #"e", #"s", #" ", #"t", #"o", #" "] o
                      (shows_rule (shows_prec_prod A3_ show_nat zero_nata)
                         (shows_prec B8_ zero_nata) [#" ", #"-", #">", #" "]
                         lr_rhs o
                        (shows_nl o
                          (shows_prec_list show_char zero_nata
                             [#"t", #"h", #"e", #" ", #"s", #"t", #"a", #"t",
                               #"e", #" "] o
                            (shows_prec B8_ zero_nata q o
                              (shows_prec_list show_char zero_nata
                                 [#" ", #"i", #"s", #" ", #"o", #"n", #"l",
                                   #"y", #" ", #"r", #"e", #"a", #"c", #"h",
                                   #"a", #"b", #"l", #"e", #" ", #"f", #"r",
                                   #"o", #"m", #" ", #"t", #"h", #"e", #" ",
                                   #"l", #"h", #"s"] o
                                shows_nl))))))))))
        end))
(fn _ =>
  catch_errora
    (state_compatible_eff_list (B5_, B6_)
      (compare_order_prod A1_ compare_order_nat) (C5_, C6_) ta rell
      (cover_bound_list_filter A2_ C6_
        (fn l =>
          not (rule_state_compatible_heuristic B5_
                (compare_order_prod A1_ compare_order_nat)
                (linorder_compare_order C5_) ta l))
        matcha (Weak_TRS c_opt) c s))
    (fn x =>
      Inl let
            val (lr, (lr_rhs, q)) = x;
          in
            shows_prec_list show_char zero_nata
              [#"T", #"A", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"c",
                #"o", #"m", #"p", #"a", #"t", #"i", #"b", #"l", #"e", #" ",
                #"w", #"i", #"t", #"h", #" ", #"r", #"e", #"l", #"a", #"t",
                #"i", #"v", #"e", #" ", #"T", #"R", #"S"] o
              (shows_nl o
                (shows_prec_list show_char zero_nata
                   [#"f", #"o", #"r", #" ", #"r", #"u", #"l", #"e", #" "] o
                  (shows_rule (shows_prec_prod A3_ show_nat zero_nata)
                     (shows_prec C8_ zero_nata) [#" ", #"-", #">", #" "] lr o
                    (shows_nl o
                      (shows_prec_list show_char zero_nata
                         [#"w", #"h", #"i", #"c", #"h", #" ", #"i", #"s", #" ",
                           #"i", #"n", #"s", #"t", #"a", #"n", #"t", #"i", #"a",
                           #"t", #"e", #"d", #" ", #"b", #"y", #" ", #"s", #"t",
                           #"a", #"t", #"e", #"s", #" ", #"t", #"o", #" "] o
                        (shows_rule (shows_prec_prod A3_ show_nat zero_nata)
                           (shows_prec B8_ zero_nata) [#" ", #"-", #">", #" "]
                           lr_rhs o
                          (shows_nl o
                            (shows_prec_list show_char zero_nata
                               [#"t", #"h", #"e", #" ", #"s", #"t", #"a", #"t",
                                 #"e", #" "] o
                              (shows_prec B8_ zero_nata q o
                                (shows_prec_list show_char zero_nata
                                   [#" ", #"i", #"s", #" ", #"o", #"n", #"l",
                                     #"y", #" ", #"r", #"e", #"a", #"c", #"h",
                                     #"a", #"b", #"l", #"e", #" ", #"f", #"r",
                                     #"o", #"m", #" ", #"t", #"h", #"e", #" ",
                                     #"l", #"h", #"s"] o
                                  shows_nl))))))))))
          end)))))))))
        end)
  end;

fun bounds_tt (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_)
  (D1_, D2_, D3_, D4_, D5_, D6_, D7_, D8_) i info tp =
  let
    val r = rulesd i tp;
    val f = funas_trs_list r;
  in
    check_bounds_generic (B1_, B2_, B3_)
      (D1_, D2_, D3_, D4_, D5_, D6_, D7_, D8_)
      (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_) info r [] f f
  end;

fun check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tp
  R_is_Empty =
  debug (i []) [#"R", #" ", #"i", #"s", #" ", #"e", #"m", #"p", #"t", #"y"]
    (if null (rc j tp) then Inr ()
      else Inl (i o (shows_string
                       [#":", #" ", #"R", #" ", #"i", #"s", #" ", #"n", #"o",
                         #"t", #" ", #"e", #"m", #"p", #"t", #"y", #" ", #"i",
                         #"n", #" ", #"t", #"h", #"e", #" ", #"f", #"o", #"l",
                         #"l", #"o", #"w", #"i", #"n", #"g", #" ", #"t", #"e",
                         #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n",
                         #"-", #"p", #"r", #"o", #"b", #"l", #"e", #"m", #" "] o
                      (shows_nl o
                        shows_tp
                          (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                          (shows_prec_list show_char zero_nata) j tp))))
  | check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tp
    (Rule_Removal (redp, rR, prf)) =
    debug (i [])
      [#"R", #"u", #"l", #"e", #" ", #"R", #"e", #"m", #"o", #"v", #"a", #"l"]
      let
        val r = rulesd j tp;
        val rr =
          ceta_list_diff
            (key_prod
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char)))
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char))))
            r rR;
      in
        bindb (catch_errora
                (rule_removal_tt (show_lab B4_ (show_list show_nat))
                  (show_list show_char) j
                  (get_redtriple
                    (ceq_lab B2_ (equal_list equal_nat),
                      ccompare_lab
                        ((compare_compare_order o compare_order_key) B3_)
                        ((compare_compare_order o compare_order_key)
                          (key_list (equal_nat, key_nat))),
                      equal_lab B2_ (equal_list equal_nat),
                      key_lab B3_ (key_list (equal_nat, key_nat)), set_impl_lab,
                      show_lab B4_ (show_list show_nat))
                    redp)
                  rr tp)
                (fn x =>
                  Inl (i o (shows_string
                              [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                #"w", #"h", #"e", #"n", #" ", #"a", #"p", #"p",
                                #"l", #"y", #"i", #"n", #"g", #" ", #"t", #"h",
                                #"e", #" ", #"r", #"u", #"l", #"e", #" ", #"r",
                                #"e", #"m", #"o", #"v", #"a", #"l", #" ", #"t",
                                #"e", #"c", #"h", #"n", #"i", #"q", #"u", #"e",
                                #" ", #"o", #"n", #" "] o
                             (shows_nl o
                               (shows_tp
                                  (shows_prec_lab B4_ (show_list show_nat)
                                    zero_nata)
                                  (shows_prec_list show_char zero_nata) j tp o
                                 (shows_nl o
                                   (shows_string
                                      [#" ", #"t", #"o", #" ", #"r", #"e", #"m",
#"o", #"v", #"e", #" ", #"t", #"h", #"e", #" ", #"r", #"u", #"l", #"e", #"s",
#" "] o
                                     (shows_nl o
                                       (shows_rules
  (shows_prec_lab B4_ (show_list show_nat) zero_nata)
  (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] rr o
 (shows_nl o x)))))))))))
          (fn tpa =>
            catch_errora
              (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
                (i o shows_string [#".", #"1"]) tpa prf)
              (fn x =>
                Inl (i o (shows_string
                            [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                              #"b", #"e", #"l", #"o", #"w", #" ", #"t", #"h",
                              #"e", #" ", #"r", #"u", #"l", #"e", #" ", #"r",
                              #"e", #"m", #"o", #"v", #"a", #"l", #" ", #"t",
                              #"e", #"c", #"h", #"n", #"i", #"q", #"u", #"e"] o
                           (shows_nl o indent x)))))
      end
  | check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tp
    (DP_Trans (nfs, m, p, prf)) =
    debug (i []) [#"D", #"P", #" ", #"t", #"r", #"a", #"n", #"s"]
      (bindb
        (catch_errora
          (dependency_pairs_tt
            (compare_lab ((compare_compare_order o compare_order_key) B3_)
               (compare_list compare_nat),
              equal_lab B2_ (equal_list equal_nat),
              linorder_lab ((compare_compare_order o compare_order_key) B3_)
                (compare_list compare_nat),
              show_lab B4_ (show_list show_nat))
            (ccompare_list ccompare_char, compare_list compare_char,
              equal_list equal_char, mapping_impl_list,
              linorder_list (equal_char, linorder_char), show_list show_char)
            Sharp j ia tp nfs m p)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"s", #"w", #"i", #"t", #"c",
                          #"h", #"i", #"n", #"g", #" ", #"f", #"r", #"o", #"m",
                          #" ", #"t", #"h", #"e", #" ", #"T", #"R", #"S"] o
                       (shows_nl o
                         (shows_tp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) j tp o
                           (shows_nl o
                             (shows_string
                                [#"t", #"o", #" ", #"t", #"h", #"e", #" ", #"i",
                                  #"n", #"i", #"t", #"i", #"a", #"l", #" ",
                                  #"D", #"P", #" ", #"p", #"r", #"o", #"b",
                                  #"l", #"e", #"m", #" ", #"w", #"i", #"t",
                                  #"h", #" ", #"p", #"a", #"i", #"r", #"s",
                                  #" "] o
                               (shows_nl o
                                 (shows_rules
                                    (shows_prec_lab B4_ (show_list show_nat)
                                      zero_nata)
                                    (shows_prec_list show_char zero_nata)
                                    [#" ", #"-", #">", #" "] p o
                                   (shows_nl o x)))))))))))
        (fn dpp =>
          catch_errora
            (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) dpp prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"s", #"w", #"i",
                            #"t", #"c", #"h", #" ", #"t", #"o", #" ", #"d",
                            #"e", #"p", #"e", #"n", #"d", #"e", #"n", #"c",
                            #"y", #" ", #"p", #"a", #"i", #"r", #"s"] o
                         (shows_nl o indent x))))))
  | check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tp
    (String_Reversal prf) =
    debug (i [])
      [#"S", #"t", #"r", #"i", #"n", #"g", #" ", #"R", #"e", #"v", #"e", #"r",
        #"s", #"a", #"l"]
      (bindb
        (catch_errora
          (string_reversal_tt (show_lab B4_ (show_list show_nat))
            (show_list show_char) j tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"s", #"t", #"r", #"i", #"n",
                          #"g", #" ", #"r", #"e", #"v", #"e", #"r", #"s", #"a",
                          #"l", #" ", #"o", #"n", #" "] o
                       (shows_nl o
                         (shows_tp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) j tp o
                           (shows_nl o x)))))))
        (fn tpa =>
          catch_errora
            (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) tpa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"s", #"t", #"r", #"i", #"n", #"g", #" ",
                            #"r", #"e", #"v", #"e", #"r", #"s", #"a", #"l",
                            #" ", #"t", #"e", #"c", #"h", #"n", #"i", #"q",
                            #"u", #"e"] o
                         (shows_nl o indent x))))))
  | check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tp
    (Constant_String (p, prf)) =
    debug (i [])
      [#"C", #"o", #"n", #"s", #"t", #"a", #"n", #"t", #" ", #"t", #"o", #" ",
        #"U", #"n", #"a", #"r", #"y"]
      (bindb
        (catch_errora
          (const_to_string_sound_tt
            (compare_lab ((compare_compare_order o compare_order_key) B3_)
               (compare_list compare_nat),
              equal_lab B2_ (equal_list equal_nat),
              show_lab B4_ (show_list show_nat))
            (finite_UNIV_list, cenum_list, ceq_list ceq_char,
              cproper_interval_list ccompare_char, compare_list compare_char,
              equal_list equal_char, set_impl_list, show_list show_char)
            p j tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"t", #"u", #"r", #"n", #"i",
                          #"n", #"g", #" ", #"c", #"o", #"n", #"s", #"t", #"a",
                          #"n", #"t", #"s", #" ", #"i", #"n", #"t", #"o", #" ",
                          #"u", #"n", #"a", #"r", #"y", #" ", #"s", #"y", #"m",
                          #"b", #"o", #"l", #"s", #" ", #"o", #"n", #" "] o
                       (shows_nl o
                         (shows_tp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) j tp o
                           (shows_nl o x)))))))
        (fn tpa =>
          catch_errora
            (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) tpa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"c", #"o", #"n", #"s", #"t", #"a", #"n",
                            #"t", #" ", #"t", #"o", #" ", #"u", #"n", #"a",
                            #"r", #"y", #" ", #"t", #"e", #"c", #"h", #"n",
                            #"i", #"q", #"u", #"e"] o
                         (shows_nl o indent x))))))
  | check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tp
    (Semlab (sli, lQ, lAll, prf)) =
    debug (i []) [#"S", #"e", #"m", #"l", #"a", #"b"]
      (bindb
        (catch_errora
          (semlab_fin_tt
            ((compare_compare_order o compare_order_key) B3_, B2_, B4_)
            (ccompare_list ccompare_char, compare_list compare_char,
              equal_list equal_char, mapping_impl_list, show_list show_char)
            j sli lQ lAll tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"s", #"e", #"m", #"a", #"n",
                          #"t", #"i", #"c", #" ", #"l", #"a", #"b", #"e", #"l",
                          #"l", #"i", #"n", #"g", #" ", #"o", #"n", #" "] o
                       (shows_nl o
                         (shows_tp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) j tp o
                           (shows_nl o x)))))))
        (fn tpa =>
          catch_errora
            (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) tpa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"s", #"e", #"m", #".", #"l", #"a", #"b",
                            #" ", #"t", #"e", #"c", #"h", #"n", #"i", #"q",
                            #"u", #"e"] o
                         (shows_nl o indent x))))))
  | check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tp
    (Bounds info) =
    debug (i []) [#"B", #"o", #"u", #"n", #"d", #"s"]
      (catch_errora
        (bounds_tt
          (compare_order_lab ((compare_compare_order o compare_order_key) B3_)
             (compare_list compare_nat),
            equal_lab B2_ (equal_list equal_nat),
            show_lab B4_ (show_list show_nat))
          (finite_UNIV_list, cenum_list, ceq_list ceq_char,
            cproper_interval_list ccompare_char,
            compare_order_list (compare_order_char, equal_char),
            equal_list equal_char, set_impl_list, show_list show_char)
          (card_UNIV_list, cenum_list, ceq_list ceq_char,
            ccompare_list ccompare_char,
            compare_order_list (compare_order_char, equal_char),
            equal_list equal_char, set_impl_list, show_list show_char)
          j info tp)
        (fn x =>
          Inl (i o (shows_string
                      [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                        #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                        #"i", #"n", #"g", #" ", #"b", #"o", #"u", #"n", #"d",
                        #"s", #" ", #"o", #"n", #" ", #"t", #"h", #"e", #" ",
                        #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
                        #"o", #"n", #" ", #"p", #"r", #"o", #"b", #"l", #"e",
                        #"m", #" "] o
                     (shows_nl o
                       (shows_tp
                          (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                          (shows_prec_list show_char zero_nata) j tp o
                         (shows_nl o x)))))))
  | check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tp
    (Uncurry (u_info, rR, prf)) =
    debug (i []) [#"U", #"n", #"c", #"u", #"r", #"r", #"y"]
      (bindb
        (catch_errora
          (uncurry_tt
            (equal_lab B2_ (equal_list equal_nat),
              show_lab B4_ (show_list show_nat))
            j u_info rR tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"c", #"u", #"r", #"r", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"r", #"a", #"n", #"s",
                          #"f", #"o", #"r", #"m", #"a", #"t", #"i", #"o",
                          #"n"] o
                       (shows_nl o x)))))
        (fn tpa =>
          catch_errora
            (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) tpa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"u", #"n", #"c", #"u", #"r", #"r", #"y",
                            #"i", #"n", #"g", #" ", #"t", #"e", #"c", #"h",
                            #"n", #"i", #"q", #"u", #"e"] o
                         (shows_nl o indent x))))))
  | check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tp
    (Fcc (fcs, r, prf)) =
    debug (i []) [#"F", #"c", #"c"]
      (bindb
        (catch_errora
          (fcc_tt
            (equal_lab B2_ (equal_list equal_nat),
              show_lab B4_ (show_list show_nat))
            (ccompare_list ccompare_char, equal_list equal_char,
              mapping_impl_list, show_list show_char)
            j fcs r tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"f", #"l", #"a", #"t", #" ",
                          #"c", #"o", #"n", #"t", #"e", #"x", #"t", #" ", #"c",
                          #"l", #"o", #"s", #"u", #"r", #"e"] o
                       (shows_nl o x)))))
        (fn tpa =>
          catch_errora
            (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) tpa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"f", #"l", #"a",
                            #"t", #" ", #"c", #"o", #"n", #"t", #"e", #"x",
                            #"t", #" ", #"c", #"l", #"o", #"s", #"u", #"r",
                            #"e"] o
                         (shows_nl o indent x))))))
  | check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tp
    (Split (rrem, prf1, prf2)) =
    debug (i []) [#"S", #"p", #"l", #"i", #"t"]
      let
        val (tp1, tp2) =
          split_tt (show_lab B4_ (show_list show_nat)) (show_list show_char) j
            tp rrem;
      in
        bindb (catch_errora
                (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia
                  assms (i o shows_string [#".", #"1"]) tp1 prf1)
                (fn x =>
                  Inl (i o (shows_string
                              [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                #"b", #"e", #"l", #"o", #"w", #" ", #"t", #"h",
                                #"e", #" ", #"s", #"p", #"l", #"i", #"t", #"t",
                                #"i", #"n", #"g"] o
                             (shows_nl o indent x)))))
          (fn _ =>
            catch_errora
              (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
                (i o shows_string [#".", #"2"]) tp2 prf2)
              (fn x =>
                Inl (i o (shows_string
                            [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                              #"b", #"e", #"l", #"o", #"w", #" ", #"t", #"h",
                              #"e", #" ", #"s", #"p", #"l", #"i", #"t", #"t",
                              #"i", #"n", #"g"] o
                           (shows_nl o indent x)))))
      end
  | check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tp
    (Switch_Innermost (joins, prf)) =
    debug (i [])
      [#"S", #"w", #"i", #"t", #"c", #"h", #" ", #"I", #"n", #"n", #"e", #"r",
        #"m", #"o", #"s", #"t"]
      (bindb
        (catch_errora
          (switch_innermost_tt
            (equal_lab B2_ (equal_list equal_nat),
              show_lab B4_ (show_list show_nat))
            j joins tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"s", #"w", #"i", #"t", #"c",
                          #"h", #"i", #"n", #"g", #" ", #"t", #"o", #" ", #"i",
                          #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ",
                          #"o", #"n", #" "] o
                       (shows_nl o
                         (shows_tp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) j tp o
                           (shows_nl o x)))))))
        (fn tpa =>
          catch_errora
            (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) tpa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"s", #"w", #"i", #"t", #"c", #"h", #" ",
                            #"t", #"o", #" ", #"i", #"n", #"n", #"e", #"r",
                            #"m", #"o", #"s", #"t"] o
                         (shows_nl o indent x))))))
  | check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tp
    (Drop_Equality prf) =
    debug (i [])
      [#"D", #"r", #"o", #"p", #" ", #"E", #"q", #"u", #"a", #"l", #"i", #"t",
        #"y"]
      let
        val tpa =
          mkc j (nfsb j tp) (qb j tp) (rc j tp)
            (filtera
              (fn (l, r) =>
                not (equal_terma (equal_lab B2_ (equal_list equal_nat))
                      (equal_list equal_char) l r))
              (rwc j tp));
      in
        catch_errora
          (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
            (i o shows_string [#".", #"1"]) tpa prf)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                          #"e", #"l", #"o", #"w", #" ", #"d", #"r", #"o", #"p",
                          #"p", #"i", #"n", #"g", #" ", #"e", #"q", #"u", #"a",
                          #"l", #"i", #"t", #"y", #" ", #"r", #"u", #"l", #"e",
                          #"s"] o
                       (shows_nl o indent x))))
      end
  | check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tp
    (Remove_Nonapplicable_Rules (r, prf)) =
    debug (i [])
      [#"R", #"e", #"m", #"o", #"v", #"i", #"n", #"g", #" ", #"n", #"o", #"n",
        #"-", #"a", #"p", #"p", #"l", #"i", #"c", #"a", #"b", #"l", #"e", #" ",
        #"r", #"u", #"l", #"e", #"s"]
      let
        val _ = rc j tp;
      in
        bindb (catch_errora (check_non_applicable_rules (is_QNFb j tp) r)
                (fn x =>
                  Inl (i o (shows_string
                              [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                #"w", #"h", #"e", #"n", #" ", #"r", #"e", #"m",
                                #"o", #"v", #"i", #"n", #"g", #" ", #"n", #"o",
                                #"n", #"-", #"a", #"p", #"p", #"l", #"i", #"c",
                                #"a", #"b", #"l", #"e", #" ", #"r", #"u", #"l",
                                #"e", #"s"] o
                             (shows_nl o
                               indent
                                 (shows_rule
                                    (shows_prec_lab B4_ (show_list show_nat)
                                      zero_nata)
                                    (shows_prec_list show_char zero_nata)
                                    [#" ", #"-", #">", #" "] x o
                                   shows_prec_list show_char zero_nata
                                     [#" ", #"i", #"s", #" ", #"a", #"p", #"p",
                                       #"l", #"i", #"c", #"a", #"b", #"l",
                                       #"e"]))))))
          (fn _ =>
            let
              val tpa = delete_R_Rwb j tp r r;
            in
              catch_errora
                (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia
                  assms (i o shows_string [#".", #"1"]) tpa prf)
                (fn x =>
                  Inl (i o (shows_string
                              [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                #"b", #"e", #"l", #"o", #"w", #" ", #"t", #"h",
                                #"e", #" ", #"n", #"o", #"n", #"-", #"a", #"p",
                                #"p", #"l", #"i", #"c", #"a", #"b", #"l", #"e",
                                #" ", #"r", #"u", #"l", #"e", #"s", #" ", #"r",
                                #"e", #"m", #"o", #"v", #"a", #"l"] o
                             (shows_nl o indent x))))
            end)
      end
  | check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tp
    (Permuting_AFS (pi, prf)) =
    debug (i [])
      [#"P", #"e", #"r", #"m", #"u", #"t", #"i", #"n", #"g", #" ", #"s", #"o",
        #"m", #"e", #" ", #"r", #"u", #"l", #"e", #"s"]
      (bindb
        (catch_errora
          (argument_filter_tt
            (ceq_lab B2_ (equal_list equal_nat),
              ccompare_lab ((compare_compare_order o compare_order_key) B3_)
                ((compare_compare_order o compare_order_key)
                  (key_list (equal_nat, key_nat))),
              key_lab B3_ (key_list (equal_nat, key_nat)), set_impl_lab,
              show_lab B4_ (show_list show_nat))
            j pi tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"p", #"e", #"r", #"m", #"u",
                          #"t", #"i", #"n", #"g", #" ", #"a", #"r", #"g", #"u",
                          #"m", #"e", #"n", #"t", #"s", #" ", #"o", #"n",
                          #" "] o
                       (shows_nl o
                         (shows_tp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) j tp o
                           (shows_nl o x)))))))
        (fn tpa =>
          catch_errora
            (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) tpa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"p", #"e", #"r", #"m", #"u", #"t", #"a",
                            #"t", #"i", #"o", #"n", #" ", #"o", #"f", #" ",
                            #"a", #"r", #"g", #"u", #"m", #"e", #"n", #"t",
                            #"s"] o
                         (shows_nl o indent x))))))
  | check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tpa
    (Assume_SN (tp, ass)) =
    debug (i [])
      [#"T", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n", #" ",
        #"A", #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #" ", #"o",
        #"r", #" ", #"U", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"P", #"r",
        #"o", #"o", #"f"]
      (if assms
        then bindb (catch_errora
                     (check_tp_subsumes (B2_, B4_)
                       (equal_list equal_nat, show_list show_nat)
                       (equal_list equal_char, show_list show_char) j tp tpa)
                     (fn x =>
                       Inl (i o (shows_string
                                   [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                     #" ", #"i", #"n", #" ", #"t", #"e", #"r",
                                     #"m", #"i", #"n", #"a", #"t", #"i", #"o",
                                     #"n", #" ", #"a", #"s", #"s", #"u", #"m",
                                     #"p", #"t", #"i", #"o", #"n", #" ", #"o",
                                     #"r", #" ", #"u", #"n", #"k", #"n", #"o",
                                     #"w", #"n", #" ", #"p", #"r", #"o", #"o",
                                     #"f"] o
                                  (shows_nl o (x o shows_nl))))))
               (fn _ =>
                 catch_errora
                   (forallM_index
                     (fn asa => fn ja =>
                       check_assma (B1_, B3_, B4_) j ia
                         (check_trs_termination_proof_main (B1_, B2_, B3_, B4_)
                           j ia assms
                           (i o (shows_string [#"."] o
                                  shows_prec_nat zero_nata (suc ja))))
                         (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j
                           ia assms
                           (i o (shows_string [#"."] o
                                  shows_prec_nat zero_nata (suc ja))))
                         (check_fptrs_termination_proof_main
                           (B1_, B2_, B3_, B4_) j ia assms
                           (i o (shows_string [#"."] o
                                  shows_prec_nat zero_nata (suc ja))))
                         (check_unknown_proof_main (B1_, B2_, B3_, B4_) j ia
                           assms
                           (i o (shows_string [#"."] o
                                  shows_prec_nat zero_nata (suc ja))))
                         asa)
                     ass)
                   (fn x => Inl (snd x)))
        else Inl (i o (shows_string
                         [#":", #" ", #"t", #"h", #"e", #" ", #"p", #"r", #"o",
                           #"o", #"f", #" ", #"c", #"o", #"n", #"t", #"a", #"i",
                           #"n", #"s", #" ", #"a", #" ", #"t", #"e", #"r", #"m",
                           #"i", #"n", #"a", #"t", #"i", #"o", #"n", #" ", #"a",
                           #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n",
                           #" ", #"o", #"r", #" ", #"u", #"n", #"k", #"n", #"o",
                           #"w", #"n", #" ", #"p", #"r", #"o", #"o", #"f"] o
                        shows_nl)))
and check_fptrs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i tpa
  (Assume_FP_SN (tp, ass)) =
  debug (i [])
    [#"O", #"u", #"t", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"T", #"e",
      #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n", #" ", #"A", #"s",
      #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #" ", #"o", #"r", #" ",
      #"U", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"P", #"r", #"o", #"o",
      #"f"]
    (if assms
      then bindb (check
                   (equal_proda
                     (equal_list
                       (equal_prod
                         (equal_ctxt (equal_lab B2_ (equal_list equal_nat))
                           (equal_list equal_char))
                         (equal_prod
                           (equal_term (equal_lab B2_ (equal_list equal_nat))
                             (equal_list equal_char))
                           equal_location)))
                     (equal_list
                       (equal_prod
                         (equal_term (equal_lab B2_ (equal_list equal_nat))
                           (equal_list equal_char))
                         (equal_term (equal_lab B2_ (equal_list equal_nat))
                           (equal_list equal_char))))
                     tpa tp)
                   (shows_prec_list show_char zero_nata
                     [#"o", #"u", #"t", #"e", #"r", #"m", #"o", #"s", #"t",
                       #" ", #"a", #"s", #"s", #"u", #"m", #"p", #"t", #"i",
                       #"o", #"n", #" ", #"d", #"o", #"e", #"s", #" ", #"n",
                       #"o", #"t", #" ", #"m", #"a", #"t", #"c", #"h", #" ",
                       #"c", #"u", #"r", #"r", #"e", #"n", #"t", #" ", #"g",
                       #"o", #"a", #"l"]))
             (fn _ =>
               catch_errora
                 (forallM_index
                   (fn asa => fn ja =>
                     check_assma (B1_, B3_, B4_) j ia
                       (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j
                         ia assms
                         (i o (shows_string [#"."] o
                                shows_prec_nat zero_nata (suc ja))))
                       (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j
                         ia assms
                         (i o (shows_string [#"."] o
                                shows_prec_nat zero_nata (suc ja))))
                       (check_fptrs_termination_proof_main (B1_, B2_, B3_, B4_)
                         j ia assms
                         (i o (shows_string [#"."] o
                                shows_prec_nat zero_nata (suc ja))))
                       (check_unknown_proof_main (B1_, B2_, B3_, B4_) j ia assms
                         (i o (shows_string [#"."] o
                                shows_prec_nat zero_nata (suc ja))))
                       asa)
                   ass)
                 (fn x => Inl (snd x)))
      else Inl (i o (shows_string
                       [#":", #" ", #"t", #"h", #"e", #" ", #"p", #"r", #"o",
                         #"o", #"f", #" ", #"c", #"o", #"n", #"t", #"a", #"i",
                         #"n", #"s", #" ", #"a", #" ", #"t", #"e", #"r", #"m",
                         #"i", #"n", #"a", #"t", #"i", #"o", #"n", #" ", #"a",
                         #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n",
                         #" ", #"o", #"r", #" ", #"u", #"n", #"k", #"n", #"o",
                         #"w", #"n", #" ", #"p", #"r", #"o", #"o", #"f"] o
                      shows_nl)))
and check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
  P_is_Empty =
  debug (i []) [#"P", #" ", #"i", #"s", #" ", #"e", #"m", #"p", #"t", #"y"]
    (if null (pb ia dpp) andalso (null (pwb ia dpp) orelse null (rd ia dpp))
      then Inr ()
      else Inl (i o (shows_string
                       [#":", #" ", #"P", #" ", #"i", #"s", #" ", #"n", #"o",
                         #"t", #" ", #"e", #"m", #"p", #"t", #"y", #" ", #"i",
                         #"n", #" ", #"t", #"h", #"e", #" ", #"f", #"o", #"l",
                         #"l", #"o", #"w", #"i", #"n", #"g", #" ", #"D", #"P",
                         #"-", #"p", #"r", #"o", #"b", #"l", #"e", #"m", #" "] o
                      (shows_nl o
                        shows_dpp
                          (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                          (shows_prec_list show_char zero_nata) ia dpp))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Subterm_Criterion_Proc (p, rseq, rP, prf)) =
    debug (i [])
      [#"S", #"u", #"b", #"t", #"e", #"r", #"m", #"_", #"C", #"r", #"i", #"t",
        #"e", #"r", #"i", #"o", #"n", #"_", #"P", #"r", #"o", #"c"]
      let
        val pa = pairsb ia dpp;
        val pr =
          ceta_list_diff
            (key_prod
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char)))
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char))))
            pa rP;
      in
        bindb (catch_errora
                (subterm_criterion_proc
                  (equal_lab B2_ (equal_list equal_nat),
                    key_lab B3_ (key_list (equal_nat, key_nat)),
                    show_lab B4_ (show_list show_nat))
                  (ccompare_list ccompare_char, equal_list equal_char,
                    key_list (equal_char, key_char), mapping_impl_list,
                    show_list show_char)
                  ia p rseq pr dpp)
                (fn x =>
                  Inl (i o (shows_string
                              [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                #"w", #"h", #"e", #"n", #" ", #"a", #"p", #"p",
                                #"l", #"y", #"i", #"n", #"g", #" ", #"t", #"h",
                                #"e", #" ", #"s", #"u", #"b", #"t", #"e", #"r",
                                #"m", #" ", #"c", #"r", #"i", #"t", #"e", #"r",
                                #"i", #"o", #"n", #" ", #"t", #"o", #" ", #"t",
                                #"h", #"e", #" ", #"D", #"P", #" ", #"p", #"r",
                                #"o", #"b", #"l", #"e", #"m"] o
                             (shows_nl o
                               (shows_dpp
                                  (shows_prec_lab B4_ (show_list show_nat)
                                    zero_nata)
                                  (shows_prec_list show_char zero_nata) ia dpp o
                                 (shows_nl o
                                   (shows_string
                                      [#"a", #"n", #"d", #" ", #"t", #"r", #"y",
#"i", #"n", #"g", #" ", #"t", #"o", #" ", #"r", #"e", #"m", #"o", #"v", #"e",
#" ", #"t", #"h", #"e", #" ", #"p", #"a", #"i", #"r", #"s", #" "] o
                                     (shows_nl o
                                       (shows_rules
  (shows_prec_lab B4_ (show_list show_nat) zero_nata)
  (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] pr o
 (shows_nl o x)))))))))))
          (fn dppa =>
            catch_errora
              (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
                (i o shows_string [#".", #"1"]) dppa prf)
              (fn x =>
                Inl (i o (shows_string
                            [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                              #"b", #"e", #"l", #"o", #"w", #" ", #"t", #"h",
                              #"e", #" ", #"s", #"u", #"b", #"t", #"e", #"r",
                              #"m", #" ", #"c", #"r", #"i", #"t", #"e", #"r",
                              #"i", #"o", #"n"] o
                           (shows_nl o indent x)))))
      end
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Gen_Subterm_Criterion_Proc (p, pr, prf)) =
    debug (i [])
      [#"G", #"e", #"n", #"_", #"S", #"u", #"b", #"t", #"e", #"r", #"m", #"_",
        #"C", #"r", #"i", #"t", #"e", #"r", #"i", #"o", #"n", #"_", #"P", #"r",
        #"o", #"c"]
      (bindb
        (catch_errora
          (generalized_subterm_proc
            (ceq_lab B2_ (equal_list equal_nat),
              ccompare_lab ((compare_compare_order o compare_order_key) B3_)
                (compare_list compare_nat),
              compare_lab ((compare_compare_order o compare_order_key) B3_)
                (compare_list compare_nat),
              equal_lab B2_ (equal_list equal_nat), set_impl_lab,
              show_lab B4_ (show_list show_nat))
            (compare_list compare_char, equal_list equal_char,
              show_list show_char)
            ia p pr dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"g",
                          #"e", #"n", #"e", #"r", #"a", #"l", #"i", #"z", #"e",
                          #"d", #" ", #"s", #"u", #"b", #"t", #"e", #"r", #"m",
                          #" ", #"c", #"r", #"i", #"t", #"e", #"r", #"i", #"o",
                          #"n", #" ", #"t", #"o", #" ", #"t", #"h", #"e", #" ",
                          #"D", #"P", #" ", #"p", #"r", #"o", #"b", #"l", #"e",
                          #"m"] o
                       (shows_nl o
                         (shows_dpp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) ia dpp o
                           (shows_nl o
                             (shows_string
                                [#"a", #"n", #"d", #" ", #"t", #"r", #"y", #"i",
                                  #"n", #"g", #" ", #"t", #"o", #" ", #"r",
                                  #"e", #"m", #"o", #"v", #"e", #" ", #"t",
                                  #"h", #"e", #" ", #"p", #"a", #"i", #"r",
                                  #"s", #" "] o
                               (shows_nl o
                                 (shows_rules
                                    (shows_prec_lab B4_ (show_list show_nat)
                                      zero_nata)
                                    (shows_prec_list show_char zero_nata)
                                    [#" ", #"-", #">", #" "] pr o
                                   (shows_nl o x)))))))))))
        (fn dppa =>
          catch_errora
            (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"g", #"e", #"n", #"e", #"r", #"a", #"l",
                            #"i", #"z", #"e", #"d", #" ", #"s", #"u", #"b",
                            #"t", #"e", #"r", #"m", #" ", #"c", #"r", #"i",
                            #"t", #"e", #"r", #"i", #"o", #"n"] o
                         (shows_nl o indent x))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Redpair_Proc (redp, rP, prf)) =
    debug (i [])
      [#"R", #"e", #"d", #"p", #"a", #"i", #"r", #"_", #"P", #"r", #"o", #"c"]
      let
        val p = pairsb ia dpp;
        val pr =
          ceta_list_diff
            (key_prod
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char)))
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char))))
            p rP;
        val proc =
          (case redp
            of Inl rrp =>
              generic_ur_af_root_redtriple_proc
                (equal_lab B2_ (equal_list equal_nat),
                  key_lab B3_ (key_list (equal_nat, key_nat)),
                  show_lab B4_ (show_list show_nat))
                ia (get_root_redtriple
                     (ceq_lab B2_ (equal_list equal_nat),
                       ccompare_lab
                         ((compare_compare_order o compare_order_key) B3_)
                         ((compare_compare_order o compare_order_key)
                           (key_list (equal_nat, key_nat))),
                       equal_lab B2_ (equal_list equal_nat),
                       key_lab B3_ (key_list (equal_nat, key_nat)),
                       set_impl_lab, show_lab B4_ (show_list show_nat))
                     rrp)
                NONE
            | Inr rp =>
              generic_ur_af_redtriple_proc
                (equal_lab B2_ (equal_list equal_nat),
                  key_lab B3_ (key_list (equal_nat, key_nat)),
                  show_lab B4_ (show_list show_nat))
                ia (get_redtriple
                     (ceq_lab B2_ (equal_list equal_nat),
                       ccompare_lab
                         ((compare_compare_order o compare_order_key) B3_)
                         ((compare_compare_order o compare_order_key)
                           (key_list (equal_nat, key_nat))),
                       equal_lab B2_ (equal_list equal_nat),
                       key_lab B3_ (key_list (equal_nat, key_nat)),
                       set_impl_lab, show_lab B4_ (show_list show_nat))
                     rp)
                NONE);
      in
        bindb (catch_errora (proc pr dpp)
                (fn x =>
                  Inl (i o (shows_string
                              [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                #"w", #"h", #"e", #"n", #" ", #"a", #"p", #"p",
                                #"l", #"y", #"i", #"n", #"g", #" ", #"t", #"h",
                                #"e", #" ", #"r", #"e", #"d", #"u", #"c", #"t",
                                #"i", #"o", #"n", #" ", #"p", #"a", #"i", #"r",
                                #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s",
                                #"o", #"r", #" ", #"t", #"o", #" ", #"r", #"e",
                                #"m", #"o", #"v", #"e", #" ", #"f", #"r", #"o",
                                #"m", #" ", #"t", #"h", #"e", #" ", #"D", #"P",
                                #" ", #"p", #"r", #"o", #"b", #"l", #"e",
                                #"m"] o
                             (shows_nl o
                               (shows_dpp
                                  (shows_prec_lab B4_ (show_list show_nat)
                                    zero_nata)
                                  (shows_prec_list show_char zero_nata) ia dpp o
                                 (shows_nl o
                                   (shows_string
                                      [#" ", #"t", #"h", #"e", #" ", #"p", #"a",
#"i", #"r", #"s", #" "] o
                                     (shows_nl o
                                       (shows_rules
  (shows_prec_lab B4_ (show_list show_nat) zero_nata)
  (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] pr o
 (shows_nl o x)))))))))))
          (fn dppa =>
            catch_errora
              (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
                (i o shows_string [#".", #"1"]) dppa prf)
              (fn x =>
                Inl (i o (shows_string
                            [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                              #"b", #"e", #"l", #"o", #"w", #" ", #"t", #"h",
                              #"e", #" ", #"r", #"e", #"d", #"u", #"c", #"t",
                              #"i", #"o", #"n", #" ", #"p", #"a", #"i", #"r",
                              #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s",
                              #"o", #"r"] o
                           (shows_nl o indent x)))))
      end
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Usable_Rules_Proc (u, prf)) =
    debug (i [])
      [#"U", #"s", #"a", #"b", #"l", #"e", #"_", #"R", #"u", #"l", #"e", #"s",
        #"_", #"P", #"r", #"o", #"c"]
      (bindb
        (catch_errora
          (usable_rules_proc
            (equal_lab B2_ (equal_list equal_nat),
              key_lab B3_ (key_list (equal_nat, key_nat)),
              show_lab B4_ (show_list show_nat))
            ia u dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"u",
                          #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"u", #"l",
                          #"e", #"s", #" ", #"p", #"r", #"o", #"c", #"e", #"s",
                          #"s", #"o", #"r", #" ", #"t", #"o", #" ", #"r", #"e",
                          #"s", #"t", #"r", #"i", #"c", #"t", #" ", #"t", #"h",
                          #"e", #" ", #"D", #"P", #" ", #"p", #"r", #"o", #"b",
                          #"l", #"e", #"m"] o
                       (shows_nl o
                         (shows_dpp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) ia dpp o
                           (shows_nl o
                             (shows_string
                                [#" ", #"t", #"o", #" ", #"t", #"h", #"e", #" ",
                                  #"u", #"s", #"a", #"b", #"l", #"e", #" ",
                                  #"r", #"u", #"l", #"e", #"s", #" "] o
                               (shows_nl o
                                 (shows_rules
                                    (shows_prec_lab B4_ (show_list show_nat)
                                      zero_nata)
                                    (shows_prec_list show_char zero_nata)
                                    [#" ", #"-", #">", #" "] u o
                                   (shows_nl o x)))))))))))
        (fn dppa =>
          catch_errora
            (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ",
                            #"r", #"u", #"l", #"e", #"s", #" ", #"p", #"r",
                            #"o", #"c", #"e", #"s", #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Q_Reduction_Proc (q, prf)) =
    debug (i [])
      [#"Q", #"_", #"R", #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n", #"_",
        #"P", #"r", #"o", #"c"]
      (bindb
        (catch_errora
          (q_reduction_proc
            (equal_lab B2_ (equal_list equal_nat),
              key_lab B3_ (key_list (equal_nat, key_nat)),
              show_lab B4_ (show_list show_nat))
            (ccompare_list ccompare_char, equal_list equal_char,
              mapping_impl_list, show_list show_char)
            ia q dpp)
          (fn x =>
            Inl (i o (shows_prec_list show_char zero_nata
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"Q",
                          #"-", #"r", #"e", #"d", #"u", #"c", #"t", #"i", #"o",
                          #"n", #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s",
                          #"o", #"r"] o
                       (shows_nl o x)))))
        (fn dppa =>
          catch_errora
            (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"Q", #"-", #"r", #"e", #"d", #"u", #"c",
                            #"t", #"i", #"o", #"n", #" ", #"p", #"r", #"o",
                            #"c", #"e", #"s", #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Mono_Redpair_Proc (redp, rP, rR, prf)) =
    debug (i [])
      [#"M", #"o", #"n", #"o", #"_", #"R", #"e", #"d", #"p", #"a", #"i", #"r",
        #"_", #"P", #"r", #"o", #"c"]
      let
        val p = pairsb ia dpp;
        val pr =
          ceta_list_diff
            (key_prod
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char)))
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char))))
            p rP;
        val r = rulese ia dpp;
        val rr =
          ceta_list_diff
            (key_prod
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char)))
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char))))
            r rR;
      in
        bindb (catch_errora
                (mono_redpair_proc (show_lab B4_ (show_list show_nat))
                  (show_list show_char) ia
                  (get_redtriple
                    (ceq_lab B2_ (equal_list equal_nat),
                      ccompare_lab
                        ((compare_compare_order o compare_order_key) B3_)
                        ((compare_compare_order o compare_order_key)
                          (key_list (equal_nat, key_nat))),
                      equal_lab B2_ (equal_list equal_nat),
                      key_lab B3_ (key_list (equal_nat, key_nat)), set_impl_lab,
                      show_lab B4_ (show_list show_nat))
                    redp)
                  pr rr dpp)
                (fn x =>
                  Inl (i o (shows_string
                              [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                #"w", #"h", #"e", #"n", #" ", #"a", #"p", #"p",
                                #"l", #"y", #"i", #"n", #"g", #" ", #"t", #"h",
                                #"e", #" ", #"m", #"o", #"n", #"o", #" ", #"r",
                                #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n",
                                #" ", #"p", #"a", #"i", #"r", #" ", #"p", #"r",
                                #"o", #"c", #"e", #"s", #"s", #"o", #"r", #" ",
                                #"t", #"o", #" ", #"r", #"e", #"m", #"o", #"v",
                                #"e", #" ", #"f", #"r", #"o", #"m", #" ", #"t",
                                #"h", #"e", #" ", #"D", #"P", #" ", #"p", #"r",
                                #"o", #"b", #"l", #"e", #"m"] o
                             (shows_nl o
                               (shows_dpp
                                  (shows_prec_lab B4_ (show_list show_nat)
                                    zero_nata)
                                  (shows_prec_list show_char zero_nata) ia dpp o
                                 (shows_nl o
                                   (shows_string
                                      [#" ", #"t", #"h", #"e", #" ", #"p", #"a",
#"i", #"r", #"s", #" "] o
                                     (shows_nl o
                                       (shows_rules
  (shows_prec_lab B4_ (show_list show_nat) zero_nata)
  (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] pr o
 (shows_nl o
   (shows_string
      [#" ", #"a", #"n", #"d", #" ", #"t", #"h", #"e", #" ", #"r", #"u", #"l",
        #"e", #"s", #" "] o
     (shows_nl o
       (shows_rules (shows_prec_lab B4_ (show_list show_nat) zero_nata)
          (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] rr o
         (shows_nl o x)))))))))))))))
          (fn dppa =>
            catch_errora
              (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
                (i o shows_string [#".", #"1"]) dppa prf)
              (fn x =>
                Inl (i o (shows_string
                            [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                              #"b", #"e", #"l", #"o", #"w", #" ", #"t", #"h",
                              #"e", #" ", #"m", #"o", #"n", #"o", #" ", #"r",
                              #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n",
                              #" ", #"p", #"a", #"i", #"r", #" ", #"p", #"r",
                              #"o", #"c", #"e", #"s", #"s", #"o", #"r"] o
                           (shows_nl o indent x)))))
      end
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Mono_URM_Redpair_Proc (redp, pr, rr, prf)) =
    debug (i [])
      [#"M", #"o", #"n", #"o", #"_", #"U", #"R", #"M", #"_", #"R", #"e", #"d",
        #"p", #"a", #"i", #"r", #"_", #"P", #"r", #"o", #"c"]
      (bindb
        (catch_errora
          (mono_urm_redpair_proc
            (equal_lab B2_ (equal_list equal_nat),
              key_lab B3_ (key_list (equal_nat, key_nat)),
              show_lab B4_ (show_list show_nat))
            ia (get_redtriple
                 (ceq_lab B2_ (equal_list equal_nat),
                   ccompare_lab
                     ((compare_compare_order o compare_order_key) B3_)
                     ((compare_compare_order o compare_order_key)
                       (key_list (equal_nat, key_nat))),
                   equal_lab B2_ (equal_list equal_nat),
                   key_lab B3_ (key_list (equal_nat, key_nat)), set_impl_lab,
                   show_lab B4_ (show_list show_nat))
                 redp)
            pr rr dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"m",
                          #"o", #"n", #"o", #" ", #"r", #"e", #"d", #"u", #"c",
                          #"t", #"i", #"o", #"n", #" ", #"p", #"a", #"i", #"r",
                          #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o",
                          #"r", #" ", #"w", #"i", #"t", #"h", #" ", #"u", #"s",
                          #"a", #"b", #"l", #"e", #" ", #"r", #"e", #"p", #"l",
                          #".", #" ", #"m", #"a", #"p", #" ", #"t", #"o", #" ",
                          #"r", #"e", #"m", #"o", #"v", #"e", #" ", #"f", #"r",
                          #"o", #"m", #" ", #"t", #"h", #"e", #" ", #"D", #"P",
                          #" ", #"p", #"r", #"o", #"b", #"l", #"e", #"m"] o
                       (shows_nl o
                         (shows_dpp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) ia dpp o
                           (shows_nl o
                             (shows_string
                                [#" ", #"t", #"h", #"e", #" ", #"p", #"a", #"i",
                                  #"r", #"s", #" "] o
                               (shows_nl o
                                 (shows_rules
                                    (shows_prec_lab B4_ (show_list show_nat)
                                      zero_nata)
                                    (shows_prec_list show_char zero_nata)
                                    [#" ", #"-", #">", #" "] pr o
                                   (shows_nl o
                                     (shows_string
[#" ", #"a", #"n", #"d", #" ", #"t", #"h", #"e", #" ", #"r", #"u", #"l", #"e",
  #"s", #" "] o
                                       (shows_nl o
 (shows_rules (shows_prec_lab B4_ (show_list show_nat) zero_nata)
    (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] rr o
   (shows_nl o x)))))))))))))))
        (fn dppa =>
          catch_errora
            (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"m", #"o", #"n", #"o", #" ", #"r", #"e",
                            #"d", #"u", #"c", #"t", #"i", #"o", #"n", #" ",
                            #"p", #"a", #"i", #"r", #" ", #"p", #"r", #"o",
                            #"c", #"e", #"s", #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Dep_Graph_Proc edpts) =
    debug (i [])
      [#"D", #"e", #"p", #"_", #"G", #"r", #"a", #"p", #"h", #"_", #"P", #"r",
        #"o", #"c"]
      (bindb
        (catch_errora
          (dep_graph_proc
            (cenum_lab, ceq_lab B2_ (equal_list equal_nat),
              ccompare_lab ((compare_compare_order o compare_order_key) B3_)
                ((compare_compare_order o compare_order_key)
                  (key_list (equal_nat, key_nat))),
              equal_lab B2_ (equal_list equal_nat),
              key_lab B3_ (key_list (equal_nat, key_nat)), mapping_impl_lab,
              set_impl_lab, show_lab B4_ (show_list show_nat))
            ia dpp edpts)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"i", #"l", #"e", #" ", #"t", #"r", #"y", #"i",
                          #"n", #"g", #" ", #"t", #"o", #" ", #"p", #"e", #"r",
                          #"f", #"o", #"r", #"m", #" ", #"S", #"c", #"t", #"x",
                          #"t", #"_", #"c", #"l", #"o", #"s", #"u", #"r", #"e",
                          #"-", #"d", #"e", #"c", #"o", #"m", #"p", #"o", #"s",
                          #"i", #"t", #"i", #"o", #"n", #" ", #" ", #"o", #"n",
                          #" "] o
                       (shows_nl o
                         (shows_dpp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) ia dpp o
                           (shows_nl o x)))))))
        (fn pdpps =>
          catch_errora
            (catch_errora
              (forallM_index
                (fn (prof, dppa) => fn ja =>
                  check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia
                    assms
                    (i o (shows_string [#"."] o
                           shows_prec_nat zero_nata (suc ja)))
                    dppa prof)
                pdpps)
              (fn x => Inl (snd x)))
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"d", #"e", #"p", #"e", #"n", #"d", #"e",
                            #"n", #"c", #"y", #" ", #"g", #"r", #"a", #"p",
                            #"h", #" ", #"p", #"r", #"o", #"c", #"e", #"s",
                            #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Redpair_UR_Proc (redp, rP, ur, prf)) =
    debug (i [])
      [#"R", #"e", #"d", #"p", #"a", #"i", #"r", #"_", #"U", #"R", #"_", #"P",
        #"r", #"o", #"c"]
      let
        val p = pairsb ia dpp;
        val pr =
          ceta_list_diff
            (key_prod
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char)))
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char))))
            p rP;
        val proc =
          (case redp
            of Inl rrp =>
              generic_ur_af_root_redtriple_proc
                (equal_lab B2_ (equal_list equal_nat),
                  key_lab B3_ (key_list (equal_nat, key_nat)),
                  show_lab B4_ (show_list show_nat))
                ia (get_root_redtriple
                     (ceq_lab B2_ (equal_list equal_nat),
                       ccompare_lab
                         ((compare_compare_order o compare_order_key) B3_)
                         ((compare_compare_order o compare_order_key)
                           (key_list (equal_nat, key_nat))),
                       equal_lab B2_ (equal_list equal_nat),
                       key_lab B3_ (key_list (equal_nat, key_nat)),
                       set_impl_lab, show_lab B4_ (show_list show_nat))
                     rrp)
                (SOME ur)
            | Inr rp =>
              generic_ur_af_redtriple_proc
                (equal_lab B2_ (equal_list equal_nat),
                  key_lab B3_ (key_list (equal_nat, key_nat)),
                  show_lab B4_ (show_list show_nat))
                ia (get_redtriple
                     (ceq_lab B2_ (equal_list equal_nat),
                       ccompare_lab
                         ((compare_compare_order o compare_order_key) B3_)
                         ((compare_compare_order o compare_order_key)
                           (key_list (equal_nat, key_nat))),
                       equal_lab B2_ (equal_list equal_nat),
                       key_lab B3_ (key_list (equal_nat, key_nat)),
                       set_impl_lab, show_lab B4_ (show_list show_nat))
                     rp)
                (SOME ur));
      in
        bindb (catch_errora (proc pr dpp)
                (fn x =>
                  Inl (i o (shows_string
                              [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                #"w", #"h", #"e", #"n", #" ", #"a", #"p", #"p",
                                #"l", #"y", #"i", #"n", #"g", #" ", #"t", #"h",
                                #"e", #" ", #"r", #"e", #"d", #"u", #"c", #"t",
                                #"i", #"o", #"n", #" ", #"p", #"a", #"i", #"r",
                                #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s",
                                #"o", #"r", #" ", #"w", #"i", #"t", #"h", #" ",
                                #"u", #"s", #"a", #"b", #"l", #"e", #" ", #"r",
                                #"u", #"l", #"e", #"s", #" ", #"t", #"o", #" ",
                                #"r", #"e", #"m", #"o", #"v", #"e", #" ", #"f",
                                #"r", #"o", #"m", #" ", #"t", #"h", #"e", #" ",
                                #"D", #"P", #" ", #"p", #"r", #"o", #"b", #"l",
                                #"e", #"m"] o
                             (shows_nl o
                               (shows_dpp
                                  (shows_prec_lab B4_ (show_list show_nat)
                                    zero_nata)
                                  (shows_prec_list show_char zero_nata) ia dpp o
                                 (shows_nl o
                                   (shows_string
                                      [#" ", #"t", #"h", #"e", #" ", #"p", #"a",
#"i", #"r", #"s", #" "] o
                                     (shows_nl o
                                       (shows_rules
  (shows_prec_lab B4_ (show_list show_nat) zero_nata)
  (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] pr o
 (shows_nl o x)))))))))))
          (fn dppa =>
            catch_errora
              (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
                (i o shows_string [#".", #"1"]) dppa prf)
              (fn x =>
                Inl (i o (shows_string
                            [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                              #"b", #"e", #"l", #"o", #"w", #" ", #"t", #"h",
                              #"e", #" ", #"r", #"e", #"d", #"u", #"c", #"t",
                              #"i", #"o", #"n", #" ", #"p", #"a", #"i", #"r",
                              #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s",
                              #"o", #"r"] o
                           (shows_nl o indent x)))))
      end
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Mono_Redpair_UR_Proc (redp, rP, rR, ur, prf)) =
    debug (i [])
      [#"M", #"o", #"n", #"o", #"_", #"R", #"e", #"d", #"p", #"a", #"i", #"r",
        #"_", #"U", #"R", #"_", #"P", #"r", #"o", #"c"]
      let
        val p = pairsb ia dpp;
        val pr =
          ceta_list_diff
            (key_prod
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char)))
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char))))
            p rP;
        val r = rulese ia dpp;
        val rr =
          ceta_list_diff
            (key_prod
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char)))
              (key_term (key_lab B3_ (key_list (equal_nat, key_nat)))
                (key_list (equal_char, key_char))))
            r rR;
      in
        bindb (catch_errora
                (generic_mono_ur_redpair_proc
                  (ceq_lab B2_ (equal_list equal_nat),
                    ccompare_lab
                      ((compare_compare_order o compare_order_key) B3_)
                      ((compare_compare_order o compare_order_key)
                        (key_list (equal_nat, key_nat))),
                    equal_lab B2_ (equal_list equal_nat),
                    key_lab B3_ (key_list (equal_nat, key_nat)), set_impl_lab,
                    show_lab B4_ (show_list show_nat))
                  ia (get_redtriple
                       (ceq_lab B2_ (equal_list equal_nat),
                         ccompare_lab
                           ((compare_compare_order o compare_order_key) B3_)
                           ((compare_compare_order o compare_order_key)
                             (key_list (equal_nat, key_nat))),
                         equal_lab B2_ (equal_list equal_nat),
                         key_lab B3_ (key_list (equal_nat, key_nat)),
                         set_impl_lab, show_lab B4_ (show_list show_nat))
                       redp)
                  pr rr ur dpp)
                (fn x =>
                  Inl (i o (shows_string
                              [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                #"w", #"h", #"e", #"n", #" ", #"a", #"p", #"p",
                                #"l", #"y", #"i", #"n", #"g", #" ", #"t", #"h",
                                #"e", #" ", #"m", #"o", #"n", #"o", #" ", #"r",
                                #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n",
                                #" ", #"p", #"a", #"i", #"r", #" ", #"p", #"r",
                                #"o", #"c", #"e", #"s", #"s", #"o", #"r", #" ",
                                #"w", #"i", #"t", #"h", #" ", #"u", #"s", #"a",
                                #"b", #"l", #"e", #" ", #"r", #"u", #"l", #"e",
                                #"s", #" ", #"t", #"o", #" ", #"r", #"e", #"m",
                                #"o", #"v", #"e", #" ", #"f", #"r", #"o", #"m",
                                #" ", #"t", #"h", #"e", #" ", #"D", #"P", #" ",
                                #"p", #"r", #"o", #"b", #"l", #"e", #"m"] o
                             (shows_nl o
                               (shows_dpp
                                  (shows_prec_lab B4_ (show_list show_nat)
                                    zero_nata)
                                  (shows_prec_list show_char zero_nata) ia dpp o
                                 (shows_nl o
                                   (shows_string
                                      [#" ", #"t", #"h", #"e", #" ", #"p", #"a",
#"i", #"r", #"s", #" "] o
                                     (shows_nl o
                                       (shows_rules
  (shows_prec_lab B4_ (show_list show_nat) zero_nata)
  (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] pr o
 (shows_nl o
   (shows_string
      [#" ", #"a", #"n", #"d", #" ", #"t", #"h", #"e", #" ", #"r", #"u", #"l",
        #"e", #"s", #" "] o
     (shows_nl o
       (shows_rules (shows_prec_lab B4_ (show_list show_nat) zero_nata)
          (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] rr o
         (shows_nl o x)))))))))))))))
          (fn dppa =>
            catch_errora
              (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
                (i o shows_string [#".", #"1"]) dppa prf)
              (fn x =>
                Inl (i o (shows_string
                            [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                              #"b", #"e", #"l", #"o", #"w", #" ", #"t", #"h",
                              #"e", #" ", #"m", #"o", #"n", #"o", #" ", #"r",
                              #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n",
                              #" ", #"p", #"a", #"i", #"r", #" ", #"p", #"r",
                              #"o", #"c", #"e", #"s", #"s", #"o", #"r", #" ",
                              #"w", #"i", #"t", #"h", #" ", #"u", #"s", #"a",
                              #"b", #"l", #"e", #" ", #"r", #"u", #"l", #"e",
                              #"s"] o
                           (shows_nl o indent x)))))
      end
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Uncurry_Proc (mode, u_info, p, r, prf)) =
    debug (i [])
      [#"U", #"n", #"c", #"u", #"r", #"r", #"y", #"_", #"P", #"r", #"o", #"c"]
      (bindb
        (catch_errora
          (uncurry_proc_both (B2_, B4_)
            (equal_list equal_nat, show_list show_nat) ia mode u_info p r dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"u",
                          #"n", #"c", #"u", #"r", #"r", #"y", #"i", #"n", #"g",
                          #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o",
                          #"r", #" ", #"o", #"n", #" ", #"t", #"h", #"e", #" ",
                          #"D", #"P", #" ", #"p", #"r", #"o", #"b", #"l", #"e",
                          #"m"] o
                       (shows_nl o
                         (shows_dpp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) ia dpp o
                           (shows_nl o x)))))))
        (fn dppa =>
          catch_errora
            (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"u", #"n", #"c", #"u", #"r", #"r", #"y",
                            #"i", #"n", #"g", #" ", #"p", #"r", #"o", #"c",
                            #"e", #"s", #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Size_Change_Subterm_Proc graphs) =
    debug (i [])
      [#"S", #"i", #"z", #"e", #"_", #"C", #"h", #"a", #"n", #"g", #"e", #"_",
        #"S", #"u", #"b", #"t", #"e", #"r", #"m", #"_", #"P", #"r", #"o", #"c"]
      (catch_errora
        (sct_subterm_proc
          (equal_lab B2_ (equal_list equal_nat),
            key_lab B3_ (key_list (equal_nat, key_nat)),
            show_lab B4_ (show_list show_nat))
          ia graphs dpp)
        (fn x =>
          Inl (i o (shows_string
                      [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                        #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                        #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"s",
                        #"i", #"z", #"e", #"-", #"c", #"h", #"a", #"n", #"g",
                        #"e", #" ", #"(", #"s", #"u", #"b", #"t", #"e", #"r",
                        #"m", #")", #" ", #"p", #"r", #"o", #"c", #"e", #"s",
                        #"s", #"o", #"r", #" ", #"o", #"n", #" ", #"t", #"h",
                        #"e", #" ", #"D", #"P", #" ", #"p", #"r", #"o", #"b",
                        #"l", #"e", #"m"] o
                     (shows_nl o
                       (shows_dpp
                          (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                          (shows_prec_list show_char zero_nata) ia dpp o
                         (shows_nl o x)))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Size_Change_Redpair_Proc (redp, u_opt, graphs)) =
    debug (i [])
      [#"S", #"i", #"z", #"e", #"_", #"C", #"h", #"a", #"n", #"g", #"e", #"_",
        #"R", #"e", #"d", #"p", #"a", #"i", #"r", #"_", #"P", #"r", #"o", #"c"]
      (catch_errora
        (sct_ur_af_proc
          (equal_lab B2_ (equal_list equal_nat),
            key_lab B3_ (key_list (equal_nat, key_nat)),
            show_lab B4_ (show_list show_nat))
          ia (get_redtriple
               (ceq_lab B2_ (equal_list equal_nat),
                 ccompare_lab ((compare_compare_order o compare_order_key) B3_)
                   ((compare_compare_order o compare_order_key)
                     (key_list (equal_nat, key_nat))),
                 equal_lab B2_ (equal_list equal_nat),
                 key_lab B3_ (key_list (equal_nat, key_nat)), set_impl_lab,
                 show_lab B4_ (show_list show_nat))
               redp)
          graphs u_opt dpp)
        (fn x =>
          Inl (i o (shows_string
                      [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                        #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                        #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"s",
                        #"i", #"z", #"e", #"-", #"c", #"h", #"a", #"n", #"g",
                        #"e", #" ", #"(", #"r", #"e", #"d", #"p", #"a", #"i",
                        #"r", #")", #" ", #"p", #"r", #"o", #"c", #"e", #"s",
                        #"s", #"o", #"r", #" ", #"o", #"n", #" ", #"t", #"h",
                        #"e", #" ", #"D", #"P", #" ", #"p", #"r", #"o", #"b",
                        #"l", #"e", #"m"] o
                     (shows_nl o
                       (shows_dpp
                          (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                          (shows_prec_list show_char zero_nata) ia dpp o
                         (shows_nl o x)))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Fcc_Proc (f, fcs, pb, r, prf)) =
    debug (i []) [#"F", #"c", #"c", #"_", #"P", #"r", #"o", #"c"]
      (bindb
        (catch_errora
          (fcc_proc
            (equal_lab B2_ (equal_list equal_nat),
              show_lab B4_ (show_list show_nat))
            (ceq_list ceq_char, ccompare_list ccompare_char,
              equal_list equal_char, mapping_impl_list, set_impl_list,
              show_list show_char)
            ia f fcs pb r dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"f",
                          #"l", #"a", #"t", #" ", #"c", #"o", #"n", #"t", #"e",
                          #"x", #"t", #" ", #"c", #"l", #"o", #"s", #"u", #"r",
                          #"e", #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s",
                          #"o", #"r", #" ", #"o", #"n", #" ", #"t", #"h", #"e",
                          #" ", #"D", #"P", #" ", #"p", #"r", #"o", #"b", #"l",
                          #"e", #"m"] o
                       (shows_nl o
                         (shows_dpp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) ia dpp o
                           (shows_nl o x)))))))
        (fn dppa =>
          catch_errora
            (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"f", #"l", #"a", #"t", #" ", #"c", #"o",
                            #"n", #"t", #"e", #"x", #"t", #" ", #"c", #"l",
                            #"o", #"s", #"u", #"r", #"e", #" ", #"p", #"r",
                            #"o", #"c", #"e", #"s", #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Split_Proc (prem, rrem, prf1, prf2)) =
    debug (i []) [#"S", #"p", #"l", #"i", #"t", #"_", #"P", #"r", #"o", #"c"]
      (case get_fcc_option prf1
        of NONE =>
          let
            val (dpp1, dpp2) =
              split_proc (show_lab B4_ (show_list show_nat))
                (show_list show_char) ia dpp prem rrem;
          in
            bindb (catch_errora
                    (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia
                      assms (i o shows_string [#".", #"1"]) dpp1 prf1)
                    (fn x =>
                      Inl (i o (shows_string
                                  [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                    #" ", #"b", #"e", #"l", #"o", #"w", #" ",
                                    #"t", #"h", #"e", #" ", #"s", #"p", #"l",
                                    #"i", #"t", #" ", #"p", #"r", #"o", #"c",
                                    #"e", #"s", #"s", #"o", #"r"] o
                                 (shows_nl o indent x)))))
              (fn _ =>
                catch_errora
                  (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia
                    assms (i o shows_string [#".", #"2"]) dpp2 prf2)
                  (fn x =>
                    Inl (i o (shows_string
                                [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                  #"b", #"e", #"l", #"o", #"w", #" ", #"t",
                                  #"h", #"e", #" ", #"s", #"p", #"l", #"i",
                                  #"t", #" ", #"p", #"r", #"o", #"c", #"e",
                                  #"s", #"s", #"o", #"r"] o
                               (shows_nl o indent x)))))
          end
        | SOME (f, (fcs, (pb, (rb, prf1a)))) =>
          debug (i [])
            [#"S", #"p", #"l", #"i", #"t", #"_", #"P", #"r", #"o", #"c", #"F",
              #"c", #"c"]
            (bindb
              (fcc_split_proc
                (equal_lab B2_ (equal_list equal_nat),
                  key_lab B3_ (key_list (equal_nat, key_nat)),
                  show_lab B4_ (show_list show_nat))
                (ceq_list ceq_char, ccompare_list ccompare_char,
                  equal_list equal_char, key_list (equal_char, key_char),
                  mapping_impl_list, set_impl_list, show_list show_char)
                ia f fcs pb rb prem rrem dpp)
              (fn (dpp1, dpp2) =>
                bindb (catch_errora
                        (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j
                          ia assms (i o shows_string [#".", #"1", #".", #"1"])
                          dpp1 prf1a)
                        (fn x =>
                          Inl (i o (shows_string
                                      [#":", #" ", #"e", #"r", #"r", #"o", #"r",
#" ", #"b", #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e", #" ", #"s", #"p",
#"l", #"i", #"t", #" ", #"a", #"n", #"d", #" ", #"f", #"c", #"c", #" ", #"p",
#"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r"] o
                                     (shows_nl o indent x)))))
                  (fn _ =>
                    catch_errora
                      (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia
                        assms (i o shows_string [#".", #"2"]) dpp2 prf2)
                      (fn x =>
                        Inl (i o (shows_string
                                    [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                      #" ", #"b", #"e", #"l", #"o", #"w", #" ",
                                      #"t", #"h", #"e", #" ", #"s", #"p", #"l",
                                      #"i", #"t", #" ", #"p", #"r", #"o", #"c",
                                      #"e", #"s", #"s", #"o", #"r"] o
                                   (shows_nl o indent x))))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Semlab_Proc (sli, lP, lQ, lR, prf)) =
    debug (i [])
      [#"S", #"e", #"m", #"l", #"a", #"b", #"_", #"P", #"r", #"o", #"c"]
      (bindb
        (catch_errora
          (semlab_fin_proc
            ((compare_compare_order o compare_order_key) B3_, B2_, B4_)
            (ceq_list ceq_char, ccompare_list ccompare_char,
              compare_list compare_char, equal_list equal_char,
              mapping_impl_list, set_impl_list, show_list show_char)
            ia sli lP lQ lR dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"s",
                          #"e", #"m", #"l", #"a", #"b", #" ", #"p", #"r", #"o",
                          #"c", #"e", #"s", #"s", #"o", #"r", #" ", #"o", #"n",
                          #" ", #"t", #"h", #"e", #" ", #"D", #"P", #" ", #"p",
                          #"r", #"o", #"b", #"l", #"e", #"m"] o
                       (shows_nl o
                         (shows_dpp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) ia dpp o
                           (shows_nl o x)))))))
        (fn dppa =>
          catch_errora
            (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"s", #"e", #"m", #"l", #"a", #"b", #" ",
                            #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o",
                            #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Switch_Innermost_Proc (joins, prf)) =
    debug (i [])
      [#"S", #"w", #"i", #"t", #"c", #"h", #"_", #"I", #"n", #"n", #"e", #"r",
        #"m", #"o", #"s", #"t", #"_", #"P", #"r", #"o", #"c"]
      (bindb
        (catch_errora
          (switch_innermost_proc
            (equal_lab B2_ (equal_list equal_nat),
              show_lab B4_ (show_list show_nat))
            ia joins dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"p",
                          #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r", #" ",
                          #"t", #"o", #" ", #"s", #"w", #"i", #"t", #"c", #"h",
                          #" ", #"t", #"o", #" ", #"i", #"n", #"n", #"e", #"r",
                          #"m", #"o", #"s", #"t", #" ", #"o", #"n", #" ", #"t",
                          #"h", #"e", #" ", #"D", #"P", #" ", #"p", #"r", #"o",
                          #"b", #"l", #"e", #"m"] o
                       (shows_nl o
                         (shows_dpp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) ia dpp o
                           (shows_nl o x)))))))
        (fn dppa =>
          catch_errora
            (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"s", #"w", #"i", #"t", #"c", #"h", #" ",
                            #"t", #"o", #" ", #"i", #"n", #"n", #"e", #"r",
                            #"m", #"o", #"s", #"t", #" ", #"p", #"r", #"o",
                            #"c", #"e", #"s", #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dppa
    (Assume_Finite (dpp, ass)) =
    debug (i [])
      [#"F", #"i", #"n", #"i", #"t", #"e", #"n", #"e", #"s", #"s", #" ", #"A",
        #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #" ", #"o", #"r",
        #" ", #"U", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"P", #"r", #"o",
        #"o", #"f"]
      (if assms
        then bindb (catch_errora
                     (check_dpp_subsumes (B2_, B3_, B4_)
                       (equal_list equal_nat, key_list (equal_nat, key_nat),
                         show_list show_nat)
                       (ccompare_list ccompare_char, equal_list equal_char,
                         mapping_impl_list, show_list show_char)
                       ia dpp dppa)
                     (fn x =>
                       Inl (i o (shows_string
                                   [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                     #" ", #"i", #"n", #" ", #"f", #"i", #"n",
                                     #"i", #"t", #"e", #"n", #"e", #"s", #"s",
                                     #" ", #"a", #"s", #"s", #"u", #"m", #"p",
                                     #"t", #"i", #"o", #"n", #" ", #"o", #"r",
                                     #" ", #"u", #"n", #"k", #"n", #"o", #"w",
                                     #"n", #" ", #"p", #"r", #"o", #"o", #"f"] o
                                  (shows_nl o (x o shows_nl))))))
               (fn _ =>
                 catch_errora
                   (catch_errora
                     (forallM_index
                       (fn asa => fn ja =>
                         check_assma (B1_, B3_, B4_) j ia
                           (check_trs_termination_proof_main
                             (B1_, B2_, B3_, B4_) j ia assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_dp_termination_proof_main (B1_, B2_, B3_, B4_)
                             j ia assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_fptrs_termination_proof_main
                             (B1_, B2_, B3_, B4_) j ia assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_unknown_proof_main (B1_, B2_, B3_, B4_) j ia
                             assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           asa)
                       ass)
                     (fn x => Inl (snd x)))
                   (fn x =>
                     Inl (i o (shows_string
                                 [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                   #" ", #"b", #"e", #"l", #"o", #"w", #" ",
                                   #"u", #"n", #"k", #"n", #"o", #"w", #"n",
                                   #" ", #"p", #"r", #"o", #"o", #"f"] o
                                (shows_nl o indent x)))))
        else Inl (i o (shows_string
                         [#":", #" ", #"t", #"h", #"e", #" ", #"p", #"r", #"o",
                           #"o", #"f", #" ", #"c", #"o", #"n", #"t", #"a", #"i",
                           #"n", #"s", #" ", #"a", #" ", #"f", #"i", #"n", #"i",
                           #"t", #"e", #"n", #"e", #"s", #"s", #" ", #"a", #"s",
                           #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #" ",
                           #"o", #"r", #" ", #"u", #"n", #"k", #"n", #"o", #"w",
                           #"n", #" ", #"p", #"r", #"o", #"o", #"f"] o
                        shows_nl)))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Rewriting_Proc (u_opt, stb, sta, st, lr, p, prf)) =
    debug (i [])
      [#"R", #"e", #"w", #"r", #"i", #"t", #"i", #"n", #"g", #"_", #"P", #"r",
        #"o", #"c"]
      (bindb
        (catch_errora
          (rewriting_proc
            (equal_lab B2_ (equal_list equal_nat),
              key_lab B3_ (key_list (equal_nat, key_nat)),
              show_lab B4_ (show_list show_nat))
            ia u_opt stb sta st lr p dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"r",
                          #"e", #"w", #"r", #"i", #"t", #"i", #"n", #"g", #" ",
                          #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r",
                          #" ", #"t", #"o", #" ", #"r", #"e", #"w", #"r", #"i",
                          #"t", #"e", #" ", #"t", #"h", #"e", #" ", #"p", #"a",
                          #"i", #"r", #" "] o
                       (shows_nl o
                         (shows_rule
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata)
                            [#" ", #"-", #">", #" "] stb o
                           (shows_nl o
                             (shows_string
                                [#" ", #"t", #"o", #" ", #"t", #"h", #"e", #" ",
                                  #"p", #"a", #"i", #"r", #" "] o
                               (shows_nl o
                                 (shows_rule
                                    (shows_prec_lab B4_ (show_list show_nat)
                                      zero_nata)
                                    (shows_prec_list show_char zero_nata)
                                    [#" ", #"-", #">", #" "] st o
                                   (shows_nl o x)))))))))))
        (fn dppa =>
          catch_errora
            (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"i",
                            #"n", #"g", #" ", #"p", #"r", #"o", #"c", #"e",
                            #"s", #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Narrowing_Proc (st, p, sts, prf)) =
    debug (i [])
      [#"N", #"a", #"r", #"r", #"o", #"w", #"i", #"n", #"g", #"_", #"P", #"r",
        #"o", #"c"]
      (bindb
        (catch_errora
          (narrowing_proc
            (equal_lab B2_ (equal_list equal_nat),
              key_lab B3_ (key_list (equal_nat, key_nat)),
              show_lab B4_ (show_list show_nat))
            ia st p sts dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"n",
                          #"a", #"r", #"r", #"o", #"w", #"i", #"n", #"g", #" ",
                          #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r",
                          #" ", #"t", #"o", #" ", #"n", #"a", #"r", #"r", #"o",
                          #"w", #" ", #"t", #"h", #"e", #" ", #"p", #"a", #"i",
                          #"r", #" "] o
                       (shows_nl o
                         (shows_rule
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata)
                            [#" ", #"-", #">", #" "] st o
                           (shows_nl o
                             (shows_string
                                [#" ", #"t", #"o", #" ", #"t", #"h", #"e", #" ",
                                  #"p", #"a", #"i", #"r", #"s", #" "] o
                               (shows_nl o
                                 (shows_trs
                                    (shows_prec_lab B4_ (show_list show_nat)
                                      zero_nata)
                                    (shows_prec_list show_char zero_nata)
                                    [#"r", #"e", #"w", #"r", #"i", #"t", #"e",
                                      #" ", #"s", #"y", #"s", #"t", #"e", #"m",
                                      #":"]
                                    [#" ", #"-", #">", #" "] sts o
                                   (shows_nl o x)))))))))))
        (fn dppa =>
          catch_errora
            (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"n", #"a", #"r", #"r", #"o", #"w", #"i",
                            #"n", #"g", #" ", #"p", #"r", #"o", #"c", #"e",
                            #"s", #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Instantiation_Proc (st, sts, prf)) =
    debug (i [])
      [#"I", #"n", #"s", #"t", #"a", #"n", #"t", #"i", #"a", #"t", #"i", #"o",
        #"n", #"_", #"P", #"r", #"o", #"c"]
      (bindb
        (catch_errora
          (instantiation_proc
            (equal_lab B2_ (equal_list equal_nat),
              key_lab B3_ (key_list (equal_nat, key_nat)),
              show_lab B4_ (show_list show_nat))
            ia st sts dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"i",
                          #"n", #"s", #"t", #"a", #"n", #"t", #"i", #"a", #"t",
                          #"i", #"o", #"n", #" ", #"p", #"r", #"o", #"c", #"e",
                          #"s", #"s", #"o", #"r", #" ", #"t", #"o", #" ", #"i",
                          #"n", #"s", #"t", #"a", #"n", #"t", #"i", #"a", #"t",
                          #"e", #" ", #"t", #"h", #"e", #" ", #"p", #"a", #"i",
                          #"r", #" "] o
                       (shows_nl o
                         (shows_rule
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata)
                            [#" ", #"-", #">", #" "] st o
                           (shows_nl o
                             (shows_string
                                [#" ", #"t", #"o", #" ", #"t", #"h", #"e", #" ",
                                  #"p", #"a", #"i", #"r", #"s", #" "] o
                               (shows_nl o
                                 (shows_trs
                                    (shows_prec_lab B4_ (show_list show_nat)
                                      zero_nata)
                                    (shows_prec_list show_char zero_nata)
                                    [#"r", #"e", #"w", #"r", #"i", #"t", #"e",
                                      #" ", #"s", #"y", #"s", #"t", #"e", #"m",
                                      #":"]
                                    [#" ", #"-", #">", #" "] sts o
                                   (shows_nl o x)))))))))))
        (fn dppa =>
          catch_errora
            (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"i", #"n", #"s", #"t", #"a", #"n", #"t",
                            #"i", #"a", #"t", #"i", #"o", #"n", #" ", #"p",
                            #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Forward_Instantiation_Proc (st, sts, u_opt, prf)) =
    debug (i [])
      [#"F", #"o", #"r", #"w", #"a", #"r", #"d", #"_", #"I", #"n", #"s", #"t",
        #"a", #"n", #"t", #"i", #"a", #"t", #"i", #"o", #"n", #"_", #"P", #"r",
        #"o", #"c"]
      (bindb
        (catch_errora
          (forward_instantiation_proc
            (equal_lab B2_ (equal_list equal_nat),
              key_lab B3_ (key_list (equal_nat, key_nat)),
              show_lab B4_ (show_list show_nat))
            ia st sts u_opt dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"f",
                          #"o", #"r", #"w", #"a", #"r", #"d", #"_", #"i", #"n",
                          #"s", #"t", #"a", #"n", #"t", #"i", #"a", #"t", #"i",
                          #"o", #"n", #" ", #"p", #"r", #"o", #"c", #"e", #"s",
                          #"s", #"o", #"r", #" ", #"t", #"o", #" ", #"i", #"n",
                          #"s", #"t", #"a", #"n", #"t", #"i", #"a", #"t", #"e",
                          #" ", #"t", #"h", #"e", #" ", #"p", #"a", #"i", #"r",
                          #" "] o
                       (shows_nl o
                         (shows_rule
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata)
                            [#" ", #"-", #">", #" "] st o
                           (shows_nl o
                             (shows_string
                                [#" ", #"t", #"o", #" ", #"t", #"h", #"e", #" ",
                                  #"p", #"a", #"i", #"r", #"s", #" "] o
                               (shows_nl o
                                 (shows_trs
                                    (shows_prec_lab B4_ (show_list show_nat)
                                      zero_nata)
                                    (shows_prec_list show_char zero_nata)
                                    [#"r", #"e", #"w", #"r", #"i", #"t", #"e",
                                      #" ", #"s", #"y", #"s", #"t", #"e", #"m",
                                      #":"]
                                    [#" ", #"-", #">", #" "] sts o
                                   (shows_nl o x)))))))))))
        (fn dppa =>
          catch_errora
            (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"f", #"o", #"r", #"w", #"a", #"r", #"d",
                            #" ", #"i", #"n", #"s", #"t", #"a", #"n", #"t",
                            #"i", #"a", #"t", #"i", #"o", #"n", #" ", #"p",
                            #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Unlab_Proc (p, r, prf)) =
    debug (i []) [#"U", #"n", #"l", #"a", #"b", #"_", #"P", #"r", #"o", #"c"]
      (Inl (shows_prec_list show_char zero_nata
             [#"u", #"n", #"l", #"a", #"b", #"e", #"l", #"i", #"n", #"g", #" ",
               #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r", #" ", #"n",
               #"o", #"t", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e",
               #"d"]))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (General_Redpair_Proc (rp, ps, pb, prof, prfs)) =
    debug (i [])
      [#"G", #"e", #"n", #"e", #"r", #"a", #"l", #"_", #"R", #"e", #"d", #"p",
        #"a", #"i", #"r", #"_", #"P", #"r", #"o", #"c", #"P", #"r", #"o", #"c"]
      let
        val n = size_list prfs;
      in
        bindb (check (less_nat zero_nata n)
                (shows_prec_list show_char zero_nata
                  [#"a", #"t", #" ", #"l", #"e", #"a", #"s", #"t", #" ", #"o",
                    #"n", #"e", #" ", #"s", #"u", #"b", #"p", #"r", #"o", #"o",
                    #"f", #" ", #"i", #"s", #" ", #"r", #"e", #"q", #"u", #"i",
                    #"r", #"e", #"d"]))
          (fn _ =>
            let
              val merge = equal_nata n one_nata;
            in
              bindb (catch_errora
                      (conditional_general_reduction_pair_proc
                        (ceq_lab B2_ (equal_list equal_nat),
                          ccompare_lab
                            ((compare_compare_order o compare_order_key) B3_)
                            ((compare_compare_order o compare_order_key)
                              (key_list (equal_nat, key_nat))),
                          equal_lab B2_ (equal_list equal_nat),
                          key_lab B3_ (key_list (equal_nat, key_nat)),
                          set_impl_lab, show_lab B4_ (show_list show_nat))
                        ia (get_non_inf_order
                             (equal_lab B2_ (equal_list equal_nat),
                               key_lab B3_ (key_list (equal_nat, key_nat)),
                               show_lab B4_ (show_list show_nat))
                             (equal_list equal_char,
                               linorder_list (equal_char, linorder_char),
                               show_list show_char)
                             rp)
                        ps pb prof merge dpp)
                      (fn x =>
                        Inl (i o (shows_string
                                    [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                      #" ", #"w", #"h", #"e", #"n", #" ", #"a",
                                      #"p", #"p", #"l", #"y", #"i", #"n", #"g",
                                      #" ", #"t", #"h", #"e", #" ", #"g", #"e",
                                      #"n", #"e", #"r", #"i", #"c", #" ", #"r",
                                      #"e", #"d", #"u", #"c", #"t", #"i", #"o",
                                      #"n", #" ", #"p", #"a", #"i", #"r", #" ",
                                      #"p", #"r", #"o", #"c", #"e", #"s", #"s",
                                      #"o", #"r", #" ", #"t", #"o", #" ", #"t",
                                      #"h", #"e", #" ", #"D", #"P", #" ", #"p",
                                      #"r", #"o", #"b", #"l", #"e", #"m"] o
                                   (shows_nl o
                                     (shows_dpp
(shows_prec_lab B4_ (show_list show_nat) zero_nata)
(shows_prec_list show_char zero_nata) ia dpp o
                                       (shows_nl o x)))))))
                (fn dpps =>
                  bindb (catch_errora
                          (check_dp_termination_proof_main (B1_, B2_, B3_, B4_)
                            j ia assms (i o shows_string [#".", #"1"])
                            (nth dpps zero_nata) (nth prfs zero_nata))
                          (fn x =>
                            Inl (i o (shows_string
[#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b", #"e", #"l", #"o", #"w",
  #" ", #"t", #"h", #"e", #" ", #"g", #"e", #"n", #"e", #"r", #"i", #"c", #" ",
  #"r", #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n", #" ", #"p", #"a", #"i",
  #"r", #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r"] o
                                       (shows_nl o indent x)))))
                    (fn _ =>
                      (if merge then Inr ()
                        else catch_errora
                               (check_dp_termination_proof_main
                                 (B1_, B2_, B3_, B4_) j ia assms
                                 (i o shows_string [#".", #"2"])
                                 (nth dpps one_nata) (nth prfs one_nata))
                               (fn x =>
                                 Inl (i o (shows_string
     [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b", #"e", #"l", #"o",
       #"w", #" ", #"t", #"h", #"e", #" ", #"g", #"e", #"n", #"e", #"r", #"i",
       #"c", #" ", #"r", #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n", #" ",
       #"p", #"a", #"i", #"r", #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s",
       #"o", #"r"] o
    (shows_nl o indent x)))))))
            end)
      end
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (Complex_Constant_Removal_Proc (p, prf)) =
    debug (i [])
      [#"C", #"o", #"m", #"p", #"l", #"e", #"x", #"_", #"C", #"o", #"n", #"s",
        #"t", #"a", #"n", #"t", #"_", #"R", #"e", #"m", #"o", #"v", #"a", #"l",
        #"_", #"P", #"r", #"o", #"c"]
      (bindb
        (catch_errora
          (complex_constant_removal_proc
            (equal_lab B2_ (equal_list equal_nat),
              key_lab B3_ (key_list (equal_nat, key_nat)),
              show_lab B4_ (show_list show_nat))
            ia p dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"c",
                          #"o", #"m", #"p", #"l", #"e", #"x", #" ", #"c", #"o",
                          #"n", #"s", #"t", #"a", #"n", #"t", #" ", #"r", #"e",
                          #"m", #"o", #"v", #"a", #"l", #" ", #"p", #"r", #"o",
                          #"c", #"e", #"s", #"s", #"o", #"r", #" ", #"t", #"o",
                          #" ", #"t", #"h", #"e", #" ", #"D", #"P", #" ", #"p",
                          #"r", #"o", #"b", #"l", #"e", #"m"] o
                       (shows_nl o
                         (shows_dpp
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) ia dpp o
                           (shows_nl o x)))))))
        (fn dppa =>
          catch_errora
            (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
              (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"c", #"o", #"m", #"p", #"l", #"e", #"x",
                            #" ", #"c", #"o", #"n", #"s", #"t", #"a", #"n",
                            #"t", #" ", #"r", #"e", #"m", #"o", #"v", #"a",
                            #"l", #" ", #"p", #"r", #"o", #"c", #"e", #"s",
                            #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms i dpp
    (To_Trs_Proc prf) =
    debug (i [])
      [#"T", #"o", #"_", #"T", #"r", #"s", #"_", #"P", #"r", #"o", #"c"]
      (catch_errora
        (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j ia assms
          (i o shows_string [#".", #"1"])
          (mk_tp j
            (nfsc ia dpp,
              (qc ia dpp, (pb ia dpp @ rd ia dpp, pwb ia dpp @ rwd ia dpp))))
          prf)
        (fn x =>
          Inl (i o (shows_string
                      [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                        #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e", #" ",
                        #"T", #"o", #"-", #"T", #"r", #"s", #" ", #"p", #"r",
                        #"o", #"c", #"e", #"s", #"s", #"o", #"r"] o
                     (shows_nl o indent x)))))
and check_unknown_proof_main (B1_, B2_, B3_, B4_) j ia assms i tpa
  (Assume_Unknown (tp, ass)) =
  debug (i [])
    [#"U", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"P", #"r", #"o", #"o",
      #"f"]
    (if assms
      then bindb (catch_errora
                   (check (equal_lista equal_char tpa tp)
                     (shows_prec_list show_char zero_nata
                        [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"p",
                          #"r", #"o", #"b", #"l", #"e", #"m", #"s", #" ", #"a",
                          #"r", #"e", #" ", #"n", #"o", #"t", #" ", #"i", #"d",
                          #"e", #"n", #"t", #"i", #"c", #"a", #"l", #":",
                          #" "] o
                       (shows_nl o
                         (shows_prec_list show_char zero_nata tpa o
                           (shows_nl o
                             (shows_prec_list show_char zero_nata
                                [#" ", #"v", #"s", #" "] o
                               (shows_nl o
                                 shows_prec_list show_char zero_nata tp)))))))
                   (fn x =>
                     Inl (i o (shows_string
                                 [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                   #" ", #"i", #"n", #" ", #"t", #"e", #"r",
                                   #"m", #"i", #"n", #"a", #"t", #"i", #"o",
                                   #"n", #" ", #"a", #"s", #"s", #"u", #"m",
                                   #"p", #"t", #"i", #"o", #"n", #" ", #"o",
                                   #"r", #" ", #"u", #"n", #"k", #"n", #"o",
                                   #"w", #"n", #" ", #"p", #"r", #"o", #"o",
                                   #"f"] o
                                (shows_nl o (x o shows_nl))))))
             (fn _ =>
               catch_errora
                 (forallM_index
                   (fn asa => fn ja =>
                     check_assma (B1_, B3_, B4_) j ia
                       (check_trs_termination_proof_main (B1_, B2_, B3_, B4_) j
                         ia assms
                         (i o (shows_string [#"."] o
                                shows_prec_nat zero_nata (suc ja))))
                       (check_dp_termination_proof_main (B1_, B2_, B3_, B4_) j
                         ia assms
                         (i o (shows_string [#"."] o
                                shows_prec_nat zero_nata (suc ja))))
                       (check_fptrs_termination_proof_main (B1_, B2_, B3_, B4_)
                         j ia assms
                         (i o (shows_string [#"."] o
                                shows_prec_nat zero_nata (suc ja))))
                       (check_unknown_proof_main (B1_, B2_, B3_, B4_) j ia assms
                         (i o (shows_string [#"."] o
                                shows_prec_nat zero_nata (suc ja))))
                       asa)
                   ass)
                 (fn x => Inl (snd x)))
      else Inl (i o (shows_string
                       [#":", #" ", #"t", #"h", #"e", #" ", #"p", #"r", #"o",
                         #"o", #"f", #" ", #"c", #"o", #"n", #"t", #"a", #"i",
                         #"n", #"s", #" ", #"a", #"n", #" ", #"u", #"n", #"k",
                         #"n", #"o", #"w", #"n", #" ", #"p", #"r", #"o", #"o",
                         #"f"] o
                      shows_nl)));

fun map_assm_proof tp dpp fptp unk (SN_assm_proof (r, p)) =
  SN_assm_proof (r, tp p)
  | map_assm_proof tp dpp fptp unk (Finite_assm_proof (d, p)) =
    Finite_assm_proof (d, dpp p)
  | map_assm_proof tp dpp fptp unk (SN_FP_assm_proof (r, p)) =
    SN_FP_assm_proof (r, fptp p)
  | map_assm_proof tp dpp fptp unk (Unknown_assm_proof (u, p)) =
    Unknown_assm_proof (u, unk p)
  | map_assm_proof tp dpp fptp unk (Not_SN_assm_proof (v, va)) =
    Not_SN_assm_proof (v, va)
  | map_assm_proof tp dpp fptp unk (Infinite_assm_proof (v, va)) =
    Infinite_assm_proof (v, va)
  | map_assm_proof tp dpp fptp unk (Not_RelSN_assm_proof (v, va)) =
    Not_RelSN_assm_proof (v, va)
  | map_assm_proof tp dpp fptp unk (Not_SN_FP_assm_proof (v, va)) =
    Not_SN_FP_assm_proof (v, va)
  | map_assm_proof tp dpp fptp unk (Complexity_assm_proof (v, va)) =
    Complexity_assm_proof (v, va);

fun no_decr A_ B_ C_ =
  filtera
    (fn (l, r) =>
      not (not (equal_terma (equal_lab A_ B_) C_ l r) andalso
            equal_terma (equal_lab A_ B_) C_ (map_term unlab (fn x => x) l)
              (map_term unlab (fn x => x) r)));

fun unlab_of_trs A_ B_ C_ r = map (map_funs_rule unlab) (no_decr A_ B_ C_ r);

fun updatec p_to_p (p, info) = (p_to_p p, info);

fun unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_)
  (DP_Trans (a1, a2, a3, p)) =
  DP_Trans
    (a1, a2, a3, fst (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p))
  | unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Rule_Removal (a1, a2, p)) =
    Rule_Removal (a1, a2, unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) (String_Reversal p) =
    String_Reversal (unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Constant_String (a1, p)) =
    Constant_String (a1, unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) (Bounds a) = Bounds a
  | unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) (Uncurry (a1, a2, p)) =
    Uncurry (a1, a2, unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) (Semlab (a1, a2, a3, p))
    = Semlab (a1, a2, a3, unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) R_is_Empty = R_is_Empty
  | unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) (Fcc (a1, a2, p)) =
    Fcc (a1, a2, unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) (Split (a1, p, q)) =
    Split (a1, unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) p,
            unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) q)
  | unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Switch_Innermost (a1, p)) =
    Switch_Innermost (a1, unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) (Drop_Equality p) =
    Drop_Equality (unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Remove_Nonapplicable_Rules (a1, p)) =
    Remove_Nonapplicable_Rules
      (a1, unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) (Permuting_AFS (a1, p))
    = Permuting_AFS (a1, unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) (Assume_SN (a, p)) =
    Assume_SN
      (a, map (map_assm_proof
                (unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_))
                (fst o unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_))
                (unlab_to_split_otrs (A1_, A2_) (B1_, B2_) (C1_, C2_))
                (unlab_to_split_unknown (A1_, A2_) (B1_, B2_) (C1_, C2_)))
            p)
and unlab_to_split_unknown (A1_, A2_) (B1_, B2_) (C1_, C2_)
  (Assume_Unknown (a1, p)) =
  Assume_Unknown
    (a1, map (map_assm_proof
               (unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_))
               (fst o unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_))
               (unlab_to_split_otrs (A1_, A2_) (B1_, B2_) (C1_, C2_))
               (unlab_to_split_unknown (A1_, A2_) (B1_, B2_) (C1_, C2_)))
           p)
and unlab_to_split_otrs (A1_, A2_) (B1_, B2_) (C1_, C2_) (Assume_FP_SN (a, p)) =
  Assume_FP_SN
    (a, map (map_assm_proof
              (unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_))
              (fst o unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_))
              (unlab_to_split_otrs (A1_, A2_) (B1_, B2_) (C1_, C2_))
              (unlab_to_split_unknown (A1_, A2_) (B1_, B2_) (C1_, C2_)))
          p)
and unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) P_is_Empty =
  (P_is_Empty, [])
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) (Dep_Graph_Proc ps) =
    (Dep_Graph_Proc
       (map (fn (po, a) =>
              (map_option
                 (fst o unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)) po,
                a))
         ps),
      [])
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Subterm_Criterion_Proc (a1, a2, a3, p)) =
    updatec (fn a => Subterm_Criterion_Proc (a1, a2, a3, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Gen_Subterm_Criterion_Proc (a1, a2, p)) =
    updatec (fn a => Gen_Subterm_Criterion_Proc (a1, a2, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Redpair_Proc (a1, a2, p)) =
    updatec (fn a => Redpair_Proc (a1, a2, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Redpair_UR_Proc (a1, a2, a3, p)) =
    updatec (fn a => Redpair_UR_Proc (a1, a2, a3, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Usable_Rules_Proc (a1, p)) =
    updatec (fn a => Usable_Rules_Proc (a1, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Q_Reduction_Proc (a1, p)) =
    updatec (fn a => Q_Reduction_Proc (a1, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Mono_Redpair_Proc (a1, a2, a3, p)) =
    updatec (fn a => Mono_Redpair_Proc (a1, a2, a3, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Mono_URM_Redpair_Proc (a1, a2, a3, p)) =
    updatec (fn a => Mono_URM_Redpair_Proc (a1, a2, a3, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Mono_Redpair_UR_Proc (a1, a2, a3, a4, p)) =
    updatec (fn a => Mono_Redpair_UR_Proc (a1, a2, a3, a4, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Size_Change_Subterm_Proc a1) = (Size_Change_Subterm_Proc a1, [])
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Size_Change_Redpair_Proc (a1, a2, a3)) =
    (Size_Change_Redpair_Proc (a1, a2, a3), [])
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Uncurry_Proc (a1, a2, a3, a4, p)) =
    updatec (fn a => Uncurry_Proc (a1, a2, a3, a4, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Fcc_Proc (a1, a2, a3, a4, p)) =
    updatec (fn a => Fcc_Proc (a1, a2, a3, a4, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Switch_Innermost_Proc (a1, p)) =
    updatec (fn a => Switch_Innermost_Proc (a1, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Rewriting_Proc (a1, a2, a3, a4, a5, a6, p)) =
    updatec (fn a => Rewriting_Proc (a1, a2, a3, a4, a5, a6, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Narrowing_Proc (a1, a2, a3, p)) =
    updatec (fn a => Narrowing_Proc (a1, a2, a3, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Instantiation_Proc (a1, a2, p)) =
    updatec (fn a => Instantiation_Proc (a1, a2, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Forward_Instantiation_Proc (a1, a2, a3, p)) =
    updatec (fn a => Forward_Instantiation_Proc (a1, a2, a3, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p)
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) (Assume_Finite (d, p)) =
    (Assume_Finite
       (d, map (map_assm_proof
                 (unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_))
                 (fst o unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_))
                 (unlab_to_split_otrs (A1_, A2_) (B1_, B2_) (C1_, C2_))
                 (unlab_to_split_unknown (A1_, A2_) (B1_, B2_) (C1_, C2_)))
             p),
      [])
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) (To_Trs_Proc p) =
    (To_Trs_Proc (unlab_to_split_trs (A1_, A2_) (B1_, B2_) (C1_, C2_) p), [])
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) (Unlab_Proc (pa, r, p)) =
    let
      val (pb, lista) = unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p;
    in
      (P_is_Empty, (pa, (r, pb)) :: lista)
    end
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Split_Proc (a1, a2, p, q)) =
    (Split_Proc
       (a1, a2, fst (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p),
         fst (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) q)),
      [])
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Semlab_Proc (a1, lP, a2, lR, p)) =
    let
      val (pa, lista) = unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p;
      val sl = Semlab_Proc (a1, lP, a2, lR, pa);
    in
      (case lista of [] => (sl, lista)
        | (pb, (r, prof)) :: listb =>
          let
            val ulP = unlab_of_trs A1_ B1_ C1_ lP;
            val ulR = unlab_of_trs A1_ B1_ C1_ lR;
            val pr =
              ceta_list_diff
                (key_prod (key_term (key_lab A2_ B2_) C2_)
                  (key_term (key_lab A2_ B2_) C2_))
                ulP pb;
            val rr =
              ceta_list_diff
                (key_prod (key_term (key_lab A2_ B2_) C2_)
                  (key_term (key_lab A2_ B2_) C2_))
                ulR r;
          in
            (Split_Proc (pr, rr, sl, prof), listb)
          end)
    end
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (General_Redpair_Proc (a1, a2, a3, a4, ps)) =
    (General_Redpair_Proc (a1, a2, a3, a4, ps), [])
  | unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_)
    (Complex_Constant_Removal_Proc (a1, p)) =
    updatec (fn a => Complex_Constant_Removal_Proc (a1, a))
      (unlab_to_split_dp (A1_, A2_) (B1_, B2_) (C1_, C2_) p);

fun check_trs_termination_proof (B1_, B2_, B3_, B4_) ia j a i tp prf =
  check_trs_termination_proof_main (B1_, B2_, B3_, B4_) ia j a i tp
    (unlab_to_split_trs (B2_, B3_)
      (equal_list equal_nat, key_list (equal_nat, key_nat))
      (equal_list equal_char, key_list (equal_char, key_char)) prf);

fun rule_lab_repr_to_lab A_ B_ ps =
  fun_of_map (ceta_map_of (key_prod (key_term A_ B_) (key_term A_ B_)) ps)
    zero_nata;

fun critical_peaks_impl A_ p r =
  maps (fn (l, ra) =>
         maps (fn pa =>
                let
                  val c = ctxt_of_pos_term pa l;
                  val la = subt_at l pa;
                  val b = equal_ctxta A_ (equal_list equal_char) c Hole;
                in
                  (if is_Var la then []
                    else maps (fn (lb, rb) =>
                                (case mgu_var_disjoint_generic
(equal_list equal_char) A_ (fn a => #"x" :: a) (fn a => #"y" :: a) la lb
                                  of NONE => []
                                  | SOME (sigma, tau) =>
                                    [(b, ((subst_apply_term l sigma,
    ((l, ra), (Empty, (sigma, (true, subst_apply_term ra sigma))))),
   (subst_apply_term l sigma,
     ((lb, rb),
       (pa, (tau, (true,
                    ctxt_apply_term (subst_apply_ctxt c sigma)
                      (subst_apply_term rb tau))))))))]))
                           r)
                end)
           (poss_list l))
    p;

fun check_rstepsa (A1_, A2_) (B1_, B2_, B3_, B4_) r [] s u =
  check (equal_terma A1_ B2_ s u)
    (shows_string
       [#"t", #"h", #"e", #" ", #"l", #"a", #"s", #"t", #" ", #"t", #"e", #"r",
         #"m", #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"r", #"e", #"w",
         #"r", #"i", #"t", #"e", #" ", #"s", #"e", #"q", #"u", #"e", #"n", #"c",
         #"e"] o
      (shows_nl o
        (shows_prec_term A2_ B4_ zero_nata s o
          (shows_nl o
            (shows_string
               [#"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"c",
                 #"o", #"r", #"r", #"e", #"s", #"p", #"o", #"n", #"d", #" ",
                 #"t", #"o", #" ", #"t", #"h", #"e", #" ", #"g", #"o", #"a",
                 #"l", #" ", #"t", #"e", #"r", #"m"] o
              (shows_nl o (shows_prec_term A2_ B4_ zero_nata u o shows_nl)))))))
  | check_rstepsa (A1_, A2_) (B1_, B2_, B3_, B4_) r ((p, (lr, t)) :: rs) s u =
    bindb (check_rstep (A1_, A2_) (B1_, B2_, B3_, B4_) r p lr s t)
      (fn _ => check_rstepsa (A1_, A2_) (B1_, B2_, B3_, B4_) r rs t u);

fun check_estep (A1_, A2_) (B1_, B2_, B3_, B4_) e p rule l_to_r s t =
  bindb (check
          (membera (equal_prod (equal_term A1_ B2_) (equal_term A1_ B2_)) e
            rule)
          (shows_rule (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
             [#" ", #"-", #">", #" "] rule o
            (shows_string
               [#"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"n", #" ",
                 #"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
                 #"f"] o
              (shows_nl o
                (shows_trs (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
                   [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"a", #"l",
                     #" ", #"s", #"y", #"s", #"t", #"e", #"m", #":"]
                   [#" ", #"=", #" "] e o
                  shows_nl)))))
    (fn _ =>
      bindb (check (in_poss p s)
              (shows_prec_pos zero_nata p o
                (shows_string
                   [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ",
                     #"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n", #" ", #"o",
                     #"f", #" "] o
                  (shows_prec_term A2_ B4_ zero_nata s o shows_nl))))
        (fn _ =>
          bindb (check (in_poss p t)
                  (shows_prec_pos zero_nata p o
                    (shows_string
                       [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                         #" ", #"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n",
                         #" ", #"o", #"f", #" "] o
                      (shows_prec_term A2_ B4_ zero_nata t o shows_nl))))
            (fn _ =>
              let
                val c = ctxt_of_pos_term p s;
                val d = ctxt_of_pos_term p t;
                val u = subt_at s p;
                val v = subt_at t p;
                val rrule = (if l_to_r then rule else (snd rule, fst rule));
                val err =
                  shows_string
                    [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #" "] o
                    (shows_prec_term A2_ B4_ zero_nata t o
                      (shows_string
                         [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t",
                           #" ", #"r", #"e", #"s", #"u", #"l", #"t", #" ", #"f",
                           #"r", #"o", #"m", #" ", #"a", #" ", #"p", #"r", #"o",
                           #"p", #"e", #"r", #" ", #"a", #"p", #"p", #"l", #"i",
                           #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o", #"f",
                           #" ", #"t", #"e", #"r", #"m", #" "] o
                        (shows_prec_term A2_ B4_ zero_nata s o
                          (shows_string
                             [#" ", #"u", #"s", #"i", #"n", #"g", #" ", #"e",
                               #"q", #"u", #"a", #"t", #"i", #"o", #"n", #" "] o
                            (shows_nl o
                              (shows_rule (shows_prec A2_ zero_nata)
                                 (shows_prec B4_ zero_nata) [#" ", #"=", #" "]
                                 rrule o
                                (shows_string
                                   [#" ", #"a", #"t", #" ", #"p", #"o", #"s",
                                     #"i", #"t", #"i", #"o", #"n", #" "] o
                                  (shows_prec_pos zero_nata p o
                                    shows_nl))))))));
              in
                (case match_list (B1_, B2_, B3_) A1_ B2_ Var
                        [(fst rrule, u), (snd rrule, v)]
                  of NONE => Inl err
                  | SOME _ => check (equal_ctxta A1_ B2_ c d) err)
              end)));

fun check_conversion (A1_, A2_) (B1_, B2_, B3_, B4_) e [] s u =
  check (equal_terma A1_ B2_ s u)
    (shows_string
       [#"t", #"h", #"e", #" ", #"l", #"a", #"s", #"t", #" ", #"t", #"e", #"r",
         #"m", #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"c", #"o", #"n",
         #"v", #"e", #"r", #"s", #"i", #"o", #"n", #" "] o
      (shows_nl o
        (shows_prec_term A2_ B4_ zero_nata s o
          (shows_nl o
            (shows_string
               [#"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"c",
                 #"o", #"r", #"r", #"e", #"s", #"p", #"o", #"n", #"d", #" ",
                 #"t", #"o", #" ", #"t", #"h", #"e", #" ", #"g", #"o", #"a",
                 #"l", #" ", #"t", #"e", #"r", #"m"] o
              (shows_nl o (shows_prec_term A2_ B4_ zero_nata u o shows_nl)))))))
  | check_conversion (A1_, A2_) (B1_, B2_, B3_, B4_) e
    ((p, (r, (l_to_r, t))) :: c) s u =
    bindb (check_estep (A1_, A2_) (B1_, B2_, B3_, B4_) e p r l_to_r s t)
      (fn _ => check_conversion (A1_, A2_) (B1_, B2_, B3_, B4_) e c t u);

fun check_ELD_1_nat beta alpha sigma_1 sigma_2 sigma_3 =
  bindb (catch_errora
          (forallM
            (fn x =>
              check (less_nat x beta)
                (shows_prec_list show_char zero_nata
                   [#"t", #"h", #"e", #" ", #"l", #"a", #"b", #"e", #"l", #"s",
                     #" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ", #"d",
                     #"e", #"c", #"r", #"e", #"a", #"s", #"i", #"n", #"g", #":",
                     #" "] o
                  (shows_prec_nat zero_nata x o
                    (shows_prec_list show_char zero_nata
                       [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"s",
                         #"m", #"a", #"l", #"l", #"e", #"r", #" "] o
                      (shows_prec_nat zero_nata beta o shows_nl)))))
            sigma_1)
          (fn x => Inl (snd x)))
    (fn _ =>
      bindb (catch_errora
              (forallM
                (fn x =>
                  check (less_eq_nat x alpha)
                    (shows_prec_list show_char zero_nata
                       [#"t", #"h", #"e", #" ", #"l", #"a", #"b", #"e", #"l",
                         #"s", #" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t",
                         #" ", #"d", #"e", #"c", #"r", #"e", #"a", #"s", #"i",
                         #"n", #"g", #":", #" "] o
                      (shows_prec_nat zero_nata x o
                        (shows_prec_list show_char zero_nata
                           [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                             #"s", #"m", #"a", #"l", #"l", #"e", #"r", #" ",
                             #"e", #"q", #"u", #"a", #"l", #" "] o
                          (shows_prec_nat zero_nata alpha o shows_nl)))))
                sigma_2)
              (fn x => Inl (snd x)))
        (fn _ =>
          bindb (check (less_eq_nat (size_list sigma_2) one_nata)
                  (shows_prec_list show_char zero_nata
                     [#" ", #" ", #"t", #"h", #"e", #" ", #"l", #"e", #"n",
                       #"g", #"t", #"h", #" ", #"o", #"f", #" ", #"t", #"h",
                       #"e", #" ", #"m", #"i", #"d", #"d", #"l", #"e", #" ",
                       #"s", #"e", #"q", #"u", #"e", #"n", #"c", #"e", #" ",
                       #"i", #"s", #" ", #"g", #"r", #"e", #"a", #"t", #"e",
                       #"r", #" ", #"1"] o
                    shows_nl))
            (fn _ =>
              catch_errora
                (forallM
                  (fn x =>
                    check (less_nat x alpha orelse less_nat x beta)
                      (shows_prec_list show_char zero_nata
                         [#"t", #"h", #"e", #" ", #"l", #"a", #"b", #"e", #"l",
                           #"s", #" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t",
                           #" ", #"d", #"e", #"c", #"r", #"e", #"a", #"s", #"i",
                           #"n", #"g", #":", #" "] o
                        (shows_prec_nat zero_nata x o
                          (shows_prec_list show_char zero_nata
                             [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                               #"s", #"m", #"a", #"l", #"l", #"e", #"r", #" "] o
                            (shows_prec_nat zero_nata alpha o
                              (shows_prec_list show_char zero_nata
                                 [#" ", #"o", #"r", #" ", #"s", #"m", #"a",
                                   #"l", #"l", #"e", #"r", #" "] o
                                (shows_prec_nat zero_nata beta o shows_nl)))))))
                  sigma_3)
                (fn x => Inl (snd x)))));

fun rule_labeling i (s, (rl, (p, (sigma, t)))) = i rl;

fun eseq_to_step_list A_ (B1_, B2_, B3_) s [] = []
  | eseq_to_step_list A_ (B1_, B2_, B3_) s ((p, (lr, (b, t))) :: steps) =
    let
      val u = subt_at s p;
      val v = subt_at t p;
    in
      (if b then let
                   val sigma =
                     let
                       val SOME tau =
                         match_list (B1_, B2_, B3_) A_ B2_ Var
                           [(fst lr, u), (snd lr, v)];
                     in
                       tau
                     end;
                 in
                   (s, (lr, (p, (sigma, (b, t))))) ::
                     eseq_to_step_list A_ (B1_, B2_, B3_) t steps
                 end
        else let
               val sigma =
                 let
                   val SOME tau =
                     match_list (B1_, B2_, B3_) A_ B2_ Var
                       [(snd lr, u), (fst lr, v)];
                 in
                   tau
                 end;
             in
               (t, (lr, (p, (sigma, (b, s))))) ::
                 eseq_to_step_list A_ (B1_, B2_, B3_) t steps
             end)
    end;

fun eseq_to_ddconv A_ (B1_, B2_, B3_) (s, eseq) =
  (s, eseq_to_step_list A_ (B1_, B2_, B3_) s eseq);

fun cpeak_instance A_ (B1_, B2_, B3_) sa cpa s cp =
  not (is_none
        (match_list (B1_, B2_, B3_) A_ B2_ (fn _ => sa)
          [(sa, s), (fst cpa, fst cp), (snd cpa, snd cp)]));

fun rseq_to_step_list A_ (B1_, B2_, B3_) s [] = []
  | rseq_to_step_list A_ (B1_, B2_, B3_) s ((p, (lr, t)) :: steps) =
    let
      val u = subt_at s p;
      val v = subt_at t p;
      val sigma =
        let
          val SOME tau =
            match_list (B1_, B2_, B3_) A_ B2_ Var [(fst lr, u), (snd lr, v)];
        in
          tau
        end;
    in
      (s, (lr, (p, (sigma, (true, t))))) ::
        rseq_to_step_list A_ (B1_, B2_, B3_) t steps
    end;

fun rseq_to_ddseq A_ (B1_, B2_, B3_) (s, rseq) =
  (s, rseq_to_step_list A_ (B1_, B2_, B3_) s rseq);

fun get_source s = fst s;

fun eseq_last s steps = last (s :: map (fn (_, (_, (_, sa))) => sa) steps);

fun check_cpeak_eldc (A1_, A2_) (B1_, B2_, B3_, B4_) r p s cp cl_1 sl cl_2 cr_1
  sr cr_2 lab n =
  let
    val ((s1, (r1, (_, (_, (true, t1))))), (_, (r2, (_, (_, (true, t2)))))) = p;
  in
    bindb (check (cpeak_instance A1_ (B1_, B2_, B3_) s cp s1 (t1, t2)) id)
      (fn _ =>
        let
          val u_1 = eseq_last (fst cp) cl_1;
          val v_1 = eseq_last (snd cp) cr_1;
          val u_2 = rseq_last u_1 sl;
          val v_2 = rseq_last v_1 sr;
          val u_3 = eseq_last u_2 cl_2;
          val v_3 = eseq_last v_2 cr_2;
        in
          bindb (check_conversion (A1_, A2_) (B1_, B2_, B3_, B4_) r cl_1
                  (fst cp) u_1)
            (fn _ =>
              bindb (check_rstepsa (A1_, A2_) (B1_, B2_, B3_, B4_) r sl u_1 u_2)
                (fn _ =>
                  bindb (check_conversion (A1_, A2_) (B1_, B2_, B3_, B4_) r cl_2
                          u_2 u_3)
                    (fn _ =>
                      bindb (check_conversion (A1_, A2_) (B1_, B2_, B3_, B4_) r
                              cr_1 (snd cp) v_1)
                        (fn _ =>
                          bindb (check_rstepsa (A1_, A2_) (B1_, B2_, B3_, B4_) r
                                  sr v_1 v_2)
                            (fn _ =>
                              bindb (check_conversion (A1_, A2_)
                                      (B1_, B2_, B3_, B4_) r cr_2 v_2 v_3)
                                (fn _ =>
                                  bindb (check (equal_terma A1_ B2_ u_3 v_3)
  (shows_prec_list show_char zero_nata
     [#"t", #"h", #"e", #" ", #"c", #"o", #"n", #"v", #"e", #"r", #"s", #"i",
       #"o", #"n", #"s", #" ", #"e", #"n", #"d", #" ", #"i", #"n", #" ", #"d",
       #"i", #"f", #"f", #"e", #"r", #"e", #"n", #"t", #" ", #"t", #"e", #"r",
       #"m", #"s", #":", #" "] o
    (shows_prec_term A2_ B4_ zero_nata u_3 o
      (shows_prec_list show_char zero_nata [#" ", #"a", #"n", #"d", #" "] o
        (shows_prec_term A2_ B4_ zero_nata v_3 o shows_nl)))))
                                    (fn _ =>
                                      let
val alpha = lab r1;
val beta = lab r2;
val cl_1a = snd (eseq_to_ddconv A1_ (B1_, B2_, B3_) (fst cp, cl_1));
val sla = snd (rseq_to_ddseq A1_ (B1_, B2_, B3_) (u_1, sl));
val cl_2a = snd (eseq_to_ddconv A1_ (B1_, B2_, B3_) (u_2, cl_2));
val cr_1a = snd (eseq_to_ddconv A1_ (B1_, B2_, B3_) (snd cp, cr_1));
val sra = snd (rseq_to_ddseq A1_ (B1_, B2_, B3_) (v_1, sr));
val cr_2a = snd (eseq_to_ddconv A1_ (B1_, B2_, B3_) (v_2, cr_2));
val tau_1 = map (rule_labeling lab) cl_1a;
val tau_2 = map (rule_labeling lab) sla;
val tau_3 = map (rule_labeling lab) cl_2a;
val sigma_1 = map (rule_labeling lab) cr_1a;
val sigma_2 = map (rule_labeling lab) sra;
val sigma_3 = map (rule_labeling lab) cr_2a;
                                      in
bindb (check_ELD_1_nat alpha beta tau_1 tau_2 tau_3)
  (fn _ =>
    bindb (check_ELD_1_nat beta alpha sigma_1 sigma_2 sigma_3)
      (fn _ =>
        (case n of NONE => Inr ()
          | SOME na =>
            let
              val check_reachable =
                (fn t =>
                  check (membera (equal_term A1_ B2_)
                          (reachable_terms A1_ (B1_, B2_, B3_) r s na) t)
                    (shows_prec_list show_char zero_nata
                       [#"t", #"h", #"e", #" ", #"f", #"a", #"n", #" ", #"p",
                         #"r", #"o", #"p", #"e", #"r", #"t", #"y", #" ", #"i",
                         #"s", #" ", #"v", #"i", #"o", #"l", #"a", #"t", #"e",
                         #"d", #":", #" "] o
                      (shows_prec_term A2_ B4_ zero_nata t o
                        (shows_prec_list show_char zero_nata
                           [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                             #"r", #"e", #"a", #"c", #"h", #"a", #"b", #"l",
                             #"e", #" ", #"f", #"r", #"o", #"m", #" "] o
                          (shows_prec_term A2_ B4_ zero_nata s o
                            (shows_prec_list show_char zero_nata
                               [#" ", #"i", #"n", #" "] o
                              (shows_prec_nat zero_nata na o
                                (shows_prec_list show_char zero_nata
                                   [#" ", #"s", #"t", #"e", #"p", #"s"] o
                                  shows_nl))))))));
            in
              bindb (catch_errora
                      (forallM check_reachable (map get_source cl_1a))
                      (fn x => Inl (snd x)))
                (fn _ =>
                  bindb (catch_errora
                          (forallM check_reachable (map get_source sla))
                          (fn x => Inl (snd x)))
                    (fn _ =>
                      bindb (catch_errora
                              (forallM check_reachable (map get_source cl_2a))
                              (fn x => Inl (snd x)))
                        (fn _ =>
                          bindb (catch_errora
                                  (forallM check_reachable
                                    (map get_source cr_1a))
                                  (fn x => Inl (snd x)))
                            (fn _ =>
                              bindb (catch_errora
                                      (forallM check_reachable
(map get_source sra))
                                      (fn x => Inl (snd x)))
                                (fn _ =>
                                  catch_errora
                                    (forallM check_reachable
                                      (map get_source cr_2a))
                                    (fn x => Inl (snd x)))))))
            end)))
                                      end)))))))
        end)
  end;

fun check_rule_labeling_eldc (A1_, A2_, A3_) r lab cs n =
  let
    val cps = critical_peaks_impl A1_ r r;
    val l = rule_lab_repr_to_lab A2_ (key_list (equal_char, key_char)) lab;
    val convs =
      cs @ map (fn (s, (u, (cl_1, (sl, (cl_2, (v, (cr_1, (sr, cr_2)))))))) =>
                 (s, (v, (cr_1, (sr, (cr_2, (u, (cl_1, (sl, cl_2)))))))))
             cs;
  in
    catch_errora
      (forallM
        (fn (_, a) =>
          let
            val (aa, b) = a;
          in
            let
              val (s1, (r1, (p1, (sigma_1, (_, t1))))) = aa;
            in
              (fn (s2, (r2, (p2, (sigma_2, (truea, t2))))) =>
                catch_errora
                  (check (equal_terma A1_ (equal_list equal_char) t1 t2)
                    (shows_prec_list show_char zero_nata
                      [#" ", #"p", #"a", #"i", #"r", #" ", #"n", #"o", #"n",
                        #"-", #"t", #"r", #"i", #"v", #"i", #"a", #"l", #" "]))
                  (fn _ =>
                    catch_errora
                      (existsM
                        (fn (s, (u, (cl_1,
                                      (sl, (cl_2, (v, (cr_1, (sr, cr_2))))))))
                           =>
                          check_cpeak_eldc (A1_, A3_)
                            (ccompare_list ccompare_char, equal_list equal_char,
                              mapping_impl_list, show_list show_char)
                            r ((s1, (r1, (p1, (sigma_1, (truea, t1))))),
                                (s2, (r2, (p2, (sigma_2, (truea, t2))))))
                            s (u, v) cl_1 sl cl_2 cr_1 sr cr_2 l n)
                        convs)
                      (fn x =>
                        Inl (shows_nl o
                              (shows_prec_list show_char zero_nata
                                 [#"t", #"h", #"e", #" ", #"c", #"r", #"i",
                                   #"t", #"i", #"c", #"a", #"l", #" ", #"p",
                                   #"e", #"a", #"k", #" "] o
                                (shows_prec_term A3_ (show_list show_char)
                                   zero_nata t1 o
                                  (shows_prec_list show_char zero_nata
                                     [#" ", #"<", #"-", #" "] o
                                    (shows_prec_term A3_ (show_list show_char)
                                       zero_nata s1 o
                                      (shows_prec_list show_char zero_nata
 [#" ", #"-", #">", #" "] o
(shows_prec_term A3_ (show_list show_char) zero_nata t2 o
  (shows_prec_list show_char zero_nata
     [#" ", #"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"b",
       #"e", #" ", #"j", #"o", #"i", #"n", #"e", #"d", #" ", #"d", #"e", #"c",
       #"r", #"e", #"a", #"s", #"i", #"n", #"g", #"l", #"y", #":"] o
    (shows_nl o shows_sep id id x))))))))))))
            end
              b
          end)
        cps)
      (fn x => Inl (snd x))
  end;

fun split_seq alpha beta ss =
  let
    val (ssa, r) = span (fn n => less_nat n alpha) ss;
  in
    (case r of [] => (ssa, ([], []))
      | h :: t =>
        (if less_eq_nat h beta then (ssa, ([h], t)) else (ssa, ([], r))))
  end;

fun check_cpeak_eld (A1_, A2_) (B1_, B2_, B3_, B4_) r p cp j1 j2 lab =
  let
    val ((_, (r1, (_, (_, (true, t1))))), (_, (r2, (_, (_, (true, t2)))))) = p;
  in
    bindb (check (instance_rule A1_ B2_ (B1_, B2_, B3_) (t1, t2) cp) id)
      (fn _ =>
        let
          val u = rseq_last (fst cp) j1;
          val v = rseq_last (snd cp) j2;
        in
          bindb (check_rstepsa (A1_, A2_) (B1_, B2_, B3_, B4_) r j1 (fst cp) u)
            (fn _ =>
              bindb (check_rstepsa (A1_, A2_) (B1_, B2_, B3_, B4_) r j2 (snd cp)
                      v)
                (fn _ =>
                  bindb (check (equal_terma A1_ B2_ u v)
                          (shows_prec_list show_char zero_nata
                             [#"t", #"h", #"e", #" ", #"r", #"e", #"w", #"r",
                               #"i", #"t", #"e", #" ", #"s", #"e", #"q", #"u",
                               #"e", #"n", #"c", #"e", #"s", #" ", #"e", #"n",
                               #"d", #" ", #"i", #"n", #" ", #"d", #"i", #"f",
                               #"f", #"e", #"r", #"e", #"n", #"t", #" ", #"t",
                               #"e", #"r", #"m", #"s", #":", #" "] o
                            (shows_prec_term A2_ B4_ zero_nata u o
                              (shows_prec_list show_char zero_nata
                                 [#" ", #"a", #"n", #"d", #" "] o
                                (shows_prec_term A2_ B4_ zero_nata v o
                                  shows_nl)))))
                    (fn _ =>
                      let
                        val alpha = lab r1;
                        val beta = lab r2;
                        val tau =
                          map (rule_labeling lab)
                            (snd (rseq_to_ddseq A1_ (B1_, B2_, B3_) (t1, j1)));
                        val sigma =
                          map (rule_labeling lab)
                            (snd (rseq_to_ddseq A1_ (B1_, B2_, B3_) (t2, j2)));
                        val (tau_1, (tau_2, tau_3)) = split_seq alpha beta tau;
                        val (sigma_1, (sigma_2, sigma_3)) =
                          split_seq beta alpha sigma;
                      in
                        bindb (check_ELD_1_nat alpha beta tau_1 tau_2 tau_3)
                          (fn _ =>
                            check_ELD_1_nat beta alpha sigma_1 sigma_2 sigma_3)
                      end)))
        end)
  end;

fun check_rule_labeling_eld (A1_, A2_, A3_) r lab js =
  let
    val cps = critical_peaks_impl A1_ r r;
    val l = rule_lab_repr_to_lab A2_ (key_list (equal_char, key_char)) lab;
    val joins = js @ map (fn (u, (j1, (v, j2))) => (v, (j2, (u, j1)))) js;
  in
    catch_errora
      (forallM
        (fn (_, a) =>
          let
            val (aa, b) = a;
          in
            let
              val (s1, (r1, (p1, (sigma_1, (_, t1))))) = aa;
            in
              (fn (s2, (r2, (p2, (sigma_2, (truea, t2))))) =>
                catch_errora
                  (check (equal_terma A1_ (equal_list equal_char) t1 t2)
                    (shows_prec_list show_char zero_nata
                      [#" ", #"p", #"a", #"i", #"r", #" ", #"n", #"o", #"n",
                        #"-", #"t", #"r", #"i", #"v", #"i", #"a", #"l", #" "]))
                  (fn _ =>
                    catch_errora
                      (existsM
                        (fn (u, (j1, (v, j2))) =>
                          check_cpeak_eld (A1_, A3_)
                            (ccompare_list ccompare_char, equal_list equal_char,
                              mapping_impl_list, show_list show_char)
                            r ((s1, (r1, (p1, (sigma_1, (truea, t1))))),
                                (s2, (r2, (p2, (sigma_2, (truea, t2))))))
                            (u, v) j1 j2 l)
                        joins)
                      (fn x =>
                        Inl (shows_nl o
                              (shows_prec_list show_char zero_nata
                                 [#"t", #"h", #"e", #" ", #"c", #"r", #"i",
                                   #"t", #"i", #"c", #"a", #"l", #" ", #"p",
                                   #"e", #"a", #"k", #" "] o
                                (shows_rule (shows_prec A3_ zero_nata)
                                   (shows_prec_list show_char zero_nata)
                                   [#" ", #"<", #"-", #" ", #".", #" ", #"-",
                                     #">", #" "]
                                   (t1, t2) o
                                  (shows_prec_list show_char zero_nata
                                     [#" ", #"c", #"o", #"u", #"l", #"d", #" ",
                                       #"n", #"o", #"t", #" ", #"b", #"e", #" ",
                                       #"j", #"o", #"i", #"n", #"e", #"d", #" ",
                                       #"d", #"e", #"c", #"r", #"e", #"a", #"s",
                                       #"i", #"n", #"g", #"l", #"y", #":"] o
                                    (shows_nl o shows_sep id id x))))))))
            end
              b
          end)
        cps)
      (fn x => Inl (snd x))
  end;

fun check_estepa (A1_, A2_) (B1_, B2_, B3_, B4_) e p rule l_to_r s t =
  bindb (check (list_ex (eq_rule_mod_vars A1_ (B1_, B2_, B3_) rule) e)
          (shows_rule (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
             [#" ", #"-", #">", #" "] rule o
            (shows_string
               [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"n",
                 #" ", #"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #" ",
                 #"o", #"f"] o
              (shows_nl o
                (shows_trs (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
                   [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"a", #"l",
                     #" ", #"s", #"y", #"s", #"t", #"e", #"m", #":"]
                   [#" ", #"=", #" "] e o
                  shows_nl)))))
    (fn _ =>
      bindb (check (in_poss p s)
              (shows_prec_pos zero_nata p o
                (shows_string
                   [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ",
                     #"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n", #" ", #"o",
                     #"f", #" "] o
                  (shows_prec_term A2_ B4_ zero_nata s o shows_nl))))
        (fn _ =>
          bindb (check (in_poss p t)
                  (shows_prec_pos zero_nata p o
                    (shows_string
                       [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                         #" ", #"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n",
                         #" ", #"o", #"f", #" "] o
                      (shows_prec_term A2_ B4_ zero_nata t o shows_nl))))
            (fn _ =>
              let
                val c = ctxt_of_pos_term p s;
                val d = ctxt_of_pos_term p t;
                val u = subt_at s p;
                val v = subt_at t p;
                val rrule = (if l_to_r then rule else (snd rule, fst rule));
                val err =
                  shows_string
                    [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #" "] o
                    (shows_prec_term A2_ B4_ zero_nata t o
                      (shows_string
                         [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t",
                           #" ", #"r", #"e", #"s", #"u", #"l", #"t", #" ", #"f",
                           #"r", #"o", #"m", #" ", #"a", #" ", #"p", #"r", #"o",
                           #"p", #"e", #"r", #" ", #"a", #"p", #"p", #"l", #"i",
                           #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"o", #"f",
                           #" ", #"t", #"e", #"r", #"m", #" "] o
                        (shows_prec_term A2_ B4_ zero_nata s o
                          (shows_string
                             [#" ", #"u", #"s", #"i", #"n", #"g", #" ", #"e",
                               #"q", #"u", #"a", #"t", #"i", #"o", #"n", #" "] o
                            (shows_nl o
                              (shows_rule (shows_prec A2_ zero_nata)
                                 (shows_prec B4_ zero_nata) [#" ", #"=", #" "]
                                 rrule o
                                (shows_string
                                   [#" ", #"a", #"t", #" ", #"p", #"o", #"s",
                                     #"i", #"t", #"i", #"o", #"n", #" "] o
                                  (shows_prec_pos zero_nata p o
                                    shows_nl))))))));
              in
                (case match_list (B1_, B2_, B3_) A1_ B2_ Var
                        [(fst rrule, u), (snd rrule, v)]
                  of NONE => Inl err
                  | SOME _ => check (equal_ctxta A1_ B2_ c d) err)
              end)));

fun check_conversiona (A1_, A2_) (B1_, B2_, B3_, B4_) e [] s u =
  check (equal_terma A1_ B2_ s u)
    (shows_string
       [#"t", #"h", #"e", #" ", #"l", #"a", #"s", #"t", #" ", #"t", #"e", #"r",
         #"m", #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"c", #"o", #"n",
         #"v", #"e", #"r", #"s", #"i", #"o", #"n", #" "] o
      (shows_nl o
        (shows_prec_term A2_ B4_ zero_nata s o
          (shows_nl o
            (shows_string
               [#"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"c",
                 #"o", #"r", #"r", #"e", #"s", #"p", #"o", #"n", #"d", #" ",
                 #"t", #"o", #" ", #"t", #"h", #"e", #" ", #"g", #"o", #"a",
                 #"l", #" ", #"t", #"e", #"r", #"m"] o
              (shows_nl o (shows_prec_term A2_ B4_ zero_nata u o shows_nl)))))))
  | check_conversiona (A1_, A2_) (B1_, B2_, B3_, B4_) e
    ((p, (r, (l_to_r, t))) :: c) s u =
    bindb (check_estepa (A1_, A2_) (B1_, B2_, B3_, B4_) e p r l_to_r s t)
      (fn _ => check_conversiona (A1_, A2_) (B1_, B2_, B3_, B4_) e c t u);

fun check_redundant_rules (A1_, A2_) (B1_, B2_, B3_, B4_) ra r n convs =
  let
    val s =
      list_diff (equal_prod (equal_term A1_ B2_) (equal_term A1_ B2_)) r ra;
    val t =
      list_diff (equal_prod (equal_term A1_ B2_) (equal_term A1_ B2_)) ra r;
  in
    bindb (catch_errora
            (forallM
              (fn (l, rb) =>
                check (membera (equal_term A1_ B2_)
                        (reachable_terms A1_ (B1_, B2_, B3_) ra l n) rb)
                  (shows_prec_list show_char zero_nata
                     [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                       #" ", #"s", #"i", #"m", #"u", #"l", #"a", #"t", #"e",
                       #" ", #"r", #"u", #"l", #"e", #" "] o
                    shows_rule (shows_prec A2_ zero_nata)
                      (shows_prec B4_ zero_nata) [#" ", #"-", #">", #" "]
                      (l, rb)))
              s)
            (fn x => Inl (snd x)))
      (fn _ =>
        catch_errora
          (forallM
            (fn (l, raa) =>
              catch_errora
                (existsM
                  (fn conv =>
                    check_conversiona (A1_, A2_) (B1_, B2_, B3_, B4_) r conv l
                      raa)
                  convs)
                (fn _ =>
                  check_join_BFS_limit (A1_, A2_) (B1_, B2_, B3_, B4_) n r l
                    raa))
            t)
          (fn x => Inl (snd x)))
  end;

fun check_cr_proof (B1_, B2_, B3_, B4_) a ia i j r (SN_WCR (joins_i, prf)) =
  debug (ia []) [#"S", #"N", #"_", #"W", #"C", #"R"]
    let
      val tp = mkc i false [] r [];
    in
      bindb (catch_errora
              (check_trs_termination_proof (B1_, B2_, B3_, B4_) i j a
                (ia o shows_string [#".", #"1"]) tp prf)
              (fn x =>
                Inl (ia o (shows_string
                             [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                               #"b", #"e", #"l", #"o", #"w", #" ", #"s", #"t",
                               #"r", #"o", #"n", #"g", #" ", #"n", #"o", #"r",
                               #"m", #"a", #"l", #"i", #"z", #"a", #"t", #"i",
                               #"o", #"n", #" ", #"+", #" ", #"w", #"c", #"r"] o
                            (shows_nl o indent x)))))
        (fn _ =>
          catch_errora
            (check_critical_pairs
              (equal_lab B2_ (equal_list equal_nat),
                show_lab B4_ (show_list show_nat))
              r (critical_pairs_impl (equal_lab B2_ (equal_list equal_nat)) r r)
              joins_i)
            (fn x =>
              Inl (ia o (shows_prec_list show_char zero_nata
                           [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h",
                             #"e", #"n", #" ", #"p", #"r", #"o", #"v", #"i",
                             #"n", #"g", #" ", #"l", #"o", #"c", #"a", #"l",
                             #" ", #"c", #"o", #"n", #"f", #"l", #"u", #"e",
                             #"n", #"c", #"e", #" ", #"o", #"f", #" "] o
                          (shows_tp
                             (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                             (shows_prec_list show_char zero_nata) i tp o
                            (shows_nl o indent x))))))
    end
  | check_cr_proof (B1_, B2_, B3_, B4_) a ia i j r Weakly_Orthogonal =
    debug (ia [])
      [#"W", #"e", #"a", #"k", #"l", #"y", #" ", #"O", #"r", #"t", #"h", #"o",
        #"g", #"o", #"n", #"a", #"l"]
      (catch_errora
        (check_weakly_orthogonal
          (equal_lab B2_ (equal_list equal_nat),
            show_lab B4_ (show_list show_nat))
          r)
        (fn x =>
          Inl (ia o (shows_prec_list show_char zero_nata
                       [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                         #"n", #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n",
                         #"g", #" ", #"w", #"e", #"a", #"k", #"l", #"y", #" ",
                         #"o", #"r", #"t", #"h", #"o", #"g", #"o", #"n", #"a",
                         #"l", #"i", #"t", #"y", #" ", #"o", #"f", #" ", #"t",
                         #"h", #"e", #" "] o
                      (shows_trs
                         (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                         (shows_prec_list show_char zero_nata)
                         [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s",
                           #"y", #"s", #"t", #"e", #"m", #":"]
                         [#" ", #"-", #">", #" "] r o
                        indent x)))))
  | check_cr_proof (B1_, B2_, B3_, B4_) a ia i j r (Strongly_Closed n) =
    debug (ia [])
      [#"S", #"t", #"r", #"o", #"n", #"g", #"l", #"y", #" ", #"C", #"l", #"o",
        #"s", #"e", #"d"]
      (catch_errora
        (check_strongly_closed
          (equal_lab B2_ (equal_list equal_nat),
            show_lab B4_ (show_list show_nat))
          r n)
        (fn x =>
          Inl (ia o (shows_prec_list show_char zero_nata
                       [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                         #"n", #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n",
                         #"g", #" ", #"s", #"t", #"r", #"o", #"n", #"g", #" ",
                         #"c", #"l", #"o", #"s", #"e", #"d", #"n", #"e", #"s",
                         #"s", #" ", #"f", #"o", #"r", #" ", #"t", #"h", #"e",
                         #" "] o
                      (shows_trs
                         (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                         (shows_prec_list show_char zero_nata)
                         [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s",
                           #"y", #"s", #"t", #"e", #"m", #":"]
                         [#" ", #"-", #">", #" "] r o
                        indent x)))))
  | check_cr_proof (B1_, B2_, B3_, B4_) a ia i j r
    (Rule_Labeling (rl, joins, prf)) =
    debug (ia [])
      [#"R", #"u", #"l", #"e", #" ", #"L", #"a", #"b", #"e", #"l", #"i", #"n",
        #"g"]
      (bindb
        (case prf
          of NONE =>
            check_linear_trs (show_lab B4_ (show_list show_nat))
              (ceq_list ceq_char, ccompare_list ccompare_char, set_impl_list,
                show_list show_char)
              r
          | SOME prfa =>
            bindb (check_left_linear_trs (show_lab B4_ (show_list show_nat))
                    (ceq_list ceq_char, ccompare_list ccompare_char,
                      set_impl_list, show_list show_char)
                    r)
              (fn _ =>
                let
                  val (rnd, rd) =
                    partition
                      (fn lr =>
                        linear_term
                          (ceq_list ceq_char, ccompare_list ccompare_char,
                            set_impl_list)
                          (snd lr))
                      r;
                  val tp = mkc i false [] rd rnd;
                in
                  catch_errora
                    (check_trs_termination_proof (B1_, B2_, B3_, B4_) i j a
                      (ia o shows_string [#".", #"1"]) tp prfa)
                    (fn x =>
                      Inl (ia o (shows_string
                                   [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                     #" ", #"b", #"e", #"l", #"o", #"w", #" ",
                                     #"r", #"e", #"l", #"a", #"t", #"i", #"v",
                                     #"e", #" ", #"t", #"e", #"r", #"m", #"i",
                                     #"n", #"a", #"t", #"i", #"o", #"n", #" ",
                                     #"f", #"o", #"r", #" ", #"r", #"u", #"l",
                                     #"e", #" ", #"l", #"a", #"b", #"e", #"l",
                                     #"i", #"n", #"g"] o
                                  (shows_nl o indent x))))
                end))
        (fn _ =>
          catch_errora
            (check_rule_labeling_eld
              (equal_lab B2_ (equal_list equal_nat),
                key_lab B3_ (key_list (equal_nat, key_nat)),
                show_lab B4_ (show_list show_nat))
              r rl joins)
            (fn x =>
              Inl (ia o (shows_prec_list show_char zero_nata
                           [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                             #"i", #"n", #" ", #"c", #"h", #"e", #"c", #"k",
                             #"i", #"n", #"g", #" ", #"d", #"e", #"c", #"r",
                             #"e", #"a", #"s", #"i", #"n", #"g", #"n", #"e",
                             #"s", #"s", #" ", #"o", #"f", #" ", #"C", #"P",
                             #"s", #" ", #"u", #"s", #"i", #"n", #"g", #" ",
                             #"r", #"u", #"l", #"e", #" ", #"l", #"a", #"b",
                             #"e", #"l", #"i", #"n", #"g", #" ", #"f", #"o",
                             #"r", #" ", #"t", #"h", #"e", #" "] o
                          (shows_trs
                             (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                             (shows_prec_list show_char zero_nata)
                             [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                               #"s", #"y", #"s", #"t", #"e", #"m", #":"]
                             [#" ", #"-", #">", #" "] r o
                            indent x))))))
  | check_cr_proof (B1_, B2_, B3_, B4_) a ia i j r
    (Rule_Labeling_Conv (rl, convs, nprf)) =
    debug (ia [])
      [#"R", #"u", #"l", #"e", #" ", #"L", #"a", #"b", #"e", #"l", #"i", #"n",
        #"g"]
      (case nprf
        of NONE =>
          bindb (check_linear_trs (show_lab B4_ (show_list show_nat))
                  (ceq_list ceq_char, ccompare_list ccompare_char,
                    set_impl_list, show_list show_char)
                  r)
            (fn _ =>
              catch_errora
                (check_rule_labeling_eldc
                  (equal_lab B2_ (equal_list equal_nat),
                    key_lab B3_ (key_list (equal_nat, key_nat)),
                    show_lab B4_ (show_list show_nat))
                  r rl convs NONE)
                (fn x =>
                  Inl (ia o (shows_prec_list show_char zero_nata
                               [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                 #"i", #"n", #" ", #"c", #"h", #"e", #"c", #"k",
                                 #"i", #"n", #"g", #" ", #"d", #"e", #"c", #"r",
                                 #"e", #"a", #"s", #"i", #"n", #"g", #"n", #"e",
                                 #"s", #"s", #" ", #"o", #"f", #" ", #"C", #"P",
                                 #"s", #" ", #"u", #"s", #"i", #"n", #"g", #" ",
                                 #"r", #"u", #"l", #"e", #" ", #"l", #"a", #"b",
                                 #"e", #"l", #"i", #"n", #"g", #" ", #"f", #"o",
                                 #"r", #" ", #"t", #"h", #"e", #" "] o
                              (shows_trs
                                 (shows_prec_lab B4_ (show_list show_nat)
                                   zero_nata)
                                 (shows_prec_list show_char zero_nata)
                                 [#"r", #"e", #"w", #"r", #"i", #"t", #"e",
                                   #" ", #"s", #"y", #"s", #"t", #"e", #"m",
                                   #":"]
                                 [#" ", #"-", #">", #" "] r o
                                indent x)))))
        | SOME (n, prf) =>
          bindb (check_left_linear_trs (show_lab B4_ (show_list show_nat))
                  (ceq_list ceq_char, ccompare_list ccompare_char,
                    set_impl_list, show_list show_char)
                  r)
            (fn _ =>
              let
                val (rnd, rd) =
                  partition
                    (fn lr =>
                      linear_term
                        (ceq_list ceq_char, ccompare_list ccompare_char,
                          set_impl_list)
                        (snd lr))
                    r;
                val tp = mkc i false [] rd rnd;
              in
                bindb (catch_errora
                        (check_trs_termination_proof (B1_, B2_, B3_, B4_) i j a
                          (ia o shows_string [#".", #"1"]) tp prf)
                        (fn x =>
                          Inl (ia o (shows_string
                                       [#":", #" ", #"e", #"r", #"r", #"o",
 #"r", #" ", #"b", #"e", #"l", #"o", #"w", #" ", #"r", #"e", #"l", #"a", #"t",
 #"i", #"v", #"e", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
 #"o", #"n", #" ", #"f", #"o", #"r", #" ", #"r", #"u", #"l", #"e", #" ", #"l",
 #"a", #"b", #"e", #"l", #"i", #"n", #"g"] o
                                      (shows_nl o indent x)))))
                  (fn _ =>
                    catch_errora
                      (check_rule_labeling_eldc
                        (equal_lab B2_ (equal_list equal_nat),
                          key_lab B3_ (key_list (equal_nat, key_nat)),
                          show_lab B4_ (show_list show_nat))
                        r rl convs (SOME n))
                      (fn x =>
                        Inl (ia o (shows_prec_list show_char zero_nata
                                     [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                       #" ", #"i", #"n", #" ", #"c", #"h", #"e",
                                       #"c", #"k", #"i", #"n", #"g", #" ", #"d",
                                       #"e", #"c", #"r", #"e", #"a", #"s", #"i",
                                       #"n", #"g", #"n", #"e", #"s", #"s", #" ",
                                       #"o", #"f", #" ", #"C", #"P", #"s", #" ",
                                       #"u", #"s", #"i", #"n", #"g", #" ", #"r",
                                       #"u", #"l", #"e", #" ", #"l", #"a", #"b",
                                       #"e", #"l", #"i", #"n", #"g", #" ", #"f",
                                       #"o", #"r", #" ", #"t", #"h", #"e",
                                       #" "] o
                                    (shows_trs
                                       (shows_prec_lab B4_ (show_list show_nat)
 zero_nata)
                                       (shows_prec_list show_char zero_nata)
                                       [#"r", #"e", #"w", #"r", #"i", #"t",
 #"e", #" ", #"s", #"y", #"s", #"t", #"e", #"m", #":"]
                                       [#" ", #"-", #">", #" "] r o
                                      indent x)))))
              end))
  | check_cr_proof (B1_, B2_, B3_, B4_) a ia i j r
    (Redundant_Rules (rs, n, convs, prf)) =
    debug (ia [])
      [#"R", #"e", #"d", #"u", #"n", #"d", #"a", #"n", #"t", #" ", #"R", #"u",
        #"l", #"e", #"s"]
      (bindb
        (catch_errora
          (check_cr_proof (B1_, B2_, B3_, B4_) a
            (ia o shows_string [#".", #"1"]) i j rs prf)
          (fn x =>
            Inl (ia o (shows_prec_list show_char zero_nata
                         [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                           #"e", #"l", #"o", #"w", #" ", #"c", #"o", #"n", #"f",
                           #"l", #"u", #"e", #"n", #"c", #"e", #" ", #"o", #"f",
                           #" ", #"m", #"o", #"d", #"i", #"f", #"i", #"e", #"d",
                           #" ", #"T", #"R", #"S"] o
                        (shows_nl o
                          (shows_trs
                             (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                             (shows_prec_list show_char zero_nata)
                             [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                               #"s", #"y", #"s", #"t", #"e", #"m", #":"]
                             [#" ", #"-", #">", #" "] rs o
                            indent x))))))
        (fn _ =>
          catch_errora
            (check_redundant_rules
              (equal_lab B2_ (equal_list equal_nat),
                show_lab B4_ (show_list show_nat))
              (ccompare_list ccompare_char, equal_list equal_char,
                mapping_impl_list, show_list show_char)
              r rs n convs)
            (fn x =>
              Inl (ia o (shows_prec_list show_char zero_nata
                           [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                             #"i", #"n", #" ", #"c", #"h", #"e", #"c", #"k",
                             #"i", #"n", #"g", #" ", #"r", #"e", #"d", #"u",
                             #"n", #"d", #"a", #"n", #"t", #" ", #"r", #"u",
                             #"l", #"e", #"s", #" ", #"t", #"r", #"a", #"n",
                             #"s", #"f", #"o", #"r", #"m", #"a", #"t", #"i",
                             #"o", #"n", #" ", #"o", #"f", #" ", #"t", #"h",
                             #"e", #" "] o
                          (shows_trs
                             (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                             (shows_prec_list show_char zero_nata)
                             [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                               #"s", #"y", #"s", #"t", #"e", #"m", #":"]
                             [#" ", #"-", #">", #" "] r o
                            (shows_prec_list show_char zero_nata
                               [#"t", #"r", #"a", #"n", #"s", #"f", #"o", #"r",
                                 #"m", #"e", #"d", #" ", #"t", #"o", #" ", #"t",
                                 #"h", #"e", #" "] o
                              (shows_trs
                                 (shows_prec_lab B4_ (show_list show_nat)
                                   zero_nata)
                                 (shows_prec_list show_char zero_nata)
                                 [#"r", #"e", #"w", #"r", #"i", #"t", #"e",
                                   #" ", #"s", #"y", #"s", #"t", #"e", #"m",
                                   #":"]
                                 [#" ", #"-", #">", #" "] rs o
                                indent x))))))))
  | check_cr_proof (B1_, B2_, B3_, B4_) a ia i j r (Parallel_Closed n) =
    debug (ia [])
      [#"P", #"a", #"r", #"a", #"l", #"l", #"e", #"l", #" ", #"C", #"l", #"o",
        #"s", #"e", #"d"]
      (catch_errora
        (check_parallel_closed
          (equal_lab B2_ (equal_list equal_nat),
            show_lab B4_ (show_list show_nat))
          r n)
        (fn x =>
          Inl (ia o (shows_prec_list show_char zero_nata
                       [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                         #"n", #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n",
                         #"g", #" ", #"p", #"a", #"r", #"a", #"l", #"l", #"e",
                         #"l", #" ", #"c", #"l", #"o", #"s", #"e", #"d", #"n",
                         #"e", #"s", #"s", #" ", #"f", #"o", #"r", #" ", #"t",
                         #"h", #"e", #" "] o
                      (shows_trs
                         (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                         (shows_prec_list show_char zero_nata)
                         [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s",
                           #"y", #"s", #"t", #"e", #"m", #":"]
                         [#" ", #"-", #">", #" "] r o
                        indent x)))))
  | check_cr_proof (B1_, B2_, B3_, B4_) a ia i j r
    (Critical_Pair_Closing_System (c, prf, n)) =
    debug (ia [])
      [#"C", #"r", #"i", #"t", #"i", #"c", #"a", #"l", #"-", #"P", #"a", #"i",
        #"r", #"-", #"C", #"l", #"o", #"s", #"i", #"n", #"g", #" ", #"S", #"y",
        #"s", #"t", #"e", #"m"]
      let
        val tp = mkc i false [] c [];
      in
        bindb (catch_errora
                (check_trs_termination_proof (B1_, B2_, B3_, B4_) i j a
                  (ia o shows_string [#".", #"1"]) tp prf)
                (fn x =>
                  Inl (ia o (shows_string
                               [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                 #"b", #"e", #"l", #"o", #"w", #" ", #"s", #"t",
                                 #"r", #"o", #"n", #"g", #" ", #"n", #"o", #"r",
                                 #"m", #"a", #"l", #"i", #"z", #"a", #"t", #"i",
                                 #"o", #"n", #" ", #"o", #"f", #" ", #"C", #"P",
                                 #"C", #"S"] o
                              (shows_nl o indent x)))))
          (fn _ =>
            catch_errora
              (check_critical_pair_closing
                (equal_lab B2_ (equal_list equal_nat),
                  show_lab B4_ (show_list show_nat))
                r c n)
              (fn x =>
                Inl (ia o (shows_prec_list show_char zero_nata
                             [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h",
                               #"e", #"n", #" ", #"c", #"l", #"o", #"s", #"i",
                               #"n", #"g", #" ", #"c", #"r", #"i", #"t", #"i",
                               #"c", #"a", #"l", #" ", #"p", #"a", #"i", #"r",
                               #"s", #" ", #"o", #"f", #" "] o
                            (shows_tp
                               (shows_prec_lab B4_ (show_list show_nat)
                                 zero_nata)
                               (shows_prec_list show_char zero_nata) i tp o
                              (shows_nl o indent x))))))
      end;

fun edges_to_adj_fun (A1_, A2_) e =
  precompute_fun A2_
    (fn a =>
      remdups A1_
        (maps (fn ea => (if eq A1_ (fst ea) a then [snd ea] else [])) e))
    (remdups A1_ (map fst e @ map snd e));

fun create_graph_impl (A1_, A2_) e =
  Gen_g_impl_ext
    (membera A1_ (map fst e @ map snd e), edges_to_adj_fun (A1_, A2_) e,
      remdups A1_ (map fst e @ map snd e), ());

fun as_singleton B_ x = (FArray.IsabelleMapping.array_of_list [x], onea B_);

fun gi_V0 (Gen_g_impl_ext (gi_V, gi_E, gi_V0, more)) = gi_V0;

fun as_is_empty s = equal_nata (snd s) zero_nata;

fun rev_append [] ac = ac
  | rev_append (x :: xs) ac = rev_append xs (x :: ac);

fun glist_delete_aux eq x [] asa = asa
  | glist_delete_aux eq x (y :: ys) asa =
    (if eq x y then rev_append asa ys else glist_delete_aux eq x ys (y :: asa));

fun glist_delete eq x l = glist_delete_aux eq x l [];

fun select_edge_tr A_ s =
  let
    val (a, (aa, (ab, bb))) = s;
  in
    (if as_is_empty bb then (NONE, (a, (aa, (ab, bb))))
      else let
             val (ac, bc) = as_top bb;
           in
             (if less_eq_nat (as_get aa (minus_nata (as_length aa) one_nata)) ac
               then let
                      val xa = gen_pick (fn x => foldli (id x)) bc;
                      val xb =
                        glist_delete
                          (comp2eq
                            (dflt_cmp
                              (less_eq
                                ((ord_preorder o preorder_order o
                                   order_linorder)
                                  A_))
                              (less ((ord_preorder o preorder_order o
                                       order_linorder)
                                      A_))))
                          xa bc;
                      val xc =
                        (if is_Nil xb then as_pop bb
                          else as_set bb (minus_nata (as_length bb) one_nata)
                                 (ac, xb));
                    in
                      (SOME xa, (a, (aa, (ab, xc))))
                    end
               else (NONE, (a, (aa, (ab, bb)))))
           end)
  end;

fun as_empty B_ uu = (FArray.IsabelleMapping.array_of_list [], zerob B_);

fun stat_start x = (fn _ => ()) x;

fun last_seg_tr A_ s =
  let
    val (a, (aa, (_, _))) = s;
    val (_, bc) =
      whilea
        (fn (xe, _) =>
          less_nat xe
            (if equal_nata
                  (plus_nata (minus_nata (as_length aa) one_nata) one_nata)
                  (as_length aa)
              then as_length a
              else as_get aa
                     (plus_nata (minus_nata (as_length aa) one_nata) one_nata)))
        (fn (ac, bc) => let
                          val xa = as_get a ac;
                        in
                          (suc ac, xa :: bc)
                        end)
        (as_get aa (minus_nata (as_length aa) one_nata), []);
  in
    bc
  end;

fun collapse_tr A_ v s = let
                           val (a, (aa, (ab, bb))) = s;
                           val x = idx_of_tr A_ v (a, (aa, (ab, bb)));
                           val xa = as_take (plus_nata x one_nata) aa;
                         in
                           (a, (xa, (ab, bb)))
                         end;

fun stat_stop x = (fn _ => ()) x;

fun compute_SCC_tr A_ g =
  let
    val _ = stat_start ();
    val xa = ([], Emptya);
    val a =
      foldli (id (gi_V0 g)) (fn _ => true)
        (fn xb => fn (a, b) =>
          (if not (case rbt_lookup
                          (less ((ord_preorder o preorder_order o
                                   order_linorder o linorder_compare_order)
                                  A_))
                          b xb
                    of NONE => false
                    | SOME i =>
                      (if less_eq_int zero_inta i then false else true))
            then let
                   val xc =
                     (a, (as_singleton one_nat xb,
                           (as_singleton one_nat zero_nata,
                             (rbt_insert A_ xb (int_of_nat zero_nata) b,
                               (if is_Nil (gi_E g xb) then as_empty zero_nat ()
                                 else as_singleton one_nat
(zero_nata, gi_E g xb))))));
                   val (aa, (_, (_, (ad, _)))) =
                     whilea
                       (fn (_, xh) =>
                         not (as_is_empty let
    val (xi, (_, (_, _))) = xh;
  in
    xi
  end))
                       (fn (aa, ba) =>
                         (case select_edge_tr (linorder_compare_order A_) ba
                           of (NONE, bb) =>
                             let
                               val xf =
                                 last_seg_tr (linorder_compare_order A_) bb;
                               val xg = pop_tr A_ bb;
                               val xh = xf :: aa;
                             in
                               (xh, xg)
                             end
                           | (SOME xf, bb) =>
                             (if (case rbt_lookup
 (less ((ord_preorder o preorder_order o order_linorder o
          linorder_compare_order)
         A_))
 let
   val (_, (_, (xn, _))) = bb;
 in
   xn
 end
 xf
                                   of NONE => false
                                   | SOME i =>
                                     (if less_eq_int zero_inta i then true
                                       else false))
                               then let
                                      val ab =
collapse_tr (linorder_compare_order A_) xf bb;
                                    in
                                      (aa, ab)
                                    end
                               else (if not
  (case rbt_lookup
          (less ((ord_preorder o preorder_order o order_linorder o
                   linorder_compare_order)
                  A_))
          let
            val (_, (_, (xn, _))) = bb;
          in
            xn
          end
          xf
    of NONE => false
    | SOME i => (if less_eq_int zero_inta i then false else true))
                                      then (aa, push_code A_ g xf bb)
                                      else (aa, bb)))))
                       xc;
                 in
                   (aa, ad)
                 end
            else (a, b)))
        xa;
    val (aa, _) = a;
    val _ = stat_stop ();
  in
    aa
  end;

fun scc_decomp (A1_, A2_, A3_, A4_, A5_) e =
  let
    val ee =
      set (ceq_prod A1_ A1_, ccompare_prod A2_ A2_, set_impl_prod A5_ A5_) e;
  in
    filtera
      (fn a =>
        (case a of [] => true
          | [v] => member (ceq_prod A1_ A1_, ccompare_prod A2_ A2_) (v, v) ee
          | _ :: _ :: _ => true))
      (compute_SCC_tr (compare_order_key A4_) (create_graph_impl (A3_, A4_) e))
  end;

fun check_acyclic (A1_, A2_, A3_, A4_, A5_, A6_) r =
  catch_errora
    (catch_errora
      (forallM
        (fn scc =>
          Inl (shows_prec_list show_char zero_nata [#"S", #"C", #"C", #" "] o
                 shows_prec_list A6_ zero_nata scc o
                shows_prec_list show_char zero_nata
                  [#" ", #"d", #"e", #"t", #"e", #"c", #"t", #"e", #"d", #" "]))
        (scc_decomp (A1_, A2_, A3_, A4_, A5_) r))
      (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"\n", #"g", #"r", #"a", #"p", #"h", #" "] o
             shows_prec_list (show_prod A6_ A6_) zero_nata r o
             shows_prec_list show_char zero_nata
               [#" ", #"n", #"o", #"t", #" ", #"a", #"c", #"y", #"c", #"l",
                 #"i", #"c", #"\n"] o
            x));

fun get_conjunctions (Conjunction phis) = maps get_conjunctions phis
  | get_conjunctions (Atom v) = [Atom v]
  | get_conjunctions (NegAtom v) = [NegAtom v]
  | get_conjunctions (Disjunction v) = [Disjunction v];

fun get_disjunctions (Disjunction phis) = maps get_disjunctions phis
  | get_disjunctions (Atom v) = [Atom v]
  | get_disjunctions (NegAtom v) = [NegAtom v]
  | get_disjunctions (Conjunction v) = [Conjunction v];

fun pos_gctxt (A1_, A2_) B_ GCHole =
  inserta (ceq_pos, ccompare_pos) Empty
    (set_empty (ceq_pos, ccompare_pos) (of_phantom set_impl_posa))
  | pos_gctxt (A1_, A2_) B_ (GCFun (f, cs)) =
    sup_seta (ceq_pos, ccompare_pos)
      (inserta (ceq_pos, ccompare_pos) Empty
        (set_empty (ceq_pos, ccompare_pos) (of_phantom set_impl_posa)))
      (sup_setb
        (finite_UNIV_pos, cenum_pos, ceq_pos, cproper_interval_pos,
          set_impl_pos)
        (image
          (ceq_prod (ceq_gctxt A2_) ceq_nat,
            ccompare_prod (ccompare_gctxt A1_ B_) ccompare_nat)
          (ceq_set
             (cenum_pos, ceq_pos,
               ccompare_cproper_interval cproper_interval_pos),
            ccompare_set
              (finite_UNIV_pos, ceq_pos, cproper_interval_pos, set_impl_pos),
            set_impl_set)
          (fn (c, i) =>
            image (ceq_pos, ccompare_pos) (ceq_pos, ccompare_pos, set_impl_pos)
              (fn a => PCons (i, a)) (pos_gctxt (A1_, A2_) B_ c))
          (set (ceq_prod (ceq_gctxt A2_) ceq_nat,
                 ccompare_prod (ccompare_gctxt A1_ B_) ccompare_nat,
                 set_impl_prod set_impl_gctxt set_impl_nat)
            (zip cs (upt zero_nata (size_list cs))))));

fun inline B_ i rho =
  let
    val cs = snd rho;
    val (s, t) = nth cs i;
    val sigma = subst B_ (the_Var t) s;
    val csa = take i cs @ drop (suc i) cs;
  in
    ((fst (fst rho), subst_apply_term (snd (fst rho)) sigma),
      map (fn (sa, a) => (subst_apply_term sa sigma, a)) csa)
  end;

fun invariant (Art_Node (x1, x2, x3, x4)) = x2;

fun location (Art_Node (x1, x2, x3, x4)) = x3;

fun initial_nodesa (Art_impl_ext (initial_nodes, nodes, more)) = initial_nodes;

fun name (Art_Node (x1, x2, x3, x4)) = x1;

fun edgea (Art_Node (x1, x2, x3, x4)) = x4;

fun nodesb (Art_impl_ext (initial_nodes, nodes, more)) = nodes;

fun art_edge_of (E1_, E2_, E3_, E4_) pi (Cover_Edge (an, uu)) = Cover an
  | art_edge_of (E1_, E2_, E3_, E4_) pi (Children_Edge ans) =
    Children
      (map (fn (t, a) => let
                           val (aa, _) = a;
                         in
                           (transition_of (E1_, E2_, E3_, E4_) pi t, aa)
                         end)
        ans);

fun art_nodes ai = map name (nodesb ai);

fun art_of (E1_, E2_, E3_, E4_) (F1_, F2_, F3_, F4_) pi ai =
  let
    val ans = nodesb ai;
  in
    Art_ext
      (initial_nodesa ai, art_nodes ai,
        map_of_total (F1_, F2_, F3_)
          (fn a =>
            [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"l", #"o",
              #"o", #"k", #"i", #"n", #"g", #" ", #"u", #"p", #" ", #"a", #"r",
              #"t", #" ", #"e", #"d", #"g", #"e", #" "] @
              shows_prec F4_ zero_nata a [])
          (map (fn a => (name a, art_edge_of (E1_, E2_, E3_, E4_) pi (edgea a)))
            ans),
        map_of_total (F1_, F2_, F3_)
          (fn a =>
            [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"l", #"o",
              #"o", #"k", #"i", #"n", #"g", #" ", #"u", #"p", #" ", #"n", #"o",
              #"d", #"e", #" ", #"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n",
              #" "] @
              shows_prec F4_ zero_nata a [])
          (map (fn a => (name a, location a)) ans),
        map_of_total (F1_, F2_, F3_)
          (fn a =>
            [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"l", #"o",
              #"o", #"k", #"i", #"n", #"g", #" ", #"u", #"p", #" ", #"n", #"o",
              #"d", #"e", #" ", #"i", #"n", #"v", #"a", #"r", #"i", #"a", #"n",
              #"t", #" "] @
              shows_prec F4_ zero_nata a [])
          (map (fn a => (name a, invariant a)) ans),
        ())
  end;

fun check_dp_loop (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_) i dpp
  (DP_loop_prf (s, prseq, sigma, c)) =
  let
    val p = pairsb i dpp;
    val r = rulese i dpp;
    val nfs = nfsc i dpp;
    val q = qc i dpp;
  in
    (if equal_ctxta B2_ C4_ c Hole
      then bindb (check (not (null prseq))
                   (shows_prec_list show_char zero_nata
                     [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s",
                       #"e", #"q", #"u", #"e", #"n", #"c", #"e", #" ", #"m",
                       #"u", #"s", #"t", #" ", #"b", #"e", #" ", #"n", #"o",
                       #"n", #"-", #"e", #"m", #"p", #"t", #"y"]))
             (fn _ =>
               (if null q
                 then check_qsteps (B2_, B3_) (C2_, C4_, C5_, C7_)
                        (fn _ => true) nfs p r prseq s
                        (subst_apply_term s (mk_subst C4_ Var sigma))
                 else check_qsteps_subst (B2_, B3_) (C2_, C4_, C5_, C7_)
                        (check_NF_iteration (C1_, C2_, C3_, C4_, C6_) (B1_, B2_)
                          sigma q)
                        nfs p r prseq s
                        (subst_apply_term s (mk_subst C4_ Var sigma))))
      else check_loop (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_) q nfs
             s (map (fn (x, (y, (_, z))) => (x, (y, z))) prseq) sigma c r)
  end;

fun check_rel_seq (A1_, A2_) (B1_, B2_, B3_, B4_) r sa [] s u true =
  check (equal_terma A1_ B2_ s u)
    (shows_string
       [#"t", #"h", #"e", #" ", #"l", #"a", #"s", #"t", #" ", #"t", #"e", #"r",
         #"m", #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ", #"r", #"e", #"w",
         #"r", #"i", #"t", #"e", #" ", #"s", #"e", #"q", #"u", #"e", #"n", #"c",
         #"e"] o
      (shows_nl o
        (shows_prec_term A2_ B4_ zero_nata s o
          (shows_string
             (shows_nl
               [#"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"c",
                 #"o", #"r", #"r", #"e", #"s", #"p", #"o", #"n", #"d", #" ",
                 #"t", #"o", #" ", #"t", #"h", #"e", #" ", #"g", #"o", #"a",
                 #"l", #" ", #"t", #"e", #"r", #"m"]) o
            (shows_nl o (shows_prec_term A2_ B4_ zero_nata u o shows_nl))))))
  | check_rel_seq (A1_, A2_) (B1_, B2_, B3_, B4_) r sa [] s u false =
    Inl (shows_prec_list show_char zero_nata
          [#"d", #"i", #"d", #" ", #"n", #"o", #"t", #" ", #"f", #"i", #"n",
            #"d", #" ", #"s", #"t", #"r", #"i", #"c", #"t", #" ", #"s", #"t",
            #"e", #"p", #" ", #"i", #"n", #" ", #"r", #"e", #"w", #"r", #"i",
            #"t", #"e", #" ", #"s", #"e", #"q", #"u", #"e", #"n", #"c", #"e"])
  | check_rel_seq (A1_, A2_) (B1_, B2_, B3_, B4_) ra sa
    ((p, (r, (true, t))) :: prts) s u b =
    bindb (check_qrstep (A1_, A2_) (B1_, B2_, B3_, B4_) (fn _ => true) false ra
            p r s t)
      (fn _ =>
        check_rel_seq (A1_, A2_) (B1_, B2_, B3_, B4_) ra sa prts t u true)
  | check_rel_seq (A1_, A2_) (B1_, B2_, B3_, B4_) ra sa
    ((p, (r, (false, t))) :: prts) s u b =
    bindb (check_qrstep (A1_, A2_) (B1_, B2_, B3_, B4_) (fn _ => true) false sa
            p r s t)
      (fn _ => check_rel_seq (A1_, A2_) (B1_, B2_, B3_, B4_) ra sa prts t u b);

fun pat_dv_impl A_ B_ p =
  let
    val (_, (sigma, mu)) = p;
  in
    remdups B_
      (map fst (mk_subst_domain B_ A_ sigma @ mk_subst_domain B_ A_ mu))
  end;

fun shows_exp A_ B_ (f, c) =
  shows_prec A_ zero_nata f o
    (shows_prec_list show_char zero_nata [#"n", #"+", #" "] o
      shows_prec B_ zero_nata c);

fun shows_p A_ B_ C_ D_ E_ (b, ((f, (c, m)), a)) =
  shows_prec A_ zero_nata b o
    (shows_prec D_ zero_nata m o
      (shows_prec_list show_char zero_nata [#" ", #"^", #" ", #"("] o
        (shows_exp B_ C_ (f, c) o
          (shows_prec_list show_char zero_nata [#")"] o
            shows_prec E_ zero_nata a))));

fun set_option (A1_, A2_, A3_) NONE = bot_set (A1_, A2_, A3_)
  | set_option (A1_, A2_, A3_) (SOME x2) =
    inserta (A1_, A2_) x2 (bot_set (A1_, A2_, A3_));

fun equal_complexity_class (Comp_Poly x) (Comp_Poly ya) = equal_nata x ya;

val default_nfs_nt_trs : bool = false;

fun string_reversal_complete_rel_tt B_ C_ i tp =
  bindb (check (q_emptyb i tp)
          (shows_prec_list show_char zero_nata
            [#"Q", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"e", #"m",
              #"p", #"t", #"y"]))
    (fn _ =>
      bindb (check_unary_signature B_ C_ (rulesd i tp))
        (fn _ =>
          Inr (mkc i default_nfs_nt_trs [] (map rev_rule (rc i tp))
                (map rev_rule (rwc i tp)))));

fun check_to_srs_complete (A1_, A2_) (B1_, B2_) v old_new r s =
  let
    val mu = funas_trs_list r;
    val (d, (da, nu)) = extract_components B1_ mu old_new;
  in
    bindb (check_components (B1_, B2_) mu (d, (da, nu)))
      (fn _ =>
        bindb (check_varcond_subset B2_ (A1_, A2_) s)
          (fn _ =>
            catch_errora
              (forallM
                (fn slr =>
                  let
                    val y = choose_var v (fst slr);
                    val stra = str d y;
                    val to_slr = (fn (l, ra) => (stra l, stra ra));
                  in
                    check (list_ex
                            (fn lr =>
                              equal_proda (equal_term B1_ A1_)
                                (equal_term B1_ A1_) (to_slr lr) slr)
                            r)
                      (shows_prec_list show_char zero_nata
                         [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                           #" ", #"f", #"i", #"n", #"d", #" ", #"o", #"r", #"i",
                           #"g", #"i", #"n", #"a", #"l", #" ", #"r", #"u", #"l",
                           #"e", #" ", #"f", #"o", #"r", #" "] o
                        shows_rule (shows_prec B2_ zero_nata)
                          (shows_prec A2_ zero_nata) [#" ", #"-", #">", #" "]
                          slr)
                  end)
                s)
              (fn x => Inl (snd x))))
  end;

fun const_to_string_complete_tt (B1_, B2_) (C1_, C2_) i tp
  (Const_string_complete_proof (v, old_new, s)) =
  bindb (check (q_emptyb i tp)
          (shows_prec_list show_char zero_nata
            [#"Q", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"e", #"m",
              #"p", #"t", #"y"]))
    (fn _ =>
      bindb (check_to_srs_complete (C1_, C2_) (B1_, B2_) v old_new (rulesd i tp)
              s)
        (fn _ => Inr (mkc i false [] s [])));

fun check_NF_trs_subset (A1_, A2_) (B1_, B2_, B3_) r =
  check_NF_terms_subset (is_NF_trs (A1_, A2_) (B1_, B2_, B3_) r);

fun switch_termination_proc (B1_, B2_, B3_) i joins_i dpp =
  let
    val p = pairsb i dpp;
    val r = rulese i dpp;
    val q = qc i dpp;
  in
    (case let
            val cp = critical_pairs_impl B1_ r r;
          in
            bindb (catch_errora
                    (forallM
                      (fn (b, _) =>
                        check b
                          (shows_prec_list show_char zero_nata
                            [#"r", #"u", #"l", #"e", #"s", #" ", #"a", #"r",
                              #"e", #" ", #"n", #"o", #"t", #" ", #"o", #"v",
                              #"e", #"r", #"l", #"a", #"y"]))
                      cp)
                    (fn x => Inl (snd x)))
              (fn _ =>
                bindb (check_wf_trs B3_
                        (equal_list equal_char, show_list show_char) r)
                  (fn _ =>
                    bindb (check_critical_pairs (B1_, B3_) r cp joins_i)
                      (fn _ =>
                        bindb (check (null (critical_pairs_impl B1_ p r))
                                (shows_prec_list show_char zero_nata
                                  [#"t", #"h", #"e", #"r", #"e", #" ", #"a",
                                    #"r", #"e", #" ", #"o", #"v", #"e", #"r",
                                    #"l", #"a", #"p", #"s", #" ", #"b", #"e",
                                    #"t", #"w", #"e", #"e", #"n", #" ", #"P",
                                    #" ", #"a", #"n", #"d", #" ", #"R"]))
                          (fn _ =>
                            catch_errora
                              (check_NF_trs_subset (B1_, B2_)
                                (ccompare_list ccompare_char,
                                  equal_list equal_char, mapping_impl_list)
                                r q)
                              (fn x =>
                                Inl (shows_prec_term B3_ (show_list show_char)
                                       zero_nata x o
                                      shows_prec_list show_char zero_nata
[#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"i", #"n", #" ", #"n", #"o",
  #"r", #"m", #"a", #"l", #" ", #"f", #"o", #"r", #"m", #" ", #"w", #".", #"r",
  #".", #"t", #".", #" ", #"R"]))))))
          end
      of Inl a => Inl a | Inr _ => Inr (mkd i (nfsc i dpp) false p [] [] [] r))
  end;

fun check_instance (A1_, A2_) (B1_, B2_, B3_, B4_) pa p =
  catch_errora
    (forallM
      (fn st =>
        check (list_ex (instance_rule A1_ B2_ (B1_, B2_, B3_) st) pa)
          (shows_rule (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
             [#" ", #"-", #">", #" "] st o
            shows_prec_list show_char zero_nata
              [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"n", #" ",
                #"i", #"n", #"s", #"t", #"a", #"n", #"c", #"e", #" ", #"o",
                #"f", #" ", #"a", #"n", #"y", #" ", #"o", #"r", #"i", #"g",
                #"i", #"n", #"a", #"l", #" ", #"p", #"a", #"i", #"r"]))
      p)
    (fn x => Inl (snd x));

fun instantiation_complete_proc (B1_, B2_) (C1_, C2_, C3_, C4_) i dpp
  (Instantiation_complete_proc_prf p) =
  let
    val pa = pairsb i dpp;
    val q = qc i dpp;
    val r = rulese i dpp;
    val nfs = nfsc i dpp;
  in
    bindb (check (not nfs orelse null q)
            (shows_prec_list show_char zero_nata
              [#"n", #"o", #"r", #"m", #"a", #"l", #" ", #"f", #"o", #"r", #"m",
                #" ", #"s", #"u", #"b", #"s", #"t", #".", #" ", #"c", #"u",
                #"r", #"r", #"e", #"n", #"t", #"l", #"y", #" ", #"n", #"o",
                #"t", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e",
                #"d", #" ", #"f", #"o", #"r", #" ", #"i", #"n", #"n", #"e",
                #"r", #"m", #"o", #"s", #"t"]))
      (fn _ =>
        bindb (check_instance (B1_, B2_) (C1_, C2_, C3_, C4_) pa p)
          (fn _ => Inr (mkd i nfs false p [] q [] r)))
  end;

fun rule_removal_nonterm_dp (B1_, B2_) (C1_, C2_) i dpp
  (Rule_removal_nonterm_dp_prf (p, r)) =
  let
    val prm =
      (if is_none p then []
        else ceta_list_diff (key_prod (key_term B1_ C1_) (key_term B1_ C1_))
               (pairsb i dpp) (the p));
    val rrm =
      (if is_none r then []
        else ceta_list_diff (key_prod (key_term B1_ C1_) (key_term B1_ C1_))
               (rulese i dpp) (the r));
  in
    Inr (delete_R_Rwc i (delete_P_Pwa i dpp prm prm) rrm rrm)
  end;

fun mk_rel_tp i (nfs, (q, (r, rw))) = mkc i nfs q r rw;

fun mk_dppa i (nfs, (m, (p, (pw, (q, (r, rw)))))) = mkd i nfs m p pw q r rw;

fun mk_tpa i (nfs, (q, r)) = mkc i nfs q r [];

fun check_assmb (B1_, B2_) (C1_, C2_) i j tp_check dp_check rtp_check fptp_check
  unk_check (Not_SN_assm_proof (t, prf)) = tp_check (mk_tpa i t) prf
  | check_assmb (B1_, B2_) (C1_, C2_) i j tp_check dp_check rtp_check fptp_check
    unk_check (Not_RelSN_assm_proof (t, prf)) = rtp_check (mk_rel_tp i t) prf
  | check_assmb (B1_, B2_) (C1_, C2_) i j tp_check dp_check rtp_check fptp_check
    unk_check (Infinite_assm_proof (t, prf)) = dp_check (mk_dppa j t) prf
  | check_assmb (B1_, B2_) (C1_, C2_) i j tp_check dp_check rtp_check fptp_check
    unk_check (Not_SN_FP_assm_proof (t, prf)) = fptp_check t prf
  | check_assmb (B1_, B2_) (C1_, C2_) i j tp_check dp_check rtp_check fptp_check
    unk_check (Unknown_assm_proof (t, prf)) = unk_check t prf
  | check_assmb (B1_, B2_) (C1_, C2_) i j uu uv uw ux uy (SN_assm_proof (v, va))
    = Inl (shows_prec_list show_char zero_nata
            [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
              #"f", #"o", #"r", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
              #"t", #"i", #"o", #"n", #" ", #"a", #"s", #"s", #"u", #"m", #"p",
              #"t", #"i", #"o", #"n", #"s", #" ", #"i", #"n", #" ", #"n", #"o",
              #"n", #"-", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
              #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"])
  | check_assmb (B1_, B2_) (C1_, C2_) i j uu uv uw ux uy
    (Finite_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
            #"t", #"i", #"o", #"n", #" ", #"a", #"s", #"s", #"u", #"m", #"p",
            #"t", #"i", #"o", #"n", #"s", #" ", #"i", #"n", #" ", #"n", #"o",
            #"n", #"-", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
            #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"])
  | check_assmb (B1_, B2_) (C1_, C2_) i j uu uv uw ux uy
    (SN_FP_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
            #"t", #"i", #"o", #"n", #" ", #"a", #"s", #"s", #"u", #"m", #"p",
            #"t", #"i", #"o", #"n", #"s", #" ", #"i", #"n", #" ", #"n", #"o",
            #"n", #"-", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
            #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"])
  | check_assmb (B1_, B2_) (C1_, C2_) i j uu uv uw ux uy
    (Complexity_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
            #"t", #"i", #"o", #"n", #" ", #"a", #"s", #"s", #"u", #"m", #"p",
            #"t", #"i", #"o", #"n", #"s", #" ", #"i", #"n", #" ", #"n", #"o",
            #"n", #"-", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
            #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"]);

fun q_increase_nonterm_dp B_ C_ i dpp (Q_increase_nonterm_dp_prf q) =
  let
    val p = pairsb i dpp;
    val r = rulese i dpp;
    val qa = qc i dpp;
    val nfs = nfsc i dpp;
  in
    Inr (mkd i nfs false p [] (list_union (equal_term B_ C_) qa q) [] r)
  end;

fun dp_q_reduction_nonterm (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
  (C1_, C2_, C3_, C4_) i dpp (DP_q_reduction_nonterm_prf q) =
  let
    val p = pairsb i dpp;
    val r = rulese i dpp;
    val qa = qc i dpp;
    val nfs = nfsc i dpp;
    val f =
      set (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat,
            set_impl_prod B6_ set_impl_nat)
        (funas_trs_list (p @ r));
    val rQ =
      filtera
        (fn qb =>
          less_eq_set
            (cenum_prod B1_ cenum_nat, ceq_prod B2_ ceq_nat,
              ccompare_prod B3_ ccompare_nat)
            (funas_term (B2_, B3_, B6_) qb) f)
        qa;
  in
    bindb (catch_errora
            (check_NF_terms_subset (is_NF_terms (B4_, B5_) (C1_, C2_, C3_) q)
              rQ)
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #" "] o
                    (shows_prec_term B7_ C4_ zero_nata x o
                      shows_prec_list show_char zero_nata
                        [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i",
                          #"n", #"g", #" ", #"i", #"n", #" ", #"Q", #"'",
                          #" "]))))
      (fn _ => Inr (mkd i nfs false p [] q [] r))
  end;

fun check_dpp_subsumesa (B1_, B2_, B3_) (C1_, C2_, C3_) j dp dpp =
  let
    val (nfsa, (_, (p, (pw, (q, (r, rw)))))) = dp;
    val pairsa = p @ pw;
    val rulesa = r @ rw;
    val nfs = nfsc j dpp;
    val pairs = pairsb j dpp;
    val rules = rulese j dpp;
    val qa = qc j dpp;
  in
    catch_errora
      (bindb
        (check (if not (null q) then (if nfs then nfsa else true) else true)
          (shows_prec_list show_char zero_nata
            [#"i", #"n", #"c", #"o", #"m", #"p", #"a", #"t", #"i", #"b", #"l",
              #"e", #" ", #"s", #"u", #"b", #"s", #"t", #"i", #"t", #"u", #"t",
              #"i", #"o", #"n", #"s", #"-", #"i", #"n", #"-", #"n", #"o", #"r",
              #"m", #"a", #"l", #"-", #"f", #"o", #"r", #"m", #" ", #"f", #"l",
              #"a", #"g", #"s"]))
        (fn _ =>
          bindb (catch_errora
                  (check_subseteq
                    (equal_prod
                      (equal_term (equal_lab B1_ C1_) (equal_list equal_char))
                      (equal_term (equal_lab B1_ C1_) (equal_list equal_char)))
                    pairsa pairs)
                  (fn x =>
                    Inl (toomuch [#"p", #"a", #"i", #"r"]
                          (shows_rule (shows_prec_lab B3_ C3_ zero_nata)
                            (shows_prec_list show_char zero_nata)
                            [#" ", #"-", #">", #" "] x))))
            (fn _ =>
              bindb (catch_errora
                      (check_subseteq
                        (equal_prod
                          (equal_term (equal_lab B1_ C1_)
                            (equal_list equal_char))
                          (equal_term (equal_lab B1_ C1_)
                            (equal_list equal_char)))
                        rulesa rules)
                      (fn x =>
                        Inl (toomuch [#"r", #"u", #"l", #"e"]
                              (shows_rule (shows_prec_lab B3_ C3_ zero_nata)
                                (shows_prec_list show_char zero_nata)
                                [#" ", #"-", #">", #" "] x))))
                (fn _ =>
                  catch_errora
                    (check_NF_terms_subset
                      (is_NF_terms (equal_lab B1_ C1_, key_lab B2_ C2_)
                        (ccompare_list ccompare_char, equal_list equal_char,
                          mapping_impl_list)
                        q)
                      qa)
                    (fn x =>
                      Inl (shows_prec_list show_char zero_nata
                             [#"N", #"F", #"(", #"Q", #")", #" ", #"d", #"i",
                               #"f", #"f", #"e", #"r", #"s", #" ", #"d", #"u",
                               #"e", #" ", #"t", #"o", #" ", #"t", #"e", #"r",
                               #"m", #" "] o
                            shows_term (shows_prec_lab B3_ C3_ zero_nata)
                              (shows_prec_list show_char zero_nata) x))))))
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"s",
                 #" ", #"s", #"h", #"o", #"w", #"i", #"n", #"g", #" ", #"s",
                 #"u", #"b", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n",
                 #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"t",
                 #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n"] o
              (shows_nl o x)))
  end;

fun enfc_cand A_ isQnf r q (uu, Var uv) = []
  | enfc_cand A_ isQnf r q (s, Fun (f, ts)) =
    map (fn a => (s, a)) ts @
      maps (fn (l, ra) =>
             (if (case mgu_class A_ (Fun (f, map (icap_impl A_ isQnf r s) ts)) l
                   of NONE => false
                   | SOME mu =>
                     list_all
                       (fn u =>
                         isQnf (subst_apply_term
                                 (map_term (fn x => x) (fn a => #"y" :: a) u)
                                 mu))
                       (args l) andalso
                       list_all
                         (fn u =>
                           isQnf (subst_apply_term
                                   (map_term (fn x => x) (fn a => #"x" :: a) u)
                                   mu))
                         s)
               then [(args l, ra)] else []))
        r;

fun enfc_impl A_ isQnf isRnf r q s t =
  list_all (fn (a, b) => enfc_q A_ isQnf isRnf r q a b)
    (mk_rtrancl_list
      (equal_proda (equal_list (equal_term A_ (equal_list equal_char)))
        (equal_term A_ (equal_list equal_char)))
      (enfc_cand A_ isQnf r q) [(s, t)]);

fun check_nfc (A1_, A2_, A3_) inn r q isQnf ss nfs t =
  bindb (check_wf_trs A3_ (equal_list equal_char, show_list show_char) r)
    (fn _ =>
      (if inn then Inr ()
        else catch_errora
               (forallM
                 (fn ta =>
                   check (enfc_impl A1_ isQnf
                           (is_NF_trs (A1_, A2_)
                             (ccompare_list ccompare_char,
                               equal_list equal_char, mapping_impl_list)
                             r)
                           r q ss ta)
                     (shows_prec_list show_char zero_nata
                        [#" ", #"n", #"f", #"c", #" ", #"n", #"o", #"t", #" ",
                          #"s", #"a", #"t", #"i", #"s", #"f", #"i", #"e", #"d",
                          #" ", #"f", #"o", #"r", #" "] o
                       shows_prec_term A3_ (show_list show_char) zero_nata ta))
                 (supteq_list t))
               (fn x => Inl (snd x))));

fun rewriting_complete_proc (B1_, B2_, B3_) i
  (Rewriting_complete_proc_prf (u_opt, stb, sta, st, lr, p)) dpp =
  (case catch_errora
          let
            val s = fst stb;
            val t = snd stb;
            val ta = snd sta;
            val r = rulese i dpp;
          in
            bindb (check_rstep (B1_, B3_)
                    (ccompare_list ccompare_char, equal_list equal_char,
                      mapping_impl_list, show_list show_char)
                    r p lr t ta)
              (fn _ =>
                bindb (check (nFQ_subset_NF_rulesc i dpp)
                        (shows_prec_list show_char zero_nata
                          [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t",
                            #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"i",
                            #"n", #"g", #" ", #"r", #"e", #"q", #"u", #"i",
                            #"r", #"e", #"d"]))
                  (fn _ =>
                    bindb (check_rewrite_common_preconditions (B1_, B2_, B3_) i
                            u_opt stb (args s) (args (subt_at t p)) ta lr p
                            false dpp)
                      (fn _ =>
                        bindb (check (not (is_Var s))
                                (shows_prec_list show_char zero_nata
                                  [#"l", #"h", #"s", #" ", #"o", #"f", #" ",
                                    #"p", #"a", #"i", #"r", #" ", #"m", #"u",
                                    #"s", #"t", #" ", #"n", #"o", #"t", #" ",
                                    #"b", #"e", #" ", #"v", #"a", #"r", #"i",
                                    #"a", #"b", #"l", #"e"]))
                          (fn _ =>
                            bindb (check
                                    (eq_rule_mod_vars B1_
                                      (ccompare_list ccompare_char,
equal_list equal_char, mapping_impl_list)
                                      sta st)
                                    (shows_prec_list show_char zero_nata
                                       [#"t", #"h", #"e", #" ", #"r", #"u",
 #"l", #"e", #" "] o
                                      (shows_rule (shows_prec B3_ zero_nata)
 (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] sta o
(shows_prec_list show_char zero_nata
   [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"r", #"e",
     #"n", #"a", #"m", #"e", #"d", #" ", #"v", #"a", #"r", #"i", #"a", #"n",
     #"t", #" ", #"o", #"f", #" "] o
  shows_rule (shows_prec B3_ zero_nata) (shows_prec_list show_char zero_nata)
    [#" ", #"-", #">", #" "] st))))
                              (fn _ =>
                                bindb (check
(equal_terma B1_ (equal_list equal_char) s (fst sta))
(shows_prec_list show_char zero_nata
  [#"l", #"e", #"f", #"t", #"-", #"h", #"a", #"n", #"d", #" ", #"s", #"i", #"d",
    #"e", #"s", #" ", #"o", #"f", #" ", #"o", #"l", #"d", #" ", #"a", #"n",
    #"d", #" ", #"n", #"e", #"w", #" ", #"p", #"a", #"i", #"r", #" ", #"d",
    #"i", #"f", #"f", #"e", #"r"]))
                                  (fn _ =>
                                    let
                                      val q = qc i dpp;
                                      val inn =
isOK (check_NF_trs_subset (B1_, B2_)
       (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list) r
       q);
                                    in
                                      bindb
(check_nfc (B1_, B2_, B3_) inn r q (is_QNFc i dpp) (args s) (nfsc i dpp)
  (subt_at t p))
(fn _ =>
  bindb (catch_errora
          (forallM
            (fn (l, _) =>
              check (not (is_Var l))
                (shows_prec_list show_char zero_nata
                  [#"l", #"h", #"s", #"s", #" ", #"m", #"u", #"s", #"t", #" ",
                    #"n", #"o", #"t", #" ", #"b", #"e", #" ", #"v", #"a", #"r",
                    #"i", #"a", #"b", #"l", #"e", #"s"]))
            r)
          (fn x => Inl (snd x)))
    (fn _ =>
      (if not (is_Var t)
        then check (not (not (null (rules_mapc i dpp (the (root t))))))
               (shows_prec_list show_char zero_nata
                  [#"r", #"o", #"o", #"t", #" ", #"o", #"f", #" "] o
                 (shows_prec_term B3_ (show_list show_char) zero_nata t o
                   shows_prec_list show_char zero_nata
                     [#" ", #"m", #"u", #"s", #"t", #" ", #"n", #"o", #"t",
                       #" ", #"b", #"e", #" ", #"d", #"e", #"f", #"i", #"n",
                       #"e", #"d"]))
        else Inr ())))
                                    end))))))
          end
          (fn x =>
            Inl (shows_string
                   [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e", #"n",
                     #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"i", #"n", #"g",
                     #" ", #"t", #"h", #"e", #" ", #"p", #"a", #"i", #"r",
                     #" "] o
                  (shows_nl o
                    (shows_rule (shows_prec B3_ zero_nata)
                       (shows_prec_list show_char zero_nata)
                       [#" ", #"-", #">", #" "] stb o
                      (shows_nl o
                        (shows_string
                           [#" ", #"t", #"o", #" ", #"t", #"h", #"e", #" ",
                             #"p", #"a", #"i", #"r", #" "] o
                          (shows_nl o
                            (shows_rule (shows_prec B3_ zero_nata)
                               (shows_prec_list show_char zero_nata)
                               [#" ", #"-", #">", #" "] st o
                              (shows_nl o x)))))))))
    of Inl a => Inl a | Inr _ => Inr (replace_paira i dpp stb [st]));

fun less_eq_pos (PCons (i, q1)) (PCons (j, q2)) =
  equal_nata i j andalso less_eq_pos q1 q2
  | less_eq_pos (PCons (i, q1)) Empty = false
  | less_eq_pos Empty p = true;

fun rstep_enum_impl A_ (B1_, B2_, B3_) r ta t p =
  concat
    (map_filter
      (fn x =>
        (if less_eq_pos p x
          then SOME let
                      val tp = subt_at ta x;
                    in
                      (if membera equal_pos (poss_list t) x
                        then (if equal_ctxta A_ B2_ (ctxt_of_pos_term x ta)
                                   (ctxt_of_pos_term x t)
                               then maps (fn tpa =>
   maps (fn (l, ra) =>
          map (fn mu => ((l, ra), (mu, x)))
            (option_to_list
              (match_list (B1_, B2_, B3_) A_ B2_ Var [(l, tp), (ra, tpa)])))
     r)
                                      [subt_at t x]
                               else [])
                        else [])
                    end
          else NONE))
      (poss_list ta));

fun narrow_enum_impl A_ (B1_, B2_, B3_) r sta st p =
  let
    val (s, t) = sta;
    val (sa, ta) = st;
  in
    maps (fn mu =>
           maps (fn (lr, (tau, q)) => [(mu, (lr, (q, tau)))])
             (rstep_enum_impl A_ (B1_, B2_, B3_) r (subst_apply_term t mu) ta
               p))
      (option_to_list (match A_ (B1_, B2_, B3_) sa s))
  end;

fun check_narrow (B1_, B2_, B3_) inn i dpp r q nfs sta st quad =
  let
    val ((_, t), ((s, ta), (mu, (lr, (p, _))))) = (sta, (st, quad));
  in
    bindb (check_nfc (B1_, B2_, B3_) inn r q (is_QNFc i dpp) (args s) nfs
            (subt_at (subst_apply_term t mu) p))
      (fn _ =>
        check_rewrite_common_preconditions (B1_, B2_, B3_) i NONE
          (s, subst_apply_term t mu) (args s)
          (args (subt_at (subst_apply_term t mu) p)) ta lr p false dpp)
  end;

fun narrowing_complete_proc (B1_, B2_, B3_) i
  (Narrowing_complete_proc_prf (st, p, sts)) dpp =
  (case catch_errora
          let
            val (s, t) = st;
            val q = qc i dpp;
            val nfs = nfsc i dpp;
            val rules = rulese i dpp;
            val check_ndef =
              check_no_defined_root B3_ (show_list show_char)
                (fn fna => not (null (rules_mapc i dpp fna)));
            val inn =
              isOK (check_NF_trs_subset (B1_, B2_)
                     (ccompare_list ccompare_char, equal_list equal_char,
                       mapping_impl_list)
                     rules q);
            val cnarrow = check_narrow (B1_, B2_, B3_) inn i dpp rules q nfs st;
          in
            bindb (check (null q orelse nFQ_subset_NF_rulesc i dpp)
                    (shows_prec_list show_char zero_nata
                      [#"f", #"u", #"l", #"l", #" ", #"o", #"r", #" ", #"i",
                        #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ",
                        #"r", #"e", #"w", #"r", #"i", #"t", #"i", #"n", #"g",
                        #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]))
              (fn _ =>
                bindb (if null q then Inr ()
                        else bindb (check_no_var B3_ (show_list show_char) s)
                               (fn _ =>
                                 bindb (check_no_var B3_ (show_list show_char)
 t)
                                   (fn _ =>
                                     bindb (check_ndef t)
                                       (fn _ =>
 (if nfs
   then bindb (catch_errora
                (forallM (fn (l, _) => check_no_var B3_ (show_list show_char) l)
                  rules)
                (fn x => Inl (snd x)))
          (fn _ =>
            check (wf_rule (equal_list equal_char) (s, t))
              (shows_rule (shows_prec B3_ zero_nata)
                 (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "]
                 (s, t) o
                shows_prec_list show_char zero_nata
                  [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"w", #"e",
                    #"l", #"l", #" ", #"f", #"o", #"r", #"m", #"e", #"d"]))
   else Inr ())))))
                  (fn _ =>
                    catch_errora
                      (forallM
                        (fn sta =>
                          let
                            val quads =
                              narrow_enum_impl B1_
                                (ccompare_list ccompare_char,
                                  equal_list equal_char, mapping_impl_list)
                                rules st sta p;
                          in
                            catch_errora
                              (existsM
                                (fn quad =>
                                  catch_errora
                                    (check (null q)
                                      (shows_prec_list show_char zero_nata
[#"q", #" ", #"n", #"o", #"t", #" ", #"e", #"m", #"p", #"t", #"y"]))
                                    (fn _ => cnarrow sta quad))
                                quads)
                              (fn x =>
                                Inl (shows_rule (shows_prec B3_ zero_nata)
                                       (shows_prec_list show_char zero_nata)
                                       [#" ", #"-", #">", #" "] sta o
                                      (shows_prec_list show_char zero_nata
 (case quads
   of [] =>
     [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"s", #"e",
       #"e", #"m", #" ", #"t", #"o", #" ", #"b", #"e", #" ", #"n", #"a", #"r",
       #"r", #"o", #"w", #"e", #"d", #" ", #"p", #"a", #"i", #"r"]
   | _ :: _ =>
     [#" ", #"v", #"i", #"o", #"l", #"a", #"t", #"e", #"s", #" ", #"s", #"i",
       #"d", #"e", #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
       #"s", #" ", #"f", #"o", #"r", #" ", #"c", #"o", #"m", #"p", #"l", #"e",
       #"t", #"e", #"n", #"e", #"s", #"s"]) o
shows_list_gen id [] [] [] [] x)))
                          end)
                        sts)
                      (fn x => Inl (snd x))))
          end
          (fn x =>
            Inl (shows_string
                   [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e", #"n",
                     #" ", #"n", #"a", #"r", #"r", #"o", #"w", #"i", #"n", #"g",
                     #" "] o
                  (shows_nl o
                    (shows_rule (shows_prec B3_ zero_nata)
                       (shows_prec_list show_char zero_nata)
                       [#" ", #"-", #">", #" "] st o
                      (shows_nl o
                        (shows_string
                           [#" ", #"t", #"o", #" ", #"t", #"h", #"e", #" ",
                             #"p", #"a", #"i", #"r", #"s", #" "] o
                          (shows_nl o
                            (shows_trs (shows_prec B3_ zero_nata)
                               (shows_prec_list show_char zero_nata)
                               [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                                 #"s", #"y", #"s", #"t", #"e", #"m", #":"]
                               [#" ", #"-", #">", #" "] sts o
                              (shows_nl o x)))))))))
    of Inl a => Inl a | Inr _ => Inr (replace_paira i dpp st sts));

fun is_inverse_renaming_impl A_ B_ sigma =
  let
    val a = mk_subst_domain A_ B_ sigma;
  in
    map (fn (x, y) => (the_Var y, Var x)) a
  end;

fun vars_subst_impl A_ B_ sigma =
  let
    val sigmaa = mk_subst_domain A_ B_ sigma;
  in
    map fst sigmaa @ maps (vars_term_list o snd) sigmaa
  end;

fun vars_pat_term_impl A_ B_ p =
  let
    val (s, (sigma, mu)) = p;
  in
    remdups B_
      (vars_term_list s @
        vars_subst_impl B_ A_ sigma @ vars_subst_impl B_ A_ mu)
  end;

fun is_renaming_impl A_ B_ sigma =
  let
    val sigmaa = map snd (mk_subst_domain A_ B_ sigma);
  in
    list_all is_Var sigmaa andalso distinct (equal_term B_ A_) sigmaa
  end;

fun pat_dom_renaming_impl A_ B_ p rho =
  let
    val rhoa = mk_subst_domain B_ A_ rho;
    val xs = map Var (vars_pat_term_impl A_ B_ p);
  in
    is_renaming_impl B_ A_ rho andalso
      (list_all (membera B_ (pat_dv_impl A_ B_ p)) (map fst rhoa) andalso
        list_all (fn t => not (membera (equal_term A_ B_) xs t)) (map snd rhoa))
  end;

fun check_pat_eqv_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
  (Pat_Irrelevant (sigmaa, mua)) (t, (sigma, mu)) =
  let
    val w = w_impl B5_ (mk_subst_domain B5_ A2_ sigma) t;
    val siga = mk_subst B5_ Var sigma;
    val sigaa = mk_subst B5_ Var sigmaa;
    val mub = mk_subst B5_ Var mu;
    val muba = mk_subst B5_ Var mua;
  in
    bindb (catch_errora
            (catch_errora
              (forallM
                (fn x =>
                  bindb (check (equal_terma A2_ B5_ (siga x) (sigaa x))
                          (x, (siga x,
                                (sigaa x,
                                  [#"p", #"u", #"m", #"p", #"i", #"n", #"g"]))))
                    (fn _ =>
                      check (equal_terma A2_ B5_ (mub x) (muba x))
                        (x, (mub x,
                              (muba x,
                                [#"c", #"l", #"o", #"s", #"i", #"n", #"g"])))))
                w)
              (fn x => Inl (snd x)))
            (fn x =>
              Inl let
                    val (xa, (tb, (ta, sub))) = x;
                  in
                    shows_string
                      [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ",
                        #"e", #"q", #"u", #"i", #"v", #"a", #"l", #"e", #"n",
                        #"c", #"e", #" ", #"(", #"i", #"r", #"r", #"e", #"l",
                        #"e", #"v", #"a", #"n", #"t", #")", #":", #" ", #"f",
                        #"o", #"r", #" ", #"v", #"a", #"r", #"i", #"a", #"b",
                        #"l", #"e", #" "] o
                      (shows_prec B7_ zero_nata xa o
                        (shows_string
                           [#" ", #"o", #"b", #"t", #"a", #"i", #"n", #" ",
                             #"d", #"i", #"f", #"f", #"e", #"r", #"e", #"n",
                             #"t", #" ", #"v", #"a", #"l", #"u", #"e", #"s",
                             #" ", #"f", #"o", #"r", #" "] o
                          (shows_prec_list show_char zero_nata sub o
                            (shows_string
                               [#" ", #"s", #"u", #"b", #"s", #"t", #"i", #"t",
                                 #"u", #"t", #"i", #"o", #"n", #":", #" "] o
                              (shows_prec_term A3_ B7_ zero_nata tb o
                                (shows_string [#" ", #"!", #"=", #" "] o
                                  shows_prec_term A3_ B7_ zero_nata ta))))))
                  end))
      (fn _ => Inr (t, (sigmaa, mua)))
  end
  | check_pat_eqv_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
    (Pat_Simplify (mu_1, mu_2)) (t, (sigma, mu)) =
    bindb (check
            (subst_eq (B1_, B2_, B3_, B4_, B5_, B6_) (A1_, A2_) mu
              (subst_compose_impl B5_ A2_ mu_1 mu_2))
            (shows_prec_list show_char zero_nata
              [#"m", #"u", #" ", #"!", #"=", #" ", #"m", #"u", #"1", #" ", #"m",
                #"u", #"2"]))
      (fn _ =>
        bindb (check
                (commutes_impl (B1_, B2_, B3_, B4_, B5_, B6_) (A1_, A2_) mu_1
                  sigma)
                (shows_prec_list show_char zero_nata
                  [#"s", #"i", #"g", #"m", #"a", #" ", #"a", #"n", #"d", #" ",
                    #"m", #"u", #"1", #" ", #"d", #"o", #" ", #"n", #"o", #"t",
                    #" ", #"c", #"o", #"m", #"m", #"u", #"t", #"e"]))
          (fn _ =>
            Inr (subst_apply_term t (mk_subst B5_ Var mu_1), (sigma, mu_2))))
  | check_pat_eqv_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
    (Pat_Dom_Renaming rho) (t, (sigma, mu)) =
    bindb (check (pat_dom_renaming_impl A2_ B5_ (t, (sigma, mu)) rho)
            (shows_prec_list show_char zero_nata
              [#"r", #"h", #"o", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                #"a", #" ", #"d", #"o", #"m", #"a", #"i", #"n", #" ", #"r",
                #"e", #"n", #"a", #"m", #"i", #"n", #"g", #" ", #"f", #"o",
                #"r", #" ", #"p"]))
      (fn _ =>
        let
          val i_rho = is_inverse_renaming_impl B5_ A2_ rho;
          val sigmaa =
            mk_subst_case B5_ A2_
              (map (the_Var o mk_subst B5_ Var rho)
                (map fst (mk_subst_domain B5_ A2_ sigma)))
              (fn x =>
                subst_apply_term
                  (subst_apply_term
                    (subst_apply_term (Var x) (mk_subst B5_ Var i_rho))
                    (mk_subst B5_ Var sigma))
                  (mk_subst B5_ Var rho))
              [];
          val mua =
            mk_subst_case B5_ A2_
              (map (the_Var o mk_subst B5_ Var rho)
                (map fst (mk_subst_domain B5_ A2_ mu)))
              (fn x =>
                subst_apply_term
                  (subst_apply_term (Var x) (mk_subst B5_ Var i_rho))
                  (mk_subst B5_ Var mu))
              i_rho;
        in
          Inr (subst_apply_term t (mk_subst B5_ Var rho), (sigmaa, mua))
        end);

fun subst_compose_impla A_ B_ sigma rho =
  map (fn (x, s) => (x, subst_apply_term s rho)) (mk_subst_domain A_ B_ sigma);

fun subst_replace_impl A_ sigma x t =
  (x, t) :: filtera (fn (y, _) => not (eq A_ y x)) sigma;

fun subst_power_impl A_ B_ sigma n =
  (if equal_nata n zero_nata then []
    else subst_compose_impl A_ B_ sigma
           (subst_power_impl A_ B_ sigma (minus_nata n one_nata)));

fun show_pat_term (A1_, A2_) (B1_, B2_) p =
  let
    val (s, (sigma, tau)) = p;
  in
    shows_prec_prod (show_term A2_ B2_)
      (show_prod (show_list (show_prod B2_ (show_term A2_ B2_)))
        (show_list (show_prod B2_ (show_term A2_ B2_))))
      zero_nata
      (s, (mk_subst_domain B1_ A1_ sigma, mk_subst_domain B1_ A1_ tau))
  end;

fun show_pat_rule (A1_, A2_) (B1_, B2_) pr =
  let
    val (p1, (p2, _)) = pr;
  in
    show_pat_term (A1_, A2_) (B1_, B2_) p1 o
      (shows_string [#" ", #"-", #"-", #">", #" "] o
        show_pat_term (A1_, A2_) (B1_, B2_) p2)
  end;

fun check_pat_rule_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
  ra p (Pat_OrigRule ((l, r), isPair)) =
  (if isPair
    then bindb (check
                 (membera (equal_prod (equal_term A2_ B5_) (equal_term A2_ B5_))
                   p (l, r))
                 (shows_rule (shows_prec A3_ zero_nata)
                    (shows_prec B8_ zero_nata) [#" ", #"-", #">", #" "] (l, r) o
                   shows_prec_list show_char zero_nata
                     [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                       #" ", #"p", #"a", #"i", #"r"]))
           (fn _ => Inr ((l, ([], [])), ((r, ([], [])), isPair)))
    else bindb (check
                 (membera (equal_prod (equal_term A2_ B5_) (equal_term A2_ B5_))
                   ra (l, r))
                 (shows_rule (shows_prec A3_ zero_nata)
                    (shows_prec B8_ zero_nata) [#" ", #"-", #">", #" "] (l, r) o
                   shows_prec_list show_char zero_nata
                     [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                       #" ", #"r", #"u", #"l", #"e"]))
           (fn _ => Inr ((l, ([], [])), ((r, ([], [])), isPair))))
  | check_pat_rule_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    r p (Pat_InitPump (pat, sigma, theta)) =
    bindb (check_pat_rule_prf (A1_, A2_, A3_)
            (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r p pat)
      (fn (a, b) =>
        let
          val (s, (siga, tau)) = a;
        in
          (fn (aa, ba) =>
            let
              val (t, (sigaa, taua)) = aa;
            in
              (fn bb =>
                catch_errora
                  (bindb
                    (check (null (siga @ tau @ sigaa @ taua))
                      (shows_prec_list show_char zero_nata
                        [#"s", #"u", #"b", #"s", #"t", #"i", #"t", #"u", #"t",
                          #"i", #"o", #"n", #"s", #" ", #"m", #"u", #"s", #"t",
                          #" ", #"b", #"e", #" ", #"e", #"m", #"p", #"t",
                          #"y"]))
                    (fn _ =>
                      bindb (check
                              (equal_terma A2_ B5_
                                (subst_apply_term s (mk_subst B5_ Var theta))
                                (subst_apply_term t (mk_subst B5_ Var sigma)))
                              (shows_prec_list show_char zero_nata
                                [#"s", #" ", #"t", #"h", #"e", #"t", #"a", #" ",
                                  #"!", #"=", #" ", #"t", #" ", #"s", #"i",
                                  #"g", #"m", #"a"]))
                        (fn _ =>
                          bindb (check
                                  (commutes_impl (B1_, B2_, B3_, B4_, B5_, B7_)
                                    (A1_, A2_) theta sigma)
                                  (shows_prec_list show_char zero_nata
                                    [#"s", #"i", #"g", #"m", #"a", #" ", #"a",
                                      #"n", #"d", #" ", #"t", #"h", #"e", #"t",
                                      #"a", #" ", #"d", #"o", #" ", #"n", #"o",
                                      #"t", #" ", #"c", #"o", #"m", #"m", #"u",
                                      #"t", #"e"]))
                            (fn _ =>
                              Inr ((s, (sigma, [])), ((t, (theta, [])), bb))))))
                  (fn x =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                             #"w", #"i", #"t", #"h", #" "] o
                          (shows_prec_list show_char zero_nata
                             [#"i", #"n", #"i", #"t", #"i", #"a", #"l", #" ",
                               #"p", #"u", #"m", #"p", #"i", #"n", #"g"] o
                            (shows_prec_list show_char zero_nata
                               [#" ", #"a", #"f", #"t", #"e", #"r", #" ", #"d",
                                 #"e", #"r", #"i", #"v", #"i", #"n", #"g", #" ",
                                 #"c", #"o", #"r", #"r", #"e", #"c", #"t", #" ",
                                 #"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ",
                                 #"r", #"u", #"l", #"e", #" "] o
                              (shows_nl o
                                (show_pat_rule (A2_, A3_) (B5_, B8_)
                                   ((s, (siga, tau)),
                                     ((t, (sigaa, taua)), bb)) o
                                  x)))))))
            end
              ba)
        end
          b)
  | check_pat_rule_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    r pa (Pat_InitPumpCtxt (pat, sigma, p, z)) =
    bindb (check_pat_rule_prf (A1_, A2_, A3_)
            (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r pa pat)
      (fn (a, b) =>
        let
          val (s, (siga, tau)) = a;
        in
          (fn (aa, ba) =>
            let
              val (t, (sigaa, taua)) = aa;
            in
              (fn bb =>
                catch_errora
                  (bindb
                    (check (not bb)
                      (shows_prec_list show_char zero_nata
                        [#"p", #"a", #"i", #"r", #"s", #" ", #"n", #"o", #"t",
                          #" ", #"a", #"l", #"l", #"o", #"w", #"e", #"d", #" ",
                          #"i", #"n", #" ", #"i", #"n", #"i", #"t", #" ", #"p",
                          #"u", #"m", #"p", #" ", #"c", #"t", #"x", #"t"]))
                    (fn _ =>
                      bindb (check (null (siga @ tau @ sigaa @ taua))
                              (shows_prec_list show_char zero_nata
                                [#"s", #"u", #"b", #"s", #"t", #"i", #"t", #"u",
                                  #"t", #"i", #"o", #"n", #"s", #" ", #"m",
                                  #"u", #"s", #"t", #" ", #"b", #"e", #" ",
                                  #"e", #"m", #"p", #"t", #"y"]))
                        (fn _ =>
                          bindb (check (in_poss p t)
                                  (shows_prec_list show_char zero_nata
                                    [#"p", #" ", #"i", #"s", #" ", #"n", #"o",
                                      #"t", #" ", #"a", #" ", #"v", #"a", #"l",
                                      #"i", #"d", #" ", #"p", #"o", #"s", #"i",
                                      #"t", #"i", #"o", #"n"]))
                            (fn _ =>
                              bindb (check
                                      (equal_terma A2_ B5_ s
(subst_apply_term (subt_at t p) (mk_subst B5_ Var sigma)))
                                      (shows_prec_list show_char zero_nata
[#"s", #" ", #"!", #"=", #" ", #"t", #" ", #"|", #"_", #" ", #"p", #" ", #"s",
  #"i", #"g", #"m", #"a"]))
                                (fn _ =>
                                  bindb (check
  (not (membera B5_
         (vars_term_list s @ vars_term_list t @ vars_subst_impl B5_ A2_ sigma)
         z))
  (shows_prec_list show_char zero_nata
    [#"z", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"f", #"r", #"e",
      #"s", #"h"]))
                                    (fn _ =>
                                      let
val tz = ctxt_apply_term (ctxt_of_pos_term p t) (Var z);
                                      in
Inr ((s, (sigma, [])), ((tz, ((z, tz) :: sigma, [(z, subt_at t p)])), bb))
                                      end))))))
                  (fn x =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                             #"w", #"i", #"t", #"h", #" "] o
                          (shows_prec_list show_char zero_nata
                             [#"i", #"n", #"i", #"t", #"i", #"a", #"l", #" ",
                               #"p", #"u", #"m", #"p", #"i", #"n", #"g", #" ",
                               #"(", #"w", #"i", #"t", #"h", #" ", #"c", #"t",
                               #"x", #"t", #")", #" "] o
                            (shows_prec_list show_char zero_nata
                               [#" ", #"a", #"f", #"t", #"e", #"r", #" ", #"d",
                                 #"e", #"r", #"i", #"v", #"i", #"n", #"g", #" ",
                                 #"c", #"o", #"r", #"r", #"e", #"c", #"t", #" ",
                                 #"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ",
                                 #"r", #"u", #"l", #"e", #" "] o
                              (shows_nl o
                                (show_pat_rule (A2_, A3_) (B5_, B8_)
                                   ((s, (siga, tau)),
                                     ((t, (sigaa, taua)), bb)) o
                                  x)))))))
            end
              ba)
        end
          b)
  | check_pat_rule_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    r p (Pat_Equiv (pat, left, eqv)) =
    bindb (check_pat_rule_prf (A1_, A2_, A3_)
            (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r p pat)
      (fn (pleft, (pright, b)) =>
        catch_errora
          (bindb
            (check_pat_eqv_prf (A1_, A2_, A3_)
              (B1_, B2_, B3_, B4_, B5_, B7_, B8_) eqv
              (if left then pleft else pright))
            (fn pnew =>
              Inr (if left then (pnew, (pright, b)) else (pleft, (pnew, b)))))
          (fn x =>
            Inl (shows_prec_list show_char zero_nata
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"i",
                     #"t", #"h", #" "] o
                  (shows_prec_list show_char zero_nata
                     [#"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ", #"e",
                       #"q", #"u", #"i", #"v", #"a", #"l", #"e", #"n", #"c",
                       #"e"] o
                    (shows_prec_list show_char zero_nata
                       [#" ", #"a", #"f", #"t", #"e", #"r", #" ", #"d", #"e",
                         #"r", #"i", #"v", #"i", #"n", #"g", #" ", #"c", #"o",
                         #"r", #"r", #"e", #"c", #"t", #" ", #"p", #"a", #"t",
                         #"t", #"e", #"r", #"n", #" ", #"r", #"u", #"l", #"e",
                         #" "] o
                      (shows_nl o
                        (show_pat_rule (A2_, A3_) (B5_, B8_)
                           (pleft, (pright, b)) o
                          x)))))))
  | check_pat_rule_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    r pa (Pat_Narrow (pat1, pat2, p)) =
    bindb (check_pat_rule_prf (A1_, A2_, A3_)
            (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r pa pat1)
      (fn (a, b) =>
        let
          val (s, (sigma, mu)) = a;
        in
          (fn (aa, ba) =>
            let
              val (t, (siga, mua)) = aa;
            in
              (fn b1 =>
                bindb (check_pat_rule_prf (A1_, A2_, A3_)
                        (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r pa pat2)
                  (fn (ab, bb) =>
                    let
                      val (u, (sig1, mu1)) = ab;
                    in
                      (fn (ac, bc) =>
                        let
                          val (v, (sig2, mu2)) = ac;
                        in
                          (fn b2 =>
                            catch_errora
                              (bindb
                                (check
                                  (subst_eq (B1_, B2_, B3_, B4_, B5_, B7_)
                                     (A1_, A2_) siga sigma andalso
                                    (subst_eq (B1_, B2_, B3_, B4_, B5_, B7_)
                                       (A1_, A2_) sig1 sigma andalso
                                      (subst_eq (B1_, B2_, B3_, B4_, B5_, B7_)
 (A1_, A2_) sig2 sigma andalso
(subst_eq (B1_, B2_, B3_, B4_, B5_, B7_) (A1_, A2_) mua mu andalso
  (subst_eq (B1_, B2_, B3_, B4_, B5_, B7_) (A1_, A2_) mu1 mu andalso
    subst_eq (B1_, B2_, B3_, B4_, B5_, B7_) (A1_, A2_) mu2 mu)))))
                                  (shows_prec_list show_char zero_nata
                                    [#"s", #"u", #"b", #"s", #"t", #"i", #"t",
                                      #"u", #"t", #"i", #"o", #"n", #"s", #" ",
                                      #"a", #"r", #"e", #" ", #"n", #"o", #"t",
                                      #" ", #"i", #"d", #"e", #"n", #"t", #"i",
                                      #"c", #"a", #"l"]))
                                (fn _ =>
                                  bindb (check (in_poss p t)
  (shows_prec_list show_char zero_nata
    [#"p", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"v",
      #"a", #"l", #"i", #"d", #" ", #"p", #"o", #"s", #"i", #"t", #"i", #"o",
      #"n"]))
                                    (fn _ =>
                                      bindb
(check (equal_terma A2_ B5_ (subt_at t p) u)
  (shows_prec_list show_char zero_nata
    [#"t", #" ", #"|", #"_", #" ", #"p", #" ", #"!", #"=", #" ", #"u"]))
(fn _ =>
  bindb (check (if b2 then equal_posa p Empty else true)
          (shows_prec_list show_char zero_nata
            [#"t", #"h", #"e", #"r", #"e", #" ", #"i", #"s", #" ", #"a", #" ",
              #"P", #" ", #"s", #"t", #"e", #"p", #",", #" ", #"s", #"o", #" ",
              #"p", #" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e", #" ", #"e",
              #"p", #"s", #"i", #"l", #"o", #"n"]))
    (fn _ =>
      Inr ((s, (sigma, mu)),
            ((ctxt_apply_term (ctxt_of_pos_term p t) v, (sigma, mu)),
              b1 orelse b2)))))))
                              (fn x =>
                                Inl (shows_prec_list show_char zero_nata
                                       [#"p", #"r", #"o", #"b", #"l", #"e",
 #"m", #" ", #"w", #"i", #"t", #"h", #" "] o
                                      (shows_prec_list show_char zero_nata
 [#"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ", #"n", #"a", #"r", #"r", #"o",
   #"w", #"i", #"n", #"g"] o
(shows_prec_list show_char zero_nata
   [#" ", #"a", #"f", #"t", #"e", #"r", #" ", #"d", #"e", #"r", #"i", #"v",
     #"i", #"n", #"g", #" ", #"c", #"o", #"r", #"r", #"e", #"c", #"t", #" ",
     #"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ", #"r", #"u", #"l", #"e",
     #"s", #" "] o
  (shows_nl o
    (show_pat_rule (A2_, A3_) (B5_, B8_)
       ((s, (sigma, mu)), ((t, (siga, mua)), b1)) o
      (shows_nl o
        (shows_prec_list show_char zero_nata [#" ", #"a", #"n", #"d", #" "] o
          (shows_nl o
            (show_pat_rule (A2_, A3_) (B5_, B8_)
               ((u, (sig1, mu1)), ((v, (sig2, mu2)), b2)) o
              x)))))))))))
                        end
                          bc)
                    end
                      bb))
            end
              ba)
        end
          b)
  | check_pat_rule_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    r p (Pat_Inst (pat, rho, Pat_Base)) =
    bindb (check_pat_rule_prf (A1_, A2_, A3_)
            (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r p pat)
      (fn (a, b) =>
        let
          val (s, (sigma_s, mu_s)) = a;
        in
          (fn (aa, ba) =>
            let
              val (t, (sigma_t, mu_t)) = aa;
            in
              (fn bb =>
                catch_errora
                  let
                    val xs =
                      map fst
                        (mk_subst_domain B5_ A2_ sigma_s @
                          mk_subst_domain B5_ A2_ mu_s @
                            mk_subst_domain B5_ A2_ sigma_t @
                              mk_subst_domain B5_ A2_ mu_t);
                  in
                    bindb (catch_errora
                            (forallM
                              (fn x =>
                                check (not (membera B5_ xs x))
                                  (shows_prec_list show_char zero_nata
                                    [#"d", #"o", #"m", #"a", #"i", #"n", #"s",
                                      #" ", #"n", #"o", #"t", #" ", #"d", #"i",
                                      #"s", #"j", #"o", #"i", #"n", #"t"]))
                              (vars_subst_impl B5_ A2_ rho))
                            (fn x => Inl (snd x)))
                      (fn _ =>
                        let
                          val rhoa = mk_subst B5_ Var rho;
                        in
                          Inr ((subst_apply_term s rhoa,
                                 (subst_compose_impla B5_ A2_ sigma_s rhoa,
                                   subst_compose_impla B5_ A2_ mu_s rhoa)),
                                ((subst_apply_term t rhoa,
                                   (subst_compose_impla B5_ A2_ sigma_t rhoa,
                                     subst_compose_impla B5_ A2_ mu_t rhoa)),
                                  bb))
                        end)
                  end
                  (fn x =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                             #"w", #"i", #"t", #"h", #" "] o
                          (shows_prec_list show_char zero_nata
                             [#"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ",
                               #"i", #"n", #"s", #"t", #"a", #"n", #"t", #"i",
                               #"a", #"t", #"i", #"o", #"n", #" ", #"(", #"b",
                               #"a", #"s", #"e", #")"] o
                            (shows_prec_list show_char zero_nata
                               [#" ", #"a", #"f", #"t", #"e", #"r", #" ", #"d",
                                 #"e", #"r", #"i", #"v", #"i", #"n", #"g", #" ",
                                 #"c", #"o", #"r", #"r", #"e", #"c", #"t", #" ",
                                 #"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ",
                                 #"r", #"u", #"l", #"e", #" "] o
                              (shows_nl o
                                (show_pat_rule (A2_, A3_) (B5_, B8_)
                                   ((s, (sigma_s, mu_s)),
                                     ((t, (sigma_t, mu_t)), bb)) o
                                  x)))))))
            end
              ba)
        end
          b)
  | check_pat_rule_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    r p (Pat_Inst (pat, rho, Pat_Pump)) =
    bindb (check_pat_rule_prf (A1_, A2_, A3_)
            (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r p pat)
      (fn (a, b) =>
        let
          val (s, (sigma_s, mu_s)) = a;
        in
          (fn (aa, ba) =>
            let
              val (t, (sigma_t, mu_t)) = aa;
            in
              (fn bb =>
                catch_errora
                  (bindb
                    (check
                      (commutes_impl (B1_, B2_, B3_, B4_, B5_, B7_) (A1_, A2_)
                        rho sigma_s)
                      (shows_prec_list show_char zero_nata
                        [#"r", #"h", #"o", #" ", #"d", #"o", #"e", #"s", #" ",
                          #"n", #"o", #"t", #" ", #"c", #"o", #"m", #"m", #"u",
                          #"t", #"e", #" ", #"w", #"i", #"t", #"h", #" ", #"s",
                          #"i", #"g", #"m", #"a", #"_", #"s"]))
                    (fn _ =>
                      bindb (check
                              (commutes_impl (B1_, B2_, B3_, B4_, B5_, B7_)
                                (A1_, A2_) rho mu_s)
                              (shows_prec_list show_char zero_nata
                                [#"r", #"h", #"o", #" ", #"d", #"o", #"e", #"s",
                                  #" ", #"n", #"o", #"t", #" ", #"c", #"o",
                                  #"m", #"m", #"u", #"t", #"e", #" ", #"w",
                                  #"i", #"t", #"h", #" ", #"m", #"u", #"_",
                                  #"s"]))
                        (fn _ =>
                          bindb (check
                                  (commutes_impl (B1_, B2_, B3_, B4_, B5_, B7_)
                                    (A1_, A2_) rho sigma_t)
                                  (shows_prec_list show_char zero_nata
                                    [#"r", #"h", #"o", #" ", #"d", #"o", #"e",
                                      #"s", #" ", #"n", #"o", #"t", #" ", #"c",
                                      #"o", #"m", #"m", #"u", #"t", #"e", #" ",
                                      #"w", #"i", #"t", #"h", #" ", #"s", #"i",
                                      #"g", #"m", #"a", #"_", #"t"]))
                            (fn _ =>
                              bindb (check
                                      (commutes_impl
(B1_, B2_, B3_, B4_, B5_, B7_) (A1_, A2_) rho mu_t)
                                      (shows_prec_list show_char zero_nata
[#"r", #"h", #"o", #" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ",
  #"c", #"o", #"m", #"m", #"u", #"t", #"e", #" ", #"w", #"i", #"t", #"h", #" ",
  #"m", #"u", #"_", #"t"]))
                                (fn _ =>
                                  Inr ((s,
 (subst_compose_impl B5_ A2_ sigma_s rho, mu_s)),
((t, (subst_compose_impl B5_ A2_ sigma_t rho, mu_t)), bb)))))))
                  (fn x =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                             #"w", #"i", #"t", #"h", #" "] o
                          (shows_prec_list show_char zero_nata
                             [#"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ",
                               #"i", #"n", #"s", #"t", #"a", #"n", #"t", #"i",
                               #"a", #"t", #"i", #"o", #"n", #" ", #"(", #"p",
                               #"u", #"m", #"p", #"i", #"n", #"g", #")"] o
                            (shows_prec_list show_char zero_nata
                               [#" ", #"a", #"f", #"t", #"e", #"r", #" ", #"d",
                                 #"e", #"r", #"i", #"v", #"i", #"n", #"g", #" ",
                                 #"c", #"o", #"r", #"r", #"e", #"c", #"t", #" ",
                                 #"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ",
                                 #"r", #"u", #"l", #"e", #" "] o
                              (shows_nl o
                                (show_pat_rule (A2_, A3_) (B5_, B8_)
                                   ((s, (sigma_s, mu_s)),
                                     ((t, (sigma_t, mu_t)), bb)) o
                                  x)))))))
            end
              ba)
        end
          b)
  | check_pat_rule_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    r p (Pat_Inst (pat, rho, Pat_Close)) =
    bindb (check_pat_rule_prf (A1_, A2_, A3_)
            (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r p pat)
      (fn (a, b) =>
        let
          val (s, (sigma_s, mu_s)) = a;
        in
          (fn (aa, ba) =>
            let
              val (t, (sigma_t, mu_t)) = aa;
            in
              (fn bb =>
                Inr ((s, (sigma_s, subst_compose_impl B5_ A2_ mu_s rho)),
                      ((t, (sigma_t, subst_compose_impl B5_ A2_ mu_t rho)),
                        bb)))
            end
              ba)
        end
          b)
  | check_pat_rule_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    r p (Pat_Rewr (pat, rewr, Pat_Base, uu)) =
    bindb (check_pat_rule_prf (A1_, A2_, A3_)
            (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r p pat)
      (fn (a, b) =>
        let
          val (s, (sigma_s, mu_s)) = a;
        in
          (fn (aa, ba) =>
            let
              val (t, (sigma_t, mu_t)) = aa;
            in
              (fn bb =>
                catch_errora
                  let
                    val (ta, rseq) = rewr;
                    val tb = last (ta :: map (fn (_, (_, tb)) => tb) rseq);
                  in
                    bindb (check (equal_terma A2_ B5_ t ta)
                            (shows_prec_list show_char zero_nata
                              [#"t", #"e", #"r", #"m", #"s", #" ", #"t", #" ",
                                #"d", #"o", #" ", #"n", #"o", #"t", #" ", #"m",
                                #"a", #"t", #"c", #"h"]))
                      (fn _ =>
                        bindb (check_rsteps (A2_, A3_) (B3_, B5_, B6_, B8_) r
                                rseq ta tb)
                          (fn _ =>
                            Inr ((s, (sigma_s, mu_s)),
                                  ((tb, (sigma_t, mu_t)), bb))))
                  end
                  (fn x =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                             #"w", #"i", #"t", #"h", #" "] o
                          (shows_prec_list show_char zero_nata
                             [#"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ",
                               #"r", #"e", #"w", #"r", #"i", #"t", #"i", #"n",
                               #"g", #" ", #"(", #"b", #"a", #"s", #"e", #")"] o
                            (shows_prec_list show_char zero_nata
                               [#" ", #"a", #"f", #"t", #"e", #"r", #" ", #"d",
                                 #"e", #"r", #"i", #"v", #"i", #"n", #"g", #" ",
                                 #"c", #"o", #"r", #"r", #"e", #"c", #"t", #" ",
                                 #"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ",
                                 #"r", #"u", #"l", #"e", #" "] o
                              (shows_nl o
                                (show_pat_rule (A2_, A3_) (B5_, B8_)
                                   ((s, (sigma_s, mu_s)),
                                     ((t, (sigma_t, mu_t)), bb)) o
                                  x)))))))
            end
              ba)
        end
          b)
  | check_pat_rule_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    r p (Pat_Rewr (pat, rewr, Pat_Pump, x)) =
    bindb (check_pat_rule_prf (A1_, A2_, A3_)
            (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r p pat)
      (fn (a, b) =>
        let
          val (s, (sigma_s, mu_s)) = a;
        in
          (fn (aa, ba) =>
            let
              val (t, (sigma_t, mu_t)) = aa;
            in
              (fn bb =>
                catch_errora
                  let
                    val (ta, rseq) = rewr;
                    val tb = last (ta :: map (fn (_, (_, tb)) => tb) rseq);
                  in
                    bindb (check
                            (equal_terma A2_ B5_ (mk_subst B5_ Var sigma_t x)
                              ta)
                            (shows_prec_list show_char zero_nata
                              [#"s", #"i", #"g", #"m", #"a", #"_", #"t", #" ",
                                #"x", #" ", #"d", #"o", #"e", #"s", #" ", #"n",
                                #"o", #"t", #" ", #"m", #"a", #"t", #"c", #"h",
                                #" ", #"s", #"t", #"a", #"r", #"t", #"i", #"n",
                                #"g", #" ", #"t", #"e", #"r", #"m"]))
                      (fn _ =>
                        bindb (check_rsteps (A2_, A3_) (B3_, B5_, B6_, B8_) r
                                rseq ta tb)
                          (fn _ =>
                            Inr ((s, (sigma_s, mu_s)),
                                  ((t, (subst_replace_impl B5_ sigma_t x tb,
 mu_t)),
                                    bb))))
                  end
                  (fn xa =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                             #"w", #"i", #"t", #"h", #" "] o
                          (shows_prec_list show_char zero_nata
                             [#"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ",
                               #"r", #"e", #"w", #"r", #"i", #"t", #"i", #"n",
                               #"g", #" ", #"(", #"p", #"u", #"m", #"p", #"i",
                               #"n", #"g", #")"] o
                            (shows_prec_list show_char zero_nata
                               [#" ", #"a", #"f", #"t", #"e", #"r", #" ", #"d",
                                 #"e", #"r", #"i", #"v", #"i", #"n", #"g", #" ",
                                 #"c", #"o", #"r", #"r", #"e", #"c", #"t", #" ",
                                 #"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ",
                                 #"r", #"u", #"l", #"e", #" "] o
                              (shows_nl o
                                (show_pat_rule (A2_, A3_) (B5_, B8_)
                                   ((s, (sigma_s, mu_s)),
                                     ((t, (sigma_t, mu_t)), bb)) o
                                  xa)))))))
            end
              ba)
        end
          b)
  | check_pat_rule_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    r p (Pat_Rewr (pat, rewr, Pat_Close, x)) =
    bindb (check_pat_rule_prf (A1_, A2_, A3_)
            (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r p pat)
      (fn (a, b) =>
        let
          val (s, (sigma_s, mu_s)) = a;
        in
          (fn (aa, ba) =>
            let
              val (t, (sigma_t, mu_t)) = aa;
            in
              (fn bb =>
                catch_errora
                  let
                    val (ta, rseq) = rewr;
                    val tb = last (ta :: map (fn (_, (_, tb)) => tb) rseq);
                  in
                    bindb (check
                            (equal_terma A2_ B5_ (mk_subst B5_ Var mu_t x) ta)
                            (shows_prec_list show_char zero_nata
                              [#"s", #"i", #"g", #"m", #"a", #"_", #"t", #" ",
                                #"x", #" ", #"d", #"o", #"e", #"s", #" ", #"n",
                                #"o", #"t", #" ", #"m", #"a", #"t", #"c", #"h",
                                #" ", #"s", #"t", #"a", #"r", #"t", #"i", #"n",
                                #"g", #" ", #"t", #"e", #"r", #"m"]))
                      (fn _ =>
                        bindb (check_rsteps (A2_, A3_) (B3_, B5_, B6_, B8_) r
                                rseq ta tb)
                          (fn _ =>
                            Inr ((s, (sigma_s, mu_s)),
                                  ((t, (sigma_t,
 subst_replace_impl B5_ mu_t x tb)),
                                    bb))))
                  end
                  (fn xa =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                             #"w", #"i", #"t", #"h", #" "] o
                          (shows_prec_list show_char zero_nata
                             [#"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ",
                               #"r", #"e", #"w", #"r", #"i", #"t", #"i", #"n",
                               #"g", #" ", #"(", #"c", #"l", #"o", #"s", #"i",
                               #"n", #"g", #")"] o
                            (shows_prec_list show_char zero_nata
                               [#" ", #"a", #"f", #"t", #"e", #"r", #" ", #"d",
                                 #"e", #"r", #"i", #"v", #"i", #"n", #"g", #" ",
                                 #"c", #"o", #"r", #"r", #"e", #"c", #"t", #" ",
                                 #"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ",
                                 #"r", #"u", #"l", #"e", #" "] o
                              (shows_nl o
                                (show_pat_rule (A2_, A3_) (B5_, B8_)
                                   ((s, (sigma_s, mu_s)),
                                     ((t, (sigma_t, mu_t)), bb)) o
                                  xa)))))))
            end
              ba)
        end
          b)
  | check_pat_rule_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    r p (Pat_Exp_Sigma (pat, k)) =
    bindb (check_pat_rule_prf (A1_, A2_, A3_)
            (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r p pat)
      (fn (a, b) =>
        let
          val (s, (sigma_s, mu_s)) = a;
        in
          (fn (aa, ba) =>
            let
              val (t, (sigma_t, mu_t)) = aa;
            in
              (fn bb =>
                Inr ((subst_apply_term s
                        (mk_subst B5_ Var (subst_power_impl B5_ A2_ sigma_s k)),
                       (sigma_s, mu_s)),
                      ((subst_apply_term t
                          (mk_subst B5_ Var
                            (subst_power_impl B5_ A2_ sigma_t k)),
                         (sigma_t, mu_t)),
                        bb)))
            end
              ba)
        end
          b);

fun check_non_loop_prf (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
  r pa (Non_loop_prf (pat, sigma, mu, m, b, p)) =
  bindb (check_pat_rule_prf (A1_, A2_, A3_)
          (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r pa pat)
    (fn (a, c) =>
      let
        val (s, (sigmaa, mua)) = a;
      in
        (fn (aa, ca) =>
          let
            val (t, (sigma_t, mu_t)) = aa;
          in
            (fn is_pair =>
              catch_errora
                (bindb
                  (check (if is_pair then equal_posa p Empty else true)
                    (shows_prec_list show_char zero_nata
                      [#"p", #" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e",
                        #" ", #"e", #"m", #"p", #"t", #"y", #",", #" ", #"s",
                        #"i", #"n", #"c", #"e", #" ", #"p", #"a", #"i", #"r",
                        #"s", #" ", #"a", #"r", #"e", #" ", #"c", #"o", #"n",
                        #"t", #"a", #"i", #"n", #"e", #"d"]))
                  (fn _ =>
                    bindb (check
                            (commutes_impl (B1_, B2_, B3_, B4_, B5_, B7_)
                              (A1_, A2_) sigmaa sigma)
                            (shows_prec_list show_char zero_nata
                              [#"s", #"i", #"g", #"m", #"a", #" ", #"a", #"n",
                                #"d", #" ", #"s", #"i", #"g", #"m", #"a", #"'",
                                #" ", #"d", #"o", #" ", #"n", #"o", #"t", #" ",
                                #"c", #"o", #"m", #"m", #"u", #"t", #"e"]))
                      (fn _ =>
                        bindb (check
                                (commutes_impl (B1_, B2_, B3_, B4_, B5_, B7_)
                                  (A1_, A2_) mua sigma)
                                (shows_prec_list show_char zero_nata
                                  [#"m", #"u", #" ", #"a", #"n", #"d", #" ",
                                    #"s", #"i", #"g", #"m", #"a", #"'", #" ",
                                    #"d", #"o", #" ", #"n", #"o", #"t", #" ",
                                    #"c", #"o", #"m", #"m", #"u", #"t", #"e"]))
                          (fn _ =>
                            bindb (check
                                    (subst_eq (B1_, B2_, B3_, B4_, B5_, B7_)
                                      (A1_, A2_) sigma_t
                                      (subst_compose_impl B5_ A2_
(subst_power_impl B5_ A2_ sigmaa m) sigma))
                                    (shows_prec_list show_char zero_nata
                                      [#"s", #"i", #"g", #"m", #"a", #"_", #"t",
#" ", #"!", #"=", #" ", #"s", #"i", #"g", #"m", #"a", #"^", #"m", #" ", #"s",
#"i", #"g", #"m", #"a", #"'", #" "]))
                              (fn _ =>
                                bindb (check
(subst_eq (B1_, B2_, B3_, B4_, B5_, B7_) (A1_, A2_) mu_t
  (subst_compose_impl B5_ A2_ mua mu))
(shows_prec_list show_char zero_nata
  [#"m", #"u", #"_", #"t", #" ", #"!", #"=", #" ", #"m", #"u", #" ", #"m", #"u",
    #"'", #" "]))
                                  (fn _ =>
                                    bindb (check (in_poss p t)
    (shows_prec_list show_char zero_nata
      [#"p", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"p",
        #"o", #"s", #"i", #"t", #"i", #"o", #"n", #" ", #"i", #"n", #" ",
        #"t"]))
                                      (fn _ =>
check (equal_terma A2_ B5_
        (subst_apply_term s
          (mk_subst B5_ Var (subst_power_impl B5_ A2_ sigmaa b)))
        (subt_at t p))
  (shows_prec_list show_char zero_nata
    [#"s", #" ", #"s", #"i", #"g", #"m", #"a", #"^", #"b", #" ", #"!", #"=",
      #" ", #"t", #" ", #"|", #"_", #" ", #"p"]))))))))
                (fn x =>
                  Inl (shows_prec_list show_char zero_nata
                         [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w",
                           #"i", #"t", #"h", #" "] o
                        (shows_prec_list show_char zero_nata
                           [#"a", #"p", #"p", #"l", #"i", #"c", #"a", #"t",
                             #"i", #"o", #"n", #" ", #"c", #"o", #"n", #"d",
                             #"i", #"t", #"i", #"o", #"n", #" ", #"o", #"f",
                             #" ", #"n", #"o", #"n", #"-", #"l", #"o", #"o",
                             #"p", #" ", #"t", #"h", #"e", #"o", #"r", #"e",
                             #"m"] o
                          (shows_prec_list show_char zero_nata
                             [#" ", #"a", #"f", #"t", #"e", #"r", #" ", #"d",
                               #"e", #"r", #"i", #"v", #"i", #"n", #"g", #" ",
                               #"c", #"o", #"r", #"r", #"e", #"c", #"t", #" ",
                               #"p", #"a", #"t", #"t", #"e", #"r", #"n", #" ",
                               #"r", #"u", #"l", #"e", #" "] o
                            (shows_nl o
                              (show_pat_rule (A2_, A3_) (B5_, B8_)
                                 ((s, (sigmaa, mua)),
                                   ((t, (sigma_t, mu_t)), is_pair)) o
                                x)))))))
          end
            ca)
      end
        c);

fun check_non_loop_dp_prf (B1_, B2_, B3_)
  (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_) i dpp prf =
  let
    val p = pairsb i dpp;
    val r = rulese i dpp;
  in
    bindb (check (null (qc i dpp))
            (shows_prec_list show_char zero_nata
              [#"s", #"t", #"r", #"a", #"t", #"e", #"g", #"y", #" ", #"f", #"o",
                #"r", #" ", #"n", #"o", #"n", #"-", #"l", #"o", #"o", #"p",
                #"s", #" ", #"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r",
                #"t", #"e", #"d"]))
      (fn _ =>
        check_non_loop_prf (B1_, B2_, B3_)
          (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_) r p prf)
  end;

fun rule_removal_nonterm_trs (B1_, B2_) (C1_, C2_) i tp
  (Rule_removal_nonterm_trs_prf r) =
  let
    val ra = rulesd i tp;
    val rrm =
      ceta_list_diff (key_prod (key_term B1_ C1_) (key_term B1_ C1_)) ra r;
  in
    Inr (delete_R_Rwb i tp rrm rrm)
  end;

fun shows_prec_location uu A =
  shows_prec_list show_char zero_nata [#"a", #"b", #"o", #"v", #"e"]
  | shows_prec_location uv Ba =
    shows_prec_list show_char zero_nata [#"b", #"e", #"l", #"o", #"w"]
  | shows_prec_location uw H =
    shows_prec_list show_char zero_nata [#"h", #"e", #"r", #"e"]
  | shows_prec_location ux Ra =
    shows_prec_list show_char zero_nata [#"r", #"i", #"g", #"h", #"t"];

fun shows_pattern A_ B_ (c, (s, p)) =
  shows_prec_list show_char zero_nata [#"("] o
    (shows_prec_term A_ B_ zero_nata (ctxt_apply_term c s) o
      (shows_prec_list show_char zero_nata [#",", #" "] o
        (shows_prec_pos zero_nata (hole_pos c) o
          (shows_prec_list show_char zero_nata [#",", #" "] o
            (shows_prec_location zero_nata p o
              shows_prec_list show_char zero_nata [#")"])))));

fun fp_R_decide (A1_, A2_) (B1_, B2_, B3_, B4_) mu l oo q c t =
  not (bex (ceq_prod (ceq_term A2_ B4_) (ceq_term A2_ B4_),
             ccompare_prod (ccompare_term A1_ B3_) (ccompare_term A1_ B3_))
        let
          val h = hole_pos c;
          val q_s = filtera (fn qa => is_left_of qa q) (poss_list t);
          val m1 = map (fn qa => (subt_at t qa, l)) q_s;
          val sterms =
            remdups (equal_term A2_ B4_)
              (map (si_subst mu)
                (remdups B4_ (maps (fn qa => si_W mu (subt_at t qa)) q_s)));
          val uterms = maps supteq_list sterms;
          val m2 = map (fn u => (u, l)) (remdups (equal_term A2_ B4_) uterms);
          val p_s =
            filtera (fn qa => is_left_of qa h)
              (poss_list (ctxt_apply_term c t));
          val m3 = map (fn p => (subt_at (ctxt_apply_term c t) p, l)) p_s;
          val stermsa =
            remdups (equal_term A2_ B4_)
              (map (si_subst mu)
                (remdups B4_
                  (maps (fn p => si_W mu (subt_at (ctxt_apply_term c t) p))
                    p_s)));
          val utermsa = maps supteq_list stermsa;
          val m4 = map (fn u => (u, l)) (remdups (equal_term A2_ B4_) utermsa);
        in
          set (ceq_prod (ceq_term A2_ B4_) (ceq_term A2_ B4_),
                ccompare_prod (ccompare_term A1_ B3_) (ccompare_term A1_ B3_),
                set_impl_prod set_impl_term set_impl_term)
            (m1 @ m2 @ m3 @ m4)
        end
        (match_decision (A1_, A2_) (B1_, B2_, B3_, B4_) mu));

fun pos_dec p q oo =
  (if equal_posa p Empty
    then (case pos_suffix oo q of NONE => NONE | SOME r => SOME (zero_nata, r))
    else let
           val n0 =
             nat (ceiling floor_ceiling_rat
                   (divide_rata
                     (of_nat semiring_1_rat
                       (minus_nata (size_pos oo) (size_pos q)))
                     (of_nat semiring_1_rat (size_pos p))));
         in
           (case pos_suffix oo (append (power power_pos p n0) q) of NONE => NONE
             | SOME r => SOME (n0, r))
         end);

fun ctxt_subst uu uv n t =
  (if equal_nata n zero_nata then t
    else ctxt_apply_term uu
           (subst_apply_term (ctxt_subst uu uv (minus_nata n one_nata) t) uv));

fun h_match_probs (A1_, A2_) (B1_, B2_) mu l oo q c t =
  (case pos_dec (hole_pos c) q oo
    of NONE =>
      set_empty
        (ceq_prod (ceq_term B2_ A2_) (ceq_term B2_ A2_),
          ccompare_prod (ccompare_term B1_ A1_) (ccompare_term B1_ A1_))
        (of_phantom (set_impl_proda set_impl_term set_impl_term))
    | SOME (n, oa) =>
      inserta
        (ceq_prod (ceq_term B2_ A2_) (ceq_term B2_ A2_),
          ccompare_prod (ccompare_term B1_ A1_) (ccompare_term B1_ A1_))
        (subt_at (ctxt_subst c mu n t) oa, l)
        (set_empty
          (ceq_prod (ceq_term B2_ A2_) (ceq_term B2_ A2_),
            ccompare_prod (ccompare_term B1_ A1_) (ccompare_term B1_ A1_))
          (of_phantom (set_impl_proda set_impl_term set_impl_term))));

fun fp_H_decide (A1_, A2_) (B1_, B2_, B3_, B4_) mu l oo q c t =
  not (bex (ceq_prod (ceq_term A2_ B4_) (ceq_term A2_ B4_),
             ccompare_prod (ccompare_term A1_ B3_) (ccompare_term A1_ B3_))
        (h_match_probs (B3_, B4_) (A1_, A2_) (si_subst mu) l oo q c t)
        (match_decision (A1_, A2_) (B1_, B2_, B3_, B4_) mu));

fun decompositions p =
  map (fn pa => (pa, the (pos_prefix pa p))) (prefix_list p);

fun simplify_emp_main (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr
  (Hole, (Fun (g, ls), (c, (t, [])))) solved =
  (if gmatch_decision (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr
        ((t, Fun (g, ls)) :: solved)
    then SOME NONE
    else (if equal_ctxta A2_ B4_ c Hole then NONE
           else simplify_emp_main (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr
                  (c, (Fun (g, ls),
                        (subst_apply_ctxt c (si_subst mu_incr),
                          (subst_apply_term t (si_subst mu_incr), []))))
                  solved))
  | simplify_emp_main (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr
    (More (f, bef, d, aft), (Fun (g, ls), (c, (t, [])))) solved =
    bind (guarda (eq A2_ f g))
      (fn _ =>
        bind (guarda
               (equal_nata (size_list ls)
                 (suc (plus_nata (size_list bef) (size_list aft)))))
          (fn _ =>
            let
              val pairs_bef = zip bef (take (size_list bef) ls);
              val pairs_aft = zip aft (drop (suc (size_list bef)) ls);
            in
              simplify_emp_main (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr
                (d, (nth ls (size_list bef), (c, (t, pairs_bef @ pairs_aft))))
                solved
            end))
  | simplify_emp_main (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr
    (d, (Var x, (c, (t, [])))) solved =
    SOME (SOME (d, (Var x, (c, (t, solved)))))
  | simplify_emp_main (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr
    (d, (l, (c, (t, (Var x, Fun (f, ls)) :: mp)))) solved =
    bind (guarda (member (B1_, B2_) x (si_v_incr mu_incr)))
      (fn _ =>
        let
          val m = map (fn (s, a) => (subst_apply_term s (si_subst mu_incr), a));
        in
          simplify_emp_main (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr
            (subst_apply_ctxt d (si_subst mu_incr),
              (l, (subst_apply_ctxt c (si_subst mu_incr),
                    (subst_apply_term t (si_subst mu_incr),
                      m ((Var x, Fun (f, ls)) :: mp)))))
            (m solved)
        end)
  | simplify_emp_main (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr
    (d, (l, (c, (t, (Fun (g, ts), Fun (f, ls)) :: mp)))) solved =
    bind (guarda (eq A2_ f g))
      (fn _ =>
        bind (zip_option ts ls)
          (fn pairs =>
            simplify_emp_main (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr
              (d, (l, (c, (t, pairs @ mp)))) solved))
  | simplify_emp_main (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr
    (d, (l, (c, (t, (s, Var x) :: mp)))) solved =
    simplify_emp_main (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr
      (d, (l, (c, (t, mp)))) ((s, Var x) :: solved);

fun simplify_emp (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr emp =
  let
    val (d, (l, (c, t))) = emp;
  in
    (case simplify_emp_main (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr
            (d, (l, (c, (t, [])))) []
      of NONE => Inr false
      | SOME a => (case a of NONE => Inr true | SOME aa => Inl aa))
  end;

fun eident_prob_to_ident_prob (d, (si, (c, t))) = (ctxt_apply_term d t, si);

fun eident_prob_of_semp A_ B_ (d, (l, (c, (t, mp)))) =
  bind (map_of (equal_term A_ B_) (reverse_rules mp) l)
    (fn si => SOME (d, (si, (c, t))));

fun ident_prob_of_semp A_ B_ (d, (l, (c, (t, mp)))) =
  ident_prob_of_smp A_ B_ mp;

fun ident_prob_of_emp (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr emp =
  (case simplify_emp (A1_, A2_) (B1_, B2_, B3_, B4_) mu_incr emp
    of Inl semp =>
      SOME (map eident_prob_to_ident_prob
              (option_to_list (eident_prob_of_semp A2_ B4_ semp)) @
             ident_prob_of_semp A2_ B4_ semp)
    | Inr true => SOME [] | Inr false => NONE);

fun n0b p q oo =
  nat (ceiling floor_ceiling_rat
        (divide_rata
          (of_nat semiring_1_rat (minus_nata (suc (size_pos oo)) (size_pos q)))
          (of_nat semiring_1_rat (size_pos p))));

fun less_pos p q = less_eq_pos p q andalso not (equal_posa p q);

fun fp_B_decide (A1_, A2_) (B1_, B2_, B3_, B4_) mu l oo q c t =
  not (bex (ceq_prod (ceq_term A2_ B4_) (ceq_term A2_ B4_),
             ccompare_prod (ccompare_term A1_ B3_) (ccompare_term A1_ B3_))
        (foldr
          (sup_seta
             (ceq_prod (ceq_term A2_ B4_) (ceq_term A2_ B4_),
               ccompare_prod (ccompare_term A1_ B3_) (ccompare_term A1_ B3_)) o
            (fn qa =>
              h_match_probs (B3_, B4_) (A1_, A2_) (si_subst mu) l oo qa c t))
          (proper_prefix_list q)
          (set_empty
            (ceq_prod (ceq_term A2_ B4_) (ceq_term A2_ B4_),
              ccompare_prod (ccompare_term A1_ B3_) (ccompare_term A1_ B3_))
            (of_phantom (set_impl_proda set_impl_term set_impl_term))))
        (match_decision (A1_, A2_) (B1_, B2_, B3_, B4_) mu)) andalso
    not (bex (ceq_prod (ceq_ctxt A2_ B4_)
                (ceq_prod (ceq_term A2_ B4_)
                  (ceq_prod (ceq_ctxt A2_ B4_) (ceq_term A2_ B4_))),
               ccompare_prod (ccompare_ctxt A1_ B3_)
                 (ccompare_prod (ccompare_term A1_ B3_)
                   (ccompare_prod (ccompare_ctxt A1_ B3_)
                     (ccompare_term A1_ B3_))))
          let
            val p = hole_pos c;
            val n = (fn pa => n0b p pa oo);
            val ps =
              filtera
                (fn (pa, pb) =>
                  less_pos oo (append pb (power power_pos p (n pb))) andalso
                    less_pos pa p)
                (remdups (equal_prod equal_pos equal_pos) (decompositions p));
          in
            set (ceq_prod (ceq_ctxt A2_ B4_)
                   (ceq_prod (ceq_term A2_ B4_)
                     (ceq_prod (ceq_ctxt A2_ B4_) (ceq_term A2_ B4_))),
                  ccompare_prod (ccompare_ctxt A1_ B3_)
                    (ccompare_prod (ccompare_term A1_ B3_)
                      (ccompare_prod (ccompare_ctxt A1_ B3_)
                        (ccompare_term A1_ B3_))),
                  set_impl_prod set_impl_ctxt
                    (set_impl_prod set_impl_term
                      (set_impl_prod set_impl_ctxt set_impl_term)))
              (map (fn (pb, pa) =>
                     (subt_at_ctxt c pb,
                       (l, (subst_apply_ctxt c (si_subst mu),
                             subst_apply_term
                               (ctxt_subst c (si_subst mu) (n pa) t)
                               (si_subst mu)))))
                (remdups (equal_prod equal_pos equal_pos) ps))
          end
          (fn ep =>
            bex (ceq_list (ceq_prod (ceq_term A2_ B4_) (ceq_term A2_ B4_)),
                  ccompare_list
                    (ccompare_prod (ccompare_term A1_ B3_)
                      (ccompare_term A1_ B3_)))
              (set_option
                (ceq_list (ceq_prod (ceq_term A2_ B4_) (ceq_term A2_ B4_)),
                  ccompare_list
                    (ccompare_prod (ccompare_term A1_ B3_)
                      (ccompare_term A1_ B3_)),
                  set_impl_list)
                (ident_prob_of_emp (A1_, A2_) (B1_, B2_, B3_, B4_) mu ep))
              (list_all (ident_decision (A1_, A2_) (B3_, B4_) mu))));

fun n0 p q oo =
  nat (ceiling floor_ceiling_rat
        (divide_rata
          (of_nat semiring_1_rat (minus_nata (size_pos oo) (size_pos q)))
          (of_nat semiring_1_rat (size_pos p))));

fun bounded_postfixes p ps =
  map_filter (fn x => (if not (is_none x) then SOME (the x) else NONE))
    (map (pos_prefix p) ps);

fun fp_A_decide (A1_, A2_) (B1_, B2_, B3_, B4_) mu l oo q c t =
  not (bex (ceq_prod (ceq_term A2_ B4_) (ceq_term A2_ B4_),
             ccompare_prod (ccompare_term A1_ B3_) (ccompare_term A1_ B3_))
        (case subt_at t q
          of Var _ =>
            set_empty
              (ceq_prod (ceq_term A2_ B4_) (ceq_term A2_ B4_),
                ccompare_prod (ccompare_term A1_ B3_) (ccompare_term A1_ B3_))
              (of_phantom (set_impl_proda set_impl_term set_impl_term))
          | Fun (_, _) =>
            let
              val h = hole_pos c;
              val n = n0 h q oo;
              val hn = power power_pos h n;
              val cs = ctxt_subst c (si_subst mu) n t;
              val q_s = bounded_postfixes q (poss_list t);
              val qoo_s =
                maps (fn qa =>
                       map (fn a => (qa, a))
                         (prefix_list (append hn (append q qa))))
                  q_s;
              val qoo_sf =
                filtera (fn qoo => less_pos (append hn q) (append (snd qoo) oo))
                  qoo_s;
              val m1 = map (fn qoo => (subt_at cs (snd qoo), l)) qoo_sf;
              val sterms =
                remdups (equal_term A2_ B4_)
                  (map (si_subst mu) (si_W mu (subt_at t q)));
              val uterms =
                maps (filtera (fn ta => not (is_Var ta)) o supteq_list) sterms;
              val m2 =
                map (fn u => (u, l)) (remdups (equal_term A2_ B4_) uterms);
            in
              set (ceq_prod (ceq_term A2_ B4_) (ceq_term A2_ B4_),
                    ccompare_prod (ccompare_term A1_ B3_)
                      (ccompare_term A1_ B3_),
                    set_impl_prod set_impl_term set_impl_term)
                (m1 @ m2)
            end)
        (match_decision (A1_, A2_) (B1_, B2_, B3_, B4_) mu));

fun fp_decide (A1_, A2_) (B1_, B2_, B3_, B4_) mu =
  (fn (q, (c, t)) => fn (l, (la, loc)) =>
    (if equal_locationa loc H
      then fp_H_decide (A1_, A2_) (B1_, B2_, B3_, B4_) mu (ctxt_apply_term l la)
             (hole_pos l) q c t
      else true) andalso
      ((if equal_locationa loc A
         then fp_A_decide (A1_, A2_) (B1_, B2_, B3_, B4_) mu
                (ctxt_apply_term l la) (hole_pos l) q c t
         else true) andalso
        ((if equal_locationa loc Ba
           then fp_B_decide (A1_, A2_) (B1_, B2_, B3_, B4_) mu
                  (ctxt_apply_term l la) (hole_pos l) q c t
           else true) andalso
          (if equal_locationa loc Ra
            then fp_R_decide (A1_, A2_) (B1_, B2_, B3_, B4_) mu
                   (ctxt_apply_term l la) (hole_pos l) q c t
            else true))));

fun fp_valid (A1_, A2_) (B1_, B2_) (C1_, C2_) p =
  ball (ceq_prod (ceq_ctxt A2_ B2_) (ceq_prod (ceq_term A2_ B2_) C1_),
         ccompare_prod (ccompare_ctxt A1_ B1_)
           (ccompare_prod (ccompare_term A1_ B1_) C2_))
    p (fn (l, (la, _)) => not (is_Var (ctxt_apply_term l la)));

fun check_fploop (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) r p
  (FP_loop_prf (c, sigma, t, seq)) =
  let
    val mu = subst_incr (B1_, B2_, B4_, B6_) A2_ sigma;
    val mua = si_subst mu;
  in
    bindb (check (not (null seq))
            (shows_prec_list show_char zero_nata
              [#"l", #"o", #"o", #"p", #"i", #"n", #"g", #" ", #"r", #"e", #"d",
                #"u", #"c", #"t", #"i", #"o", #"n", #" ", #"m", #"u", #"s",
                #"t", #" ", #"n", #"o", #"t", #" ", #"b", #"e", #" ", #"e",
                #"m", #"p", #"t", #"y"]))
      (fn _ =>
        bindb (check
                (equal_terma A2_ B4_ let
                                       val (_, (_, ta)) = last seq;
                                     in
                                       ta
                                     end
                  (ctxt_apply_term c (subst_apply_term t mua)))
                (shows_prec_list show_char zero_nata
                  [#"l", #"a", #"s", #"t", #" ", #"t", #"e", #"r", #"m", #" ",
                    #"i", #"n", #" ", #"s", #"e", #"q", #"u", #"e", #"n", #"c",
                    #"e", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"C",
                    #"[", #"t", #" ", #"s", #"i", #"g", #"m", #"a", #"]"]))
          (fn _ =>
            bindb (check
                    (fp_valid (A1_, A2_) (B3_, B4_)
                      (ceq_location, ccompare_location)
                      (set (ceq_prod (ceq_ctxt A2_ B4_)
                              (ceq_prod (ceq_term A2_ B4_) ceq_location),
                             ccompare_prod (ccompare_ctxt A1_ B3_)
                               (ccompare_prod (ccompare_term A1_ B3_)
                                 ccompare_location),
                             set_impl_prod set_impl_ctxt
                               (set_impl_prod set_impl_term set_impl_location))
                        p))
                    (shows_prec_list show_char zero_nata
                      [#"l", #"h", #"s", #"s", #" ", #"i", #"n", #" ", #"f",
                        #"o", #"r", #"b", #"i", #"d", #"d", #"e", #"n", #" ",
                        #"p", #"a", #"t", #"t", #"e", #"r", #"n", #"s", #" ",
                        #"m", #"u", #"s", #"t", #" ", #"n", #"o", #"t", #" ",
                        #"b", #"e", #" ", #"v", #"a", #"r", #"i", #"a", #"b",
                        #"l", #"e", #"s"]))
              (fn _ =>
                bindb (catch_errora
                        (forallM
                          (fn (l, _) =>
                            check (not (is_Var l))
                              (shows_prec_list show_char zero_nata
                                [#"l", #"h", #"s", #"s", #" ", #"o", #"f", #" ",
                                  #"T", #"R", #"S", #" ", #"m", #"u", #"s",
                                  #"t", #" ", #"n", #"o", #"t", #" ", #"b",
                                  #"e", #" ", #"v", #"a", #"r", #"i", #"a",
                                  #"b", #"l", #"e", #"s"]))
                          r)
                        (fn x => Inl (snd x)))
                  (fn _ =>
                    let
                      val seqa = zip (t :: map (fn (_, (_, ta)) => ta) seq) seq;
                    in
                      catch_errora
                        (forallM
                          (fn (ta, (q, (ra, s))) =>
                            bindb (check_rstep (A2_, A3_) (B2_, B4_, B5_, B7_) r
                                    q ra ta s)
                              (fn _ =>
                                let
                                  val check_fpstep =
                                    fp_decide (A1_, A2_) (B1_, B2_, B3_, B4_) mu
                                      (q, (c, ta));
                                in
                                  catch_errora
                                    (forallM
                                      (fn pt =>
check (check_fpstep pt)
  (shows_prec_list show_char zero_nata
     [#"i", #"t", #"e", #"r", #"a", #"t", #"i", #"n", #"g", #" ", #"r", #"e",
       #"d", #"u", #"c", #"t", #"i", #"o", #"n", #" "] o
    (shows_prec_term A3_ B7_ zero_nata ta o
      (shows_prec_list show_char zero_nata [#" ", #"-", #"-", #">"] o
        (shows_prec_pos zero_nata q o
          (shows_prec_list show_char zero_nata [#" "] o
            (shows_prec_term A3_ B7_ zero_nata s o
              (shows_prec_list show_char zero_nata
                 [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ",
                   #"r", #"e", #"s", #"p", #"e", #"c", #"t", #" ", #"f", #"o",
                   #"r", #"b", #"i", #"d", #"d", #"e", #"n", #" ", #"p", #"a",
                   #"t", #"t", #"e", #"r", #"n", #" "] o
                shows_pattern A3_ B7_ pt))))))))
                                      p)
                                    (fn x => Inl (snd x))
                                end))
                          seqa)
                        (fn x => Inl (snd x))
                    end))))
  end;

fun check_fp_tp_subsumes (A1_, A2_, A3_) (B1_, B2_, B3_) ta t =
  let
    val ((p, r), (pa, ra)) = (ta, t);
  in
    catch_errora
      (bindb
        (check
          (equal_lista
            (equal_prod (equal_ctxt (equal_lab A1_ B1_) (equal_list equal_char))
              (equal_prod
                (equal_term (equal_lab A1_ B1_) (equal_list equal_char))
                equal_location))
            p pa)
          (shows_prec_list show_char zero_nata
            [#"d", #"i", #"f", #"f", #"e", #"r", #"e", #"n", #"c", #"e", #" ",
              #"i", #"n", #" ", #"f", #"o", #"r", #"b", #"i", #"d", #"d", #"e",
              #"n", #" ", #"p", #"a", #"t", #"t", #"e", #"r", #"n", #"s", #" ",
              #"s", #"t", #"r", #"a", #"t", #"e", #"g", #"y"]))
        (fn _ =>
          catch_errora
            (check_subseteq
              (equal_prod
                (equal_term (equal_lab A1_ B1_) (equal_list equal_char))
                (equal_term (equal_lab A1_ B1_) (equal_list equal_char)))
              r ra)
            (fn x =>
              Inl (toomuch [#"r", #"u", #"l", #"e"]
                    (shows_rule (shows_prec_lab A3_ B3_ zero_nata)
                      (shows_prec_list show_char zero_nata)
                      [#" ", #"-", #">", #" "] x)))))
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                 #" ", #"s", #"h", #"o", #"w", #"i", #"n", #"g", #" ", #"s",
                 #"u", #"b", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n",
                 #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"t",
                 #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n"] o
              (shows_nl o x)))
  end;

fun string_reversal_complete_tt B_ C_ i tp =
  let
    val r = rulesd i tp;
  in
    bindb (check (q_emptyb i tp)
            (shows_prec_list show_char zero_nata
              [#"Q", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"e", #"m",
                #"p", #"t", #"y"]))
      (fn _ =>
        bindb (check_unary_signature B_ C_ r)
          (fn _ => Inr (mkc i default_nfs_nt_trs [] (map rev_rule r) [])))
  end;

fun show_ta A_ B_ (Tree_Automaton (fin, rules, eps)) =
  shows_prec_list show_char zero_nata
    [#"f", #"i", #"n", #"a", #"l", #":", #" "] o
    shows_prec_list A_ zero_nata fin o
    shows_nl o
    shows_prec_list show_char zero_nata
      [#"r", #"u", #"l", #"e", #"s", #":", #" "] o
    shows_lines (show_ta_rule A_ B_) rules o
    shows_nl o
    shows_prec_list show_char zero_nata
      [#"e", #"p", #"s", #"i", #"l", #"o", #"n", #":", #" "] o
    shows_prec_list (show_prod A_ A_) zero_nata eps o
    shows_nl;

fun shows_prec_tree_automaton A_ B_ d r = show_ta A_ B_ r;

fun ta_idx_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = idx;

fun comp_res_of_order Eq = EQUAL
  | comp_res_of_order Lt = LESS
  | comp_res_of_order Gt = GREATER;

fun compare_res A_ x y = comp_res_of_order (compare A_ x y);

fun set_iterator_image g it = (fn c => fn f => it c (fn x => f (g x)));

fun map_iterator_dom it = set_iterator_image fst it;

fun list_eq eq [] [] = true
  | list_eq eq (aa :: la) (a :: l) =
    (if eq aa a then list_eq eq la l else false)
  | list_eq uu (v :: va) [] = false
  | list_eq uu [] (v :: va) = false;

fun rule_filter_opt_code A_ B_ a b c =
  (case rbt_comp_lookup (compare_proda (compare_compare_order B_) compare_nat)
          (ta_idx_impl a) (b, size_list c)
    of NONE => Emptya
    | SOME xc =>
      gen_image (map_iterator_dom o rm_iterateoi) Emptya
        (fn k => rbt_comp_insert (compare (compare_compare_order A_)) k ()) snd
        (gen_filter (map_iterator_dom o rm_iterateoi) Emptya
          (fn k =>
            rbt_comp_insert
              (compare_proda (compare_list (compare_compare_order A_))
                (compare_compare_order A_))
              k ())
          (fn (xd, _) =>
            list_eq (comp2eq (compare_res (compare_compare_order A_))) xd c)
          xc));

fun ta_rhs_states_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = rhs;

fun update_all_code A_ m s v =
  (map_iterator_dom o rm_iterateoi) s (fn _ => true)
    (fn x => rbt_comp_insert (compare A_) x v) m;

fun update_all2_code A_ B_ m s1 s2 v =
  (map_iterator_dom o rm_iterateoi) s1 (fn _ => true)
    (fn x => fn sigma =>
      let
        val xa =
          update_all_code B_
            (case rbt_comp_lookup (compare A_) sigma x of NONE => Emptya
              | SOME a => id a)
            s2 v;
      in
        rbt_comp_insert (compare A_) x xa sigma
      end)
    m;

fun union_image_rs_code A_ B_ s f =
  (map_iterator_dom o rm_iterateoi) s (fn _ => true)
    (fn x =>
      rbt_comp_union_with_key (compare B_) (fn _ => fn _ => fn rv => rv) (f x))
    Emptya;

fun ta_eps_cl_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) q = efcl q;

fun ta_match_var_ref_code A_ B_ C_ ta qsig x q =
  (map_iterator_dom o rm_iterateoi) qsig (fn _ => true)
    (fn xa => fn sigma =>
      (if not (gen_disjoint (map_iterator_dom o rm_iterateoi)
                (fn k => fn s =>
                  (case rbt_comp_lookup (compare (compare_compare_order A_)) s k
                    of NONE => false | SOME _ => true))
                (ta_eps_cl_impl ta xa) q)
        then rbt_comp_insert
               (compare_lista (compare_prod C_ (compare_compare_order A_)))
               [(x, xa)] () sigma
        else sigma))
    Emptya;

fun set_App_code A_ x xs =
  (map_iterator_dom o rm_iterateoi) x (fn _ => true)
    (fn xa =>
      (map_iterator_dom o rm_iterateoi) xs (fn _ => true)
        (fn xaa => rbt_comp_insert (compare_lista A_) (xa @ xaa) ()))
    Emptya;

fun concat_listset_code A_ =
  rec_list (rbt_comp_insert (compare_lista A_) [] () Emptya)
    (fn x => fn _ => set_App_code A_ x);

fun map2 f [] ys = []
  | map2 f (v :: va) [] = []
  | map2 f (x :: xs) (y :: ys) = f x y :: map2 f xs ys;

fun ta_match_code A_ B_ C_ ta qsig (Var x) q =
  ta_match_var_ref_code A_ B_ C_ ta qsig x q
  | ta_match_code A_ B_ C_ a b (Fun (c, d)) e =
    (case rbt_comp_lookup (compare_proda (compare_compare_order B_) compare_nat)
            (ta_idx_impl a) (c, size_list d)
      of NONE => Emptya
      | SOME xe =>
        union_image_rs_code
          (compare_prod (compare_list (compare_compare_order A_))
            (compare_compare_order A_))
          (compare_list (compare_prod C_ (compare_compare_order A_))) xe
          (fn (xf, xg) =>
            (if not (gen_disjoint (map_iterator_dom o rm_iterateoi)
                      (fn k => fn s =>
                        (case rbt_comp_lookup
                                (compare (compare_compare_order A_)) s k
                          of NONE => false | SOME _ => true))
                      (ta_eps_cl_impl a xg) e)
              then concat_listset_code
                     (compare_prod C_ (compare_compare_order A_))
                     (map2 (fn t => fn q =>
                             ta_match_code A_ B_ C_ a b t
                               (rbt_comp_insert
                                 (compare (compare_compare_order A_)) q ()
                                 Emptya))
                       d xf)
              else Emptya)));

fun ta_res_args_aux_code A_ B_ =
  (fn x => fn xa => fn xb =>
    (case rbt_comp_lookup (compare_proda (compare_compare_order B_) compare_nat)
            (ta_idx_impl x) (xa, size_list xb)
      of NONE => Emptya
      | SOME xc =>
        union_image_rs_code
          (compare_prod (compare_list (compare_compare_order A_))
            (compare_compare_order A_))
          (compare_compare_order A_) xc
          (fn (xd, xe) =>
            (if list_all2
                  (fn xf => fn s =>
                    (case rbt_comp_lookup (compare (compare_compare_order A_)) s
                            xf
                      of NONE => false | SOME _ => true))
                  xd xb
              then ta_eps_cl_impl x xe else Emptya))));

fun ta_res_code A_ B_ =
  (fn x => fn xa =>
    rec_term (fn xb => fn xc => ta_eps_cl_impl xc xb)
      (fn xb => fn xc => fn xd => let
                                    val a = map (fn xe => snd xe xd) xc;
                                  in
                                    ta_res_args_aux_code A_ B_ xd xb a
                                  end)
      xa x);

fun is_compatible_code A_ B_ (C1_, C2_) ta r =
  (map_iterator_dom o rm_iterateoi) r is_Inr
    (fn x => fn sigma =>
      let
        val (a, b) = x;
        val xa =
          ta_match_code A_ B_ C1_ ta (ta_rhs_states_impl ta) a
            (ta_rhs_states_impl ta);
      in
        (map_iterator_dom o rm_iterateoi) xa is_Inr
          (fn xb => fn sigmaa =>
            let
              val xc = map_term (fn xh => xh) (fun_of C2_ xb) a;
              val xd = ta_res_code A_ B_ ta xc;
            in
              (if gen_isEmptya (gen_balla (map_iterator_dom o rm_iterateoi)) xd
                then sigmaa
                else let
                       val xe = map_term (fn xj => xj) (fun_of C2_ xb) b;
                       val xf = ta_res_code A_ B_ ta xe;
                     in
                       (if gen_isEmptya
                             (gen_balla (map_iterator_dom o rm_iterateoi)) xf
                         then let
                                val xg =
                                  gen_pick (map_iterator_dom o rm_iterateoi) xd;
                              in
                                Inl (xg, (xc, xe))
                              end
                         else let
                                val aa =
                                  update_all2_code (compare_compare_order A_)
                                    (compare_compare_order A_) (projr sigmaa) xd
                                    xf (xc, xe);
                              in
                                Inr aa
                              end)
                     end)
            end)
          sigma
      end)
    (Inr Emptya);

fun ta_rules_impla (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = r;

fun ta_final_impla (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = f;

fun ta_idx_rhs_init_code A_ B_ C_ det rs efcl =
  (map_iterator_dom o rm_iterateoi) rs (fn _ => true)
    (fn x => fn (a, (aa, ba)) =>
      let
        val TA_rule (xg, xh, xi) = x;
        val xj = size_list xh;
      in
        (case rbt_comp_lookup (compare_proda B_ compare_nat) a (xg, xj)
          of NONE =>
            (rbt_comp_insert (compare_proda B_ compare_nat) (xg, xj)
               (rbt_comp_insert (compare_proda (compare_list A_) A_) (xh, xi) ()
                 Emptya)
               a,
              (aa, rbt_comp_union_with_key (compare C_)
                     (fn _ => fn _ => fn rv => rv) (efcl xi) ba))
          | SOME xk =>
            (rbt_comp_insert (compare_proda B_ compare_nat) (xg, xj)
               (rbt_comp_insert (compare_proda (compare_list A_) A_) (xh, xi) ()
                 xk)
               a,
              ((if aa
                 then gen_balla (map_iterator_dom o rm_iterateoi) xk
                        (fn (xl, _) =>
                          not (list_eq (comp2eq (compare_res A_)) xh xl))
                 else false),
                rbt_comp_union_with_key (compare C_)
                  (fn _ => fn _ => fn rv => rv) (efcl xi) ba)))
      end)
    (Emptya, (det, Emptya));

fun prod_eq eqa eqb x1 x2 = let
                              val (a1, b1) = x1;
                              val (a2, b2) = x2;
                            in
                              eqa a1 a2 andalso eqb b1 b2
                            end;

fun glist_member eq x [] = false
  | glist_member eq x (y :: ys) = eq x y orelse glist_member eq x ys;

fun glist_insert eq x xs = (if glist_member eq x xs then xs else x :: xs);

fun ta_make_code A_ B_ C_ f r e =
  let
    val a =
      ta_idx_rhs_init_code (compare_compare_order B_) C_
        (compare_compare_order B_) (is_Nil e) r
        (fn xi =>
          impl_of (linorder_compare_order B_) (memo_rbt_rtrancl B_ e xi));
    val (ab, (aa, ba)) = a;
  in
    (f, (r, (e, (ba, (ab, (aa, ((fn s =>
                                  impl_of (linorder_compare_order B_)
                                    (memo_rbt_rtrancl B_ e s)),
                                 (fn s =>
                                   impl_of (linorder_compare_order B_)
                                     (memo_rbt_rtrancl B_
                                       (gen_image foldli []
 (glist_insert
   (prod_eq (comp2eq (compare_res (compare_compare_order B_)))
     (comp2eq (compare_res (compare_compare_order B_)))))
 (fn xc => (snd xc, fst xc)) e)
                                       s)))))))))
  end;

fun ta_eps_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = e;

fun is_None a = (case a of NONE => true | SOME _ => false);

fun ta_only_res_wits_code A_ B_ a b =
  let
    val xb =
      gen_filter (map_iterator_dom o rm_iterateoi) Emptya
        (fn k => rbt_comp_insert (compare (compare_compare_order A_)) k ())
        (fn xb =>
          not (is_None
                (rbt_comp_lookup (compare (compare_compare_order A_)) b xb)))
        (ta_final_impla a);
    val xc =
      gen_filter (map_iterator_dom o rm_iterateoi) Emptya
        (fn k =>
          rbt_comp_insert
            (compare_ta_rule (compare_compare_order A_)
              (compare_compare_order B_))
            k ())
        (fn xc =>
          list_all_rec
            (fn xd =>
              not (is_None
                    (rbt_comp_lookup (compare (compare_compare_order A_)) b
                      xd)))
            (r_lhs_states xc))
        (ta_rules_impla a);
    val aa =
      filtera
        (fn xd =>
          not (is_None
                (rbt_comp_lookup (compare (compare_compare_order A_)) b
                  (fst xd))))
        (ta_eps_impl a);
  in
    ta_make_code (compare_compare_order A_) A_ (compare_compare_order B_) xb xc
      aa
  end;

fun ta_only_prs_wits_code A_ B_ a b =
  let
    val xb =
      gen_filter (map_iterator_dom o rm_iterateoi) Emptya
        (fn k => rbt_comp_insert (compare (compare_compare_order A_)) k ())
        (fn xb =>
          not (is_None
                (rbt_comp_lookup (compare (compare_compare_order A_)) b xb)))
        (ta_final_impla a);
    val xc =
      gen_filter (map_iterator_dom o rm_iterateoi) Emptya
        (fn k =>
          rbt_comp_insert
            (compare_ta_rule (compare_compare_order A_)
              (compare_compare_order B_))
            k ())
        (fn xc =>
          not (is_None
                (rbt_comp_lookup (compare (compare_compare_order A_)) b
                  (r_rhs xc))))
        (ta_rules_impla a);
    val aa =
      filtera
        (fn xd =>
          not (is_None
                (rbt_comp_lookup (compare (compare_compare_order A_)) b
                  (snd xd))))
        (ta_eps_impl a);
  in
    ta_make_code (compare_compare_order A_) A_ (compare_compare_order B_) xb xc
      aa
  end;

fun next_res_wit_code A_ B_ r m =
  (map_iterator_dom o rm_iterateoi) r is_None
    (fn x => fn _ =>
      let
        val TA_rule (xb, xc, xd) = x;
      in
        bind (mapMa (rbt_comp_lookup (compare A_) m) xc)
          (fn xe => SOME (xd, Fun (xb, xe)))
      end)
    NONE;

fun res_wits_code A_ B_ tAi =
  let
    val x = (ta_rules_impla tAi, Emptya);
    val (_, b) =
      whilea
        (fn (xc, _) =>
          not (gen_isEmptya (gen_balla (map_iterator_dom o rm_iterateoi)) xc))
        (fn (a, b) =>
          (case next_res_wit_code (compare_compare_order A_)
                  (compare_compare_order B_) a b
            of NONE => (Emptya, b)
            | SOME (aa, ba) =>
              let
                val xd = ta_eps_cl_impl tAi aa;
                val xe = update_all_code (compare_compare_order A_) b xd ba;
                val xf =
                  gen_filter (map_iterator_dom o rm_iterateoi) Emptya
                    (fn k =>
                      rbt_comp_insert
                        (compare_ta_rule (compare_compare_order A_)
                          (compare_compare_order B_))
                        k ())
                    (fn xi =>
                      not (case rbt_comp_lookup
                                  (compare (compare_compare_order A_)) xd
                                  (r_rhs xi)
                            of NONE => false | SOME _ => true))
                    a;
              in
                (xf, xe)
              end))
        x;
  in
    b
  end;

fun ta_eps_icl_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) q = eicl q;

fun prs_wits_code A_ B_ tAi =
  let
    val x =
      update_all_code (compare_compare_order A_) Emptya
        (union_image_rs_code (compare_compare_order A_)
          (compare_compare_order A_) (ta_final_impla tAi) (ta_eps_icl_impl tAi))
        Hole;
    val xa = (false, (ta_rules_impla tAi, x));
    val (_, (_, ba)) =
      whilea (fn (xd, (_, _)) => not xd)
        (fn (_, (aa, ba)) =>
          (map_iterator_dom o rm_iterateoi) aa (fn _ => true)
            (fn xc => fn (ab, (ac, bc)) =>
              (case rbt_comp_lookup (compare (compare_compare_order A_)) bc
                      (r_rhs xc)
                of NONE =>
                  (ab, (rbt_comp_insert
                          (compare_ta_rule (compare_compare_order A_)
                            (compare_compare_order B_))
                          xc () ac,
                         bc))
                | SOME xd =>
                  (false,
                    (ac, let
                           val TA_rule (xl, xm, _) = xc;
                         in
                           rec_list
                             (fn _ => fn xp => fn _ => fn _ => fn _ => xp)
                             (fn xo => fn xp => fn xq => fn xr => fn xs =>
                               fn xt => fn xu => fn xv =>
                               let
                                 val xw =
                                   update_all_code (compare_compare_order A_) xs
                                     (ta_eps_icl_impl xr (the_Var xo))
                                     (ctxt_compose xt
                                       (More (xu, xv, Hole, xp)));
                               in
                                 xq xr xw xt xu (xv @ [xo])
                               end)
                             (map Var xm) tAi bc xd xl []
                         end))))
            (true, (Emptya, ba)))
        xa;
  in
    ba
  end;

fun trim_ta_wits_code A_ B_ tAi = let
                                    val x = res_wits_code A_ B_ tAi;
                                    val xa = ta_only_res_wits_code A_ B_ tAi x;
                                    val xb = prs_wits_code A_ B_ xa;
                                    val xc = ta_only_prs_wits_code A_ B_ xa xb;
                                  in
                                    (xc, (x, xb))
                                  end;

fun is_coh_final_code A_ fin rel =
  rm_iterateoi rel is_None
    (fn x => fn _ =>
      let
        val (a, b) = x;
      in
        (if (case rbt_comp_lookup (compare A_) fin a of NONE => false
              | SOME _ => true)
          then rm_iterateoi b is_None
                 (fn xa => fn _ =>
                   let
                     val (aa, (ab, bb)) = xa;
                   in
                     (if (case rbt_comp_lookup (compare A_) fin aa
                           of NONE => false | SOME _ => true)
                       then NONE else SOME (ab, bb))
                   end)
                 NONE
          else NONE)
      end)
    NONE;

fun map_add2_code A_ B_ m1 m2 =
  rm_iterateoi m2 (fn _ => true)
    (fn x => fn sigma =>
      let
        val (a, b) = x;
      in
        (case rbt_comp_lookup (compare A_) sigma a
          of NONE => rbt_comp_insert (compare A_) a b sigma
          | SOME xc =>
            rbt_comp_insert (compare A_) a
              (rbt_comp_union_with_key (compare B_)
                (fn _ => fn _ => fn rv => rv) xc b)
              sigma)
      end)
    m1;

fun ta_check_comcoh_code A_ B_ (C1_, C2_) ta r =
  let
    val a = trim_ta_wits_code A_ B_ ta;
    val (ab, (aa, ba)) = a;
    val xa = is_compatible_code A_ B_ (C1_, C2_) ab r;
    val xb =
      (fn xf => fn xg =>
        subst_apply_term
          (ctxt_apply_term
            (the (rbt_comp_lookup (compare (compare_compare_order A_)) ba xf))
            xg)
          (fn xh =>
            the (rbt_comp_lookup (compare (compare_compare_order A_)) aa xh)));
  in
    (case xa of Inl (aba, (ac, bc)) => SOME (xb aba ac, xb aba bc)
      | Inr ra =>
        (case let
                val (aba, bb) =
                  whilea
                    (fn ac =>
                      (case ac of (Inl _, _) => false
                        | (Inr xk, _) =>
                          not (gen_isEmpty (gen_ball rm_iterateoi) xk)))
                    (fn (aba, bb) =>
                      let
                        val xd =
                          (map_iterator_dom o rm_iterateoi) (ta_rules_impla ab)
                            is_Inr
                            (fn xd => fn sigma =>
                              let
                                val TA_rule (xe, y, z) = xd;
                              in
                                foldli (upt zero_nata (size_list y)) is_Inr
                                  (fn xf => fn s =>
                                    let
                                      val xg = nth y xf;
                                    in
                                      (case
rbt_comp_lookup (compare (compare_compare_order A_)) (projr aba) xg of NONE => s
| SOME xh =>
  rm_iterateoi xh is_Inr
    (fn xi => fn sigmaa =>
      let
        val (ac, (ad, bd)) = xi;
        val xj = map Var (take xf y);
        val xk = map Var (drop (suc xf) y);
        val xl = Fun (xe, xj @ ad :: xk);
        val xm = Fun (xe, xj @ bd :: xk);
        val xn = list_update y xf ac;
        val xo = rule_filter_opt_code A_ B_ ab xe xn;
      in
        (if gen_isEmptya (gen_balla (map_iterator_dom o rm_iterateoi)) xo
          then Inl (z, (xl, xm))
          else let
                 val xp =
                   gen_filter (map_iterator_dom o rm_iterateoi) Emptya
                     (fn k =>
                       rbt_comp_insert (compare (compare_compare_order A_)) k
                         ())
                     (fn yd =>
                       is_None
                         (bind (rbt_comp_lookup
                                 (compare (compare_compare_order A_)) bb z)
                           (fn ye =>
                             rbt_comp_lookup
                               (compare (compare_compare_order A_)) ye yd)))
                     xo;
               in
                 (if gen_isEmptya (gen_balla (map_iterator_dom o rm_iterateoi))
                       xp
                   then sigmaa
                   else Inr (update_all2_code (compare_compare_order A_)
                              (compare_compare_order A_) (projr sigmaa)
                              (rbt_comp_insert
                                (compare (compare_compare_order A_)) z ()
                                Emptya)
                              xp (xl, xm)))
               end)
      end)
    s)
                                    end)
                                  sigma
                              end)
                            (Inr Emptya);
                      in
                        (if is_Inr xd
                          then (xd, map_add2_code (compare_compare_order A_)
                                      (compare_compare_order A_) bb (projr xd))
                          else (xd, bb))
                      end)
                    (Inr ra, ra);
              in
                (if is_Inr aba then Inr bb else aba)
              end
          of Inl (aba, (ac, bc)) => SOME (xb aba ac, xb aba bc)
          | Inr raa =>
            (case is_coh_final_code (compare_compare_order A_)
                    (ta_final_impla ab) raa
              of NONE => NONE
              | SOME (aba, bb) =>
                SOME (subst_apply_term aba
                        (fn xk =>
                          the (rbt_comp_lookup
                                (compare (compare_compare_order A_)) aa xk)),
                       subst_apply_term bb
                         (fn xk =>
                           the (rbt_comp_lookup
                                 (compare (compare_compare_order A_)) aa
                                 xk))))))
  end;

fun rep_ta_code B_ A_ (Abs_ta_code x) = x;

fun check_comcoh_wit A_ B_ (C1_, C2_) x xa =
  ta_check_comcoh_code A_ B_ (compare_compare_order C1_, C2_)
    (rep_ta_code A_ B_ x)
    (impl_of
      (linorder_prod
        (linorder_term (compare_compare_order B_) (compare_compare_order C1_))
        (linorder_term (compare_compare_order B_) (compare_compare_order C1_)))
      xa);

fun check_comcoh_wit_ls A_ B_ (C1_, C2_) ta r =
  check_comcoh_wit A_ B_ (C1_, C2_) ta
    (g_from_list_dflt_basic_oops_rm_basic_ops
      (compare_order_prod
        (compare_order_term (compare_compare_order B_)
          (compare_compare_order C1_))
        (compare_order_term (compare_compare_order B_)
          (compare_compare_order C1_)))
      r);

fun ta_make_ls_code A_ B_ =
  (fn x => fn xa => fn xb =>
    ta_make_code (compare_compare_order A_) A_ (compare_compare_order B_)
      (gen_set Emptya
        (fn k => rbt_comp_insert (compare (compare_compare_order A_)) k ()) x)
      (gen_set Emptya
        (fn k =>
          rbt_comp_insert
            (compare_ta_rule (compare_compare_order A_)
              (compare_compare_order B_))
            k ())
        xa)
      (gen_set []
        (glist_insert
          (prod_eq (comp2eq (compare_res (compare_compare_order A_)))
            (comp2eq (compare_res (compare_compare_order A_)))))
        xb));

fun make_ls A_ B_ x xa xb = Abs_ta_code (ta_make_ls_code A_ B_ x xa xb);

fun ta_code_make_impl A_ B_ (Tree_Automaton (fin, rs, eps)) =
  make_ls A_ B_ fin rs eps;

fun ta_rhs_states (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) ta =
  sup_seta (A2_, A3_)
    (image (ceq_ta_rule A4_ B2_, ccompare_ta_rule A3_ B1_) (A2_, A3_, A5_) r_rhs
      (ta_rules ta))
    (compute_trancl (A1_, A2_, A3_, A5_)
      (image (ceq_ta_rule A4_ B2_, ccompare_ta_rule A3_ B1_) (A2_, A3_, A5_)
        r_rhs (ta_rules ta))
      (ta_eps ta));

fun initial_rel (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_)
  (C1_, C2_, C3_, C4_, C5_, C6_, C7_) ta r =
  let
    val rhs =
      ta_rhs_states (A2_, A3_, ccompare_cproper_interval A4_, A5_, A6_)
        (B1_, B3_) ta;
    val match =
      ta_matcha (A2_, A3_, ccompare_cproper_interval A4_, A5_, A6_) (B1_, B3_)
        (C3_, ccompare_cproper_interval C4_) ta rhs;
    val analyze_rule =
      (fn (l, ra) =>
        let
          val _ = vars_term (B2_, B3_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_) l;
        in
          sup_setb
            (finite_UNIV_prod (finite_UNIV_card_UNIV A1_)
               (finite_UNIV_set (finite_UNIV_card_UNIV A1_)),
              cenum_prod A2_
                (cenum_set (A2_, A3_, ccompare_cproper_interval A4_, A6_)),
              ceq_prod A3_ (ceq_set (A2_, A3_, ccompare_cproper_interval A4_)),
              cproper_interval_prod A4_
                (cproper_interval_set (A1_, A3_, A4_, A6_)),
              set_impl_prod A6_ set_impl_set)
            (image
              (ceq_list (ceq_prod C3_ A3_),
                ccompare_list
                  (ccompare_prod (ccompare_cproper_interval C4_)
                    (ccompare_cproper_interval A4_)))
              (ceq_set
                 (cenum_prod A2_
                    (cenum_set (A2_, A3_, ccompare_cproper_interval A4_, A6_)),
                   ceq_prod A3_
                     (ceq_set (A2_, A3_, ccompare_cproper_interval A4_)),
                   ccompare_cproper_interval
                     (cproper_interval_prod A4_
                       (cproper_interval_set (A1_, A3_, A4_, A6_)))),
                ccompare_set
                  (finite_UNIV_prod (finite_UNIV_card_UNIV A1_)
                     (finite_UNIV_set (finite_UNIV_card_UNIV A1_)),
                    ceq_prod A3_
                      (ceq_set (A2_, A3_, ccompare_cproper_interval A4_)),
                    cproper_interval_prod A4_
                      (cproper_interval_set (A1_, A3_, A4_, A6_)),
                    set_impl_prod A6_ set_impl_set),
                set_impl_set)
              (fn sigma =>
                let
                  val qr =
                    ta_res (A2_, A3_, ccompare_cproper_interval A4_, A5_, A6_)
                      (B1_, B3_) ta
                      (map_term (fn x => x) (fun_of C6_ sigma) ra);
                in
                  image (A3_, ccompare_cproper_interval A4_)
                    (ceq_prod A3_
                       (ceq_set (A2_, A3_, ccompare_cproper_interval A4_)),
                      ccompare_prod (ccompare_cproper_interval A4_)
                        (ccompare_set
                          (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_)),
                      set_impl_prod A6_ set_impl_set)
                    (fn q => (q, qr))
                    (ta_res (A2_, A3_, ccompare_cproper_interval A4_, A5_, A6_)
                      (B1_, B3_) ta (map_term (fn x => x) (fun_of C6_ sigma) l))
                end)
              (match l))
        end);
  in
    sup_setb
      (finite_UNIV_prod (finite_UNIV_card_UNIV A1_)
         (finite_UNIV_set (finite_UNIV_card_UNIV A1_)),
        cenum_prod A2_
          (cenum_set (A2_, A3_, ccompare_cproper_interval A4_, A6_)),
        ceq_prod A3_ (ceq_set (A2_, A3_, ccompare_cproper_interval A4_)),
        cproper_interval_prod A4_ (cproper_interval_set (A1_, A3_, A4_, A6_)),
        set_impl_prod A6_ set_impl_set)
      (image
        (ceq_prod (ceq_term B3_ C6_) (ceq_term B3_ C6_),
          ccompare_prod (ccompare_term B2_ C5_) (ccompare_term B2_ C5_))
        (ceq_set
           (cenum_prod A2_
              (cenum_set (A2_, A3_, ccompare_cproper_interval A4_, A6_)),
             ceq_prod A3_ (ceq_set (A2_, A3_, ccompare_cproper_interval A4_)),
             ccompare_cproper_interval
               (cproper_interval_prod A4_
                 (cproper_interval_set (A1_, A3_, A4_, A6_)))),
          ccompare_set
            (finite_UNIV_prod (finite_UNIV_card_UNIV A1_)
               (finite_UNIV_set (finite_UNIV_card_UNIV A1_)),
              ceq_prod A3_ (ceq_set (A2_, A3_, ccompare_cproper_interval A4_)),
              cproper_interval_prod A4_
                (cproper_interval_set (A1_, A3_, A4_, A6_)),
              set_impl_prod A6_ set_impl_set),
          set_impl_set)
        analyze_rule r)
  end;

fun initial_relation (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_)
  (C1_, C2_, C3_, C4_, C5_, C6_, C7_) ta r =
  let
    val q_qs =
      initial_rel (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_)
        (C1_, C2_, C3_, C4_, C5_, C6_, C7_) ta r;
  in
    (if member
          (ceq_set (A2_, A3_, ccompare_cproper_interval A4_),
            ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_))
          (bot_set (A3_, ccompare_cproper_interval A4_, A6_))
          (image
            (ceq_prod A3_ (ceq_set (A2_, A3_, ccompare_cproper_interval A4_)),
              ccompare_prod (ccompare_cproper_interval A4_)
                (ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_)))
            (ceq_set (A2_, A3_, ccompare_cproper_interval A4_),
              ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_),
              set_impl_set)
            snd q_qs)
      then NONE
      else SOME (sup_setb
                  (finite_UNIV_prod (finite_UNIV_card_UNIV A1_)
                     (finite_UNIV_card_UNIV A1_),
                    cenum_prod A2_ A2_, ceq_prod A3_ A3_,
                    cproper_interval_prod A4_ A4_, set_impl_prod A6_ A6_)
                  (image
                    (ceq_prod A3_
                       (ceq_set (A2_, A3_, ccompare_cproper_interval A4_)),
                      ccompare_prod (ccompare_cproper_interval A4_)
                        (ccompare_set
                          (finite_UNIV_card_UNIV A1_, A3_, A4_, A6_)))
                    (ceq_set
                       (cenum_prod A2_ A2_, ceq_prod A3_ A3_,
                         ccompare_cproper_interval
                           (cproper_interval_prod A4_ A4_)),
                      ccompare_set
                        (finite_UNIV_prod (finite_UNIV_card_UNIV A1_)
                           (finite_UNIV_card_UNIV A1_),
                          ceq_prod A3_ A3_, cproper_interval_prod A4_ A4_,
                          set_impl_prod A6_ A6_),
                      set_impl_set)
                    (fn (q, a) =>
                      image (A3_, ccompare_cproper_interval A4_)
                        (ceq_prod A3_ A3_,
                          ccompare_prod (ccompare_cproper_interval A4_)
                            (ccompare_cproper_interval A4_),
                          set_impl_prod A6_ A6_)
                        (fn aa => (q, aa)) a)
                    q_qs)))
  end;

fun decide_coherent_compatible_main (A1_, A2_, A3_, A4_, A5_, A6_)
  (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_) ta r normalizer =
  (case normalizer
          (initial_relation (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_)
            (C1_, C2_, C3_, C4_, C5_, C6_, C7_) ta r)
    of NONE => false
    | SOME rel =>
      less_eq_set (A2_, A3_, ccompare_cproper_interval A4_)
        (imagea (A3_, ccompare_cproper_interval A4_)
          (A3_, ccompare_cproper_interval A4_, A6_) rel (ta_final ta))
        (ta_final ta));

fun coherent_rule (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) rel rules
  (TA_rule (f, qs, q)) =
  foldr (sup_seta
           (ceq_prod A3_ (ceq_option A3_),
             ccompare_prod (ccompare_cproper_interval A4_)
               (ccompare_option (ccompare_cproper_interval A4_))) o
          (fn i =>
            let
              val qi = nth qs i;
              val qi_s =
                image (ceq_prod A3_ A3_,
                        ccompare_prod (ccompare_cproper_interval A4_)
                          (ccompare_cproper_interval A4_))
                  (A3_, ccompare_cproper_interval A4_, A6_) snd
                  (filter
                    (ceq_prod A3_ A3_,
                      ccompare_prod (ccompare_cproper_interval A4_)
                        (ccompare_cproper_interval A4_))
                    (fn qq => eq A5_ (fst qq) qi) rel);
              val a =
                sup_setb
                  (finite_UNIV_option A1_, cenum_option A2_, ceq_option A3_,
                    cproper_interval_option A4_, set_impl_option A6_)
                  (image (A3_, ccompare_cproper_interval A4_)
                    (ceq_set
                       (cenum_option A2_, ceq_option A3_,
                         ccompare_cproper_interval
                           (cproper_interval_option A4_)),
                      ccompare_set
                        (finite_UNIV_option A1_, ceq_option A3_,
                          cproper_interval_option A4_, set_impl_option A6_),
                      set_impl_set)
                    (fn qia =>
                      let
                        val qsa = list_update qs i qia;
                        val rls =
                          filter
                            (ceq_ta_rule A5_ B2_,
                              ccompare_ta_rule (ccompare_cproper_interval A4_)
                                B1_)
                            (fn TA_rule (g, qsaa, _) =>
                              eq B2_ g f andalso equal_lista A5_ qsaa qsa)
                            rules;
                      in
                        (if less_eq_set
                              (cenum_ta_rule, ceq_ta_rule A5_ B2_,
                                ccompare_ta_rule (ccompare_cproper_interval A4_)
                                  B1_)
                              rls (set_empty
                                    (ceq_ta_rule A5_ B2_,
                                      ccompare_ta_rule
(ccompare_cproper_interval A4_) B1_)
                                    (of_phantom set_impl_ta_rulea))
                          then inserta
                                 (ceq_option A3_,
                                   ccompare_option
                                     (ccompare_cproper_interval A4_))
                                 NONE
                                 (bot_set
                                   (ceq_option A3_,
                                     ccompare_option
                                       (ccompare_cproper_interval A4_),
                                     set_impl_option A6_))
                          else image (ceq_ta_rule A5_ B2_,
                                       ccompare_ta_rule
 (ccompare_cproper_interval A4_) B1_)
                                 (ceq_option A3_,
                                   ccompare_option
                                     (ccompare_cproper_interval A4_),
                                   set_impl_option A6_)
                                 (SOME o r_rhs) rls)
                      end)
                    qi_s);
            in
              image (ceq_option A3_,
                      ccompare_option (ccompare_cproper_interval A4_))
                (ceq_prod A3_ (ceq_option A3_),
                  ccompare_prod (ccompare_cproper_interval A4_)
                    (ccompare_option (ccompare_cproper_interval A4_)),
                  set_impl_prod A6_ (set_impl_option A6_))
                (fn aa => (q, aa)) a
            end))
    (upt zero_nata (size_list qs))
    (bot_set
      (ceq_prod A3_ (ceq_option A3_),
        ccompare_prod (ccompare_cproper_interval A4_)
          (ccompare_option (ccompare_cproper_interval A4_)),
        set_impl_prod A6_ (set_impl_option A6_)));

fun new_states (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) ta rel =
  let
    val rules = ta_rules ta;
  in
    sup_setb
      (finite_UNIV_prod A1_ (finite_UNIV_option A1_),
        cenum_prod A2_ (cenum_option A2_), ceq_prod A3_ (ceq_option A3_),
        cproper_interval_prod A4_ (cproper_interval_option A4_),
        set_impl_prod A6_ (set_impl_option A6_))
      (image
        (ceq_ta_rule A5_ B2_,
          ccompare_ta_rule (ccompare_cproper_interval A4_) B1_)
        (ceq_set
           (cenum_prod A2_ (cenum_option A2_), ceq_prod A3_ (ceq_option A3_),
             ccompare_cproper_interval
               (cproper_interval_prod A4_ (cproper_interval_option A4_))),
          ccompare_set
            (finite_UNIV_prod A1_ (finite_UNIV_option A1_),
              ceq_prod A3_ (ceq_option A3_),
              cproper_interval_prod A4_ (cproper_interval_option A4_),
              set_impl_prod A6_ (set_impl_option A6_)),
          set_impl_set)
        (coherent_rule (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) rel rules)
        rules)
  end;

fun normalize_main (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) ta rel accu =
  let
    val new = new_states (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) ta rel;
  in
    (if member (ceq_option A3_, ccompare_option (ccompare_cproper_interval A4_))
          NONE
          (image
            (ceq_prod A3_ (ceq_option A3_),
              ccompare_prod (ccompare_cproper_interval A4_)
                (ccompare_option (ccompare_cproper_interval A4_)))
            (ceq_option A3_, ccompare_option (ccompare_cproper_interval A4_),
              set_impl_option A6_)
            snd new)
      then NONE
      else let
             val new_rel =
               image (ceq_prod A3_ (ceq_option A3_),
                       ccompare_prod (ccompare_cproper_interval A4_)
                         (ccompare_option (ccompare_cproper_interval A4_)))
                 (ceq_prod A3_ A3_,
                   ccompare_prod (ccompare_cproper_interval A4_)
                     (ccompare_cproper_interval A4_),
                   set_impl_prod A6_ A6_)
                 (fn (x, y) => (x, the y)) new;
             val new_accu =
               sup_seta
                 (ceq_prod A3_ A3_,
                   ccompare_prod (ccompare_cproper_interval A4_)
                     (ccompare_cproper_interval A4_))
                 accu rel;
             val todo =
               minus_set
                 (ceq_prod A3_ A3_,
                   ccompare_prod (ccompare_cproper_interval A4_)
                     (ccompare_cproper_interval A4_))
                 new_rel new_accu;
           in
             (if less_eq_set
                   (cenum_prod A2_ A2_, ceq_prod A3_ A3_,
                     ccompare_prod (ccompare_cproper_interval A4_)
                       (ccompare_cproper_interval A4_))
                   todo
                   (bot_set
                     (ceq_prod A3_ A3_,
                       ccompare_prod (ccompare_cproper_interval A4_)
                         (ccompare_cproper_interval A4_),
                       set_impl_prod A6_ A6_))
               then SOME new_accu
               else normalize_main (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) ta
                      todo new_accu)
           end)
  end;

fun normalizea (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) ta (SOME rel) =
  normalize_main (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) ta rel
    (bot_set
      (ceq_prod A3_ A3_,
        ccompare_prod (ccompare_cproper_interval A4_)
          (ccompare_cproper_interval A4_),
        set_impl_prod A6_ A6_))
  | normalizea (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) ta NONE = NONE;

fun decide_coherent_compatible (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_)
  (C1_, C2_, C3_, C4_, C5_, C6_, C7_) ta r =
  decide_coherent_compatible_main (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_)
    (C1_, C2_, C3_, C4_, C5_, C6_, C7_) ta r
    (normalizea (finite_UNIV_card_UNIV A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B3_)
      ta);

fun closed_under_rewriting (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_, B4_)
  (C1_, C2_, C3_, C4_, C5_, C6_, C7_) ta r =
  decide_coherent_compatible (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B4_)
    (C1_, C2_, C3_, C4_, C5_, C6_, C7_)
    (trim_ta (finite_UNIV_card_UNIV A1_, A2_, A3_, A4_, A5_, A6_)
      (B1_, B3_, B4_) ta)
    r;

fun ta_det_impl (f, (r, (e, (rhs, (idx, (det, x)))))) = det;

fun deta A_ B_ x = ta_det_impl (rep_ta_code A_ B_ x);

fun sorted_ps_ta (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_)
  (B1_, B2_, B3_, B4_, B5_) ta =
  Tree_Automaton
    (sorted_list_of_set
       (ceq_list A3_, ccompare_list (ccompare_cproper_interval A4_),
         equal_list A6_, linorder_list (A6_, A7_))
       (image
         (ceq_set (A2_, A3_, ccompare_cproper_interval A4_),
           ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A8_))
         (ceq_list A3_, ccompare_list (ccompare_cproper_interval A4_),
           set_impl_list)
         (sorted_list_of_set (A3_, ccompare_cproper_interval A4_, A6_, A7_))
         (ta_final
           (ps_ta (A1_, A2_, A3_, A4_, A6_, A8_) (B1_, B2_, B4_, B5_) ta))),
      sorted_list_of_set
        (ceq_ta_rule (equal_list A6_) B4_,
          ccompare_ta_rule (ccompare_list (ccompare_cproper_interval A4_)) B2_,
          equal_ta_rule (equal_list A6_) B4_,
          linorder_ta_rule (compare_list A5_) B3_)
        (image
          (ceq_ta_rule
             (equal_set (A2_, A3_, ccompare_cproper_interval A4_, A6_)) B4_,
            ccompare_ta_rule
              (ccompare_set (finite_UNIV_card_UNIV A1_, A3_, A4_, A8_)) B2_)
          (ceq_ta_rule (equal_list A6_) B4_,
            ccompare_ta_rule (ccompare_list (ccompare_cproper_interval A4_))
              B2_,
            set_impl_ta_rule)
          (fn TA_rule (g, qs, q) =>
            TA_rule
              (g, map (sorted_list_of_set
                        (A3_, ccompare_cproper_interval A4_, A6_, A7_))
                    qs,
                sorted_list_of_set
                  (A3_, ccompare_cproper_interval A4_, A6_, A7_) q))
          (ta_rules
            (ps_ta (A1_, A2_, A3_, A4_, A6_, A8_) (B1_, B2_, B4_, B5_) ta))),
      []);

fun tree_aut_trs_closed (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_)
  ta rel r =
  bindb (check_varcond_subset B7_ (C6_, C8_) r)
    (fn _ =>
      catch_errora
        (case rel
          of Decision_Proc_Old =>
            bindb (catch_errora (check_det A6_ B5_ ta)
                    (fn x =>
                      Inl (shows_prec_list show_char zero_nata
                             [#"d", #"e", #"c", #"i", #"s", #"i", #"o", #"n",
                               #" ", #"p", #"r", #"o", #"c", #"e", #"d", #"u",
                               #"r", #"e", #" ", #"r", #"e", #"q", #"u", #"i",
                               #"r", #"e", #"s", #" ", #"d", #"e", #"t", #".",
                               #" ", #"T", #"A", #" ", #"a", #"s", #" ", #"i",
                               #"n", #"p", #"u", #"t"] o
                            (shows_nl o x))))
              (fn _ =>
                check (closed_under_rewriting (A1_, A2_, A3_, A4_, A6_, A7_)
                        (B2_, compare_compare_order B3_, B4_, B5_)
                        (C1_, C2_, C3_, C4_, compare_compare_order C5_, C6_,
                          C7_)
                        (ta_of_ta (A3_, ccompare_cproper_interval A4_, A6_, A7_)
                          (B2_, B5_) ta)
                        (set (ceq_prod (ceq_term B5_ C6_) (ceq_term B5_ C6_),
                               ccompare_prod
                                 (ccompare_term (compare_compare_order B3_)
                                   (compare_compare_order C5_))
                                 (ccompare_term (compare_compare_order B3_)
                                   (compare_compare_order C5_)),
                               set_impl_prod set_impl_term set_impl_term)
                          r))
                  (shows_prec_list show_char zero_nata
                    [#"T", #"A", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                      #"c", #"l", #"o", #"s", #"e", #"d", #" ", #"u", #"n",
                      #"d", #"e", #"r", #" ", #"r", #"e", #"w", #"r", #"i",
                      #"t", #"i", #"n", #"g"]))
          | Decision_Proc =>
            let
              val tc = ta_code_make_impl A5_ B3_ ta;
            in
              (if deta A5_ B3_ tc
                then (case check_comcoh_wit_ls A5_ B3_ (C5_, C6_) tc r
                       of NONE => Inr ()
                       | SOME (wl, wr) =>
                         Inl (shows_prec_list show_char zero_nata
                                [#"T", #"A", #" ", #"i", #"s", #" ", #"n", #"o",
                                  #"t", #" ", #"c", #"l", #"o", #"s", #"e",
                                  #"d", #" ", #"u", #"n", #"d", #"e", #"r",
                                  #" ", #"r", #"e", #"w", #"r", #"i", #"t",
                                  #"i", #"n", #"g"] o
                               (shows_nl o
                                 (shows_term (shows_prec B7_ zero_nata)
                                    (shows_prec C8_ zero_nata) wl o
                                   (shows_prec_list show_char zero_nata
                                      [#" ", #"i", #"s", #" ", #"a", #"c", #"c",
#"e", #"p", #"t", #"e", #"d", #" ", #"b", #"y", #" ", #"T", #"A", #" ", #"a",
#"n", #"d", #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"e", #"s", #" ", #"t",
#"o"] o
                                     (shows_nl o
                                       (shows_term (shows_prec B7_ zero_nata)
  (shows_prec C8_ zero_nata) wr o
 shows_prec_list show_char zero_nata
   [#" ", #"w", #"h", #"i", #"c", #"h", #" ", #"i", #"s", #" ", #"n", #"o",
     #"t", #" ", #"a", #"c", #"c", #"e", #"p", #"t", #"e", #"d", #" ", #"b",
     #"y", #" ", #"T", #"A"])))))))
                else let
                       val tca =
                         ta_code_make_impl (compare_order_list (A5_, A6_)) B3_
                           (sorted_ps_ta
                             (A1_, A2_, A3_, A4_, compare_compare_order A5_,
                               A6_, linorder_compare_order A5_, A7_)
                             (B1_, B2_, compare_compare_order B3_, B5_, B6_)
                             (trim_ta
                               (finite_UNIV_card_UNIV A1_, A2_, A3_, A4_, A6_,
                                 A7_)
                               (B2_, B4_, B5_)
                               (ta_of_ta
                                 (A3_, ccompare_cproper_interval A4_, A6_, A7_)
                                 (B2_, B5_) ta)));
                     in
                       (case check_comcoh_wit_ls (compare_order_list (A5_, A6_))
                               B3_ (C5_, C6_) tca r
                         of NONE => Inr ()
                         | SOME (wl, wr) =>
                           Inl (shows_prec_list show_char zero_nata
                                  [#"T", #"A", #" ", #"i", #"s", #" ", #"n",
                                    #"o", #"t", #" ", #"c", #"l", #"o", #"s",
                                    #"e", #"d", #" ", #"u", #"n", #"d", #"e",
                                    #"r", #" ", #"r", #"e", #"w", #"r", #"i",
                                    #"t", #"i", #"n", #"g"] o
                                 (shows_nl o
                                   (shows_term (shows_prec B7_ zero_nata)
                                      (shows_prec C8_ zero_nata) wl o
                                     (shows_prec_list show_char zero_nata
[#" ", #"i", #"s", #" ", #"a", #"c", #"c", #"e", #"p", #"t", #"e", #"d", #" ",
  #"b", #"y", #" ", #"T", #"A", #" ", #"a", #"n", #"d", #" ", #"r", #"e", #"w",
  #"r", #"i", #"t", #"e", #"s", #" ", #"t", #"o"] o
                                       (shows_nl o
 (shows_term (shows_prec B7_ zero_nata) (shows_prec C8_ zero_nata) wr o
   shows_prec_list show_char zero_nata
     [#" ", #"w", #"h", #"i", #"c", #"h", #" ", #"i", #"s", #" ", #"n", #"o",
       #"t", #" ", #"a", #"c", #"c", #"e", #"p", #"t", #"e", #"d", #" ", #"b",
       #"y", #" ", #"T", #"A"])))))))
                     end)
            end
          | Id_Relation =>
            bindb (generate_ta_cond
                    (A1_, A2_, A3_, ccompare_cproper_interval A4_, A5_, A6_,
                      A7_, A8_)
                    (B3_, B5_, B7_) ta rel)
              (fn taa =>
                bindb (catch_errora
                        (if isOK (check_left_linear_trs B7_
                                   (C3_, ccompare_cproper_interval C4_, C7_,
                                     C8_)
                                   r)
                          then Inr () else check_det A6_ B5_ ta)
                        (fn x =>
                          Inl (shows_prec_list show_char zero_nata
                                 [#"c", #"o", #"u", #"l", #"d", #" ", #"n",
                                   #"o", #"t", #" ", #"e", #"n", #"s", #"u",
                                   #"r", #"e", #" ", #"l", #"e", #"f", #"t",
                                   #"-", #"l", #"i", #"n", #"e", #"a", #"r",
                                   #"i", #"t", #"y", #" ", #"o", #"r", #" ",
                                   #"d", #"e", #"t", #"e", #"r", #"m", #"i",
                                   #"n", #"i", #"s", #"m"] o
                                (shows_nl o x))))
                  (fn _ =>
                    catch_errora
                      (state_compatible_eff_list (A5_, A6_) B3_ (C5_, C6_) taa
                        (rel_checker (A5_, A6_) rel) r)
                      (fn x =>
                        Inl let
                              val (lr, (lrq, q)) = x;
                            in
                              shows_prec_list show_char zero_nata
                                [#"T", #"A", #" ", #"i", #"s", #" ", #"n", #"o",
                                  #"t", #" ", #"c", #"o", #"m", #"p", #"a",
                                  #"t", #"i", #"b", #"l", #"e", #" ", #"w",
                                  #"i", #"t", #"h", #" ", #"R"] o
                                (shows_nl o
                                  (shows_prec_list show_char zero_nata
                                     [#"f", #"o", #"r", #" ", #"r", #"u", #"l",
                                       #"e", #" "] o
                                    (shows_rule (shows_prec B7_ zero_nata)
                                       (shows_prec C8_ zero_nata)
                                       [#" ", #"-", #">", #" "] lr o
                                      (shows_nl o
(shows_prec_list show_char zero_nata
   [#"w", #"h", #"i", #"c", #"h", #" ", #"i", #"s", #" ", #"i", #"n", #"s",
     #"t", #"a", #"n", #"t", #"i", #"a", #"t", #"e", #"d", #" ", #"b", #"y",
     #" ", #"s", #"t", #"a", #"t", #"e", #"s", #" ", #"t", #"o", #" "] o
  (shows_rule (shows_prec B7_ zero_nata) (shows_prec A8_ zero_nata)
     [#" ", #"-", #">", #" "] lrq o
    (shows_nl o
      (shows_prec_list show_char zero_nata
         [#"t", #"h", #"e", #" ", #"s", #"t", #"a", #"t", #"e", #" "] o
        (shows_prec A8_ zero_nata q o
          (shows_prec_list show_char zero_nata
             [#" ", #"i", #"s", #" ", #"o", #"n", #"l", #"y", #" ", #"r", #"e",
               #"a", #"c", #"h", #"a", #"b", #"l", #"e", #" ", #"f", #"r", #"o",
               #"m", #" ", #"t", #"h", #"e", #" ", #"l", #"h", #"s"] o
            shows_nl))))))))))
                            end)))
          | Some_Relation _ =>
            bindb (generate_ta_cond
                    (A1_, A2_, A3_, ccompare_cproper_interval A4_, A5_, A6_,
                      A7_, A8_)
                    (B3_, B5_, B7_) ta rel)
              (fn taa =>
                bindb (catch_errora
                        (if isOK (check_left_linear_trs B7_
                                   (C3_, ccompare_cproper_interval C4_, C7_,
                                     C8_)
                                   r)
                          then Inr () else check_det A6_ B5_ ta)
                        (fn x =>
                          Inl (shows_prec_list show_char zero_nata
                                 [#"c", #"o", #"u", #"l", #"d", #" ", #"n",
                                   #"o", #"t", #" ", #"e", #"n", #"s", #"u",
                                   #"r", #"e", #" ", #"l", #"e", #"f", #"t",
                                   #"-", #"l", #"i", #"n", #"e", #"a", #"r",
                                   #"i", #"t", #"y", #" ", #"o", #"r", #" ",
                                   #"d", #"e", #"t", #"e", #"r", #"m", #"i",
                                   #"n", #"i", #"s", #"m"] o
                                (shows_nl o x))))
                  (fn _ =>
                    catch_errora
                      (state_compatible_eff_list (A5_, A6_) B3_ (C5_, C6_) taa
                        (rel_checker (A5_, A6_) rel) r)
                      (fn x =>
                        Inl let
                              val (lr, (lrq, q)) = x;
                            in
                              shows_prec_list show_char zero_nata
                                [#"T", #"A", #" ", #"i", #"s", #" ", #"n", #"o",
                                  #"t", #" ", #"c", #"o", #"m", #"p", #"a",
                                  #"t", #"i", #"b", #"l", #"e", #" ", #"w",
                                  #"i", #"t", #"h", #" ", #"R"] o
                                (shows_nl o
                                  (shows_prec_list show_char zero_nata
                                     [#"f", #"o", #"r", #" ", #"r", #"u", #"l",
                                       #"e", #" "] o
                                    (shows_rule (shows_prec B7_ zero_nata)
                                       (shows_prec C8_ zero_nata)
                                       [#" ", #"-", #">", #" "] lr o
                                      (shows_nl o
(shows_prec_list show_char zero_nata
   [#"w", #"h", #"i", #"c", #"h", #" ", #"i", #"s", #" ", #"i", #"n", #"s",
     #"t", #"a", #"n", #"t", #"i", #"a", #"t", #"e", #"d", #" ", #"b", #"y",
     #" ", #"s", #"t", #"a", #"t", #"e", #"s", #" ", #"t", #"o", #" "] o
  (shows_rule (shows_prec B7_ zero_nata) (shows_prec A8_ zero_nata)
     [#" ", #"-", #">", #" "] lrq o
    (shows_nl o
      (shows_prec_list show_char zero_nata
         [#"t", #"h", #"e", #" ", #"s", #"t", #"a", #"t", #"e", #" "] o
        (shows_prec A8_ zero_nata q o
          (shows_prec_list show_char zero_nata
             [#" ", #"i", #"s", #" ", #"o", #"n", #"l", #"y", #" ", #"r", #"e",
               #"a", #"c", #"h", #"a", #"b", #"l", #"e", #" ", #"f", #"r", #"o",
               #"m", #" ", #"t", #"h", #"e", #" ", #"l", #"h", #"s"] o
            shows_nl))))))))))
                            end))))
        (fn x =>
          Inl (shows_prec_list show_char zero_nata
                 [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h",
                   #"e", #"n", #" ", #"e", #"n", #"s", #"u", #"r", #"i", #"n",
                   #"g", #" ", #"(", #"s", #"t", #"a", #"t", #"e", #"-", #")",
                   #"c", #"o", #"m", #"p", #"a", #"t", #"i", #"b", #"i", #"l",
                   #"i", #"t", #"y", #" ", #"o", #"f", #" ", #"T", #"R", #"S",
                   #" ", #"w", #"i", #"t", #"h", #" ", #"T", #"A", #" "] o
                (shows_nl o
                  (shows_prec_tree_automaton A8_ B7_ zero_nata ta o
                    (shows_nl o x))))));

fun intersect_ta (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_, B4_)
  (C1_, C2_, C3_, C4_, C5_, C6_) tA1 tA2 =
  prod_ta (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_, B3_, B4_)
    (C1_, C2_, C3_, C4_, C5_, C6_) tA1 tA2
    (productc (A3_, ccompare_cproper_interval A4_, A6_)
      (C3_, ccompare_cproper_interval C4_, C6_) (ta_final tA1) (ta_final tA2));

fun ta_contains_nf (A1_, A2_, A3_, A4_, A5_, A6_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) (C1_, C2_) ta r =
  not (ta_empty
        (cenum_prod cenum_term A2_, ceq_prod (ceq_term B7_ equal_unit) A3_,
          ccompare_prod (ccompare_term B5_ compare_unit)
            (ccompare_cproper_interval A4_),
          equal_prod (equal_term B7_ equal_unit) A5_,
          set_impl_prod set_impl_term A6_)
        (ccompare_cproper_interval B4_, B6_, B7_)
        (intersect_ta
          (finite_UNIV_term, cenum_term, ceq_term B7_ equal_unit,
            cproper_interval_term B5_ compare_unit, equal_term B7_ equal_unit,
            set_impl_term)
          (B3_, ccompare_cproper_interval B4_, B7_, B8_)
          (A1_, A2_, A3_, A4_, A5_, A6_)
          (ta_nf (B1_, B2_, B3_, B4_, B5_, B7_, B8_) (C1_, C2_)
            (image
              (ceq_prod (ceq_term B7_ C2_) (ceq_term B7_ C2_),
                ccompare_prod (ccompare_term B5_ C1_) (ccompare_term B5_ C1_))
              (ceq_term B7_ C2_, ccompare_term B5_ C1_, set_impl_term) fst r)
            (ta_syms (ccompare_cproper_interval A4_, A5_)
              (B3_, ccompare_cproper_interval B4_, B7_, B8_) ta))
          ta));

fun check_trs_not_wn (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
  (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_) r (Not_wn_ta_prf (ta, rel)) =
  bindb (check_varcond_subset A9_ (B6_, B8_) r)
    (fn _ =>
      bindb (check_left_linear_trs A9_
              (B3_, ccompare_cproper_interval B4_, B7_, B8_) r)
        (fn _ =>
          let
            val tA_trim =
              trim_ta (finite_UNIV_card_UNIV C1_, C2_, C3_, C4_, C6_, C7_)
                (ccompare_cproper_interval A4_, A6_, A7_)
                (ta_of_ta (C3_, ccompare_cproper_interval C4_, C6_, C7_)
                  (ccompare_cproper_interval A4_, A7_) ta);
          in
            bindb (check
                    (not (ta_empty
                           (C2_, C3_, ccompare_cproper_interval C4_, C6_, C7_)
                           (ccompare_cproper_interval A4_, A6_, A7_) tA_trim))
                    (shows_prec_list show_char zero_nata
                      [#"T", #"A", #" ", #"i", #"s", #" ", #"e", #"m", #"p",
                        #"t", #"y"]))
              (fn _ =>
                bindb (tree_aut_trs_closed
                        (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_)
                        (A3_, ccompare_cproper_interval A4_, A5_, A6_, A7_, A8_,
                          A9_)
                        (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) ta rel r)
                  (fn _ =>
                    check (not (ta_contains_nf
                                 (finite_UNIV_card_UNIV C1_, C2_, C3_, C4_, C6_,
                                   C7_)
                                 (A1_, A2_, A3_, A4_, compare_compare_order A5_,
                                   A6_, A7_, A8_)
                                 (compare_compare_order B5_, B6_) tA_trim
                                 (set (ceq_prod (ceq_term A7_ B6_)
 (ceq_term A7_ B6_),
ccompare_prod
  (ccompare_term (compare_compare_order A5_) (compare_compare_order B5_))
  (ccompare_term (compare_compare_order A5_) (compare_compare_order B5_)),
set_impl_prod set_impl_term set_impl_term)
                                   r)))
                      (shows_prec_list show_char zero_nata
                        [#"T", #"A", #" ", #"a", #"c", #"c", #"e", #"p", #"t",
                          #"s", #" ", #"s", #"o", #"m", #"e", #" ", #"n", #"o",
                          #"r", #"m", #"a", #"l", #" ", #"f", #"o", #"r",
                          #"m"])))
          end));

fun check_not_wn_ta_prf (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_)
  (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_)
  (E1_, E2_, E3_, E4_, E5_, E6_, E7_, E8_) i tp prf =
  let
    val r = rulesd i tp;
  in
    bindb (check (null (qb i tp))
            (shows_prec_list show_char zero_nata
              [#"s", #"t", #"r", #"a", #"t", #"e", #"g", #"y", #" ", #"i", #"s",
                #" ", #"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r", #"t",
                #"e", #"d", #" ", #"f", #"o", #"r", #" ", #"t", #"r", #"e",
                #"e", #" ", #"a", #"u", #"t", #"o", #"m", #"a", #"t", #"a",
                #" ", #"b", #"a", #"s", #"e", #"d", #" ", #"n", #"o", #"n",
                #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o",
                #"n"]))
      (fn _ =>
        check_trs_not_wn (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_)
          (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_)
          (E1_, E2_, E3_, E4_, E5_, E6_, E7_, E8_) r prf)
  end;

fun check_dps (A1_, A2_) (B1_, B2_) unshp r p =
  let
    val d = defined_list r;
  in
    catch_errora
      (forallM
        (fn x =>
          (if let
                val (ll, rr) = x;
              in
                not (is_Var rr) andalso
                  (not (membera (equal_prod A1_ equal_nat) d
                         (the (root rr))) andalso
                    list_ex
                      (fn (l, ra) =>
                        equal_terma A1_ B1_ l (sharp_term unshp ll) andalso
                          (equal_terma A1_ B1_ ra (sharp_term unshp rr) orelse
                            supt_impl A1_ B1_ ra (sharp_term unshp rr)))
                      r)
              end
            then Inr () else Inl x))
        p)
      (fn x => Inl (snd x))
  end;

fun unsharp (Sharp f) = f
  | unsharp (Lab (v, va)) = Lab (v, va)
  | unsharp (FunLab (v, va)) = FunLab (v, va)
  | unsharp (UnLab v) = UnLab v;

fun dp_trans_nontermination_tt (B1_, B2_) (C1_, C2_) (D1_, D2_) i j tp
  (DP_trans_nontermination_tt_prf p) =
  let
    val r = rulesd i tp;
    val q = qb i tp;
  in
    bindb (check (null q orelse not (nfsb i tp))
            (shows_prec_list show_char zero_nata
              [#"s", #"t", #"r", #"a", #"t", #"e", #"g", #"i", #"e", #"s", #" ",
                #"a", #"n", #"d", #" ", #"n", #"o", #"r", #"m", #"a", #"l",
                #" ", #"f", #"o", #"r", #"m", #" ", #"s", #"u", #"b", #"s",
                #"t", #"i", #"t", #"u", #"t", #"i", #"o", #"n", #"s", #" ",
                #"p", #"r", #"o", #"b", #"l", #"e", #"m"]))
      (fn _ =>
        bindb (catch_errora
                (check_dps (equal_lab B1_ C1_, show_lab B2_ C2_) (D1_, D2_)
                  unsharp r p)
                (fn x =>
                  Inl (shows_prec_list show_char zero_nata
                         [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #"a", #"t",
                           #"i", #"c", #" ", #"r", #"u", #"l", #"e", #":",
                           #" "] o
                        shows_rule (shows_prec_lab B2_ C2_ zero_nata)
                          (shows_prec D2_ zero_nata) [#" ", #"-", #">", #" "]
                          x)))
          (fn _ => Inr (mkd j false false p [] q [] r)))
  end;

fun switch_termination_tt (B1_, B2_, B3_) i joins_i tp =
  let
    val r = rulesd i tp;
    val q = qb i tp;
  in
    (case let
            val cp = critical_pairs_impl B1_ r r;
          in
            bindb (catch_errora
                    (forallM
                      (fn (b, _) =>
                        check b
                          (shows_prec_list show_char zero_nata
                            [#"r", #"u", #"l", #"e", #"s", #" ", #"a", #"r",
                              #"e", #" ", #"n", #"o", #"t", #" ", #"o", #"v",
                              #"e", #"r", #"l", #"a", #"y"]))
                      cp)
                    (fn x => Inl (snd x)))
              (fn _ =>
                bindb (check_wf_trs B3_
                        (equal_list equal_char, show_list show_char) r)
                  (fn _ =>
                    bindb (check_critical_pairs (B1_, B3_) r cp joins_i)
                      (fn _ =>
                        catch_errora
                          (check_NF_trs_subset (B1_, B2_)
                            (ccompare_list ccompare_char, equal_list equal_char,
                              mapping_impl_list)
                            r q)
                          (fn x =>
                            Inl (shows_prec_term B3_ (show_list show_char)
                                   zero_nata x o
                                  shows_prec_list show_char zero_nata
                                    [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
                                      #" ", #"i", #"n", #" ", #"n", #"o", #"r",
                                      #"m", #"a", #"l", #" ", #"f", #"o", #"r",
                                      #"m", #" ", #"w", #".", #"r", #".", #"t",
                                      #".", #" ", #"R"])))))
          end
      of Inl a => Inl a | Inr _ => Inr (mkc i (nfsb i tp) [] r []))
  end;

fun q_increase_nonterm_trs (B1_, B2_, B3_) (C1_, C2_, C3_) i dpp
  (Q_increase_nonterm_trs_prf q) =
  let
    val r = rulesd i dpp;
    val qa = qb i dpp;
    val nfs = nfsb i dpp;
  in
    Inr (mkc i nfs (list_union (equal_term B1_ C1_) qa q) r [])
  end;

fun shows_srs_rule A_ B_ (l, r) =
  shows_prec A_ zero_nata l o
    (shows_prec_list show_char zero_nata [#" ", #"-", #">", #" "] o
      shows_prec B_ zero_nata r);

fun shows_pat A_ B_ C_ D_ E_ F_ G_ H_ I_ J_ (p1, p2) =
  shows_p A_ B_ C_ D_ E_ p1 o
    (shows_prec_list show_char zero_nata [#" ", #"-", #">", #"+", #" "] o
      shows_p F_ G_ H_ I_ J_ p2);

fun normalize_wp A_ x =
  let
    val (l, (aa, r)) = x;
    val (f, aaa) = aa;
  in
    (if equal_nata f zero_nata
      then let
             val (aab, m) = aaa;
           in
             (if equal_nata aab zero_nata
               then ([], ((zero_nata, (zero_nata, [])), l @ r))
               else normalize_wp A_
                      (l @ concat (replicate (suc (minus_nata aab one_nata)) m),
                        ((zero_nata, (zero_nata, m)), r)))
           end
      else (if equal_nata (minus_nata f one_nata) zero_nata
             then let
                    val (aab, m) = aaa;
                  in
                    (if equal_nata aab zero_nata
                      then (case m
                             of [] =>
                               ([], ((zero_nata, (zero_nata, [])), l @ r))
                             | a :: ma =>
                               (case r
                                 of [] =>
                                   (l, ((suc zero_nata, (zero_nata, a :: ma)),
 []))
                                 | b :: ra =>
                                   (if eq A_ a b
                                     then normalize_wp A_
    (l @ [b], ((suc zero_nata, (zero_nata, ma @ [b])), ra))
                                     else (l,
    ((suc zero_nata, (zero_nata, a :: ma)), b :: ra)))))
                      else normalize_wp A_
                             (l @ concat
                                    (replicate (suc (minus_nata aab one_nata))
                                      m),
                               ((suc zero_nata, (zero_nata, m)), r)))
                  end
             else let
                    val (aab, m) = aaa;
                  in
                    (if equal_nata aab zero_nata
                      then (case m
                             of [] =>
                               ([], ((zero_nata, (zero_nata, [])), l @ r))
                             | vb :: vba =>
                               normalize_wp A_
                                 (l, ((suc zero_nata,
(zero_nata,
  concat
    (replicate (suc (suc (minus_nata (minus_nata f one_nata) one_nata)))
      (vb :: vba)))),
                                       r)))
                      else normalize_wp A_
                             (l @ concat
                                    (replicate (suc (minus_nata aab one_nata))
                                      m),
                               ((suc (suc (minus_nata (minus_nata f one_nata)
    one_nata)),
                                  (zero_nata, m)),
                                 r)))
                  end))
  end;

fun word_pat_equiv A_ wp1 wp2 =
  equal_proda (equal_list A_)
    (equal_prod (equal_prod equal_nat (equal_prod equal_nat (equal_list A_)))
      (equal_list A_))
    wp1 wp2 orelse
    equal_proda (equal_list A_)
      (equal_prod (equal_prod equal_nat (equal_prod equal_nat (equal_list A_)))
        (equal_list A_))
      (normalize_wp A_ wp1) (normalize_wp A_ wp2);

fun shows_oc A_ B_ (l, r) =
  shows_prec A_ zero_nata l o
    (shows_prec_list show_char zero_nata [#" ", #"-", #">", #"+", #" "] o
      shows_prec B_ zero_nata r);

fun check_stepb (A1_, A2_, A3_, A4_) r step =
  (case step
    of OC1 (uv, _) =>
      check (member
              (ceq_prod (ceq_list A1_) (ceq_list A1_),
                ccompare_prod (ccompare_list A2_) (ccompare_list A2_))
              uv r)
        (shows_srs_rule (show_list A4_) (show_list A4_) uv o
          shows_prec_list show_char zero_nata
            [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"n", #" ",
              #"o", #"r", #"i", #"g", #"i", #"n", #"a", #"l", #" ", #"r", #"u",
              #"l", #"e"])
    | OC2 (oc_new, oc1, oc2, t, x, l) =>
      let
        val (wl, tr) = oc_new;
        val (w, tx) = oc1;
        val (xl, ra) = oc2;
      in
        catch_errora
          (bindb
            (check (equal_lista A3_ xl (x @ l))
              (shows_prec_list show_char zero_nata
                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"x",
                  #"l", #" ", #"!", #"=", #" ", #"x", #" ", #"l"]))
            (fn _ =>
              bindb (check (equal_lista A3_ tx (t @ x))
                      (shows_prec_list show_char zero_nata
                        [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                          #"t", #"x", #" ", #"!", #"=", #" ", #"t", #" ",
                          #"x"]))
                (fn _ =>
                  bindb (check (equal_lista A3_ wl (w @ l))
                          (shows_prec_list show_char zero_nata
                            [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":",
                              #" ", #"w", #"l", #" ", #"!", #"=", #" ", #"w",
                              #" ", #"l"]))
                    (fn _ =>
                      check (equal_lista A3_ tr (t @ ra))
                        (shows_prec_list show_char zero_nata
                          [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                            #"t", #"r", #" ", #"!", #"=", #" ", #"t", #" ",
                            #"r"])))))
          (fn xa =>
            Inl (shows_prec_list show_char zero_nata
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                     #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ",
                     #"o", #"v", #"e", #"r", #"l", #"a", #"p", #" ", #"O", #"C",
                     #"2", #" ", #"o", #"f", #" "] o
                  (shows_nl o
                    (shows_oc (show_list A4_) (show_list A4_) oc1 o
                      (shows_nl o
                        (shows_oc (show_list A4_) (show_list A4_) oc2 o
                          (shows_nl o
                            (shows_prec_list show_char zero_nata
                               [#"t", #"o", #" ", #"y", #"i", #"e", #"l",
                                 #"d"] o
                              (shows_nl o
                                (shows_oc (show_list A4_) (show_list A4_)
                                   oc_new o
                                  (shows_nl o xa)))))))))))
      end
    | OC2p (oc_new, oc1, oc2, x, t, l) =>
      let
        val (lw, rt) = oc_new;
        val (w, xt) = oc1;
        val (lx, ra) = oc2;
      in
        catch_errora
          (bindb
            (check (equal_lista A3_ lx (l @ x))
              (shows_prec_list show_char zero_nata
                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l",
                  #"x", #" ", #"!", #"=", #" ", #"l", #" ", #"x"]))
            (fn _ =>
              bindb (check (equal_lista A3_ lw (l @ w))
                      (shows_prec_list show_char zero_nata
                        [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                          #"l", #"w", #" ", #"!", #"=", #" ", #"l", #" ",
                          #"w"]))
                (fn _ =>
                  bindb (check (equal_lista A3_ rt (ra @ t))
                          (shows_prec_list show_char zero_nata
                            [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":",
                              #" ", #"r", #"t", #" ", #"!", #"=", #" ", #"r",
                              #" ", #"t"]))
                    (fn _ =>
                      check (equal_lista A3_ xt (x @ t))
                        (shows_prec_list show_char zero_nata
                          [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                            #"x", #"t", #" ", #"!", #"=", #" ", #"x", #" ",
                            #"t"])))))
          (fn xa =>
            Inl (shows_prec_list show_char zero_nata
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                     #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ",
                     #"o", #"v", #"e", #"r", #"l", #"a", #"p", #" ", #"O", #"C",
                     #"2", #"'", #" ", #"o", #"f", #" "] o
                  (shows_nl o
                    (shows_oc (show_list A4_) (show_list A4_) oc1 o
                      (shows_nl o
                        (shows_oc (show_list A4_) (show_list A4_) oc2 o
                          (shows_nl o
                            (shows_prec_list show_char zero_nata
                               [#"t", #"o", #" ", #"y", #"i", #"e", #"l",
                                 #"d"] o
                              (shows_nl o
                                (shows_oc (show_list A4_) (show_list A4_)
                                   oc_new o
                                  (shows_nl o xa)))))))))))
      end
    | OC3 (oc_new, oc1, oc2, t1, t2) =>
      let
        val (w, t1rt2) = oc_new;
        val (wa, t1xt2) = oc1;
        val (x, ra) = oc2;
      in
        catch_errora
          (bindb
            (check (equal_lista A3_ t1rt2 (t1 @ ra @ t2))
              (shows_prec_list show_char zero_nata
                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"t",
                  #"1", #"_", #"r", #"_", #"t", #"2", #" ", #"!", #"=", #" ",
                  #"t", #"1", #" ", #"r", #" ", #"t", #"2"]))
            (fn _ =>
              bindb (check (equal_lista A3_ t1xt2 (t1 @ x @ t2))
                      (shows_prec_list show_char zero_nata
                        [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                          #"t", #"1", #"_", #"x", #"_", #"t", #"2", #" ", #"!",
                          #"=", #" ", #"t", #"1", #" ", #"x", #" ", #"t",
                          #"2"]))
                (fn _ =>
                  check (equal_lista A3_ w wa)
                    (shows_prec_list show_char zero_nata
                      [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                        #"w", #" ", #"d", #"i", #"f", #"f", #"e", #"r",
                        #"s"]))))
          (fn xa =>
            Inl (shows_prec_list show_char zero_nata
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                     #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ",
                     #"o", #"v", #"e", #"r", #"l", #"a", #"p", #" ", #"O", #"C",
                     #"3", #" ", #"o", #"f", #" "] o
                  (shows_nl o
                    (shows_oc (show_list A4_) (show_list A4_) oc1 o
                      (shows_nl o
                        (shows_oc (show_list A4_) (show_list A4_) oc2 o
                          (shows_nl o
                            (shows_prec_list show_char zero_nata
                               [#"t", #"o", #" ", #"y", #"i", #"e", #"l",
                                 #"d"] o
                              (shows_nl o
                                (shows_oc (show_list A4_) (show_list A4_)
                                   oc_new o
                                  (shows_nl o xa)))))))))))
      end
    | OC3p (oc_new, oc1, oc2, t1, t2) =>
      let
        val (t1wt2, ra) = oc_new;
        val (t1xt2, raa) = oc1;
        val (w, x) = oc2;
      in
        catch_errora
          (bindb
            (check (equal_lista A3_ t1wt2 (t1 @ w @ t2))
              (shows_prec_list show_char zero_nata
                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"t",
                  #"1", #"_", #"w", #"_", #"t", #"2", #" ", #"!", #"=", #" ",
                  #"t", #"1", #" ", #"w", #" ", #"t", #"2"]))
            (fn _ =>
              bindb (check (equal_lista A3_ t1xt2 (t1 @ x @ t2))
                      (shows_prec_list show_char zero_nata
                        [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                          #"t", #"1", #"_", #"x", #"_", #"t", #"2", #" ", #"!",
                          #"=", #" ", #"t", #"1", #" ", #"x", #" ", #"t",
                          #"2"]))
                (fn _ =>
                  check (equal_lista A3_ ra raa)
                    (shows_prec_list show_char zero_nata
                      [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                        #"r", #" ", #"d", #"i", #"f", #"f", #"e", #"r",
                        #"s"]))))
          (fn xa =>
            Inl (shows_prec_list show_char zero_nata
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                     #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ",
                     #"o", #"v", #"e", #"r", #"l", #"a", #"p", #" ", #"O", #"C",
                     #"3", #"'", #" ", #"o", #"f", #" "] o
                  (shows_nl o
                    (shows_oc (show_list A4_) (show_list A4_) oc1 o
                      (shows_nl o
                        (shows_oc (show_list A4_) (show_list A4_) oc2 o
                          (shows_nl o
                            (shows_prec_list show_char zero_nata
                               [#"t", #"o", #" ", #"y", #"i", #"e", #"l",
                                 #"d"] o
                              (shows_nl o
                                (shows_oc (show_list A4_) (show_list A4_)
                                   oc_new o
                                  (shows_nl o xa)))))))))))
      end
    | OCDP1 (p, oc1) =>
      let
        val (lc, cr) = oc1;
        val a = p;
        val (aa, b) = a;
      in
        let
          val (e1, ab) = aa;
          val (ac, ba) = ab;
        in
          let
            val (f, (d, l)) = ac;
          in
            (fn c1 => fn (c2, ad) =>
              let
                val (ae, bb) = ad;
              in
                let
                  val (fa, (da, ra)) = ae;
                in
                  (fn e2 =>
                    catch_errora
                      (bindb
                        (check (null e1)
                          (shows_prec_list show_char zero_nata
                            [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":",
                              #" ", #"e", #"1", #" ", #"n", #"o", #"t", #" ",
                              #"e", #"m", #"p", #"t", #"y"]))
                        (fn _ =>
                          bindb (check (null e2)
                                  (shows_prec_list show_char zero_nata
                                    [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                      #":", #" ", #"e", #"2", #" ", #"n", #"o",
                                      #"t", #" ", #"e", #"m", #"p", #"t",
                                      #"y"]))
                            (fn _ =>
                              bindb (check (equal_lista A3_ c1 c2)
                                      (shows_prec_list show_char zero_nata
[#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"c", #" ", #"n", #"o",
  #"t", #" ", #"e", #"q", #"u", #"a", #"l"]))
                                (fn _ =>
                                  bindb (check
  (equal_nata f one_nata andalso
    (equal_nata fa one_nata andalso
      (equal_nata d zero_nata andalso equal_nata da zero_nata)))
  (shows_prec_list show_char zero_nata
    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"0", #" ", #"a",
      #"n", #"d", #" ", #"1", #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i",
      #"o", #"n", #"s", #" ", #"n", #"o", #"t", #" ", #"m", #"e", #"t"]))
                                    (fn _ =>
                                      bindb
(check (equal_lista A3_ lc (l @ c1))
  (shows_prec_list show_char zero_nata
    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l", #"c", #" ",
      #"!", #"=", #" ", #"l", #" ", #"c"]))
(fn _ =>
  check (equal_lista A3_ cr (c1 @ ra))
    (shows_prec_list show_char zero_nata
      [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"c", #"r", #" ",
        #"!", #"=", #" ", #"c", #" ", #"r"])))))))
                      (fn x =>
                        Inl (shows_prec_list show_char zero_nata
                               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                                 #"i", #"n", #" ", #"c", #"h", #"e", #"c", #"k",
                                 #"i", #"n", #"g", #" ", #"o", #"v", #"e", #"r",
                                 #"l", #"a", #"p", #" ", #"O", #"C", #"D", #"P",
                                 #"1", #" ", #"o", #"f", #" "] o
                              (shows_nl o
                                (shows_oc (show_list A4_) (show_list A4_) oc1 o
                                  (shows_nl o
                                    (shows_prec_list show_char zero_nata
                                       [#"t", #"o", #" ", #"y", #"i", #"e",
 #"l", #"d"] o
                                      (shows_nl o
(shows_pat (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_)
   (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_) p o
  (shows_nl o x))))))))))
                end
                  bb
              end)
          end
            ba
        end
          b
      end
    | OCDP2 (p, oc1) =>
      let
        val (cl, rc) = oc1;
        val a = p;
        val (aa, b) = a;
      in
        let
          val (c1, ab) = aa;
          val (ac, ba) = ab;
        in
          let
            val (f, (d, l)) = ac;
          in
            (fn e1 => fn (e2, ad) =>
              let
                val (ae, bb) = ad;
              in
                let
                  val (fa, (da, ra)) = ae;
                in
                  (fn c2 =>
                    catch_errora
                      (bindb
                        (check (null e1 andalso null e2)
                          (shows_prec_list show_char zero_nata
                            [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":",
                              #" ", #"e", #"1", #" ", #"o", #"r", #" ", #"e",
                              #"2", #" ", #"n", #"o", #"t", #" ", #"e", #"m",
                              #"p", #"t", #"y"]))
                        (fn _ =>
                          bindb (check (equal_lista A3_ c1 c2)
                                  (shows_prec_list show_char zero_nata
                                    [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                      #":", #" ", #"c", #" ", #"n", #"o", #"t",
                                      #" ", #"e", #"q", #"u", #"a", #"l"]))
                            (fn _ =>
                              bindb (check
                                      (equal_nata f one_nata andalso
(equal_nata fa one_nata andalso
  (equal_nata d zero_nata andalso equal_nata da zero_nata)))
                                      (shows_prec_list show_char zero_nata
[#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"0", #" ", #"a", #"n",
  #"d", #" ", #"1", #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
  #"s", #" ", #"n", #"o", #"t", #" ", #"m", #"e", #"t"]))
                                (fn _ =>
                                  bindb (check (equal_lista A3_ cl (c1 @ l))
  (shows_prec_list show_char zero_nata
    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l", #"c", #" ",
      #"!", #"=", #" ", #"l", #" ", #"c"]))
                                    (fn _ =>
                                      check (equal_lista A3_ rc (ra @ c1))
(shows_prec_list show_char zero_nata
  [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"c", #"r", #" ", #"!",
    #"=", #" ", #"c", #" ", #"r"]))))))
                      (fn x =>
                        Inl (shows_prec_list show_char zero_nata
                               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                                 #"i", #"n", #" ", #"c", #"h", #"e", #"c", #"k",
                                 #"i", #"n", #"g", #" ", #"o", #"v", #"e", #"r",
                                 #"l", #"a", #"p", #" ", #"O", #"C", #"D", #"P",
                                 #"1", #" ", #"o", #"f", #" "] o
                              (shows_nl o
                                (shows_oc (show_list A4_) (show_list A4_) oc1 o
                                  (shows_nl o
                                    (shows_prec_list show_char zero_nata
                                       [#"t", #"o", #" ", #"y", #"i", #"e",
 #"l", #"d"] o
                                      (shows_nl o
(shows_pat (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_)
   (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_) p o
  (shows_nl o x))))))))))
                end
                  bb
              end)
          end
            ba
        end
          b
      end
    | WPEQ (p_new, p) =>
      let
        val (left, right) = p;
        val (lefta, righta) = p_new;
      in
        catch_errora
          (bindb
            (check (word_pat_equiv A3_ left lefta)
              (shows_prec_list show_char zero_nata
                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l",
                  #"h", #"s", #"s", #" ", #"a", #"r", #"e", #" ", #"n", #"o",
                  #"t", #" ", #"e", #"q", #"u", #"i", #"v", #"a", #"l", #"e",
                  #"n", #"t"]))
            (fn _ =>
              check (word_pat_equiv A3_ right righta)
                (shows_prec_list show_char zero_nata
                  [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"r",
                    #"h", #"s", #"s", #" ", #"a", #"r", #"e", #" ", #"n", #"o",
                    #"t", #" ", #"e", #"q", #"u", #"i", #"v", #"a", #"l", #"e",
                    #"n", #"t"])))
          (fn x =>
            Inl (shows_prec_list show_char zero_nata
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                     #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ",
                     #"e", #"q", #"u", #"i", #"v", #"a", #"l", #"e", #"n", #"c",
                     #"e", #" ", #"o", #"f", #" "] o
                  (shows_nl o
                    (shows_pat (show_list A4_) show_nat show_nat (show_list A4_)
                       (show_list A4_) (show_list A4_) show_nat show_nat
                       (show_list A4_) (show_list A4_) p o
                      (shows_nl o
                        (shows_prec_list show_char zero_nata
                           [#"a", #"n", #"d"] o
                          (shows_nl o
                            (shows_pat (show_list A4_) show_nat show_nat
                               (show_list A4_) (show_list A4_) (show_list A4_)
                               show_nat show_nat (show_list A4_) (show_list A4_)
                               p_new o
                              (shows_nl o x)))))))))
      end
    | Lift (p_new, p) =>
      let
        val a = p;
        val (aa, b) = a;
      in
        let
          val (l1, ab) = aa;
          val (ac, ba) = ab;
        in
          let
            val (f1, (c1, m1)) = ac;
          in
            (fn r1 => fn (l2, ad) =>
              let
                val (ae, bb) = ad;
              in
                let
                  val (f2, (c2, m2)) = ae;
                in
                  (fn r2 =>
                    let
                      val af = p_new;
                      val (ag, bc) = af;
                    in
                      let
                        val (l1a, ah) = ag;
                        val (ai, bd) = ah;
                      in
                        let
                          val (f1a, (c1a, m1a)) = ai;
                        in
                          (fn r1a => fn (l2a, aj) =>
                            let
                              val (ak, be) = aj;
                            in
                              let
                                val (f2a, (c2a, m2a)) = ak;
                              in
                                (fn r2a =>
                                  catch_errora
                                    (bindb
                                      (check
(equal_lista A3_ l1 l1a andalso equal_lista A3_ l2 l2a)
(shows_prec_list show_char zero_nata
  [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l", #" ", #"a", #"n",
    #"d", #" ", #"l", #"'", #" ", #"d", #"o", #" ", #"n", #"o", #"t", #" ",
    #"m", #"a", #"t", #"c", #"h"]))
                                      (fn _ =>
bindb (check (equal_lista A3_ r1 r1a andalso equal_lista A3_ r2 r2a)
        (shows_prec_list show_char zero_nata
          [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"r", #" ",
            #"a", #"n", #"d", #" ", #"r", #"'", #" ", #"d", #"o", #" ", #"n",
            #"o", #"t", #" ", #"m", #"a", #"t", #"c", #"h"]))
  (fn _ =>
    bindb (check (equal_nata f1 f1a andalso equal_nata f2 f2a)
            (shows_prec_list show_char zero_nata
              [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"f", #" ",
                #"a", #"n", #"d", #" ", #"f", #"'", #" ", #"d", #"o", #" ",
                #"n", #"o", #"t", #" ", #"m", #"a", #"t", #"c", #"h"]))
      (fn _ =>
        bindb (check (equal_lista A3_ m1 m1a andalso equal_lista A3_ m2 m2a)
                (shows_prec_list show_char zero_nata
                  [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"m",
                    #" ", #"a", #"n", #"d", #" ", #"m", #"'", #" ", #"d", #"o",
                    #" ", #"n", #"o", #"t", #" ", #"m", #"a", #"t", #"c",
                    #"h"]))
          (fn _ =>
            bindb (check (equal_nata c1a (plus_nata c1 f1))
                    (shows_prec_list show_char zero_nata
                      [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                        #"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t", #" ",
                        #"f", #"a", #"c", #"t", #"o", #"r", #" ", #"o", #"n",
                        #" ", #"t", #"h", #"e", #" ", #"l", #"e", #"f", #"t",
                        #" ", #"n", #"o", #"t", #" ", #"p", #"r", #"o", #"p",
                        #"e", #"r", #"l", #"y", #" ", #"i", #"n", #"c", #"r",
                        #"e", #"a", #"s", #"e", #"d"]))
              (fn _ =>
                check (equal_nata c2a (plus_nata c2 f2))
                  (shows_prec_list show_char zero_nata
                    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"c",
                      #"o", #"n", #"s", #"t", #"a", #"n", #"t", #" ", #"f",
                      #"a", #"c", #"t", #"o", #"r", #" ", #"o", #"n", #" ",
                      #"t", #"h", #"e", #" ", #"r", #"i", #"g", #"h", #"t",
                      #" ", #"n", #"o", #"t", #" ", #"p", #"r", #"o", #"p",
                      #"e", #"r", #"l", #"y", #" ", #"i", #"n", #"c", #"r",
                      #"e", #"a", #"s", #"e", #"d"])))))))
                                    (fn x =>
                                      Inl
(shows_prec_list show_char zero_nata
   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ", #"c",
     #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ", #"l", #"i", #"f", #"t",
     #"i", #"n", #"g", #" ", #"o", #"f", #" "] o
  (shows_nl o
    (shows_pat (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_)
       (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_) p o
      (shows_nl o
        (shows_prec_list show_char zero_nata
           [#"t", #"o", #" ", #"y", #"i", #"e", #"l", #"d"] o
          (shows_nl o
            (shows_pat (show_list A4_) show_nat show_nat (show_list A4_)
               (show_list A4_) (show_list A4_) show_nat show_nat (show_list A4_)
               (show_list A4_) p_new o
              (shows_nl o x))))))))))
                              end
                                be
                            end)
                        end
                          bd
                      end
                        bc
                    end)
                end
                  bb
              end)
          end
            ba
        end
          b
      end
    | DPOC1_1 (p_new, p1, oc1, l, ra) =>
      let
        val (left, (lxr, (m2, r2))) = p1;
        val (x, v) = oc1;
        val (lefta, (lvr, (m2a, r2a))) = p_new;
      in
        catch_errora
          (bindb
            (check
              (equal_proda (equal_list A3_)
                (equal_prod
                  (equal_prod equal_nat (equal_prod equal_nat (equal_list A3_)))
                  (equal_list A3_))
                left lefta)
              (shows_prec_list show_char zero_nata
                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l",
                  #"h", #"s", #"s", #" ", #"a", #"r", #"e", #" ", #"n", #"o",
                  #"t", #" ", #"e", #"q", #"u", #"a", #"l"]))
            (fn _ =>
              bindb (check
                      (equal_proda equal_nat
                        (equal_prod equal_nat (equal_list A3_)) m2 m2a)
                      (shows_prec_list show_char zero_nata
                        [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                          #"m", #"2", #" ", #"a", #"n", #"d", #" ", #"m", #"2",
                          #"'", #" ", #"d", #"o", #" ", #"n", #"o", #"t", #" ",
                          #"m", #"a", #"t", #"c", #"h"]))
                (fn _ =>
                  bindb (check (equal_lista A3_ r2 r2a)
                          (shows_prec_list show_char zero_nata
                            [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":",
                              #" ", #"r", #"2", #" ", #"a", #"n", #"d", #" ",
                              #"r", #"2", #"'", #" ", #"d", #"o", #" ", #"n",
                              #"o", #"t", #" ", #"m", #"a", #"t", #"c", #"h"]))
                    (fn _ =>
                      bindb (check (equal_lista A3_ lxr (l @ x @ ra))
                              (shows_prec_list show_char zero_nata
                                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":",
                                  #" ", #"l", #"_", #"x", #"_", #"r", #" ",
                                  #"!", #"=", #" ", #"l", #" ", #"@", #" ",
                                  #"x", #" ", #"@", #" ", #"r"]))
                        (fn _ =>
                          check (equal_lista A3_ lvr (l @ v @ ra))
                            (shows_prec_list show_char zero_nata
                              [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":",
                                #" ", #"l", #"_", #"v", #"_", #"r", #" ", #"!",
                                #"=", #" ", #"l", #" ", #"@", #" ", #"v", #" ",
                                #"@", #" ", #"r"]))))))
          (fn xa =>
            Inl (shows_prec_list show_char zero_nata
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                     #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ",
                     #"o", #"v", #"e", #"r", #"l", #"a", #"p", #" ", #"D", #"P",
                     #"O", #"C", #"1", #"_", #"1", #" ", #"o", #"f", #" "] o
                  (shows_nl o
                    (shows_pat (show_list A4_) show_nat show_nat (show_list A4_)
                       (show_list A4_) (show_list A4_) show_nat show_nat
                       (show_list A4_) (show_list A4_) p1 o
                      (shows_nl o
                        (shows_oc (show_list A4_) (show_list A4_) oc1 o
                          (shows_nl o
                            (shows_prec_list show_char zero_nata
                               [#"t", #"o", #" ", #"y", #"i", #"e", #"l",
                                 #"d"] o
                              (shows_nl o
                                (shows_pat (show_list A4_) show_nat show_nat
                                   (show_list A4_) (show_list A4_)
                                   (show_list A4_) show_nat show_nat
                                   (show_list A4_) (show_list A4_) p_new o
                                  (shows_nl o xa)))))))))))
      end
    | DPOC1_2 (p_new, p1, oc1, l, ra, x) =>
      let
        val a = p1;
        val (aa, b) = a;
      in
        let
          val (l1, (m1, r1)) = aa;
        in
          (fn (xr, (m2, r2)) =>
            let
              val (lx, v) = oc1;
              val ab = p_new;
              val (ac, ba) = ab;
            in
              let
                val (ll1, (m1a, r1a)) = ac;
              in
                (fn (vr, (m2a, r2a)) =>
                  catch_errora
                    (bindb
                      (check
                        (equal_proda equal_nat
                           (equal_prod equal_nat (equal_list A3_)) m1
                           m1a andalso
                          equal_proda equal_nat
                            (equal_prod equal_nat (equal_list A3_)) m2 m2a)
                        (shows_prec_list show_char zero_nata
                          [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                            #"m", #" ", #"c", #"o", #"m", #"p", #"o", #"n",
                            #"e", #"n", #"t", #"s", #" ", #"m", #"o", #"d",
                            #"i", #"f", #"i", #"e", #"d"]))
                      (fn _ =>
                        bindb (check
                                (equal_lista A3_ r1 r1a andalso
                                  equal_lista A3_ r2 r2a)
                                (shows_prec_list show_char zero_nata
                                  [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                    #":", #" ", #"r", #" ", #"c", #"o", #"m",
                                    #"p", #"o", #"n", #"e", #"n", #"t", #"s",
                                    #" ", #"m", #"o", #"d", #"i", #"f", #"i",
                                    #"e", #"d"]))
                          (fn _ =>
                            bindb (check (equal_lista A3_ ll1 (l @ l1))
                                    (shows_prec_list show_char zero_nata
                                      [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
#":", #" ", #"l", #"_", #"l", #"1", #" ", #"!", #"=", #" ", #"l", #" ", #"@",
#" ", #"l", #"l", #"1"]))
                              (fn _ =>
                                bindb (check (equal_lista A3_ xr (x @ ra))
(shows_prec_list show_char zero_nata
  [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"x", #"_", #"r", #" ",
    #"!", #"=", #" ", #"x", #" ", #"@", #" ", #"r"]))
                                  (fn _ =>
                                    bindb (check (equal_lista A3_ lx (l @ x))
    (shows_prec_list show_char zero_nata
      [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l", #"_", #"x",
        #" ", #"!", #"=", #" ", #"l", #" ", #"@", #" ", #"x"]))
                                      (fn _ =>
check (equal_lista A3_ vr (v @ ra))
  (shows_prec_list show_char zero_nata
    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"v", #"_", #"r",
      #" ", #"!", #"=", #" ", #"v", #" ", #"@", #" ", #"r"])))))))
                    (fn xa =>
                      Inl (shows_prec_list show_char zero_nata
                             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                               #"i", #"n", #" ", #"c", #"h", #"e", #"c", #"k",
                               #"i", #"n", #"g", #" ", #"o", #"v", #"e", #"r",
                               #"l", #"a", #"p", #" ", #"D", #"P", #"O", #"C",
                               #"1", #"_", #"2", #" ", #"o", #"f", #" "] o
                            (shows_nl o
                              (shows_pat (show_list A4_) show_nat show_nat
                                 (show_list A4_) (show_list A4_) (show_list A4_)
                                 show_nat show_nat (show_list A4_)
                                 (show_list A4_) p1 o
                                (shows_nl o
                                  (shows_oc (show_list A4_) (show_list A4_)
                                     oc1 o
                                    (shows_nl o
                                      (shows_prec_list show_char zero_nata
 [#"t", #"o", #" ", #"y", #"i", #"e", #"l", #"d"] o
(shows_nl o
  (shows_pat (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_)
     (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_) p_new o
    (shows_nl o xa))))))))))))
              end
                ba
            end)
        end
          b
      end
    | DPOC2 (p_new, p1, oc1, l, ra) =>
      let
        val a = p1;
        val (left, aa) = a;
        val (l2, ab) = aa;
        val (ac, b) = ab;
      in
        let
          val (f2, (c2, lxr)) = ac;
        in
          (fn r2 =>
            let
              val (x, v) = oc1;
              val ad = p_new;
              val (lefta, ae) = ad;
              val (l2a, af) = ae;
              val (ag, ba) = af;
            in
              let
                val (f2a, (c2a, lvr)) = ag;
              in
                (fn r2a =>
                  catch_errora
                    (bindb
                      (check
                        (equal_proda (equal_list A3_)
                          (equal_prod
                            (equal_prod equal_nat
                              (equal_prod equal_nat (equal_list A3_)))
                            (equal_list A3_))
                          left lefta)
                        (shows_prec_list show_char zero_nata
                          [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                            #"l", #"e", #"f", #"t", #" ", #"c", #"o", #"m",
                            #"p", #"o", #"n", #"e", #"n", #"t", #"s", #" ",
                            #"m", #"o", #"d", #"i", #"f", #"i", #"e", #"d"]))
                      (fn _ =>
                        bindb (check (equal_nata f2 f2a)
                                (shows_prec_list show_char zero_nata
                                  [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                    #":", #" ", #"f", #" ", #"c", #"o", #"m",
                                    #"p", #"o", #"n", #"e", #"n", #"t", #"s",
                                    #" ", #"m", #"o", #"d", #"i", #"f", #"i",
                                    #"e", #"d"]))
                          (fn _ =>
                            bindb (check (equal_nata c2 c2a)
                                    (shows_prec_list show_char zero_nata
                                      [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
#":", #" ", #"c", #" ", #"c", #"o", #"m", #"p", #"o", #"n", #"e", #"n", #"t",
#"s", #" ", #"m", #"o", #"d", #"i", #"f", #"i", #"e", #"d"]))
                              (fn _ =>
                                bindb (check (equal_lista A3_ l2 l2a)
(shows_prec_list show_char zero_nata
  [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l", #" ", #"c", #"o",
    #"m", #"p", #"o", #"n", #"e", #"n", #"t", #"s", #" ", #"m", #"o", #"d",
    #"i", #"f", #"i", #"e", #"d"]))
                                  (fn _ =>
                                    bindb (check (equal_lista A3_ r2 r2a)
    (shows_prec_list show_char zero_nata
      [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"r", #" ", #"c",
        #"o", #"m", #"p", #"o", #"n", #"e", #"n", #"t", #"s", #" ", #"m", #"o",
        #"d", #"i", #"f", #"i", #"e", #"d"]))
                                      (fn _ =>
bindb (check (equal_lista A3_ lxr (l @ x @ ra))
        (shows_prec_list show_char zero_nata
          [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l", #"_",
            #"x", #"_", #"r", #" ", #"!", #"=", #" ", #"l", #" ", #"@", #" ",
            #"x", #" ", #"@", #" ", #"r"]))
  (fn _ =>
    check (equal_lista A3_ lvr (l @ v @ ra))
      (shows_prec_list show_char zero_nata
        [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l", #"_", #"v",
          #"_", #"r", #" ", #"!", #"=", #" ", #"l", #" ", #"@", #" ", #"v",
          #" ", #"@", #" ", #"r"]))))))))
                    (fn xa =>
                      Inl (shows_prec_list show_char zero_nata
                             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                               #"i", #"n", #" ", #"c", #"h", #"e", #"c", #"k",
                               #"i", #"n", #"g", #" ", #"o", #"v", #"e", #"r",
                               #"l", #"a", #"p", #" ", #"D", #"P", #"O", #"C",
                               #"2", #" ", #"o", #"f", #" "] o
                            (shows_nl o
                              (shows_pat (show_list A4_) show_nat show_nat
                                 (show_list A4_) (show_list A4_) (show_list A4_)
                                 show_nat show_nat (show_list A4_)
                                 (show_list A4_) p1 o
                                (shows_nl o
                                  (shows_oc (show_list A4_) (show_list A4_)
                                     oc1 o
                                    (shows_nl o
                                      (shows_prec_list show_char zero_nata
 [#"t", #"o", #" ", #"y", #"i", #"e", #"l", #"d"] o
(shows_nl o
  (shows_pat (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_)
     (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_) p_new o
    (shows_nl o xa))))))))))))
              end
                ba
            end)
        end
          b
      end
    | DPOC3_1 (p_new, p1, oc1, l, ra) =>
      let
        val (left, (l2, (m2, lxr))) = p1;
        val (x, v) = oc1;
        val (lefta, (l2a, (m2a, lvr))) = p_new;
      in
        catch_errora
          (bindb
            (check
              (equal_proda (equal_list A3_)
                (equal_prod
                  (equal_prod equal_nat (equal_prod equal_nat (equal_list A3_)))
                  (equal_list A3_))
                left lefta)
              (shows_prec_list show_char zero_nata
                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l",
                  #"e", #"f", #"t", #" ", #"c", #"o", #"m", #"p", #"o", #"n",
                  #"e", #"n", #"t", #"s", #" ", #"m", #"o", #"d", #"i", #"f",
                  #"i", #"e", #"d"]))
            (fn _ =>
              bindb (check
                      (equal_proda equal_nat
                        (equal_prod equal_nat (equal_list A3_)) m2 m2a)
                      (shows_prec_list show_char zero_nata
                        [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                          #"m", #" ", #"c", #"o", #"m", #"p", #"o", #"n", #"e",
                          #"n", #"t", #"s", #" ", #"m", #"o", #"d", #"i", #"f",
                          #"i", #"e", #"d"]))
                (fn _ =>
                  bindb (check (equal_lista A3_ l2 l2a)
                          (shows_prec_list show_char zero_nata
                            [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":",
                              #" ", #"l", #" ", #"c", #"o", #"m", #"p", #"o",
                              #"n", #"e", #"n", #"t", #"s", #" ", #"m", #"o",
                              #"d", #"i", #"f", #"i", #"e", #"d"]))
                    (fn _ =>
                      bindb (check (equal_lista A3_ lxr (l @ x @ ra))
                              (shows_prec_list show_char zero_nata
                                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":",
                                  #" ", #"l", #"_", #"x", #"_", #"r", #" ",
                                  #"!", #"=", #" ", #"l", #" ", #"@", #" ",
                                  #"x", #" ", #"@", #" ", #"r"]))
                        (fn _ =>
                          check (equal_lista A3_ lvr (l @ v @ ra))
                            (shows_prec_list show_char zero_nata
                              [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":",
                                #" ", #"l", #"_", #"v", #"_", #"r", #" ", #"!",
                                #"=", #" ", #"l", #" ", #"@", #" ", #"v", #" ",
                                #"@", #" ", #"r"]))))))
          (fn xa =>
            Inl (shows_prec_list show_char zero_nata
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                     #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ",
                     #"o", #"v", #"e", #"r", #"l", #"a", #"p", #" ", #"D", #"P",
                     #"O", #"C", #"3", #"_", #"1", #" ", #"o", #"f", #" "] o
                  (shows_nl o
                    (shows_pat (show_list A4_) show_nat show_nat (show_list A4_)
                       (show_list A4_) (show_list A4_) show_nat show_nat
                       (show_list A4_) (show_list A4_) p1 o
                      (shows_nl o
                        (shows_oc (show_list A4_) (show_list A4_) oc1 o
                          (shows_nl o
                            (shows_prec_list show_char zero_nata
                               [#"t", #"o", #" ", #"y", #"i", #"e", #"l",
                                 #"d"] o
                              (shows_nl o
                                (shows_pat (show_list A4_) show_nat show_nat
                                   (show_list A4_) (show_list A4_)
                                   (show_list A4_) show_nat show_nat
                                   (show_list A4_) (show_list A4_) p_new o
                                  (shows_nl o xa)))))))))))
      end
    | DPOC3_2 (p_new, p1, oc1, l, ra, x) =>
      let
        val a = p1;
        val (aa, b) = a;
      in
        let
          val (l1, (m1, r1)) = aa;
        in
          (fn (l2, (m2, lx)) =>
            let
              val (xr, v) = oc1;
              val ab = p_new;
              val (ac, ba) = ab;
            in
              let
                val (l1a, (m1a, r1r)) = ac;
              in
                (fn (l2a, (m2a, lv)) =>
                  catch_errora
                    (bindb
                      (check
                        (equal_proda equal_nat
                           (equal_prod equal_nat (equal_list A3_)) m2
                           m2a andalso
                          equal_proda equal_nat
                            (equal_prod equal_nat (equal_list A3_)) m1 m1a)
                        (shows_prec_list show_char zero_nata
                          [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                            #"m", #" ", #"c", #"o", #"m", #"p", #"o", #"n",
                            #"e", #"n", #"t", #"s", #" ", #"m", #"o", #"d",
                            #"i", #"f", #"i", #"e", #"d"]))
                      (fn _ =>
                        bindb (check (equal_lista A3_ l1 l1a)
                                (shows_prec_list show_char zero_nata
                                  [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                    #":", #" ", #"l", #" ", #"c", #"o", #"m",
                                    #"p", #"o", #"n", #"e", #"n", #"t", #"s",
                                    #" ", #"m", #"o", #"d", #"i", #"f", #"i",
                                    #"e", #"d"]))
                          (fn _ =>
                            bindb (check (equal_lista A3_ l2 l2a)
                                    (shows_prec_list show_char zero_nata
                                      [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
#":", #" ", #"l", #"2", #" ", #"c", #"o", #"m", #"p", #"o", #"n", #"e", #"n",
#"t", #"s", #" ", #"m", #"o", #"d", #"i", #"f", #"i", #"e", #"d"]))
                              (fn _ =>
                                bindb (check (equal_lista A3_ lx (l @ x))
(shows_prec_list show_char zero_nata
  [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l", #"_", #"x", #" ",
    #"!", #"=", #" ", #"l", #" ", #"@", #" ", #"x"]))
                                  (fn _ =>
                                    bindb (check (equal_lista A3_ xr (x @ ra))
    (shows_prec_list show_char zero_nata
      [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"x", #"_", #"r",
        #" ", #"!", #"=", #" ", #"x", #" ", #"@", #" ", #"r"]))
                                      (fn _ =>
bindb (check (equal_lista A3_ r1r (r1 @ ra))
        (shows_prec_list show_char zero_nata
          [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"r", #"1",
            #"_", #"r", #" ", #"!", #"=", #" ", #"r", #"1", #" ", #"@", #" ",
            #"r"]))
  (fn _ =>
    check (equal_lista A3_ lv (l @ v))
      (shows_prec_list show_char zero_nata
        [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l", #"_", #"v",
          #" ", #"!", #"=", #" ", #"l", #" ", #"@", #" ", #"v"]))))))))
                    (fn xa =>
                      Inl (shows_prec_list show_char zero_nata
                             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                               #"i", #"n", #" ", #"c", #"h", #"e", #"c", #"k",
                               #"i", #"n", #"g", #" ", #"o", #"v", #"e", #"r",
                               #"l", #"a", #"p", #" ", #"D", #"P", #"O", #"C",
                               #"3", #"_", #"2", #" ", #"o", #"f", #" "] o
                            (shows_nl o
                              (shows_pat (show_list A4_) show_nat show_nat
                                 (show_list A4_) (show_list A4_) (show_list A4_)
                                 show_nat show_nat (show_list A4_)
                                 (show_list A4_) p1 o
                                (shows_nl o
                                  (shows_oc (show_list A4_) (show_list A4_)
                                     oc1 o
                                    (shows_nl o
                                      (shows_prec_list show_char zero_nata
 [#"t", #"o", #" ", #"y", #"i", #"e", #"l", #"d"] o
(shows_nl o
  (shows_pat (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_)
     (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_) p_new o
    (shows_nl o xa))))))))))))
              end
                ba
            end)
        end
          b
      end
    | DPDP1_1 (p_new, p1, p2, l, ra) =>
      let
        val (left, (ll2, (mm, r2r))) = p1;
        val a = p2;
        val (aa, b) = a;
      in
        let
          val (l2, (mma, r2)) = aa;
        in
          (fn (l2a, (mm2, r2a)) =>
            let
              val (lefta, (ll2a, (mm2a, r2pr))) = p_new;
            in
              catch_errora
                (bindb
                  (check
                    (equal_proda (equal_list A3_)
                      (equal_prod
                        (equal_prod equal_nat
                          (equal_prod equal_nat (equal_list A3_)))
                        (equal_list A3_))
                      left lefta)
                    (shows_prec_list show_char zero_nata
                      [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                        #"l", #"e", #"f", #"t", #" ", #"c", #"o", #"m", #"p",
                        #"o", #"n", #"e", #"n", #"t", #"s", #" ", #"m", #"o",
                        #"d", #"i", #"f", #"i", #"e", #"d"]))
                  (fn _ =>
                    bindb (check
                            (equal_proda equal_nat
                              (equal_prod equal_nat (equal_list A3_)) mm mma)
                            (shows_prec_list show_char zero_nata
                              [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":",
                                #" ", #"m", #"m", #" ", #"c", #"o", #"m", #"p",
                                #"o", #"n", #"e", #"n", #"t", #"s", #" ", #"m",
                                #"o", #"d", #"i", #"f", #"i", #"e", #"d"]))
                      (fn _ =>
                        bindb (check
                                (equal_proda equal_nat
                                  (equal_prod equal_nat (equal_list A3_)) mm2
                                  mm2a)
                                (shows_prec_list show_char zero_nata
                                  [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                    #":", #" ", #"m", #"m", #"2", #" ", #"c",
                                    #"o", #"m", #"p", #"o", #"n", #"e", #"n",
                                    #"t", #"s", #" ", #"m", #"o", #"d", #"i",
                                    #"f", #"i", #"e", #"d"]))
                          (fn _ =>
                            bindb (check (equal_lista A3_ ll2 (l @ l2))
                                    (shows_prec_list show_char zero_nata
                                      [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
#":", #" ", #"l", #"_", #"l", #"2", #" ", #"!", #"=", #" ", #"l", #" ", #"@",
#" ", #"l", #"2"]))
                              (fn _ =>
                                bindb (check (equal_lista A3_ r2r (r2 @ ra))
(shows_prec_list show_char zero_nata
  [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"r", #"2", #"_", #"r",
    #" ", #"!", #"=", #" ", #"r", #"2", #" ", #"@", #" ", #"r"]))
                                  (fn _ =>
                                    bindb (check
    (equal_lista A3_ r2pr (r2a @ ra))
    (shows_prec_list show_char zero_nata
      [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"r", #"2", #"p",
        #"r", #" ", #"!", #"=", #" ", #"r", #"2", #"'", #" ", #"@", #" ",
        #"r"]))
                                      (fn _ =>
check (equal_lista A3_ ll2a (l @ l2a))
  (shows_prec_list show_char zero_nata
    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l", #"_", #"l",
      #"2", #" ", #"!", #"=", #" ", #"l", #" ", #"@", #" ", #"l", #"2",
      #" "]))))))))
                (fn x =>
                  Inl (shows_prec_list show_char zero_nata
                         [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i",
                           #"n", #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n",
                           #"g", #" ", #"o", #"v", #"e", #"r", #"l", #"a", #"p",
                           #" ", #"D", #"P", #"D", #"P", #"1", #"_", #"1", #" ",
                           #"o", #"f", #" "] o
                        (shows_nl o
                          (shows_pat (show_list A4_) show_nat show_nat
                             (show_list A4_) (show_list A4_) (show_list A4_)
                             show_nat show_nat (show_list A4_) (show_list A4_)
                             p1 o
                            (shows_nl o
                              (shows_pat (show_list A4_) show_nat show_nat
                                 (show_list A4_) (show_list A4_) (show_list A4_)
                                 show_nat show_nat (show_list A4_)
                                 (show_list A4_) p2 o
                                (shows_nl o
                                  (shows_prec_list show_char zero_nata
                                     [#"t", #"o", #" ", #"y", #"i", #"e", #"l",
                                       #"d"] o
                                    (shows_nl o
                                      (shows_pat (show_list A4_) show_nat
 show_nat (show_list A4_) (show_list A4_) (show_list A4_) show_nat show_nat
 (show_list A4_) (show_list A4_) p_new o
(shows_nl o x)))))))))))
            end)
        end
          b
      end
    | DPDP1_2 (p_new, p1, p2, l, ra) =>
      let
        val a = p1;
        val (aa, b) = a;
      in
        let
          val (l1, (mm1, r1)) = aa;
        in
          (fn (ll2, (mm, r1a)) =>
            let
              val ab = p2;
              val (ac, ba) = ab;
            in
              let
                val (l2, (mm2, r1r)) = ac;
              in
                (fn (l2a, (mm2a, r2)) =>
                  let
                    val ad = p_new;
                    val (ae, bb) = ad;
                  in
                    let
                      val (l3, (mm3, r1pr)) = ae;
                    in
                      (fn (ll2a, (mm3a, r3)) =>
                        catch_errora
                          (bindb
                            (check (equal_lista A3_ l1 l3)
                              (shows_prec_list show_char zero_nata
                                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":",
                                  #" ", #"l", #"1", #"'", #" ", #"c", #"o",
                                  #"m", #"p", #"o", #"n", #"e", #"n", #"t",
                                  #"s", #" ", #"m", #"o", #"d", #"i", #"f",
                                  #"i", #"e", #"d"]))
                            (fn _ =>
                              bindb (check
                                      (equal_proda equal_nat
(equal_prod equal_nat (equal_list A3_)) mm1 mm3)
                                      (shows_prec_list show_char zero_nata
[#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"m", #"m", #"1", #"'",
  #" ", #"c", #"o", #"m", #"p", #"o", #"n", #"e", #"n", #"t", #"s", #" ", #"m",
  #"o", #"d", #"i", #"f", #"i", #"e", #"d"]))
                                (fn _ =>
                                  bindb (check
  (equal_proda equal_nat (equal_prod equal_nat (equal_list A3_)) mm mm2)
  (shows_prec_list show_char zero_nata
    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"m", #"m", #" ",
      #"c", #"o", #"m", #"p", #"o", #"n", #"e", #"n", #"t", #"s", #" ", #"m",
      #"o", #"d", #"i", #"f", #"i", #"e", #"d"]))
                                    (fn _ =>
                                      bindb
(check (equal_proda equal_nat (equal_prod equal_nat (equal_list A3_)) mm2a mm3a)
  (shows_prec_list show_char zero_nata
    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"m", #"m", #"2",
      #"'", #" ", #"c", #"o", #"m", #"p", #"o", #"n", #"e", #"n", #"t", #"s",
      #" ", #"m", #"o", #"d", #"i", #"f", #"i", #"e", #"d"]))
(fn _ =>
  bindb (check (equal_lista A3_ r2 r3)
          (shows_prec_list show_char zero_nata
            [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"r", #"2",
              #"'", #" ", #"c", #"o", #"m", #"p", #"o", #"n", #"e", #"n", #"t",
              #"s", #" ", #"m", #"o", #"d", #"i", #"f", #"i", #"e", #"d"]))
    (fn _ =>
      bindb (check (equal_lista A3_ ll2 (l @ l2))
              (shows_prec_list show_char zero_nata
                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l",
                  #"_", #"l", #"2", #" ", #"!", #"=", #" ", #"l", #" ", #"@",
                  #" ", #"l", #"2"]))
        (fn _ =>
          bindb (check (equal_lista A3_ r1pr (r1 @ ra))
                  (shows_prec_list show_char zero_nata
                    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"r",
                      #"1", #"'", #"r", #" ", #"!", #"=", #" ", #"r", #"1",
                      #"'", #" ", #"@", #" ", #"r"]))
            (fn _ =>
              bindb (check (equal_lista A3_ r1r (r1a @ ra))
                      (shows_prec_list show_char zero_nata
                        [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                          #"r", #"1", #"r", #" ", #"!", #"=", #" ", #"r", #"1",
                          #" ", #"@", #" ", #"r"]))
                (fn _ =>
                  check (equal_lista A3_ ll2a (l @ l2a))
                    (shows_prec_list show_char zero_nata
                      [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                        #"l", #"_", #"l", #"2", #" ", #"!", #"=", #" ", #"l",
                        #" ", #"@", #" ", #"l", #"2", #" "]))))))))))
                          (fn x =>
                            Inl (shows_prec_list show_char zero_nata
                                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                     #" ", #"i", #"n", #" ", #"c", #"h", #"e",
                                     #"c", #"k", #"i", #"n", #"g", #" ", #"o",
                                     #"v", #"e", #"r", #"l", #"a", #"p", #" ",
                                     #"D", #"P", #"D", #"P", #"1", #"_", #"2",
                                     #" ", #"o", #"f", #" "] o
                                  (shows_nl o
                                    (shows_pat (show_list A4_) show_nat show_nat
                                       (show_list A4_) (show_list A4_)
                                       (show_list A4_) show_nat show_nat
                                       (show_list A4_) (show_list A4_) p1 o
                                      (shows_nl o
(shows_pat (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_)
   (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_) p2 o
  (shows_nl o
    (shows_prec_list show_char zero_nata
       [#"t", #"o", #" ", #"y", #"i", #"e", #"l", #"d"] o
      (shows_nl o
        (shows_pat (show_list A4_) show_nat show_nat (show_list A4_)
           (show_list A4_) (show_list A4_) show_nat show_nat (show_list A4_)
           (show_list A4_) p_new o
          (shows_nl o x))))))))))))
                    end
                      bb
                  end)
              end
                ba
            end)
        end
          b
      end
    | DPDP2_1 (p_new, p1, p2, l, ra) =>
      let
        val a = p1;
        val (aa, b) = a;
      in
        let
          val (l1, (mm1, r1)) = aa;
        in
          (fn (l1a, (mm, r2r)) =>
            let
              val ab = p2;
              val (ac, ba) = ab;
            in
              let
                val (ll1, (mm2, r2)) = ac;
              in
                (fn (l2, (mm2a, r2a)) =>
                  let
                    val ad = p_new;
                    val (ae, bb) = ad;
                  in
                    let
                      val (ll1a, (mm3, r3)) = ae;
                    in
                      (fn (l3, (mm3a, r2pr)) =>
                        catch_errora
                          (bindb
                            (check (equal_lista A3_ r2r (r2 @ ra))
                              (shows_prec_list show_char zero_nata
                                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":",
                                  #" ", #"r", #"2", #"r", #" ", #"!", #"=",
                                  #" ", #"r", #"2", #" ", #"@", #" ", #"r"]))
                            (fn _ =>
                              bindb (check (equal_lista A3_ ll1 (l @ l1a))
                                      (shows_prec_list show_char zero_nata
[#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l", #"_", #"l", #"1",
  #" ", #"!", #"=", #" ", #"l", #" ", #"@", #" ", #"l", #"1"]))
                                (fn _ =>
                                  bindb (check (equal_lista A3_ ll1a (l @ l1))
  (shows_prec_list show_char zero_nata
    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l", #"_", #"l",
      #"1", #"'", #" ", #"!", #"=", #" ", #"l", #" ", #"@", #" ", #"l", #"1",
      #"'", #" "]))
                                    (fn _ =>
                                      bindb
(check (equal_proda equal_nat (equal_prod equal_nat (equal_list A3_)) mm1 mm3)
  (shows_prec_list show_char zero_nata
    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"m", #"m", #"1",
      #"'", #" ", #"c", #"o", #"m", #"p", #"o", #"n", #"e", #"n", #"t", #" ",
      #"m", #"o", #"d", #"i", #"f", #"i", #"e", #"d"]))
(fn _ =>
  bindb (check (equal_lista A3_ r1 r3)
          (shows_prec_list show_char zero_nata
            [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"r", #"1",
              #"'", #" ", #"c", #"o", #"m", #"p", #"o", #"n", #"e", #"n", #"t",
              #" ", #"m", #"o", #"d", #"i", #"f", #"i", #"e", #"d"]))
    (fn _ =>
      bindb (check (equal_lista A3_ l2 l3)
              (shows_prec_list show_char zero_nata
                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l",
                  #"2", #"'", #" ", #"c", #"o", #"m", #"p", #"o", #"n", #"e",
                  #"n", #"t", #" ", #"m", #"o", #"d", #"i", #"f", #"i", #"e",
                  #"d"]))
        (fn _ =>
          bindb (check
                  (equal_proda equal_nat (equal_prod equal_nat (equal_list A3_))
                    mm2a mm3a)
                  (shows_prec_list show_char zero_nata
                    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"m",
                      #"m", #"2", #"'", #" ", #"c", #"o", #"m", #"p", #"o",
                      #"n", #"e", #"n", #"t", #"s", #" ", #"m", #"o", #"d",
                      #"i", #"f", #"i", #"e", #"d"]))
            (fn _ =>
              bindb (check
                      (equal_proda equal_nat
                        (equal_prod equal_nat (equal_list A3_)) mm mm2)
                      (shows_prec_list show_char zero_nata
                        [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                          #"m", #"m", #" ", #"c", #"o", #"m", #"p", #"o", #"n",
                          #"e", #"n", #"t", #"s", #" ", #"m", #"o", #"d", #"i",
                          #"f", #"i", #"e", #"d"]))
                (fn _ =>
                  check (equal_lista A3_ r2pr (r2a @ ra))
                    (shows_prec_list show_char zero_nata
                      [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                        #"r", #"2", #"'", #"r", #" ", #"!", #"=", #" ", #"r",
                        #"2", #"'", #" ", #"@", #" ", #"r"]))))))))))
                          (fn x =>
                            Inl (shows_prec_list show_char zero_nata
                                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                     #" ", #"i", #"n", #" ", #"c", #"h", #"e",
                                     #"c", #"k", #"i", #"n", #"g", #" ", #"o",
                                     #"v", #"e", #"r", #"l", #"a", #"p", #" ",
                                     #"D", #"P", #"D", #"P", #"2", #"_", #"1",
                                     #" ", #"o", #"f", #" "] o
                                  (shows_nl o
                                    (shows_pat (show_list A4_) show_nat show_nat
                                       (show_list A4_) (show_list A4_)
                                       (show_list A4_) show_nat show_nat
                                       (show_list A4_) (show_list A4_) p1 o
                                      (shows_nl o
(shows_pat (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_)
   (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_) p2 o
  (shows_nl o
    (shows_prec_list show_char zero_nata
       [#"t", #"o", #" ", #"y", #"i", #"e", #"l", #"d"] o
      (shows_nl o
        (shows_pat (show_list A4_) show_nat show_nat (show_list A4_)
           (show_list A4_) (show_list A4_) show_nat show_nat (show_list A4_)
           (show_list A4_) p_new o
          (shows_nl o x))))))))))))
                    end
                      bb
                  end)
              end
                ba
            end)
        end
          b
      end
    | DPDP2_2 (p_new, p1, p2, l, ra) =>
      let
        val a = p1;
        val (aa, b) = a;
      in
        let
          val (l1, (mm1, r1)) = aa;
        in
          (fn (l1a, (mm1a, r1a)) =>
            let
              val ab = p2;
              val (ac, ba) = ab;
            in
              let
                val (ll1, (mm2, r1r)) = ac;
              in
                (fn right =>
                  let
                    val ad = p_new;
                    val (ae, bb) = ad;
                  in
                    let
                      val (ll1a, (mm3, r1pr)) = ae;
                    in
                      (fn righta =>
                        catch_errora
                          (bindb
                            (check (equal_lista A3_ r1r (r1a @ ra))
                              (shows_prec_list show_char zero_nata
                                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":",
                                  #" ", #"r", #"1", #"r", #" ", #"!", #"=",
                                  #" ", #"r", #"1", #" ", #"@", #" ", #"r"]))
                            (fn _ =>
                              bindb (check (equal_lista A3_ ll1 (l @ l1a))
                                      (shows_prec_list show_char zero_nata
[#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l", #"_", #"l", #"1",
  #" ", #"!", #"=", #" ", #"l", #" ", #"@", #" ", #"l", #"1"]))
                                (fn _ =>
                                  bindb (check (equal_lista A3_ ll1a (l @ l1))
  (shows_prec_list show_char zero_nata
    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"l", #"_", #"l",
      #"1", #"'", #" ", #"!", #"=", #" ", #"l", #" ", #"@", #" ", #"l", #"1",
      #"'", #" "]))
                                    (fn _ =>
                                      bindb
(check (equal_lista A3_ r1pr (r1 @ ra))
  (shows_prec_list show_char zero_nata
    [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"r", #"1", #"'",
      #"_", #"r", #" ", #"!", #"=", #" ", #"r", #"1", #"'", #" ", #"@", #" ",
      #"r", #" "]))
(fn _ =>
  bindb (check
          (equal_proda equal_nat (equal_prod equal_nat (equal_list A3_)) mm1
            mm3)
          (shows_prec_list show_char zero_nata
            [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"m", #"m",
              #"1", #"'", #" ", #"c", #"o", #"m", #"p", #"o", #"n", #"e", #"n",
              #"t", #" ", #"m", #"o", #"d", #"i", #"f", #"i", #"e", #"d"]))
    (fn _ =>
      bindb (check
              (equal_proda equal_nat (equal_prod equal_nat (equal_list A3_))
                mm1a mm2)
              (shows_prec_list show_char zero_nata
                [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"m",
                  #"m", #" ", #"c", #"o", #"m", #"p", #"o", #"n", #"e", #"n",
                  #"t", #"s", #" ", #"m", #"o", #"d", #"i", #"f", #"i", #"e",
                  #"d"]))
        (fn _ =>
          check (equal_proda (equal_list A3_)
                  (equal_prod
                    (equal_prod equal_nat
                      (equal_prod equal_nat (equal_list A3_)))
                    (equal_list A3_))
                  right righta)
            (shows_prec_list show_char zero_nata
              [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ", #"r", #"i",
                #"g", #"h", #"t", #" ", #"c", #"o", #"m", #"p", #"o", #"n",
                #"e", #"n", #"t", #"s", #" ", #"m", #"o", #"d", #"i", #"f",
                #"i", #"e", #"d"]))))))))
                          (fn x =>
                            Inl (shows_prec_list show_char zero_nata
                                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                     #" ", #"i", #"n", #" ", #"c", #"h", #"e",
                                     #"c", #"k", #"i", #"n", #"g", #" ", #"o",
                                     #"v", #"e", #"r", #"l", #"a", #"p", #" ",
                                     #"D", #"P", #"D", #"P", #"2", #"_", #" ",
                                     #"o", #"f", #" "] o
                                  (shows_nl o
                                    (shows_pat (show_list A4_) show_nat show_nat
                                       (show_list A4_) (show_list A4_)
                                       (show_list A4_) show_nat show_nat
                                       (show_list A4_) (show_list A4_) p1 o
                                      (shows_nl o
(shows_pat (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_)
   (show_list A4_) show_nat show_nat (show_list A4_) (show_list A4_) p2 o
  (shows_nl o
    (shows_prec_list show_char zero_nata
       [#"t", #"o", #" ", #"y", #"i", #"e", #"l", #"d"] o
      (shows_nl o
        (shows_pat (show_list A4_) show_nat show_nat (show_list A4_)
           (show_list A4_) (show_list A4_) show_nat show_nat (show_list A4_)
           (show_list A4_) p_new o
          (shows_nl o x))))))))))))
                    end
                      bb
                  end)
              end
                ba
            end)
        end
          b
      end);

fun prems_ofa step =
  (case step of OC1 (_, _) => []
    | OC2 (_, p, pa, _, _, _) =>
      [(([], ((zero_nata, (zero_nata, [])), fst p)),
         ([], ((zero_nata, (zero_nata, [])), snd p))),
        (([], ((zero_nata, (zero_nata, [])), fst pa)),
          ([], ((zero_nata, (zero_nata, [])), snd pa)))]
    | OC2p (_, p, pa, _, _, _) =>
      [(([], ((zero_nata, (zero_nata, [])), fst p)),
         ([], ((zero_nata, (zero_nata, [])), snd p))),
        (([], ((zero_nata, (zero_nata, [])), fst pa)),
          ([], ((zero_nata, (zero_nata, [])), snd pa)))]
    | OC3 (_, p, pa, _, _) =>
      [(([], ((zero_nata, (zero_nata, [])), fst p)),
         ([], ((zero_nata, (zero_nata, [])), snd p))),
        (([], ((zero_nata, (zero_nata, [])), fst pa)),
          ([], ((zero_nata, (zero_nata, [])), snd pa)))]
    | OC3p (_, p, pa, _, _) =>
      [(([], ((zero_nata, (zero_nata, [])), fst p)),
         ([], ((zero_nata, (zero_nata, [])), snd p))),
        (([], ((zero_nata, (zero_nata, [])), fst pa)),
          ([], ((zero_nata, (zero_nata, [])), snd pa)))]
    | OCDP1 (_, p) =>
      [(([], ((zero_nata, (zero_nata, [])), fst p)),
         ([], ((zero_nata, (zero_nata, [])), snd p)))]
    | OCDP2 (_, p) =>
      [(([], ((zero_nata, (zero_nata, [])), fst p)),
         ([], ((zero_nata, (zero_nata, [])), snd p)))]
    | WPEQ (_, p) => [p] | Lift (_, p) => [p]
    | DPOC1_1 (_, p, rl, _, _) =>
      [p, (([], ((zero_nata, (zero_nata, [])), fst rl)),
            ([], ((zero_nata, (zero_nata, [])), snd rl)))]
    | DPOC1_2 (_, p, rl, _, _, _) =>
      [p, (([], ((zero_nata, (zero_nata, [])), fst rl)),
            ([], ((zero_nata, (zero_nata, [])), snd rl)))]
    | DPOC2 (_, p, rl, _, _) =>
      [p, (([], ((zero_nata, (zero_nata, [])), fst rl)),
            ([], ((zero_nata, (zero_nata, [])), snd rl)))]
    | DPOC3_1 (_, p, rl, _, _) =>
      [p, (([], ((zero_nata, (zero_nata, [])), fst rl)),
            ([], ((zero_nata, (zero_nata, [])), snd rl)))]
    | DPOC3_2 (_, p, rl, _, _, _) =>
      [p, (([], ((zero_nata, (zero_nata, [])), fst rl)),
            ([], ((zero_nata, (zero_nata, [])), snd rl)))]
    | DPDP1_1 (_, p1, p2, _, _) => [p1, p2]
    | DPDP1_2 (_, p1, p2, _, _) => [p1, p2]
    | DPDP2_1 (_, p1, p2, _, _) => [p1, p2]
    | DPDP2_2 (_, p1, p2, _, _) => [p1, p2]);

fun check_proof (A1_, A2_, A3_, A4_) r delta (p :: ps) =
  bindb (check_stepb (A1_, A2_, A3_, A4_) r p)
    (fn _ =>
      bindb (catch_errora
              (forallM
                (fn pa =>
                  check (member
                          (ceq_prod
                             (ceq_prod (ceq_list A1_)
                               (ceq_prod
                                 (ceq_prod ceq_nat
                                   (ceq_prod ceq_nat (ceq_list A1_)))
                                 (ceq_list A1_)))
                             (ceq_prod (ceq_list A1_)
                               (ceq_prod
                                 (ceq_prod ceq_nat
                                   (ceq_prod ceq_nat (ceq_list A1_)))
                                 (ceq_list A1_))),
                            ccompare_prod
                              (ccompare_prod (ccompare_list A2_)
                                (ccompare_prod
                                  (ccompare_prod ccompare_nat
                                    (ccompare_prod ccompare_nat
                                      (ccompare_list A2_)))
                                  (ccompare_list A2_)))
                              (ccompare_prod (ccompare_list A2_)
                                (ccompare_prod
                                  (ccompare_prod ccompare_nat
                                    (ccompare_prod ccompare_nat
                                      (ccompare_list A2_)))
                                  (ccompare_list A2_))))
                          pa delta)
                    (shows_prec_list show_char zero_nata
                       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #":", #" ",
                         #"n", #"o", #"t", #"h", #"i", #"n", #"g", #" ", #"k",
                         #"n", #"o", #"w", #"n", #" ", #"a", #"b", #"o", #"u",
                         #"t", #" ", #"p", #"r", #"e", #"m", #"i", #"s", #"e",
                         #" "] o
                      shows_pat (show_list A4_) show_nat show_nat
                        (show_list A4_) (show_list A4_) (show_list A4_) show_nat
                        show_nat (show_list A4_) (show_list A4_) pa))
                (prems_ofa p))
              (fn x => Inl (snd x)))
        (fn _ =>
          check_proof (A1_, A2_, A3_, A4_) r
            (sup_seta
              (ceq_prod
                 (ceq_prod (ceq_list A1_)
                   (ceq_prod
                     (ceq_prod ceq_nat (ceq_prod ceq_nat (ceq_list A1_)))
                     (ceq_list A1_)))
                 (ceq_prod (ceq_list A1_)
                   (ceq_prod
                     (ceq_prod ceq_nat (ceq_prod ceq_nat (ceq_list A1_)))
                     (ceq_list A1_))),
                ccompare_prod
                  (ccompare_prod (ccompare_list A2_)
                    (ccompare_prod
                      (ccompare_prod ccompare_nat
                        (ccompare_prod ccompare_nat (ccompare_list A2_)))
                      (ccompare_list A2_)))
                  (ccompare_prod (ccompare_list A2_)
                    (ccompare_prod
                      (ccompare_prod ccompare_nat
                        (ccompare_prod ccompare_nat (ccompare_list A2_)))
                      (ccompare_list A2_))))
              delta
              (inserta
                (ceq_prod
                   (ceq_prod (ceq_list A1_)
                     (ceq_prod
                       (ceq_prod ceq_nat (ceq_prod ceq_nat (ceq_list A1_)))
                       (ceq_list A1_)))
                   (ceq_prod (ceq_list A1_)
                     (ceq_prod
                       (ceq_prod ceq_nat (ceq_prod ceq_nat (ceq_list A1_)))
                       (ceq_list A1_))),
                  ccompare_prod
                    (ccompare_prod (ccompare_list A2_)
                      (ccompare_prod
                        (ccompare_prod ccompare_nat
                          (ccompare_prod ccompare_nat (ccompare_list A2_)))
                        (ccompare_list A2_)))
                    (ccompare_prod (ccompare_list A2_)
                      (ccompare_prod
                        (ccompare_prod ccompare_nat
                          (ccompare_prod ccompare_nat (ccompare_list A2_)))
                        (ccompare_list A2_))))
                (pat_of p)
                (set_empty
                  (ceq_prod
                     (ceq_prod (ceq_list A1_)
                       (ceq_prod
                         (ceq_prod ceq_nat (ceq_prod ceq_nat (ceq_list A1_)))
                         (ceq_list A1_)))
                     (ceq_prod (ceq_list A1_)
                       (ceq_prod
                         (ceq_prod ceq_nat (ceq_prod ceq_nat (ceq_list A1_)))
                         (ceq_list A1_))),
                    ccompare_prod
                      (ccompare_prod (ccompare_list A2_)
                        (ccompare_prod
                          (ccompare_prod ccompare_nat
                            (ccompare_prod ccompare_nat (ccompare_list A2_)))
                          (ccompare_list A2_)))
                      (ccompare_prod (ccompare_list A2_)
                        (ccompare_prod
                          (ccompare_prod ccompare_nat
                            (ccompare_prod ccompare_nat (ccompare_list A2_)))
                          (ccompare_list A2_))))
                  (of_phantom
                    (set_impl_proda
                      (set_impl_prod set_impl_list
                        (set_impl_prod
                          (set_impl_prod set_impl_nat
                            (set_impl_prod set_impl_nat set_impl_list))
                          set_impl_list))
                      (set_impl_prod set_impl_list
                        (set_impl_prod
                          (set_impl_prod set_impl_nat
                            (set_impl_prod set_impl_nat set_impl_list))
                          set_impl_list)))))))
            ps))
  | check_proof (A1_, A2_, A3_, A4_) r delta [] = Inr ();

fun check_non_loop_srs_proof (A1_, A2_, A3_, A4_) ra
  (SE_OC ((m, lmr), l, r, steps)) =
  bindb (check
          (membera
            (equal_prod
              (equal_prod (equal_list A3_)
                (equal_prod
                  (equal_prod equal_nat (equal_prod equal_nat (equal_list A3_)))
                  (equal_list A3_)))
              (equal_prod (equal_list A3_)
                (equal_prod
                  (equal_prod equal_nat (equal_prod equal_nat (equal_list A3_)))
                  (equal_list A3_))))
            (map pat_of steps)
            (([], ((zero_nata, (zero_nata, [])), m)),
              ([], ((zero_nata, (zero_nata, [])), lmr))))
          (shows_prec_list show_char zero_nata
            [#"o", #"v", #"e", #"r", #"l", #"a", #"p", #" ", #"c", #"l", #"o",
              #"s", #"u", #"r", #"e", #" ", #"n", #"o", #"t", #" ", #"d", #"e",
              #"r", #"i", #"v", #"e", #"d", #" ", #"w", #"i", #"t", #"h", #"i",
              #"n", #" ", #"p", #"r", #"o", #"o", #"f"]))
    (fn _ =>
      bindb (check (equal_lista A3_ lmr (l @ m @ r))
              (shows_prec_list show_char zero_nata
                [#"n", #"o", #" ", #"s", #"e", #"l", #"f", #"o", #"v", #"e",
                  #"r", #"l", #"a", #"p"]))
        (fn _ =>
          check_proof (A1_, A2_, A3_, A4_) ra
            (set_empty
              (ceq_prod
                 (ceq_prod (ceq_list A1_)
                   (ceq_prod
                     (ceq_prod ceq_nat (ceq_prod ceq_nat (ceq_list A1_)))
                     (ceq_list A1_)))
                 (ceq_prod (ceq_list A1_)
                   (ceq_prod
                     (ceq_prod ceq_nat (ceq_prod ceq_nat (ceq_list A1_)))
                     (ceq_list A1_))),
                ccompare_prod
                  (ccompare_prod (ccompare_list A2_)
                    (ccompare_prod
                      (ccompare_prod ccompare_nat
                        (ccompare_prod ccompare_nat (ccompare_list A2_)))
                      (ccompare_list A2_)))
                  (ccompare_prod (ccompare_list A2_)
                    (ccompare_prod
                      (ccompare_prod ccompare_nat
                        (ccompare_prod ccompare_nat (ccompare_list A2_)))
                      (ccompare_list A2_))))
              (of_phantom
                (set_impl_proda
                  (set_impl_prod set_impl_list
                    (set_impl_prod
                      (set_impl_prod set_impl_nat
                        (set_impl_prod set_impl_nat set_impl_list))
                      set_impl_list))
                  (set_impl_prod set_impl_list
                    (set_impl_prod
                      (set_impl_prod set_impl_nat
                        (set_impl_prod set_impl_nat set_impl_list))
                      set_impl_list)))))
            steps))
  | check_non_loop_srs_proof (A1_, A2_, A3_, A4_) ra
    (SE_DP ((left, right), l, r, steps)) =
    bindb (check
            (membera
              (equal_prod
                (equal_prod (equal_list A3_)
                  (equal_prod
                    (equal_prod equal_nat
                      (equal_prod equal_nat (equal_list A3_)))
                    (equal_list A3_)))
                (equal_prod (equal_list A3_)
                  (equal_prod
                    (equal_prod equal_nat
                      (equal_prod equal_nat (equal_list A3_)))
                    (equal_list A3_))))
              (map pat_of steps) (left, right))
            (shows_prec_list show_char zero_nata
              [#"o", #"v", #"e", #"r", #"l", #"a", #"p", #" ", #"c", #"l", #"o",
                #"s", #"u", #"r", #"e", #" ", #"n", #"o", #"t", #" ", #"d",
                #"e", #"r", #"i", #"v", #"e", #"d", #" ", #"w", #"i", #"t",
                #"h", #"i", #"n", #" ", #"p", #"r", #"o", #"o", #"f"]))
      (fn _ =>
        let
          val a = left;
          val (l1, aa) = a;
          val (ab, b) = aa;
        in
          let
            val (f1, (c1, m1)) = ab;
          in
            (fn r1 =>
              let
                val ac = right;
                val (l2, ad) = ac;
                val (ae, ba) = ad;
              in
                let
                  val (f2, (c2, m2)) = ae;
                in
                  (fn r2 =>
                    bindb (check
                            (equal_lista A3_ m1 m2 andalso
                              (equal_lista A3_ l2 (l @ l1) andalso
                                equal_lista A3_ r2 (r1 @ r)))
                            (shows_prec_list show_char zero_nata
                              [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                                #"w", #"i", #"t", #"h", #" ", #"s", #"e", #"l",
                                #"f", #"o", #"v", #"e", #"r", #"l", #"a",
                                #"p"]))
                      (fn _ =>
                        bindb (check
                                (less_eq_nat f1 f2 andalso
                                  (equal_nata
                                     (modulo_nata
                                       (max ord_nat (minus_nata c2 c1)
 (minus_nata c1 c2))
                                       f1)
                                     zero_nata andalso
                                    ((if less_nat f1 f2
                                       then equal_nata (modulo_nata f2 f1)
      zero_nata
                                       else true) andalso
                                      (if equal_nata f1 f2
then less_eq_nat c1 c2 else true))))
                                (shows_prec_list show_char zero_nata
                                  [#"c", #"o", #"u", #"l", #"d", #" ", #"n",
                                    #"o", #"t", #" ", #"e", #"n", #"s", #"u",
                                    #"r", #"e", #" ", #"f", #"i", #"t", #"t",
                                    #"i", #"n", #"g", #" ", #"c", #"o", #"n",
                                    #"d", #"i", #"t", #"i", #"o", #"n", #" ",
                                    #"f", #"o", #"r", #" ", #"s", #"e", #"l",
                                    #"f", #"o", #"v", #"e", #"r", #"l", #"a",
                                    #"p"]))
                          (fn _ =>
                            check_proof (A1_, A2_, A3_, A4_) ra
                              (set_empty
                                (ceq_prod
                                   (ceq_prod (ceq_list A1_)
                                     (ceq_prod
                                       (ceq_prod ceq_nat
 (ceq_prod ceq_nat (ceq_list A1_)))
                                       (ceq_list A1_)))
                                   (ceq_prod (ceq_list A1_)
                                     (ceq_prod
                                       (ceq_prod ceq_nat
 (ceq_prod ceq_nat (ceq_list A1_)))
                                       (ceq_list A1_))),
                                  ccompare_prod
                                    (ccompare_prod (ccompare_list A2_)
                                      (ccompare_prod
(ccompare_prod ccompare_nat (ccompare_prod ccompare_nat (ccompare_list A2_)))
(ccompare_list A2_)))
                                    (ccompare_prod (ccompare_list A2_)
                                      (ccompare_prod
(ccompare_prod ccompare_nat (ccompare_prod ccompare_nat (ccompare_list A2_)))
(ccompare_list A2_))))
                                (of_phantom
                                  (set_impl_proda
                                    (set_impl_prod set_impl_list
                                      (set_impl_prod
(set_impl_prod set_impl_nat (set_impl_prod set_impl_nat set_impl_list))
set_impl_list))
                                    (set_impl_prod set_impl_list
                                      (set_impl_prod
(set_impl_prod set_impl_nat (set_impl_prod set_impl_nat set_impl_list))
set_impl_list)))))
                              steps)))
                end
                  ba
              end)
          end
            b
        end);

fun term_to_string (Fun (f, [t])) = f :: term_to_string t
  | term_to_string (Var v) = []
  | term_to_string (Fun (v, [])) = []
  | term_to_string (Fun (v, vb :: vd :: ve)) = [];

fun srs_of_trs_impl r =
  maps (fn (l, ra) =>
         (if unary_term l
           then (if unary_term ra then [(term_to_string l, term_to_string ra)]
                  else [])
           else []))
    r;

fun check_non_loop_srs_prf (B1_, B2_, B3_, B4_) i tp prf =
  let
    val r = rulesd i tp;
    val s =
      set (ceq_prod (ceq_list B1_) (ceq_list B1_),
            ccompare_prod (ccompare_list B2_) (ccompare_list B2_),
            set_impl_prod set_impl_list set_impl_list)
        (srs_of_trs_impl r);
  in
    bindb (check (null (qb i tp))
            (shows_prec_list show_char zero_nata
              [#"s", #"t", #"r", #"a", #"t", #"e", #"g", #"y", #" ", #"f", #"o",
                #"r", #" ", #"n", #"o", #"n", #"-", #"l", #"o", #"o", #"p",
                #"s", #" ", #"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r",
                #"t", #"e", #"d"]))
      (fn _ => check_non_loop_srs_proof (B1_, B2_, B3_, B4_) s prf)
  end;

fun check_not_wwf_qtrs (B1_, B2_) (C1_, C2_, C3_) i tp =
  bindb (check (null (qb i tp) orelse not (nfsb i tp))
          (shows_prec_list show_char zero_nata
            [#"s", #"t", #"r", #"a", #"t", #"e", #"g", #"i", #"e", #"s", #" ",
              #"a", #"n", #"d", #" ", #"n", #"o", #"r", #"m", #"a", #"l", #" ",
              #"f", #"o", #"r", #"m", #" ", #"s", #"u", #"b", #"s", #"t", #"i",
              #"t", #"u", #"t", #"i", #"o", #"n", #"s", #" ", #"p", #"r", #"o",
              #"b", #"l", #"e", #"m"]))
    (fn _ =>
      check (not (isOK (check_wwf_qtrs B2_ (C1_, C3_) (is_QNFb i tp)
                         (rulesd i tp))))
        (shows_string
           [#"T", #"h", #"e", #" ", #"Q", #"-", #"T", #"R", #"S", #" ", #"i",
             #"s", #" ", #"w", #"e", #"l", #"l", #" ", #"f", #"o", #"r", #"m",
             #"e", #"d"] o
          shows_nl));

fun check_tp_subsumesa (B1_, B2_, B3_) (C1_, C2_, C3_) i t tp =
  let
    val (nfsa, (q, rs)) = t;
    val nfs = nfsb i tp;
    val rsa = rulesd i tp;
    val qa = qb i tp;
  in
    catch_errora
      (bindb
        (check (if not (null q) then (if nfs then nfsa else true) else true)
          (shows_prec_list show_char zero_nata
            [#"i", #"n", #"c", #"o", #"m", #"p", #"a", #"t", #"i", #"b", #"l",
              #"e", #" ", #"s", #"u", #"b", #"s", #"t", #"i", #"t", #"u", #"t",
              #"i", #"o", #"n", #"s", #"-", #"i", #"n", #"-", #"n", #"o", #"r",
              #"m", #"a", #"l", #"-", #"f", #"o", #"r", #"m", #" ", #"f", #"l",
              #"a", #"g", #"s"]))
        (fn _ =>
          bindb (catch_errora
                  (check_subseteq
                    (equal_prod
                      (equal_term (equal_lab B1_ C1_) (equal_list equal_char))
                      (equal_term (equal_lab B1_ C1_) (equal_list equal_char)))
                    rs rsa)
                  (fn x =>
                    Inl (toomuch [#"r", #"u", #"l", #"e"]
                          (shows_rule (shows_prec_lab B3_ C3_ zero_nata)
                            (shows_prec_list show_char zero_nata)
                            [#" ", #"-", #">", #" "] x))))
            (fn _ =>
              catch_errora
                (check_NF_terms_subset
                  (is_NF_terms (equal_lab B1_ C1_, key_lab B2_ C2_)
                    (ccompare_list ccompare_char, equal_list equal_char,
                      mapping_impl_list)
                    q)
                  qa)
                (fn x =>
                  Inl (shows_prec_list show_char zero_nata
                         [#"N", #"F", #"(", #"Q", #")", #" ", #"d", #"i", #"f",
                           #"f", #"e", #"r", #"s", #" ", #"d", #"u", #"e", #" ",
                           #"t", #"o", #" ", #"t", #"e", #"r", #"m", #" "] o
                        shows_term (shows_prec_lab B3_ C3_ zero_nata)
                          (shows_prec_list show_char zero_nata) x)))))
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                 #" ", #"s", #"h", #"o", #"w", #"i", #"n", #"g", #" ", #"s",
                 #"u", #"b", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n",
                 #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"t",
                 #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n"] o
               shows_nl o
              x))
  end;

fun check_non_loop_trs_prf (B1_, B2_, B3_)
  (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_) i tp prf =
  let
    val r = rulesd i tp;
  in
    bindb (check (null (qb i tp))
            (shows_prec_list show_char zero_nata
              [#"s", #"t", #"r", #"a", #"t", #"e", #"g", #"y", #" ", #"f", #"o",
                #"r", #" ", #"n", #"o", #"n", #"-", #"l", #"o", #"o", #"p",
                #"s", #" ", #"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r",
                #"t", #"e", #"d"]))
      (fn _ =>
        check_non_loop_prf (B1_, B2_, B3_)
          (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_) r [] prf)
  end;

fun uncurry_nonterm_tt_check (B1_, B2_) i info fmap check_inj r dpp =
  let
    val (a, (sml, (u, e))) = info;
    val ra = rulesd i dpp;
    val nfs = nfsb i dpp;
    val sm = sig_list_to_sig_map B1_ a sml fmap;
    val r_eta = e @ ra;
    val uR = uncurry_rules B1_ a sm r_eta;
  in
    (case bindb (check (null (qb i dpp))
                  (shows_prec_list show_char zero_nata
                    [#"s", #"t", #"r", #"a", #"t", #"e", #"g", #"y", #" ", #"n",
                      #"o", #"t", #" ", #"s", #"u", #"p", #"p", #"o", #"r",
                      #"t", #"e", #"d", #" ", #"f", #"o", #"r", #" ", #"u",
                      #"n", #"c", #"u", #"r", #"r", #"y", #"i", #"n", #"g"]))
            (fn _ =>
              let
                val s = uncurry_of_sig_list a sml sm;
              in
                bindb (only_eta_rules (B1_, B2_)
                        (ccompare_list ccompare_char, equal_list equal_char,
                          mapping_impl_list, show_list show_char)
                        e r_eta)
                  (fn _ =>
                    bindb (check_inj a (nat_of_integer (2 : IntInf.int)) sml)
                      (fn _ =>
                        bindb (catch_errora
                                (check_CS_subseteq B1_
                                  (ccompare_list ccompare_char,
                                    equal_list equal_char, mapping_impl_list)
                                  u s)
                                (fn x =>
                                  Inl (shows_prec_list show_char zero_nata
 [#"r", #"u", #"l", #"e", #" "] o
(shows_rule (shows_prec B2_ zero_nata) (shows_prec_list show_char zero_nata)
   [#" ", #"-", #">", #" "] x o
  shows_prec_list show_char zero_nata
    [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"n", #" ", #"u",
      #"n", #"c", #"u", #"r", #"r", #"y", #" ", #"r", #"u", #"l", #"e"]))))
                          (fn _ =>
                            catch_errora
                              (check_subseteq
                                (equal_prod
                                  (equal_term B1_ (equal_list equal_char))
                                  (equal_term B1_ (equal_list equal_char)))
                                r (u @ uR))
                              (fn x =>
                                Inl (shows_prec_list show_char zero_nata
                                       [#"r", #"u", #"l", #"e", #" "] o
                                      (shows_rule (shows_prec B2_ zero_nata)
 (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "] x o
shows_prec_list show_char zero_nata
  [#" ", #"i", #"s", #" ", #"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"u",
    #"n", #"c", #"u", #"r", #"r", #"i", #"e", #"d", #" ", #"r", #"u", #"l",
    #"e", #"s", #" ", #"n", #"o", #"r", #" ", #"u", #"n", #"c", #"u", #"r",
    #"r", #"y", #" ", #"r", #"u", #"l", #"e"]))))))
              end)
      of Inl aa => Inl aa | Inr _ => Inr (mkc i nfs [] r []))
  end;

fun uncurry_nonterm_tt (B1_, B2_) (C1_, C2_) i
  (Uncurry_nt_proof ((a, (sml, (u, e))), r)) tp =
  uncurry_nonterm_tt_check (equal_lab B1_ C1_, show_lab B2_ C2_) i
    (a, (sml, (u, e))) (fmap B1_ C1_ a (nat_of_integer (2 : IntInf.int)))
    (check_inj (B1_, B2_) (C1_, C2_)) r tp;

fun check_trs_loop (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_) i tp
  (TRS_loop_prf (s, rseq, sigma, c)) =
  check_loop (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_) (qb i tp)
    (nfsb i tp) s rseq sigma c (rulesd i tp);

fun rule_removal_nonterm_reltrs (B1_, B2_) (C1_, C2_) i tp
  (Rule_removal_nonterm_reltrs_prf (r, s)) =
  let
    val rrm =
      (if is_none r then []
        else ceta_list_diff (key_prod (key_term B1_ C1_) (key_term B1_ C1_))
               (rc i tp) (the r));
    val srm =
      (if is_none s then []
        else ceta_list_diff (key_prod (key_term B1_ C1_) (key_term B1_ C1_))
               (rwc i tp) (the s));
  in
    Inr (delete_R_Rwb i tp rrm srm)
  end;

fun check_rel_tp_subsumes (B1_, B2_, B3_) (C1_, C2_, C3_) i t tp =
  let
    val (nfsa, (q, (r, rw))) = t;
    val nfs = nfsb i tp;
    val rules = rulesd i tp;
    val ra = rc i tp;
    val qa = qb i tp;
  in
    catch_errora
      (bindb
        (check (if not (null q) then (if nfs then nfsa else true) else true)
          (shows_prec_list show_char zero_nata
            [#"i", #"n", #"c", #"o", #"m", #"p", #"a", #"t", #"i", #"b", #"l",
              #"e", #" ", #"s", #"u", #"b", #"s", #"t", #"i", #"t", #"u", #"t",
              #"i", #"o", #"n", #"s", #"-", #"i", #"n", #"-", #"n", #"o", #"r",
              #"m", #"a", #"l", #"-", #"f", #"o", #"r", #"m", #" ", #"f", #"l",
              #"a", #"g", #"s"]))
        (fn _ =>
          bindb (catch_errora
                  (check_subseteq
                    (equal_prod
                      (equal_term (equal_lab B1_ C1_) (equal_list equal_char))
                      (equal_term (equal_lab B1_ C1_) (equal_list equal_char)))
                    rw rules)
                  (fn x =>
                    Inl (toomuch [#"r", #"u", #"l", #"e"]
                          (shows_rule (shows_prec_lab B3_ C3_ zero_nata)
                            (shows_prec_list show_char zero_nata)
                            [#" ", #"-", #">", #" "] x))))
            (fn _ =>
              bindb (catch_errora
                      (check_subseteq
                        (equal_prod
                          (equal_term (equal_lab B1_ C1_)
                            (equal_list equal_char))
                          (equal_term (equal_lab B1_ C1_)
                            (equal_list equal_char)))
                        r ra)
                      (fn x =>
                        Inl (toomuch [#"r", #"u", #"l", #"e"]
                              (shows_rule (shows_prec_lab B3_ C3_ zero_nata)
                                (shows_prec_list show_char zero_nata)
                                [#" ", #"-", #">", #" "] x))))
                (fn _ =>
                  catch_errora
                    (check_NF_terms_subset
                      (is_NF_terms (equal_lab B1_ C1_, key_lab B2_ C2_)
                        (ccompare_list ccompare_char, equal_list equal_char,
                          mapping_impl_list)
                        q)
                      qa)
                    (fn x =>
                      Inl (shows_prec_list show_char zero_nata
                             [#"N", #"F", #"(", #"Q", #")", #" ", #"d", #"i",
                               #"f", #"f", #"e", #"r", #"s", #" ", #"d", #"u",
                               #"e", #" ", #"t", #"o", #" ", #"t", #"e", #"r",
                               #"m", #" "] o
                            shows_term (shows_prec_lab B3_ C3_ zero_nata)
                              (shows_prec_list show_char zero_nata) x))))))
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                 #" ", #"s", #"h", #"o", #"w", #"i", #"n", #"g", #" ", #"s",
                 #"u", #"b", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n",
                 #" ", #"f", #"o", #"r", #" ", #"n", #"o", #"n", #"-", #"t",
                 #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n"] o
              (shows_nl o x)))
  end;

fun check_wf_reltrs A_ (B1_, B2_) (r, s) =
  bindb (check_wf_trs A_ (B1_, B2_) r)
    (fn _ => (if null r then Inr () else check_varcond_subset A_ (B1_, B2_) s));

fun check_not_wf_reltrs (B1_, B2_) (C1_, C2_, C3_) i tp =
  bindb (check (q_emptyb i tp)
          (shows_prec_list show_char zero_nata
            [#"c", #"u", #"r", #"r", #"e", #"n", #"t", #"l", #"y", #" ", #"o",
              #"n", #"l", #"y", #" ", #"e", #"m", #"p", #"t", #"y", #" ", #"Q",
              #" ", #"i", #"s", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t",
              #"e", #"d"]))
    (fn _ =>
      check (not (isOK (check_wf_reltrs B2_ (C1_, C3_) (rc i tp, rwc i tp))))
        (shows_string
           [#"T", #"h", #"e", #" ", #"T", #"R", #"S", #"s", #" ", #"R", #" ",
             #"a", #"n", #"d", #" ", #"S", #" ", #"a", #"r", #"e", #" ", #"w",
             #"e", #"l", #"l", #" ", #"f", #"o", #"r", #"m", #"e", #"d"] o
          shows_nl));

fun reltrs_as_trs i tp = let
                           val q = qb i tp;
                           val r = rc i tp;
                           val nfs = nfsb i tp;
                           val a = mkc i nfs q r [];
                         in
                           Inr a
                         end;

fun check_rel_loop (A1_, A2_) (B1_, B2_, B3_, B4_) sa rseq sigma c r s =
  check_rel_seq (A1_, A2_) (B1_, B2_, B3_, B4_) r s rseq sa
    (ctxt_apply_term c (subst_apply_term sa (mk_subst B2_ Var sigma))) false;

fun check_rel_trs_loop (B1_, B2_) (C1_, C2_, C3_, C4_) i tp
  (Rel_trs_loop_prf (s, rseq, sigma, c)) =
  bindb (check (q_emptyb i tp)
          (shows_prec_list show_char zero_nata
            [#"Q", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"e", #"m",
              #"p", #"t", #"y"]))
    (fn _ =>
      check_rel_loop (B1_, B2_) (C1_, C2_, C3_, C4_) s rseq sigma c (rc i tp)
        (rwc i tp));

fun check_reltrs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
  assms i tp (Rel_Loop p) =
  debug (i []) [#"L", #"o", #"o", #"p"]
    (catch_errora
      (check_rel_trs_loop (equal_lab B2_ C1_, show_lab B4_ C3_)
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list,
          show_list show_char)
        ia tp p)
      (fn x =>
        Inl (i o (shows_string
                    [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n",
                      #" ", #"l", #"o", #"o", #"p", #" ", #"p", #"r", #"o",
                      #"o", #"f"] o
                   (shows_nl o x)))))
  | check_reltrs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (Rel_R_Not_SN prf) =
    bindb (reltrs_as_trs ia tp)
      (fn tpa =>
        catch_errora
          (check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
            ia j assms (i o shows_string [#".", #"1"]) tpa prf)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                          #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e", #" ",
                          #"n", #"o", #"n", #"t", #"e", #"r", #"m", #"i", #"n",
                          #"a", #"t", #"i", #"o", #"n", #" ", #"p", #"r", #"o",
                          #"o", #"f", #" ", #"f", #"o", #"r", #" ", #"R"] o
                       (shows_nl o indent x)))))
  | check_reltrs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp Rel_Not_Well_Formed =
    debug (i [])
      [#"N", #"o", #"t", #" ", #"W", #"e", #"l", #"l", #"-", #"F", #"o", #"r",
        #"m", #"e", #"d"]
      (catch_errora
        (check_not_wf_reltrs (key_lab B3_ C2_, show_lab B4_ C3_)
          (equal_list equal_char, key_list (equal_char, key_char),
            show_list show_char)
          ia tp)
        (fn x =>
          Inl (i o (shows_string
                      [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                        #"n", #" ", #"n", #"o", #"t", #"-", #"w", #"e", #"l",
                        #"l", #"-", #"f", #"o", #"r", #"m", #"e", #"d", #" ",
                        #"p", #"r", #"o", #"o", #"f"] o
                     (shows_nl o x)))))
  | check_reltrs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (Rel_TRS_String_Reversal prf) =
    debug (i [])
      [#"S", #"t", #"r", #"i", #"n", #"g", #" ", #"R", #"e", #"v", #"e", #"r",
        #"s", #"a", #"l"]
      (bindb
        (catch_errora
          (string_reversal_complete_rel_tt (show_lab B4_ C3_)
            (show_list show_char) ia tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"s", #"t", #"r", #"i", #"n",
                          #"g", #" ", #"r", #"e", #"v", #"e", #"r", #"s", #"a",
                          #"l", #" ", #"o", #"n"] o
                       (shows_nl o
                         (shows_tp (shows_prec_lab B4_ C3_ zero_nata)
                            (shows_prec_list show_char zero_nata) ia tp o
                           (shows_nl o x)))))))
        (fn tpa =>
          catch_errora
            (check_reltrs_nontermination_proof (B1_, B2_, B3_, B4_)
              (C1_, C2_, C3_) ia j assms (i o shows_string [#".", #"1"]) tpa
              prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"s", #"t", #"r", #"i", #"n", #"g", #" ",
                            #"r", #"e", #"v", #"e", #"r", #"s", #"a", #"l",
                            #" ", #"t", #"e", #"c", #"h", #"n", #"i", #"q",
                            #"u", #"e"] o
                         (shows_nl o indent x))))))
  | check_reltrs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (Rel_Rule_Removal (p, prf)) =
    debug (i [])
      [#"R", #"u", #"l", #"e", #" ", #"R", #"e", #"m", #"o", #"v", #"a", #"l"]
      (bindb
        (rule_removal_nonterm_reltrs (key_lab B3_ C2_, show_lab B4_ C3_)
          (key_list (equal_char, key_char), show_list show_char) ia tp p)
        (fn tpa =>
          catch_errora
            (check_reltrs_nontermination_proof (B1_, B2_, B3_, B4_)
              (C1_, C2_, C3_) ia j assms (i o shows_string [#".", #"1"]) tpa
              prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"r", #"u", #"l", #"e", #" ", #"r", #"e",
                            #"m", #"o", #"v", #"a", #"l"] o
                         (shows_nl o indent x))))))
  | check_reltrs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (Rel_TRS_Assume_Not_SN (t, ass)) =
    debug (i [])
      [#"F", #"i", #"n", #"i", #"t", #"e", #"n", #"e", #"s", #"s", #" ", #"A",
        #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #" ", #"o", #"r",
        #" ", #"U", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"P", #"r", #"o",
        #"o", #"f"]
      (if assms
        then bindb (catch_errora
                     (check_rel_tp_subsumes (B2_, B3_, B4_) (C1_, C2_, C3_) ia t
                       tp)
                     (fn x =>
                       Inl (i o (shows_string
                                   [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                     #" ", #"i", #"n", #" ", #"n", #"o", #"n",
                                     #"-", #"t", #"e", #"r", #"m", #"i", #"n",
                                     #"a", #"t", #"i", #"o", #"n", #" ", #"a",
                                     #"s", #"s", #"u", #"m", #"p", #"t", #"i",
                                     #"o", #"n", #" ", #"o", #"r", #" ", #"u",
                                     #"n", #"k", #"n", #"o", #"w", #"n", #" ",
                                     #"p", #"r", #"o", #"o", #"f"] o
                                  (shows_nl o (x o shows_nl))))))
               (fn _ =>
                 catch_errora
                   (catch_errora
                     (forallM_index
                       (fn asa => fn ja =>
                         check_assmb (B3_, B4_) (C2_, C3_) ia j
                           (check_trs_nontermination_proof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_dp_nontermination_proof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_reltrs_nontermination_proof
                             (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_fp_nontermination_proof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_unknown_disproof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           asa)
                       ass)
                     (fn x => Inl (snd x)))
                   (fn x =>
                     Inl (i o (shows_string
                                 [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                   #" ", #"b", #"e", #"l", #"o", #"w", #" ",
                                   #"u", #"n", #"k", #"n", #"o", #"w", #"n",
                                   #" ", #"p", #"r", #"o", #"o", #"f"] o
                                (shows_nl o indent x)))))
        else Inl (i o (shows_string
                         [#":", #" ", #"t", #"h", #"e", #" ", #"p", #"r", #"o",
                           #"o", #"f", #" ", #"c", #"o", #"n", #"t", #"a", #"i",
                           #"n", #"s", #" ", #"a", #"n", #" ", #"a", #"s", #"s",
                           #"u", #"m", #"p", #"t", #"i", #"o", #"n", #" ", #"o",
                           #"r", #" ", #"u", #"n", #"k", #"n", #"o", #"w", #"n",
                           #" ", #"p", #"r", #"o", #"o", #"f"] o
                        shows_nl)))
and check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
  assms i tp (TRS_Loop p) =
  debug (i []) [#"L", #"o", #"o", #"p"]
    (catch_errora
      (check_trs_loop
        (compare_lab ((compare_compare_order o compare_order_key) B3_)
           ((compare_compare_order o compare_order_key) C2_),
          equal_lab B2_ C1_, show_lab B4_ C3_)
        (ceq_list ceq_char, ccompare_list ccompare_char,
          compare_list compare_char, equal_list equal_char, mapping_impl_list,
          set_impl_list, show_list show_char)
        ia tp p)
      (fn x =>
        Inl (i o (shows_string
                    [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h",
                      #"e", #"n", #" ", #"c", #"h", #"e", #"c", #"k", #"i",
                      #"n", #"g", #" ", #"l", #"o", #"o", #"p", #" ", #"o",
                      #"f", #" "] o
                   (shows_nl o
                     (shows_tp (shows_prec_lab B4_ C3_ zero_nata)
                        (shows_prec_list show_char zero_nata) ia tp o
                       (shows_nl o indent x)))))))
  | check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Nonloop p) =
    debug (i []) [#"N", #"o", #"n", #"l", #"o", #"o", #"p"]
      (catch_errora
        (check_non_loop_trs_prf
          (compare_lab ((compare_compare_order o compare_order_key) B3_)
             ((compare_compare_order o compare_order_key) C2_),
            equal_lab B2_ C1_, show_lab B4_ C3_)
          (cenum_list, ceq_list ceq_char, ccompare_list ccompare_char,
            compare_list compare_char, equal_list equal_char, mapping_impl_list,
            set_impl_list, show_list show_char)
          ia tp p)
        (fn x =>
          Inl (shows_prec_list show_char zero_nata
                 [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                   #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ",
                   #"p", #"o", #"s", #"s", #"i", #"b", #"l", #"y", #" ", #"n",
                   #"o", #"n", #"-", #"l", #"o", #"o", #"p", #"i", #"n", #"g",
                   #" ", #"i", #"n", #"f", #"i", #"n", #"i", #"t", #"e", #" ",
                   #"r", #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n", #" ",
                   #"f", #"o", #"r", #" "] o
                (shows_nl o
                  (shows_tp (shows_prec_lab B4_ C3_ zero_nata)
                     (shows_prec_list show_char zero_nata) ia tp o
                    indent x)))))
  | check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Nonloop_SRS p) =
    debug (i [])
      [#"N", #"o", #"n", #"l", #"o", #"o", #"p", #" ", #"S", #"R", #"S"]
      (catch_errora
        (check_non_loop_srs_prf
          (ceq_lab B2_ C1_,
            ccompare_lab ((compare_compare_order o compare_order_key) B3_)
              ((compare_compare_order o compare_order_key) C2_),
            equal_lab B2_ C1_, show_lab B4_ C3_)
          ia tp p)
        (fn x =>
          Inl (shows_prec_list show_char zero_nata
                 [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                   #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ",
                   #"p", #"o", #"s", #"s", #"i", #"b", #"l", #"y", #" ", #"n",
                   #"o", #"n", #"-", #"l", #"o", #"o", #"p", #"i", #"n", #"g",
                   #" ", #"i", #"n", #"f", #"i", #"n", #"i", #"t", #"e", #" ",
                   #"r", #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n", #" ",
                   #"f", #"o", #"r", #" "] o
                (shows_nl o
                  (shows_tp (shows_prec_lab B4_ C3_ zero_nata)
                     (shows_prec_list show_char zero_nata) ia tp o
                    indent x)))))
  | check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp TRS_Not_Well_Formed =
    debug (i [])
      [#"N", #"o", #"t", #" ", #"W", #"e", #"l", #"l", #"-", #"F", #"o", #"r",
        #"m", #"e", #"d"]
      (catch_errora
        (check_not_wwf_qtrs (key_lab B3_ C2_, show_lab B4_ C3_)
          (equal_list equal_char, key_list (equal_char, key_char),
            show_list show_char)
          ia tp)
        (fn x =>
          Inl (i o (shows_string
                      [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                        #"n", #" ", #"n", #"o", #"t", #" ", #"w", #"e", #"l",
                        #"l", #"-", #"f", #"o", #"r", #"m", #"e", #"d", #" ",
                        #"p", #"r", #"o", #"o", #"f"] o
                     (shows_nl o x)))))
  | check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Termination_Switch (p, prf)) =
    debug (i [])
      [#"S", #"w", #"i", #"t", #"c", #"h", #" ", #"t", #"o", #" ", #"T", #"e",
        #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n"]
      (bindb
        (catch_errora
          (switch_termination_tt
            (equal_lab B2_ C1_, key_lab B3_ C2_, show_lab B4_ C3_) ia p tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                          #"n", #" ", #"s", #"w", #"i", #"t", #"c", #"h", #"i",
                          #"n", #"g", #" ", #"t", #"o", #" ", #"f", #"u", #"l",
                          #"l", #" ", #"s", #"t", #"r", #"a", #"t", #"e", #"g",
                          #"y", #" ", #"f", #"o", #"r", #" ", #"t", #"h", #"e",
                          #" ", #"D", #"P", #"-", #"p", #"r", #"o", #"b", #"l",
                          #"e", #"m", #" "] o
                       (shows_nl o
                         (shows_tp (shows_prec_lab B4_ C3_ zero_nata)
                            (shows_prec_list show_char zero_nata) ia tp o
                           (shows_nl o indent x)))))))
        (fn tpa =>
          catch_errora
            (check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) tpa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
                            #"t", #"i", #"o", #"n", #" ", #"s", #"w", #"i",
                            #"t", #"c", #"h", #" ", #"t", #"e", #"c", #"h",
                            #"n", #"i", #"q", #"u", #"e"] o
                         (shows_nl o indent x))))))
  | check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Rule_Removal (p, prf)) =
    debug (i [])
      [#"R", #"u", #"l", #"e", #" ", #"R", #"e", #"m", #"o", #"v", #"a", #"l"]
      (bindb
        (rule_removal_nonterm_trs (key_lab B3_ C2_, show_lab B4_ C3_)
          (key_list (equal_char, key_char), show_list show_char) ia tp p)
        (fn tpa =>
          catch_errora
            (check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) tpa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"r", #"u", #"l", #"e", #" ", #"r", #"e",
                            #"m", #"o", #"v", #"a", #"l"] o
                         (shows_nl o indent x))))))
  | check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_String_Reversal prf) =
    debug (i [])
      [#"S", #"t", #"r", #"i", #"n", #"g", #" ", #"R", #"e", #"v", #"e", #"r",
        #"s", #"a", #"l"]
      (bindb
        (catch_errora
          (string_reversal_complete_tt (show_lab B4_ C3_) (show_list show_char)
            ia tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"s", #"t", #"r", #"i", #"n",
                          #"g", #" ", #"r", #"e", #"v", #"e", #"r", #"s", #"a",
                          #"l", #" ", #"o", #"n"] o
                       (shows_nl o
                         (shows_tp (shows_prec_lab B4_ C3_ zero_nata)
                            (shows_prec_list show_char zero_nata) ia tp o
                           (shows_nl o x)))))))
        (fn tpa =>
          catch_errora
            (check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) tpa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"s", #"t", #"r", #"i", #"n", #"g", #" ",
                            #"r", #"e", #"v", #"e", #"r", #"s", #"a", #"l",
                            #" ", #"t", #"e", #"c", #"h", #"n", #"i", #"q",
                            #"u", #"e"] o
                         (shows_nl o indent x))))))
  | check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Constant_String (p, prf)) =
    debug (i [])
      [#"C", #"o", #"n", #"s", #"t", #"a", #"n", #"t", #"s", #" ", #"i", #"n",
        #"t", #"o", #" ", #"U", #"n", #"a", #"r", #"y"]
      (bindb
        (catch_errora
          (const_to_string_complete_tt (equal_lab B2_ C1_, show_lab B4_ C3_)
            (equal_list equal_char, show_list show_char) ia tp p)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"t", #"u", #"r", #"n", #"i",
                          #"n", #"g", #" ", #"c", #"o", #"n", #"s", #"t", #"a",
                          #"n", #"t", #"s", #" ", #"i", #"n", #"t", #"o", #" ",
                          #"s", #"t", #"r", #"i", #"n", #"g", #"s", #" ", #"o",
                          #"n"] o
                       (shows_nl o
                         (shows_tp (shows_prec_lab B4_ C3_ zero_nata)
                            (shows_prec_list show_char zero_nata) ia tp o
                           (shows_nl o x)))))))
        (fn tpa =>
          catch_errora
            (check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) tpa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"c", #"o", #"n", #"s", #"t", #"a", #"n",
                            #"t", #"s", #" ", #"i", #"n", #"t", #"o", #" ",
                            #"s", #"t", #"r", #"i", #"n", #"g", #" ", #"t",
                            #"e", #"c", #"h", #"n", #"i", #"q", #"u", #"e"] o
                         (shows_nl o indent x))))))
  | check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_DP_Trans (p, prf)) =
    debug (i [])
      [#"D", #"P", #" ", #"T", #"r", #"a", #"n", #"s", #"f", #"o", #"r", #"m",
        #"a", #"t", #"i", #"o", #"n"]
      (bindb
        (catch_errora
          (dp_trans_nontermination_tt (B2_, B4_) (C1_, C3_)
            (equal_list equal_char, show_list show_char) ia j tp p)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                          #"n", #" ", #"D", #"P", #" ", #"t", #"r", #"a", #"n",
                          #"s", #"f", #"o", #"r", #"m", #"a", #"t", #"i", #"o",
                          #"n", #" ", #"o", #"n"] o
                       (shows_nl o
                         (shows_tp (shows_prec_lab B4_ C3_ zero_nata)
                            (shows_prec_list show_char zero_nata) ia tp o
                           (shows_nl o x)))))))
        (fn dpp =>
          catch_errora
            (check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) dpp prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"D", #"P", #" ", #"t", #"r", #"a", #"n",
                            #"s", #"f", #"o", #"r", #"m", #"a", #"t", #"i",
                            #"o", #"n"] o
                         (shows_nl o indent x))))))
  | check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Q_Increase (p, prf)) =
    debug (i []) [#"Q", #" ", #"i", #"n", #"c", #"r", #"e", #"a", #"s", #"e"]
      (bindb
        (q_increase_nonterm_trs
          (equal_lab B2_ C1_, key_lab B3_ C2_, show_lab B4_ C3_)
          (equal_list equal_char, key_list (equal_char, key_char),
            show_list show_char)
          ia tp p)
        (fn tpa =>
          catch_errora
            (check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) tpa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"Q", #" ", #"i", #"n", #"c", #"r", #"e",
                            #"a", #"s", #"e", #" ", #"t", #"e", #"c", #"h",
                            #"n", #"i", #"q", #"u", #"e"] o
                         (shows_nl o indent x))))))
  | check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Uncurry (p, prf)) =
    debug (i []) [#"U", #"n", #"c", #"u", #"r", #"r", #"y", #"i", #"n", #"g"]
      (bindb (uncurry_nonterm_tt (B2_, B4_) (C1_, C3_) ia p tp)
        (fn tpa =>
          catch_errora
            (check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) tpa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"u", #"n", #"c", #"u", #"r", #"r", #"y",
                            #"i", #"n", #"g", #" ", #"t", #"e", #"c", #"h",
                            #"n", #"i", #"q", #"u", #"e"] o
                         (shows_nl o indent x))))))
  | check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Not_WN_Tree_Automaton prf) =
    catch_errora
      (check_not_wn_ta_prf
        (finite_UNIV_lab, cenum_lab, ceq_lab B2_ C1_,
          cproper_interval_lab ((compare_compare_order o compare_order_key) B3_)
            ((compare_compare_order o compare_order_key) C2_),
          compare_order_lab ((compare_compare_order o compare_order_key) B3_)
            ((compare_compare_order o compare_order_key) C2_),
          default_lab B1_, equal_lab B2_ C1_, set_impl_lab, show_lab B4_ C3_)
        (finite_UNIV_list, cenum_list, ceq_list ceq_char,
          cproper_interval_list ccompare_char,
          compare_order_list (compare_order_char, equal_char),
          equal_list equal_char, set_impl_list, show_list show_char)
        (card_UNIV_list, cenum_list, ceq_list ceq_char,
          cproper_interval_list ccompare_char,
          compare_order_list (compare_order_char, equal_char),
          equal_list equal_char, set_impl_list, show_list show_char)
        ia tp prf)
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"t",
                 #"r", #"e", #"e", #" ", #"a", #"u", #"t", #"o", #"m", #"a",
                 #"t", #"o", #"n", #" ", #"b", #"a", #"s", #"e", #"d", #" ",
                 #"n", #"o", #"n", #"-", #"t", #"e", #"r", #"m", #"i", #"n",
                 #"a", #"t", #"i", #"o", #"n", #" ", #"p", #"r", #"o", #"o",
                 #"f", #" ", #"f", #"o", #"r", #" "] o
              (shows_nl o
                (shows_tp (shows_prec_lab B4_ C3_ zero_nata)
                   (shows_prec_list show_char zero_nata) ia tp o
                  indent x))))
  | check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Assume_Not_SN (t, ass)) =
    debug (i [])
      [#"F", #"i", #"n", #"i", #"t", #"e", #"n", #"e", #"s", #"s", #" ", #"A",
        #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #" ", #"o", #"r",
        #" ", #"U", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"P", #"r", #"o",
        #"o", #"f"]
      (if assms
        then bindb (catch_errora
                     (check_tp_subsumesa (B2_, B3_, B4_) (C1_, C2_, C3_) ia t
                       tp)
                     (fn x =>
                       Inl (i o (shows_string
                                   [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                     #" ", #"i", #"n", #" ", #"n", #"o", #"n",
                                     #"-", #"t", #"e", #"r", #"m", #"i", #"n",
                                     #"a", #"t", #"i", #"o", #"n", #" ", #"a",
                                     #"s", #"s", #"u", #"m", #"p", #"t", #"i",
                                     #"o", #"n", #" ", #"o", #"r", #" ", #"u",
                                     #"n", #"k", #"n", #"o", #"w", #"n", #" ",
                                     #"p", #"r", #"o", #"o", #"f"] o
                                  (shows_nl o (x o shows_nl))))))
               (fn _ =>
                 catch_errora
                   (catch_errora
                     (forallM_index
                       (fn asa => fn ja =>
                         check_assmb (B3_, B4_) (C2_, C3_) ia j
                           (check_trs_nontermination_proof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_dp_nontermination_proof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_reltrs_nontermination_proof
                             (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_fp_nontermination_proof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_unknown_disproof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           asa)
                       ass)
                     (fn x => Inl (snd x)))
                   (fn x =>
                     Inl (i o (shows_string
                                 [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                   #" ", #"b", #"e", #"l", #"o", #"w", #" ",
                                   #"u", #"n", #"k", #"n", #"o", #"w", #"n",
                                   #" ", #"p", #"r", #"o", #"o", #"f"] o
                                (shows_nl o indent x)))))
        else Inl (i o (shows_string
                         [#":", #" ", #"t", #"h", #"e", #" ", #"p", #"r", #"o",
                           #"o", #"f", #" ", #"c", #"o", #"n", #"t", #"a", #"i",
                           #"n", #"s", #" ", #"a", #"n", #" ", #"a", #"s", #"s",
                           #"u", #"m", #"p", #"t", #"i", #"o", #"n", #" ", #"o",
                           #"r", #" ", #"u", #"n", #"k", #"n", #"o", #"w", #"n",
                           #" ", #"p", #"r", #"o", #"o", #"f"] o
                        shows_nl)))
  | check_trs_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (FPTRS_Assume_Not_SN (t, ass)) =
    Inl (i o (shows_string
                [#":", #" ", #"e", #"n", #"c", #"o", #"u", #"n", #"t", #"e",
                  #"r", #"e", #"d", #" ", #"u", #"n", #"e", #"x", #"p", #"e",
                  #"c", #"t", #"e", #"d", #" ", #"F", #"P", #"T", #"R", #"S",
                  #"_", #"A", #"s", #"s", #"u", #"m", #"e", #"_", #"N", #"o",
                  #"t", #"_", #"S", #"N"] o
               shows_nl))
and check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
  assms i (pa, r) (TRS_Loop p) =
  let
    val TRS_loop_prf (a, b, c, d) = p;
  in
    debug (i []) [#"L", #"o", #"o", #"p"]
      (catch_errora
        (check_fploop
          (compare_lab ((compare_compare_order o compare_order_key) B3_)
             ((compare_compare_order o compare_order_key) C2_),
            equal_lab B2_ C1_, show_lab B4_ C3_)
          (ceq_list ceq_char, ccompare_list ccompare_char,
            compare_list compare_char, equal_list equal_char, mapping_impl_list,
            set_impl_list, show_list show_char)
          r pa (FP_loop_prf (d, c, a, b)))
        (fn x =>
          Inl (i o (shows_string
                      [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                        #"h", #"e", #"n", #" ", #"c", #"h", #"e", #"c", #"k",
                        #"i", #"n", #"g", #" ", #"f", #"o", #"r", #"b", #"i",
                        #"d", #"d", #"e", #"n", #" ", #"p", #"a", #"t", #"t",
                        #"e", #"r", #"n", #" ", #"l", #"o", #"o", #"p"] o
                     (shows_nl o indent x)))))
  end
  | check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i (pa, r) (TRS_Rule_Removal (p, prf)) =
    debug (i [])
      [#"R", #"u", #"l", #"e", #" ", #"R", #"e", #"m", #"o", #"v", #"a", #"l"]
      (bindb
        (rule_removal_nonterm_trs (key_lab B3_ C2_, show_lab B4_ C3_)
          (key_list (equal_char, key_char), show_list show_char) ia
          (mkc ia false [] r []) p)
        (fn tp =>
          catch_errora
            (check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) (pa, rulesd ia tp) prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"r", #"u", #"l", #"e", #" ", #"r", #"e",
                            #"m", #"o", #"v", #"a", #"l"] o
                         (shows_nl o indent x))))))
  | check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (FPTRS_Assume_Not_SN (t, ass)) =
    debug (i [])
      [#"F", #"i", #"n", #"i", #"t", #"e", #"n", #"e", #"s", #"s", #" ", #"A",
        #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #" ", #"o", #"r",
        #" ", #"U", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"P", #"r", #"o",
        #"o", #"f"]
      (if assms
        then bindb (catch_errora
                     (check_fp_tp_subsumes (B2_, B3_, B4_) (C1_, C2_, C3_) t tp)
                     (fn x =>
                       Inl (i o (shows_string
                                   [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                     #" ", #"i", #"n", #" ", #"n", #"o", #"n",
                                     #"-", #"t", #"e", #"r", #"m", #"i", #"n",
                                     #"a", #"t", #"i", #"o", #"n", #" ", #"a",
                                     #"s", #"s", #"u", #"m", #"p", #"t", #"i",
                                     #"o", #"n", #" ", #"o", #"r", #" ", #"u",
                                     #"n", #"k", #"n", #"o", #"w", #"n", #" ",
                                     #"p", #"r", #"o", #"o", #"f"] o
                                  (shows_nl o (x o shows_nl))))))
               (fn _ =>
                 catch_errora
                   (catch_errora
                     (forallM_index
                       (fn asa => fn ja =>
                         check_assmb (B3_, B4_) (C2_, C3_) ia j
                           (check_trs_nontermination_proof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_dp_nontermination_proof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_reltrs_nontermination_proof
                             (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_fp_nontermination_proof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_unknown_disproof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           asa)
                       ass)
                     (fn x => Inl (snd x)))
                   (fn x =>
                     Inl (i o (shows_string
                                 [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                   #" ", #"b", #"e", #"l", #"o", #"w", #" ",
                                   #"u", #"n", #"k", #"n", #"o", #"w", #"n",
                                   #" ", #"p", #"r", #"o", #"o", #"f"] o
                                (shows_nl o indent x)))))
        else Inl (i o (shows_string
                         [#":", #" ", #"t", #"h", #"e", #" ", #"p", #"r", #"o",
                           #"o", #"f", #" ", #"c", #"o", #"n", #"t", #"a", #"i",
                           #"n", #"s", #" ", #"a", #"n", #" ", #"a", #"s", #"s",
                           #"u", #"m", #"p", #"t", #"i", #"o", #"n", #" ", #"o",
                           #"r", #" ", #"u", #"n", #"k", #"n", #"o", #"w", #"n",
                           #" ", #"p", #"r", #"o", #"o", #"f"] o
                        shows_nl)))
  | check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp TRS_Not_Well_Formed =
    Inl (i o (shows_string
                [#":", #" ", #"e", #"n", #"c", #"o", #"u", #"n", #"t", #"e",
                  #"r", #"e", #"d", #" ", #"u", #"n", #"e", #"x", #"p", #"e",
                  #"c", #"t", #"e", #"d", #" ", #"p", #"r", #"o", #"o", #"f"] o
               shows_nl))
  | check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_String_Reversal v) =
    Inl (i o (shows_string
                [#":", #" ", #"e", #"n", #"c", #"o", #"u", #"n", #"t", #"e",
                  #"r", #"e", #"d", #" ", #"u", #"n", #"e", #"x", #"p", #"e",
                  #"c", #"t", #"e", #"d", #" ", #"p", #"r", #"o", #"o", #"f"] o
               shows_nl))
  | check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Constant_String (v, va)) =
    Inl (i o (shows_string
                [#":", #" ", #"e", #"n", #"c", #"o", #"u", #"n", #"t", #"e",
                  #"r", #"e", #"d", #" ", #"u", #"n", #"e", #"x", #"p", #"e",
                  #"c", #"t", #"e", #"d", #" ", #"p", #"r", #"o", #"o", #"f"] o
               shows_nl))
  | check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_DP_Trans (v, va)) =
    Inl (i o (shows_string
                [#":", #" ", #"e", #"n", #"c", #"o", #"u", #"n", #"t", #"e",
                  #"r", #"e", #"d", #" ", #"u", #"n", #"e", #"x", #"p", #"e",
                  #"c", #"t", #"e", #"d", #" ", #"p", #"r", #"o", #"o", #"f"] o
               shows_nl))
  | check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Termination_Switch (v, va)) =
    Inl (i o (shows_string
                [#":", #" ", #"e", #"n", #"c", #"o", #"u", #"n", #"t", #"e",
                  #"r", #"e", #"d", #" ", #"u", #"n", #"e", #"x", #"p", #"e",
                  #"c", #"t", #"e", #"d", #" ", #"p", #"r", #"o", #"o", #"f"] o
               shows_nl))
  | check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Nonloop v) =
    Inl (i o (shows_string
                [#":", #" ", #"e", #"n", #"c", #"o", #"u", #"n", #"t", #"e",
                  #"r", #"e", #"d", #" ", #"u", #"n", #"e", #"x", #"p", #"e",
                  #"c", #"t", #"e", #"d", #" ", #"p", #"r", #"o", #"o", #"f"] o
               shows_nl))
  | check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Nonloop_SRS v) =
    Inl (i o (shows_string
                [#":", #" ", #"e", #"n", #"c", #"o", #"u", #"n", #"t", #"e",
                  #"r", #"e", #"d", #" ", #"u", #"n", #"e", #"x", #"p", #"e",
                  #"c", #"t", #"e", #"d", #" ", #"p", #"r", #"o", #"o", #"f"] o
               shows_nl))
  | check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Q_Increase (v, va)) =
    Inl (i o (shows_string
                [#":", #" ", #"e", #"n", #"c", #"o", #"u", #"n", #"t", #"e",
                  #"r", #"e", #"d", #" ", #"u", #"n", #"e", #"x", #"p", #"e",
                  #"c", #"t", #"e", #"d", #" ", #"p", #"r", #"o", #"o", #"f"] o
               shows_nl))
  | check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Uncurry (v, va)) =
    Inl (i o (shows_string
                [#":", #" ", #"e", #"n", #"c", #"o", #"u", #"n", #"t", #"e",
                  #"r", #"e", #"d", #" ", #"u", #"n", #"e", #"x", #"p", #"e",
                  #"c", #"t", #"e", #"d", #" ", #"p", #"r", #"o", #"o", #"f"] o
               shows_nl))
  | check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Not_WN_Tree_Automaton v) =
    Inl (i o (shows_string
                [#":", #" ", #"e", #"n", #"c", #"o", #"u", #"n", #"t", #"e",
                  #"r", #"e", #"d", #" ", #"u", #"n", #"e", #"x", #"p", #"e",
                  #"c", #"t", #"e", #"d", #" ", #"p", #"r", #"o", #"o", #"f"] o
               shows_nl))
  | check_fp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i tp (TRS_Assume_Not_SN (v, va)) =
    Inl (i o (shows_string
                [#":", #" ", #"e", #"n", #"c", #"o", #"u", #"n", #"t", #"e",
                  #"r", #"e", #"d", #" ", #"u", #"n", #"e", #"x", #"p", #"e",
                  #"c", #"t", #"e", #"d", #" ", #"p", #"r", #"o", #"o", #"f"] o
               shows_nl))
and check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
  assms i dpp (DP_Loop p) =
  debug (i []) [#"L", #"o", #"o", #"p"]
    (catch_errora
      (check_dp_loop
        (compare_lab ((compare_compare_order o compare_order_key) B3_)
           ((compare_compare_order o compare_order_key) C2_),
          equal_lab B2_ C1_, show_lab B4_ C3_)
        (ceq_list ceq_char, ccompare_list ccompare_char,
          compare_list compare_char, equal_list equal_char, mapping_impl_list,
          set_impl_list, show_list show_char)
        j dpp p)
      (fn x =>
        Inl (i o (shows_string
                    [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n",
                      #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g",
                      #" ", #"l", #"o", #"o", #"p", #" ", #"f", #"o", #"r",
                      #" ", #"t", #"h", #"e", #" ", #"f", #"o", #"l", #"l",
                      #"o", #"w", #"i", #"n", #"g", #" ", #"D", #"P", #"-",
                      #"p", #"r", #"o", #"b", #"l", #"e", #"m", #" "] o
                   (shows_nl o
                     (shows_dpp (shows_prec_lab B4_ C3_ zero_nata)
                        (shows_prec_list show_char zero_nata) j dpp o
                       (shows_nl o indent x)))))))
  | check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i dpp (DP_Nonloop p) =
    debug (i []) [#"N", #"o", #"n", #"l", #"o", #"o", #"p"]
      (catch_errora
        (check_non_loop_dp_prf
          (compare_lab ((compare_compare_order o compare_order_key) B3_)
             ((compare_compare_order o compare_order_key) C2_),
            equal_lab B2_ C1_, show_lab B4_ C3_)
          (cenum_list, ceq_list ceq_char, ccompare_list ccompare_char,
            compare_list compare_char, equal_list equal_char, mapping_impl_list,
            set_impl_list, show_list show_char)
          j dpp p)
        (fn x =>
          Inl (i o (shows_string
                      [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                        #"n", #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n",
                        #"g", #" ", #"n", #"o", #"n", #"l", #"o", #"o", #"p",
                        #" ", #"f", #"o", #"r", #" ", #"t", #"h", #"e", #" ",
                        #"f", #"o", #"l", #"l", #"o", #"w", #"i", #"n", #"g",
                        #" ", #"D", #"P", #"-", #"p", #"r", #"o", #"b", #"l",
                        #"e", #"m", #" "] o
                     (shows_nl o
                       (shows_dpp (shows_prec_lab B4_ C3_ zero_nata)
                          (shows_prec_list show_char zero_nata) j dpp o
                         (shows_nl o indent x)))))))
  | check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i dpp (DP_Rule_Removal (p, prf)) =
    debug (i [])
      [#"R", #"u", #"l", #"e", #" ", #"R", #"e", #"m", #"o", #"v", #"a", #"l"]
      (bindb
        (rule_removal_nonterm_dp (key_lab B3_ C2_, show_lab B4_ C3_)
          (key_list (equal_char, key_char), show_list show_char) j dpp p)
        (fn dppa =>
          catch_errora
            (check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"p", #"a", #"i", #"r", #" ", #"a", #"n",
                            #"d", #" ", #"r", #"u", #"l", #"e", #" ", #"r",
                            #"e", #"m", #"o", #"v", #"a", #"l"] o
                         (shows_nl o indent x))))))
  | check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i dpp (DP_Q_Reduction (p, prf)) =
    debug (i [])
      [#"Q", #" ", #"r", #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n"]
      (bindb
        (catch_errora
          (dp_q_reduction_nonterm
            (cenum_lab, ceq_lab B2_ C1_,
              ccompare_lab ((compare_compare_order o compare_order_key) B3_)
                ((compare_compare_order o compare_order_key) C2_),
              equal_lab B2_ C1_, key_lab B3_ C2_, set_impl_lab,
              show_lab B4_ C3_)
            (ccompare_list ccompare_char, equal_list equal_char,
              mapping_impl_list, show_list show_char)
            j dpp p)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                          #"n", #" ", #"r", #"e", #"d", #"u", #"c", #"i", #"n",
                          #"g", #" ", #"t", #"h", #"e", #" ", #"i", #"n", #"n",
                          #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"l", #"h",
                          #"s", #"s", #" ", #"i", #"n", #" ", #"t", #"h", #"e",
                          #" ", #"f", #"o", #"l", #"l", #"o", #"w", #"i", #"n",
                          #"g", #" ", #"D", #"P", #"-", #"p", #"r", #"o", #"b",
                          #"l", #"e", #"m", #" "] o
                       (shows_nl o
                         (shows_dpp (shows_prec_lab B4_ C3_ zero_nata)
                            (shows_prec_list show_char zero_nata) j dpp o
                           (shows_nl o indent x)))))))
        (fn dppa =>
          catch_errora
            (check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"Q", #" ", #"r", #"e", #"d", #"u", #"c",
                            #"t", #"i", #"o", #"n"] o
                         (shows_nl o indent x))))))
  | check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i dpp (DP_Q_Increase (p, prf)) =
    debug (i []) [#"Q", #" ", #"i", #"n", #"c", #"r", #"e", #"a", #"s", #"e"]
      (bindb
        (q_increase_nonterm_dp (equal_lab B2_ C1_) (equal_list equal_char) j dpp
          p)
        (fn dppa =>
          catch_errora
            (check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"Q", #" ", #"i", #"n", #"c", #"r", #"e",
                            #"a", #"s", #"e"] o
                         (shows_nl o indent x))))))
  | check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i dpp (DP_Termination_Switch (p, prf)) =
    debug (i [])
      [#"S", #"w", #"i", #"t", #"c", #"h", #" ", #"t", #"o", #" ", #"T", #"e",
        #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n"]
      (bindb
        (catch_errora
          (switch_termination_proc
            (equal_lab B2_ C1_, key_lab B3_ C2_, show_lab B4_ C3_) j p dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                          #"n", #" ", #"s", #"w", #"i", #"t", #"c", #"h", #"i",
                          #"n", #"g", #" ", #"t", #"o", #" ", #"f", #"u", #"l",
                          #"l", #" ", #"s", #"t", #"r", #"a", #"t", #"e", #"g",
                          #"y", #" ", #"f", #"o", #"r", #" ", #"t", #"h", #"e",
                          #" ", #"D", #"P", #"-", #"p", #"r", #"o", #"b", #"l",
                          #"e", #"m", #" "] o
                       (shows_nl o
                         (shows_dpp (shows_prec_lab B4_ C3_ zero_nata)
                            (shows_prec_list show_char zero_nata) j dpp o
                           (shows_nl o indent x)))))))
        (fn dppa =>
          catch_errora
            (check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
                            #"t", #"i", #"o", #"n", #" ", #"s", #"w", #"i",
                            #"t", #"c", #"h", #" ", #"p", #"r", #"o", #"c",
                            #"e", #"s", #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i dpp (DP_Instantiation (p, prf)) =
    debug (i [])
      [#"I", #"n", #"s", #"t", #"a", #"n", #"t", #"i", #"a", #"t", #"i", #"o",
        #"n"]
      (bindb
        (catch_errora
          (instantiation_complete_proc (equal_lab B2_ C1_, show_lab B4_ C3_)
            (ccompare_list ccompare_char, equal_list equal_char,
              mapping_impl_list, show_list show_char)
            j dpp p)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"i",
                          #"n", #"s", #"t", #"a", #"n", #"t", #"i", #"a", #"t",
                          #"i", #"o", #"n", #" ", #"p", #"r", #"o", #"c", #"e",
                          #"s", #"s", #"o", #"r", #" ", #"o", #"n", #" "] o
                       (shows_nl o
                         (shows_dpp (shows_prec_lab B4_ C3_ zero_nata)
                            (shows_prec_list show_char zero_nata) j dpp o
                           (shows_nl o indent x)))))))
        (fn dppa =>
          catch_errora
            (check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"i", #"n", #"s", #"t", #"a", #"n", #"t",
                            #"i", #"a", #"t", #"i", #"o", #"n", #" ", #"p",
                            #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i dpp (DP_Rewriting (p, prf)) =
    debug (i []) [#"R", #"e", #"w", #"r", #"i", #"t", #"i", #"n", #"g"]
      (bindb
        (catch_errora
          (rewriting_complete_proc
            (equal_lab B2_ C1_, key_lab B3_ C2_, show_lab B4_ C3_) j p dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"r",
                          #"e", #"w", #"r", #"i", #"t", #"i", #"n", #"g", #" ",
                          #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o",
                          #"r"] o
                       (shows_nl o x)))))
        (fn dppa =>
          catch_errora
            (check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"i",
                            #"n", #"g", #" ", #"p", #"r", #"o", #"c", #"e",
                            #"s", #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i dpp (DP_Narrowing (p, prf)) =
    debug (i []) [#"N", #"a", #"r", #"r", #"o", #"w", #"i", #"n", #"g"]
      (bindb
        (catch_errora
          (narrowing_complete_proc
            (equal_lab B2_ C1_, key_lab B3_ C2_, show_lab B4_ C3_) j p dpp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"n",
                          #"a", #"r", #"r", #"o", #"w", #"i", #"n", #"g", #" ",
                          #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o",
                          #"r"] o
                       (shows_nl o x)))))
        (fn dppa =>
          catch_errora
            (check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
              ia j assms (i o shows_string [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"i",
                            #"n", #"g", #" ", #"p", #"r", #"o", #"c", #"e",
                            #"s", #"s", #"o", #"r"] o
                         (shows_nl o indent x))))))
  | check_dp_nontermination_proof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j
    assms i dpp (DP_Assume_Infinite (dp, ass)) =
    debug (i [])
      [#"F", #"i", #"n", #"i", #"t", #"e", #"n", #"e", #"s", #"s", #" ", #"A",
        #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #" ", #"o", #"r",
        #" ", #"U", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"P", #"r", #"o",
        #"o", #"f"]
      (if assms
        then bindb (catch_errora
                     (check_dpp_subsumesa (B2_, B3_, B4_) (C1_, C2_, C3_) j dp
                       dpp)
                     (fn x =>
                       Inl (i o (shows_string
                                   [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                     #" ", #"i", #"n", #" ", #"f", #"i", #"n",
                                     #"i", #"t", #"e", #"n", #"e", #"s", #"s",
                                     #" ", #"a", #"s", #"s", #"u", #"m", #"p",
                                     #"t", #"i", #"o", #"n", #" ", #"o", #"r",
                                     #" ", #"u", #"n", #"k", #"n", #"o", #"w",
                                     #"n", #" ", #"p", #"r", #"o", #"o", #"f"] o
                                  (shows_nl o (x o shows_nl))))))
               (fn _ =>
                 catch_errora
                   (catch_errora
                     (forallM_index
                       (fn asa => fn ja =>
                         check_assmb (B3_, B4_) (C2_, C3_) ia j
                           (check_trs_nontermination_proof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_dp_nontermination_proof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_reltrs_nontermination_proof
                             (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_fp_nontermination_proof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           (check_unknown_disproof (B1_, B2_, B3_, B4_)
                             (C1_, C2_, C3_) ia j assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc ja))))
                           asa)
                       ass)
                     (fn x => Inl (snd x)))
                   (fn x =>
                     Inl (i o (shows_string
                                 [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                   #" ", #"b", #"e", #"l", #"o", #"w", #" ",
                                   #"u", #"n", #"k", #"n", #"o", #"w", #"n",
                                   #" ", #"p", #"r", #"o", #"o", #"f"] o
                                (shows_nl o indent x)))))
        else Inl (i o (shows_string
                         [#":", #" ", #"t", #"h", #"e", #" ", #"p", #"r", #"o",
                           #"o", #"f", #" ", #"c", #"o", #"n", #"t", #"a", #"i",
                           #"n", #"s", #" ", #"a", #"n", #" ", #"a", #"s", #"s",
                           #"u", #"m", #"p", #"t", #"i", #"o", #"n", #" ", #"o",
                           #"r", #" ", #"u", #"n", #"k", #"n", #"o", #"w", #"n",
                           #" ", #"p", #"r", #"o", #"o", #"f"] o
                        shows_nl)))
and check_unknown_disproof (B1_, B2_, B3_, B4_) (C1_, C2_, C3_) ia j assms i tpa
  (Assume_NT_Unknown (tp, ass)) =
  debug (i [])
    [#"U", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"P", #"r", #"o", #"o",
      #"f"]
    (if assms
      then bindb (catch_errora
                   (check (equal_lista equal_char tpa tp)
                     (shows_prec_list show_char zero_nata
                        [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"p",
                          #"r", #"o", #"b", #"l", #"e", #"m", #"s", #" ", #"a",
                          #"r", #"e", #" ", #"n", #"o", #"t", #" ", #"i", #"d",
                          #"e", #"n", #"t", #"i", #"c", #"a", #"l", #":",
                          #" "] o
                       (shows_nl o
                         (shows_prec_list show_char zero_nata tpa o
                           (shows_nl o
                             (shows_prec_list show_char zero_nata
                                [#" ", #"v", #"s", #" "] o
                               (shows_nl o
                                 shows_prec_list show_char zero_nata tp)))))))
                   (fn x =>
                     Inl (i o (shows_string
                                 [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                   #" ", #"i", #"n", #" ", #"n", #"o", #"n",
                                   #"t", #"e", #"r", #"m", #"i", #"n", #"a",
                                   #"t", #"i", #"o", #"n", #" ", #"a", #"s",
                                   #"s", #"u", #"m", #"p", #"t", #"i", #"o",
                                   #"n", #" ", #"o", #"r", #" ", #"u", #"n",
                                   #"k", #"n", #"o", #"w", #"n", #" ", #"p",
                                   #"r", #"o", #"o", #"f"] o
                                (shows_nl o (x o shows_nl))))))
             (fn _ =>
               catch_errora
                 (forallM_index
                   (fn asa => fn ja =>
                     check_assmb (B3_, B4_) (C2_, C3_) ia j
                       (check_trs_nontermination_proof (B1_, B2_, B3_, B4_)
                         (C1_, C2_, C3_) ia j assms
                         (i o (shows_string [#"."] o
                                shows_prec_nat zero_nata (suc ja))))
                       (check_dp_nontermination_proof (B1_, B2_, B3_, B4_)
                         (C1_, C2_, C3_) ia j assms
                         (i o (shows_string [#"."] o
                                shows_prec_nat zero_nata (suc ja))))
                       (check_reltrs_nontermination_proof (B1_, B2_, B3_, B4_)
                         (C1_, C2_, C3_) ia j assms
                         (i o (shows_string [#"."] o
                                shows_prec_nat zero_nata (suc ja))))
                       (check_fp_nontermination_proof (B1_, B2_, B3_, B4_)
                         (C1_, C2_, C3_) ia j assms
                         (i o (shows_string [#"."] o
                                shows_prec_nat zero_nata (suc ja))))
                       (check_unknown_disproof (B1_, B2_, B3_, B4_)
                         (C1_, C2_, C3_) ia j assms
                         (i o (shows_string [#"."] o
                                shows_prec_nat zero_nata (suc ja))))
                       asa)
                   ass)
                 (fn x => Inl (snd x)))
      else Inl (i o (shows_string
                       [#":", #" ", #"t", #"h", #"e", #" ", #"p", #"r", #"o",
                         #"o", #"f", #" ", #"c", #"o", #"n", #"t", #"a", #"i",
                         #"n", #"s", #" ", #"a", #"n", #" ", #"u", #"n", #"k",
                         #"n", #"o", #"w", #"n", #" ", #"p", #"r", #"o", #"o",
                         #"f"] o
                      shows_nl)));

fun firstM f [] = Inl []
  | firstM f (x :: xs) =
    catch_errora (bindb (f x) (fn _ => Inr x))
      (fn e => catch_errora (firstM f xs) (fn xa => Inl (e :: xa)));

fun check_variants_rule (A1_, A2_) (B1_, B2_, B3_, B4_) ra r =
  check (not (is_none (match_rules A1_ (B1_, B2_, B3_) [ra] [r])) andalso
          not (is_none (match_rules A1_ (B1_, B2_, B3_) [r] [ra])))
    (shows_rule (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
       [#" ", #"-", #">", #" "] ra o
       shows_prec_list show_char zero_nata [#" ", #"a", #"n", #"d", #" "] o
       shows_rule (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
         [#" ", #"-", #">", #" "] r o
       shows_prec_list show_char zero_nata
         [#" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ", #"v", #"a",
           #"r", #"i", #"a", #"n", #"t", #"s", #" ", #"o", #"f", #" ", #"e",
           #"a", #"c", #"h", #" ", #"o", #"t", #"h", #"e", #"r"] o
      shows_nl);

fun find_variant_in_trs (A1_, A2_) (B1_, B2_, B3_, B4_) ra r =
  catch_errora
    (firstM (check_variants_rule (A1_, A2_) (B1_, B2_, B3_, B4_) ra) r)
    (fn x => Inl (shows_sep id shows_nl x));

fun check_rstep_p A_ (B1_, B2_, B3_) c rho p s t =
  (if not (membera equal_pos (poss_list t) p)
    then Inl (shows_prec_list show_char zero_nata
               [#"n", #"o", #" ", #"s", #"t", #"e", #"p", #" ", #"p", #"o",
                 #"s", #"s", #"i", #"b", #"l", #"e", #" ", #"a", #"t", #" ",
                 #"t", #"h", #"i", #"s", #" ", #"p", #"o", #"s", #"i", #"t",
                 #"i", #"o", #"n"])
    else let
           val (l, r) = rho;
         in
           (case match_list (B1_, B2_, B3_) A_ B2_ Var
                   [(l, subt_at s p), (r, subt_at t p)]
             of NONE =>
               Inl (shows_prec_list show_char zero_nata
                     [#"r", #"u", #"l", #"e", #" ", #"d", #"o", #"e", #"s",
                       #" ", #"n", #"o", #"t", #" ", #"m", #"a", #"t", #"c",
                       #"h"])
             | SOME sigma =>
               (if equal_terma A_ B2_ t
                     (ctxt_apply_term (ctxt_of_pos_term p s)
                       (subst_apply_term r sigma))
                 then c (subst_apply_term l sigma) (subst_apply_term r sigma)
                 else Inl (shows_prec_list show_char zero_nata
                            [#"r", #"e", #"s", #"u", #"l", #"t", #" ", #"d",
                              #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ",
                              #"m", #"a", #"t", #"c", #"h"])))
         end);

fun check_step_rule A_ (B1_, B2_, B3_) c rho s t =
  catch_errora
    (existsM (fn p => check_rstep_p A_ (B1_, B2_, B3_) c rho p s t)
      (poss_list s))
    (fn _ =>
      Inl (shows_prec_list show_char zero_nata
            [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"r",
              #"e", #"d", #"u", #"c", #"t"]));

fun check_step (A1_, A2_) (B1_, B2_, B3_, B4_) c (ea :: e) s t =
  catch_errora
    (choice
      [check_step_rule A1_ (B1_, B2_, B3_) c ea s t,
        check_step (A1_, A2_) (B1_, B2_, B3_, B4_) c e s t])
    (fn x => Inl (shows_sep id shows_nl x))
  | check_step (A1_, A2_) (B1_, B2_, B3_, B4_) c [] s t =
    Inl (shows_prec_list show_char zero_nata
           [#"n", #"o", #" ", #"s", #"t", #"e", #"p", #" ", #"f", #"r", #"o",
             #"m"] o
           shows_prec_term A2_ B4_ zero_nata s o
           shows_prec_list show_char zero_nata [#" ", #"a", #"n", #"d", #" "] o
           shows_prec_term A2_ B4_ zero_nata t o
          shows_prec_list show_char zero_nata
            [#" ", #"f", #"o", #"u", #"n", #"d", #" "]);

fun sym_list A_ xs = union (equal_prod A_ A_) xs (map (fn (x, y) => (y, x)) xs);

fun check_stepa (A1_, A2_) check_ord (e, r) (OC_Collapse (s, t, u)) =
  catch_errora
    (bindb
      (find_variant_in_trs (A1_, A2_)
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list,
          show_list show_char)
        (t, s) r)
      (fn ts =>
        let
          val ra =
            removeAll
              (equal_prod (equal_term A1_ (equal_list equal_char))
                (equal_term A1_ (equal_list equal_char)))
              ts r;
        in
          bindb (catch_errora
                  (check_step (A1_, A2_)
                    (ccompare_list ccompare_char, equal_list equal_char,
                      mapping_impl_list, show_list show_char)
                    check_ord
                    (ra @ sym_list (equal_term A1_ (equal_list equal_char)) e) t
                    u)
                  (fn x =>
                    Inl (shows_string
                           [#" ", #"n", #"o", #" ", #"o", #"r", #"d", #"s",
                             #"t", #"e", #"p", #" ", #"f", #"r", #"o", #"m",
                             #" "] o
                          (shows_term (shows_prec A2_ zero_nata)
                             (shows_prec_list show_char zero_nata) t o
                            (shows_string [#" ", #"t", #"o", #" "] o
                              (shows_term (shows_prec A2_ zero_nata)
                                 (shows_prec_list show_char zero_nata) u o
                                x))))))
            (fn _ => Inr ((u, s) :: e, ra))
        end))
    (fn x =>
      Inl (shows_string
             [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"c", #"o",
               #"l", #"l", #"a", #"p", #"s", #"e", #" ", #"s", #"t", #"e", #"p",
               #" ", #"f", #"r", #"o", #"m", #" "] o
            (shows_term (shows_prec A2_ zero_nata)
               (shows_prec_list show_char zero_nata) s o
              (shows_string [#" ", #"-", #">", #" "] o
                (shows_term (shows_prec A2_ zero_nata)
                   (shows_prec_list show_char zero_nata) t o
                  (shows_string [#" ", #"t", #"o", #" "] o
                    (shows_term (shows_prec A2_ zero_nata)
                       (shows_prec_list show_char zero_nata) u o
                      (shows_string [#" ", #"=", #" "] o
                        (shows_term (shows_prec A2_ zero_nata)
                           (shows_prec_list show_char zero_nata) t o
                          x)))))))))
  | check_stepa (A1_, A2_) check_ord (e, r) (OC_Simplifyr (s, t, u)) =
    catch_errora
      (bindb
        (find_variant_in_trs (A1_, A2_)
          (ccompare_list ccompare_char, equal_list equal_char,
            mapping_impl_list, show_list show_char)
          (s, t) e)
        (fn st =>
          let
            val ea =
              removeAll
                (equal_prod (equal_term A1_ (equal_list equal_char))
                  (equal_term A1_ (equal_list equal_char)))
                st e;
          in
            bindb (catch_errora
                    (check_step (A1_, A2_)
                      (ccompare_list ccompare_char, equal_list equal_char,
                        mapping_impl_list, show_list show_char)
                      check_ord
                      (r @ sym_list (equal_term A1_ (equal_list equal_char)) ea)
                      t u)
                    (fn x =>
                      Inl (shows_string
                             [#" ", #"n", #"o", #" ", #"o", #"r", #"d", #"s",
                               #"t", #"e", #"p", #" ", #"f", #"r", #"o", #"m",
                               #" "] o
                            (shows_term (shows_prec A2_ zero_nata)
                               (shows_prec_list show_char zero_nata) t o
                              (shows_string [#" ", #"t", #"o", #" "] o
                                (shows_term (shows_prec A2_ zero_nata)
                                   (shows_prec_list show_char zero_nata) u o
                                  x))))))
              (fn _ => Inr ((s, u) :: ea, r))
          end))
      (fn x =>
        Inl (shows_string
               [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"s",
                 #"i", #"m", #"p", #"l", #"i", #"f", #"y", #"r", #" ", #"s",
                 #"t", #"e", #"p", #" ", #"f", #"r", #"o", #"m", #" "] o
              (shows_term (shows_prec A2_ zero_nata)
                 (shows_prec_list show_char zero_nata) s o
                (shows_string [#" ", #"=", #" "] o
                  (shows_term (shows_prec A2_ zero_nata)
                     (shows_prec_list show_char zero_nata) t o
                    (shows_string [#" ", #"t", #"o", #" "] o
                      (shows_term (shows_prec A2_ zero_nata)
                         (shows_prec_list show_char zero_nata) s o
                        (shows_string [#" ", #"=", #" "] o
                          (shows_term (shows_prec A2_ zero_nata)
                             (shows_prec_list show_char zero_nata) u o
                            x)))))))))
  | check_stepa (A1_, A2_) check_ord (e, r) (OC_Simplifyl (s, t, u)) =
    catch_errora
      (bindb
        (find_variant_in_trs (A1_, A2_)
          (ccompare_list ccompare_char, equal_list equal_char,
            mapping_impl_list, show_list show_char)
          (s, t) e)
        (fn st =>
          let
            val ea =
              removeAll
                (equal_prod (equal_term A1_ (equal_list equal_char))
                  (equal_term A1_ (equal_list equal_char)))
                st e;
          in
            bindb (catch_errora
                    (check_step (A1_, A2_)
                      (ccompare_list ccompare_char, equal_list equal_char,
                        mapping_impl_list, show_list show_char)
                      check_ord
                      (r @ sym_list (equal_term A1_ (equal_list equal_char)) ea)
                      s u)
                    (fn x =>
                      Inl (shows_string
                             [#" ", #"n", #"o", #" ", #"o", #"r", #"d", #"s",
                               #"t", #"e", #"p", #" ", #"f", #"r", #"o", #"m",
                               #" "] o
                            (shows_term (shows_prec A2_ zero_nata)
                               (shows_prec_list show_char zero_nata) s o
                              (shows_string [#" ", #"t", #"o", #" "] o
                                (shows_term (shows_prec A2_ zero_nata)
                                   (shows_prec_list show_char zero_nata) u o
                                  x))))))
              (fn _ => Inr ((u, t) :: ea, r))
          end))
      (fn x =>
        Inl (shows_string
               [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"s",
                 #"i", #"m", #"p", #"l", #"i", #"f", #"y", #"l", #" ", #"s",
                 #"t", #"e", #"p", #" ", #"f", #"r", #"o", #"m", #" "] o
              (shows_term (shows_prec A2_ zero_nata)
                 (shows_prec_list show_char zero_nata) s o
                (shows_string [#" ", #"=", #" "] o
                  (shows_term (shows_prec A2_ zero_nata)
                     (shows_prec_list show_char zero_nata) t o
                    (shows_string [#" ", #"t", #"o", #" "] o
                      (shows_term (shows_prec A2_ zero_nata)
                         (shows_prec_list show_char zero_nata) u o
                        (shows_string [#" ", #"=", #" "] o
                          (shows_term (shows_prec A2_ zero_nata)
                             (shows_prec_list show_char zero_nata) t o
                            x)))))))))
  | check_stepa (A1_, A2_) check_ord (e, r) (OC_Compose (s, t, u)) =
    catch_errora
      (bindb
        (find_variant_in_trs (A1_, A2_)
          (ccompare_list ccompare_char, equal_list equal_char,
            mapping_impl_list, show_list show_char)
          (s, t) r)
        (fn st =>
          let
            val ra =
              removeAll
                (equal_prod (equal_term A1_ (equal_list equal_char))
                  (equal_term A1_ (equal_list equal_char)))
                st r;
          in
            bindb (catch_errora
                    (check_step (A1_, A2_)
                      (ccompare_list ccompare_char, equal_list equal_char,
                        mapping_impl_list, show_list show_char)
                      check_ord
                      (ra @ sym_list (equal_term A1_ (equal_list equal_char)) e)
                      t u)
                    (fn x =>
                      Inl (shows_string
                             [#" ", #"n", #"o", #" ", #"o", #"r", #"d", #"s",
                               #"t", #"e", #"p", #" ", #"f", #"r", #"o", #"m",
                               #" "] o
                            (shows_term (shows_prec A2_ zero_nata)
                               (shows_prec_list show_char zero_nata) t o
                              (shows_string [#" ", #"t", #"o", #" "] o
                                (shows_term (shows_prec A2_ zero_nata)
                                   (shows_prec_list show_char zero_nata) u o
                                  x))))))
              (fn _ => Inr (e, (s, u) :: ra))
          end))
      (fn x =>
        Inl (shows_string
               [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"c",
                 #"o", #"m", #"p", #"o", #"s", #"e", #" ", #"s", #"t", #"e",
                 #"p", #" ", #"f", #"r", #"o", #"m", #" "] o
              (shows_term (shows_prec A2_ zero_nata)
                 (shows_prec_list show_char zero_nata) s o
                (shows_string [#" ", #"-", #">", #" "] o
                  (shows_term (shows_prec A2_ zero_nata)
                     (shows_prec_list show_char zero_nata) t o
                    (shows_string [#" ", #"t", #"o", #" "] o
                      (shows_term (shows_prec A2_ zero_nata)
                         (shows_prec_list show_char zero_nata) s o
                        (shows_string [#" ", #"-", #">", #" "] o
                          (shows_term (shows_prec A2_ zero_nata)
                             (shows_prec_list show_char zero_nata) u o
                            x)))))))))
  | check_stepa (A1_, A2_) check_ord (e, r) (OC_Delete s) =
    catch_errora
      (bindb
        (find_variant_in_trs (A1_, A2_)
          (ccompare_list ccompare_char, equal_list equal_char,
            mapping_impl_list, show_list show_char)
          (s, s) e)
        (fn ss =>
          Inr (removeAll
                 (equal_prod (equal_term A1_ (equal_list equal_char))
                   (equal_term A1_ (equal_list equal_char)))
                 ss e,
                r)))
      (fn x =>
        Inl (shows_string
               [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"d",
                 #"e", #"l", #"e", #"t", #"e", #" ", #"s", #"t", #"e", #"p",
                 #" ", #"f", #"o", #"r", #" "] o
              (shows_term (shows_prec A2_ zero_nata)
                 (shows_prec_list show_char zero_nata) s o
                (shows_string [#" ", #"=", #" "] o
                  (shows_term (shows_prec A2_ zero_nata)
                     (shows_prec_list show_char zero_nata) s o
                    x)))))
  | check_stepa (A1_, A2_) check_ord (e, r) (OC_Orientr (s, t)) =
    catch_errora
      (bindb (check_ord t s)
        (fn _ =>
          bindb (find_variant_in_trs (A1_, A2_)
                  (ccompare_list ccompare_char, equal_list equal_char,
                    mapping_impl_list, show_list show_char)
                  (s, t) e)
            (fn st =>
              Inr (removeAll
                     (equal_prod (equal_term A1_ (equal_list equal_char))
                       (equal_term A1_ (equal_list equal_char)))
                     st e,
                    (t, s) :: r))))
      (fn x =>
        Inl (shows_string
               [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"o",
                 #"r", #"i", #"e", #"n", #"t", #"r", #" ", #"s", #"t", #"e",
                 #"p", #" ", #"f", #"o", #"r", #" "] o
              (shows_term (shows_prec A2_ zero_nata)
                 (shows_prec_list show_char zero_nata) s o
                (shows_string [#" ", #"-", #">", #" "] o
                  (shows_term (shows_prec A2_ zero_nata)
                     (shows_prec_list show_char zero_nata) t o
                    x)))))
  | check_stepa (A1_, A2_) check_ord (e, r) (OC_Orientl (s, t)) =
    catch_errora
      (bindb (check_ord s t)
        (fn _ =>
          bindb (find_variant_in_trs (A1_, A2_)
                  (ccompare_list ccompare_char, equal_list equal_char,
                    mapping_impl_list, show_list show_char)
                  (s, t) e)
            (fn st =>
              Inr (removeAll
                     (equal_prod (equal_term A1_ (equal_list equal_char))
                       (equal_term A1_ (equal_list equal_char)))
                     st e,
                    (s, t) :: r))))
      (fn x =>
        Inl (shows_string
               [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"o",
                 #"r", #"i", #"e", #"n", #"t", #"l", #" ", #"s", #"t", #"e",
                 #"p", #" ", #"f", #"o", #"r", #" "] o
              (shows_term (shows_prec A2_ zero_nata)
                 (shows_prec_list show_char zero_nata) s o
                (shows_string [#" ", #"-", #">", #" "] o
                  (shows_term (shows_prec A2_ zero_nata)
                     (shows_prec_list show_char zero_nata) t o
                    x)))))
  | check_stepa (A1_, A2_) check_ord (e, r) (OC_Deduce (s, t, u)) =
    catch_errora
      let
        val sa = r @ sym_list (equal_term A1_ (equal_list equal_char)) e;
      in
        bindb (catch_errora
                (check_step (A1_, A2_)
                  (ccompare_list ccompare_char, equal_list equal_char,
                    mapping_impl_list, show_list show_char)
                  (fn _ => fn _ => Inr ()) sa s t)
                (fn x =>
                  Inl (shows_string
                         [#" ", #"n", #"o", #" ", #"s", #"t", #"e", #"p", #" ",
                           #"f", #"r", #"o", #"m", #" "] o
                        (shows_term (shows_prec A2_ zero_nata)
                           (shows_prec_list show_char zero_nata) s o
                          (shows_string [#" ", #"t", #"o", #" "] o
                            (shows_term (shows_prec A2_ zero_nata)
                               (shows_prec_list show_char zero_nata) t o
                              x))))))
          (fn _ =>
            bindb (catch_errora
                    (check_step (A1_, A2_)
                      (ccompare_list ccompare_char, equal_list equal_char,
                        mapping_impl_list, show_list show_char)
                      (fn _ => fn _ => Inr ()) sa s u)
                    (fn x =>
                      Inl (shows_string
                             [#" ", #"n", #"o", #" ", #"s", #"t", #"e", #"p",
                               #" ", #"f", #"r", #"o", #"m", #" "] o
                            (shows_term (shows_prec A2_ zero_nata)
                               (shows_prec_list show_char zero_nata) s o
                              (shows_string [#" ", #"t", #"o", #" "] o
                                (shows_term (shows_prec A2_ zero_nata)
                                   (shows_prec_list show_char zero_nata) u o
                                  x))))))
              (fn _ => Inr ((t, u) :: e, r)))
      end
      (fn x =>
        Inl (shows_string
               [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"d",
                 #"e", #"d", #"u", #"c", #"e", #" ", #"s", #"t", #"e", #"p",
                 #" "] o
              (shows_term (shows_prec A2_ zero_nata)
                 (shows_prec_list show_char zero_nata) t o
                (shows_string [#" ", #"<", #"-", #" "] o
                  (shows_term (shows_prec A2_ zero_nata)
                     (shows_prec_list show_char zero_nata) s o
                    (shows_string [#" ", #"-", #">", #" "] o
                      (shows_term (shows_prec A2_ zero_nata)
                         (shows_prec_list show_char zero_nata) u o
                        x)))))));

fun check_same_set A_ xs ys =
  bindb (check_subseteq A_ xs ys) (fn _ => check_subseteq A_ ys xs);

fun check_oc (A1_, A2_) check_ord (ea, ra) (e, r) (x :: xs) =
  bindb (check_stepa (A1_, A2_) check_ord (ea, ra) x)
    (fn (eaa, raa) => check_oc (A1_, A2_) check_ord (eaa, raa) (e, r) xs)
  | check_oc (A1_, A2_) check_ord (ea, ra) (e, r) [] =
    bindb (catch_errora
            (check_same_set
              (equal_prod (equal_term A1_ (equal_list equal_char))
                (equal_term A1_ (equal_list equal_char)))
              ea e)
            (fn _ =>
              Inl (shows_prec_list show_char zero_nata
                    [#" ", #"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #" ",
                      #"s", #"e", #"t", #"s", #" ", #"d", #"o", #" ", #"n",
                      #"o", #"t", #" ", #"m", #"a", #"t", #"c", #"h"])))
      (fn _ =>
        catch_errora
          (check_same_set
            (equal_prod (equal_term A1_ (equal_list equal_char))
              (equal_term A1_ (equal_list equal_char)))
            ra r)
          (fn _ =>
            Inl (shows_prec_list show_char zero_nata
                  [#" ", #"r", #"u", #"l", #"e", #" ", #"s", #"e", #"t", #"s",
                    #" ", #"d", #"o", #" ", #"n", #"o", #"t", #" ", #"m", #"a",
                    #"t", #"c", #"h"])));

fun check_ooverlap (A1_, A2_, A3_) (B1_, B2_) xvar yvar check_joinable
  check_instance e r rho_1 rho_2 p =
  (case mgu_var_disjoint_generic A1_ B1_ xvar yvar (fst rho_1)
          (subt_at (fst rho_2) p)
    of NONE => Inr ()
    | SOME (sigma_1, sigma_2) =>
      let
        val s =
          ctxt_apply_term
            (ctxt_of_pos_term p (subst_apply_term (fst rho_2) sigma_2))
            (subst_apply_term (snd rho_1) sigma_1);
        val t = subst_apply_term (snd rho_2) sigma_2;
      in
        catch_errora
          (choice
            [catch_errora (check_instance e r s t)
               (fn x =>
                 Inl (shows_string [#"C", #"P", #" "] o
                       (shows_term (shows_prec B2_ zero_nata)
                          (shows_prec A3_ zero_nata) s o
                         (shows_string [#" ", #"=", #" "] o
                           (shows_term (shows_prec B2_ zero_nata)
                              (shows_prec A3_ zero_nata) t o
                             (shows_string
                                [#" ", #"n", #"o", #"t", #" ", #"a", #"n", #" ",
                                  #"i", #"n", #"s", #"t", #"a", #"n", #"c",
                                  #"e", #" ", #"o", #"f", #" ", #"a", #"n",
                                  #" ", #"e", #"q", #"u", #"a", #"t", #"i",
                                  #"o", #"n"] o
                               x)))))),
              catch_errora (check_joinable e r s t)
                (fn x =>
                  Inl (shows_string [#"C", #"P", #" "] o
                        (shows_term (shows_prec B2_ zero_nata)
                           (shows_prec A3_ zero_nata) s o
                          (shows_string [#" ", #"=", #" "] o
                            (shows_term (shows_prec B2_ zero_nata)
                               (shows_prec A3_ zero_nata) t o
                              (shows_string
                                 [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
                                   #" ", #"j", #"o", #"i", #"n", #"a", #"b",
                                   #"l", #"e"] o
                                x))))))])
          (fn x => Inl (shows_sep id shows_nl x))
      end);

fun check_ECPsa (A1_, A2_, A3_) (B1_, B2_) xvar yvar check_joinable
  check_instance e r =
  let
    val ea = sym_list (equal_term B1_ A1_) e;
    val s = union (equal_prod (equal_term B1_ A1_) (equal_term B1_ A1_)) r ea;
  in
    catch_errora
      (forallM
        (fn rho_2 =>
          let
            val l_2 = fst rho_2;
          in
            catch_errora
              (forallM
                (fn rho_1 =>
                  catch_errora
                    (forallM
                      (check_ooverlap (A1_, A2_, A3_) (B1_, B2_) xvar yvar
                        check_joinable check_instance ea r rho_1 rho_2)
                      (funposs_list l_2))
                    (fn x => Inl (snd x)))
                s)
              (fn x => Inl (snd x))
          end)
        s)
      (fn x => Inl (snd x))
  end;

fun check_joinable A_ (B1_, B2_, B3_) r s t =
  (case (compute_rstep_NF A_ (B1_, B2_, B3_) r s,
          compute_rstep_NF A_ (B1_, B2_, B3_) r t)
    of (NONE, _) =>
      Inl (shows_prec_list show_char zero_nata
            [#"e", #"r", #"r", #"o", #"r", #":", #" ", #"c", #"h", #"e", #"c",
              #"k", #"_", #"j", #"o", #"i", #"n", #"a", #"b", #"l", #"e"])
    | (SOME _, NONE) =>
      Inl (shows_prec_list show_char zero_nata
            [#"e", #"r", #"r", #"o", #"r", #":", #" ", #"c", #"h", #"e", #"c",
              #"k", #"_", #"j", #"o", #"i", #"n", #"a", #"b", #"l", #"e"])
    | (SOME u, SOME v) =>
      check (equal_terma A_ B2_ u v)
        (shows_prec_list show_char zero_nata
          [#"n", #"o", #"r", #"m", #"a", #"l", #" ", #"f", #"o", #"r", #"m",
            #"s", #" ", #"d", #"i", #"f", #"f", #"e", #"r"]));

fun check_rule_instance A_ (B1_, B2_, B3_) ra r =
  (case match_list (B1_, B2_, B3_) A_ B2_ Var [(fst r, fst ra), (snd r, snd ra)]
    of NONE =>
      Inl (shows_prec_list show_char zero_nata
            [#"r", #"u", #"l", #"e", #"s", #" ", #"d", #"o", #" ", #"n", #"o",
              #"t", #" ", #"m", #"a", #"t", #"c", #"h"])
    | SOME _ => Inr ());

fun check_instancea A_ (B1_, B2_, B3_) e s t =
  catch_errora (existsM (check_rule_instance A_ (B1_, B2_, B3_) (s, t)) e)
    (fn x => Inl (shows_sep id shows_nl x));

fun check_ECPs (A1_, A2_) =
  check_ECPsa (equal_list equal_char, infinite_list, show_list show_char)
    (A1_, A2_) (fn a => #"x" :: a) (fn a => #"y" :: a)
    (fn _ =>
      check_joinable A1_
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list))
    (fn e => fn _ =>
      check_instancea A1_
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list)
        e);

fun valida (Redord_ext (valid, less, min_const, more)) = valid;

fun check_FGCR (A1_, A2_) ro f e r =
  bindb (valida ro f)
    (fn _ =>
      bindb (catch_errora
              (check_subseteq (equal_prod A1_ equal_nat)
                (funas_trs_list
                  (union
                    (equal_prod (equal_term A1_ (equal_list equal_char))
                      (equal_term A1_ (equal_list equal_char)))
                    e r))
                f)
              (fn x =>
                Inl (shows_prec_list show_char zero_nata
                       [#"t", #"h", #"e", #" ", #"f", #"u", #"n", #"c", #"t",
                         #"i", #"o", #"n", #" ", #"s", #"y", #"m", #"b", #"o",
                         #"l", #" "] o
                       shows_prec_prod A2_ show_nat zero_nata x o
                      shows_prec_list show_char zero_nata
                        [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t",
                          #" ", #"o", #"c", #"c", #"u", #"r", #" ", #"i", #"n",
                          #" ", #"t", #"h", #"e", #" ", #"T", #"R", #"S",
                          #"\n"])))
        (fn _ => check_ECPs (A1_, A2_) e r));

fun lessa (Redord_ext (valid, less, min_const, more)) = less;

fun check_FGCR_run (A1_, A2_) ro f e_0 r_0 e r steps =
  let
    val check_ord =
      (fn s => fn t =>
        check (lessa ro s t)
          (shows_prec_list show_char zero_nata
            [#"t", #"e", #"r", #"m", #" ", #"p", #"a", #"i", #"r", #" ", #"c",
              #"a", #"n", #"n", #"o", #"t", #" ", #"b", #"e", #" ", #"o", #"r",
              #"i", #"e", #"n", #"t", #"e", #"d"]));
  in
    bindb (catch_errora (forallM (fn (a, b) => check_ord a b) r_0)
            (fn x => Inl (snd x)))
      (fn _ =>
        bindb (catch_errora
                (check_oc (A1_, A2_) check_ord (e_0, r_0) (e, r) steps)
                (fn x =>
                  Inl (shows_prec_list show_char zero_nata
                         [#"t", #"h", #"e", #" ", #"o", #"K", #"B", #" ", #"r",
                           #"u", #"n", #" ", #"c", #"o", #"u", #"l", #"d", #" ",
                           #"n", #"o", #"t", #" ", #"b", #"e", #" ", #"r", #"e",
                           #"c", #"o", #"n", #"s", #"t", #"r", #"u", #"c", #"t",
                           #"e", #"d", #"\n"] o
                        (shows_nl o x))))
          (fn _ =>
            catch_errora (check_FGCR (A1_, A2_) ro f e r)
              (fn x =>
                Inl (shows_prec_list show_char zero_nata
                       [#"g", #"r", #"o", #"u", #"n", #"d", #" ", #"c", #"o",
                         #"n", #"f", #"l", #"u", #"e", #"n", #"c", #"e", #" ",
                         #"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                         #" ", #"b", #"e", #" ", #"v", #"e", #"r", #"i", #"f",
                         #"i", #"e", #"d", #"\n"] o
                      (shows_nl o x)))))
  end;

fun create_KBO_redord (A1_, A2_, A3_) pr =
  let
    val (ch, (p, (w, (w0, (lcs, scf))))) =
      prec_weight_repr_to_prec_weight (A1_, A2_, A3_) pr;
    val valid =
      (fn fs =>
        bindb ch
          (fn _ =>
            bindb (catch_errora
                    (check_same_set (equal_prod A1_ equal_nat) fs
                      (map fst (fst pr)))
                    (fn _ =>
                      Inl (shows_prec_list show_char zero_nata
                            [#" ", #"s", #"i", #"g", #"n", #"a", #"t", #"u",
                              #"r", #"e", #" ", #"d", #"o", #"e", #"s", #" ",
                              #"n", #"o", #"t", #" ", #"m", #"a", #"t", #"c",
                              #"h", #" "])))
              (fn _ =>
                bindb (check (less_nat zero_nata (size_list lcs))
                        (shows_prec_list show_char zero_nata
                          [#"t", #"h", #"e", #"r", #"e", #" ", #"m", #"u", #"s",
                            #"t", #" ", #"b", #"e", #" ", #"a", #" ", #"m",
                            #"i", #"n", #"i", #"m", #"a", #"l", #" ", #"c",
                            #"o", #"n", #"s", #"t", #"a", #"n", #"t", #" ",
                            #"w", #"i", #"t", #"h", #" ", #"w", #"e", #"i",
                            #"g", #"h", #"t", #" ", #"w", #"0"]))
                  (fn _ =>
                    check (distinct equal_nat (map (fst o snd) (fst pr)))
                      (shows_prec_list show_char zero_nata
                        [#"t", #"h", #"e", #" ", #"g", #"i", #"v", #"e", #"n",
                          #" ", #"p", #"r", #"e", #"c", #"e", #"d", #"e", #"n",
                          #"c", #"e", #" ", #"i", #"s", #" ", #"n", #"o", #"t",
                          #" ", #"i", #"n", #"j", #"e", #"c", #"t", #"i", #"v",
                          #"e"])))));
  in
    Redord_ext
      (valid,
        (fn s => fn t =>
          fst (kbo_impl (equal_list equal_char) w w0 p (membera A1_ lcs) scf s
                t)),
        nth lcs zero_nata, ())
  end;

fun check_ordered_completion_proof (B1_, B2_, B3_) a ia i j e_0 e r ro
  (OKB steps) =
  debug (ia []) [#"O", #"K", #"B"]
    (case ro
      of RPO_Input _ =>
        Inl (shows_string
              [#"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
                #" ", #"r", #"e", #"d", #"u", #"c", #"t", #"i", #"o", #"n",
                #" ", #"o", #"r", #"d", #"e", #"r", #" "])
      | KBO_Input precw =>
        catch_errora
          (check_FGCR_run
            (equal_lab B1_ (equal_list equal_nat),
              show_lab B3_ (show_list show_nat))
            (create_KBO_redord
              (equal_lab B1_ (equal_list equal_nat),
                key_lab B2_ (key_list (equal_nat, key_nat)),
                show_lab B3_ (show_list show_nat))
              precw)
            (funas_trs_list e_0) e_0 [] e r steps)
          (fn x =>
            Inl (ia o (shows_prec_list show_char zero_nata
                         [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                           #"n", #" ", #"g", #"r", #"o", #"u", #"n", #"d", #" ",
                           #"c", #"o", #"m", #"p", #"l", #"e", #"t", #"e", #"n",
                           #"e", #"s", #"s", #" ", #"p", #"r", #"o", #"o", #"f",
                           #" "] o
                        (shows_nl o indent x)))));

fun rhs_n u (lr, cs) n =
  (if less_nat n (size_list cs)
    then ctxt_apply_term (u (lr, cs) n) (fst (nth cs n)) else snd lr);

fun lhs_n u (lr, cs) n =
  (if equal_nata n zero_nata then fst lr
    else ctxt_apply_term (u (lr, cs) (minus_nata n one_nata))
           (snd (nth cs (minus_nata n one_nata))));

fun rules_impl u cr =
  map (fn i => (lhs_n u cr i, rhs_n u cr i))
    (upt zero_nata (suc (size_list (snd cr))));

fun create_ctxts r =
  (case r of [] => NONE
    | _ :: rr =>
      bind (mapMa
             (fn a =>
               (case a of (Var _, _) => NONE | (Fun (_, []), _) => NONE
                 | (Fun (u, _ :: ts), _) => SOME (More (u, [], Hole, ts))))
             rr)
        (fn cs =>
          let
            val _ = size_list cs;
          in
            SOME (fn i =>
                   (if less_nat i (size_list cs) then nth cs i else Hole))
          end));

fun create_U A_ B_ c_rs =
  bind (mapMa
         (fn (cr, rs) =>
           bind (guarda (equal_nata (size_list rs) (suc (size_list (snd cr)))))
             (fn _ => bind (create_ctxts rs) (fn ctxt => SOME (cr, ctxt))))
         c_rs)
    (fn cr_ctxts =>
      let
        val m =
          map_of
            (equal_prod (equal_prod (equal_term A_ B_) (equal_term A_ B_))
              (equal_list (equal_prod (equal_term A_ B_) (equal_term A_ B_))))
            cr_ctxts;
      in
        SOME (fn cr =>
               (case m cr of NONE => (fn _ => Hole) | SOME ctxt => ctxt))
      end);

fun check_unraveling (A1_, A2_) (B1_, B2_) c_rs ctrs =
  catch_errora
    (bindb
      (catch_errora
        (check_subseteq
          (equal_prod (equal_prod (equal_term A1_ B1_) (equal_term A1_ B1_))
            (equal_list (equal_prod (equal_term A1_ B1_) (equal_term A1_ B1_))))
          ctrs (map fst c_rs))
        (fn x =>
          Inl (shows_prec_list show_char zero_nata
                 [#"d", #"i", #"d", #" ", #"n", #"o", #"t", #" ", #"f", #"i",
                   #"n", #"d", #" ", #"r", #"u", #"l", #"e", #" "] o
                (shows_crule (shows_prec A2_ zero_nata)
                   (shows_prec B2_ zero_nata) x o
                  shows_nl))))
      (fn _ =>
        bindb (case create_U A1_ B1_ c_rs
                of NONE =>
                  Inl (shows_prec_list show_char zero_nata
                        [#"u", #"n", #"a", #"b", #"l", #"e", #" ", #"t", #"o",
                          #" ", #"e", #"x", #"t", #"r", #"a", #"c", #"t", #" ",
                          #"u", #"n", #"r", #"a", #"v", #"e", #"l", #"i", #"n",
                          #"g", #" ", #"c", #"o", #"n", #"t", #"e", #"x", #"t",
                          #"s"])
                | SOME a => Inr a)
          (fn u =>
            bindb (catch_errora
                    (forallM
                      (fn (c, rs) =>
                        check (equal_lista
                                (equal_prod (equal_term A1_ B1_)
                                  (equal_term A1_ B1_))
                                (rules_impl u c) rs)
                          (shows_prec_list show_char zero_nata
                             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                               #"w", #"i", #"t", #"h", #" ", #"r", #"u", #"l",
                               #"e", #"s", #" ", #"o", #"f", #" "] o
                            (shows_crule (shows_prec A2_ zero_nata)
                               (shows_prec B2_ zero_nata) c o
                              shows_nl)))
                      c_rs)
                    (fn x => Inl (snd x)))
              (fn _ => Inr (maps snd c_rs)))))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"u", #"n", #"r", #"a", #"v", #"e", #"l", #"i", #"n", #"g",
               #" "] o
            (shows_nl o x)));

fun check_quasi_reductive_proof (B1_, B2_, B3_, B4_) a ia i j ctrs
  (Unravel (u_info, prf)) =
  debug (ia []) [#"U", #"n", #"r", #"a", #"v", #"e", #"l"]
    (bindb
      (catch_errora
        (check_unraveling
          (equal_lab B2_ (equal_list equal_nat),
            show_lab B4_ (show_list show_nat))
          (equal_list equal_char, show_list show_char) u_info ctrs)
        (fn x =>
          Inl (ia o (shows_string
                       [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                         #"n", #" ", #"u", #"n", #"r", #"a", #"v", #"e", #"l",
                         #"i", #"n", #"g"] o
                      (shows_nl o indent x)))))
      (fn r =>
        let
          val tp = mkc i false [] r [];
        in
          catch_errora
            (check_trs_termination_proof (B1_, B2_, B3_, B4_) i j a
              (ia o shows_string [#".", #"1"]) tp prf)
            (fn x =>
              Inl (ia o (shows_string
                           [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                             #"b", #"e", #"l", #"o", #"w", #" ", #"s", #"t",
                             #"r", #"o", #"n", #"g", #" ", #"n", #"o", #"r",
                             #"m", #"a", #"l", #"i", #"z", #"a", #"t", #"i",
                             #"o", #"n", #" ", #"+", #" ", #"w", #"c", #"r"] o
                          (shows_nl o indent x))))
        end));

fun shows_gctxt A_ GCHole = shows_string [#"_"]
  | shows_gctxt A_ (GCFun (f, ts)) =
    shows_prec A_ zero_nata f o
      shows_list_gen id [] [#"("] [#",", #" "] [#")"] (map (shows_gctxt A_) ts);

fun shows_prec_gctxt A_ p c = shows_gctxt A_ c;

fun gctxts_to_terms_intern iv i (GCFun (f, ts) :: cs) =
  let
    val (i1, res1) = gctxts_to_terms_intern iv i ts;
    val (i2, res2) = gctxts_to_terms_intern iv i1 cs;
  in
    (i2, Fun (f, res1) :: res2)
  end
  | gctxts_to_terms_intern iv i (GCHole :: cs) =
    let
      val (ia, res) = gctxts_to_terms_intern iv (plus_nata i one_nata) cs;
    in
      (ia, Var (iv i) :: res)
    end
  | gctxts_to_terms_intern iv i [] = (i, []);

fun gc_matcher A_ c l =
  map_option fst
    (mgu_var_disjoint_generic (equal_list equal_char) A_ (fn a => #"x" :: a)
      (fn a => #"y" :: a) l
      (hda (snd (gctxts_to_terms_intern
                  (fn i => #"x" :: shows_prec_nat zero_nata i []) zero_nata
                  [c]))));

fun check_contains_U0 (A1_, A2_, A3_) r u s =
  catch_errora
    (forallM
      (fn fts =>
        (case fts of Var _ => Inr ()
          | Fun (f, ts) =>
            let
              val tcapb =
                GCFun (f, map (tcap (A1_, A2_)
                                (compare_list compare_char,
                                  equal_list equal_char)
                                u)
                            ts);
            in
              catch_errora
                (forallM
                  (fn lr =>
                    (case gc_matcher A2_ tcapb (fst lr) of NONE => Inr ()
                      | SOME sigma =>
                        let
                          val irule =
                            (subst_apply_term (fst lr) sigma,
                              subst_apply_term (snd lr) sigma);
                        in
                          check (in_rstep_impl (A1_, A2_)
                                  (ccompare_list ccompare_char,
                                    compare_list compare_char,
                                    equal_list equal_char, mapping_impl_list)
                                  (fst irule) (snd irule) u)
                            (shows_prec_list show_char zero_nata
                               [#"W", #"h", #"e", #"n", #" ", #"c", #"o", #"n",
                                 #"s", #"i", #"d", #"e", #"r", #"i", #"n", #"g",
                                 #" ", #"t", #"h", #"e", #" ", #"s", #"u", #"b",
                                 #"t", #"e", #"r", #"m", #" "] o
                              (shows_prec_term A3_ (show_list show_char)
                                 zero_nata fts o
                                (shows_nl o
                                  (shows_prec_list show_char zero_nata
                                     [#"a", #"n", #"d", #" ", #"t", #"h", #"e",
                                       #" ", #"r", #"u", #"l", #"e", #" "] o
                                    (shows_rule (shows_prec A3_ zero_nata)
                                       (shows_prec_list show_char zero_nata)
                                       [#" ", #"-", #">", #" "] lr o
                                      (shows_nl o
(shows_prec_list show_char zero_nata
   [#"t", #"h", #"e", #" ", #"c", #"a", #"p", #"p", #"e", #"d", #" ", #"s",
     #"u", #"b", #"t", #"e", #"r", #"m", #" ", #"i", #"s", #" "] o
  (shows_prec_gctxt A3_ zero_nata tcapb o
    (shows_nl o
      (shows_prec_list show_char zero_nata
         [#"l", #"e", #"a", #"d", #"i", #"n", #"g", #" ", #"t", #"o", #" ",
           #"t", #"h", #"e", #" ", #"m", #"g", #"u", #" ", #"w", #"i", #"t",
           #"h", #" ", #"t", #"h", #"e", #" ", #"l", #"h", #"s", #":", #" "] o
        (shows_prec_list
           (show_prod (show_list show_char)
             (show_term A3_ (show_list show_char)))
           zero_nata (map (fn x => (x, sigma x)) (vars_term_list (fst lr))) o
          (shows_nl o
            (shows_prec_list show_char zero_nata
               [#"T", #"h", #"e", #" ", #"i", #"n", #"s", #"t", #"a", #"n",
                 #"t", #"i", #"a", #"t", #"e", #"d", #" ", #"r", #"u", #"l",
                 #"e", #" "] o
              (shows_prec_prod (show_term A3_ (show_list show_char))
                 (show_term A3_ (show_list show_char)) zero_nata irule o
                (shows_nl o
                  shows_prec_list show_char zero_nata
                    [#"c", #"a", #"n", #"n", #"o", #"t", #" ", #"b", #"e", #" ",
                      #"s", #"i", #"m", #"u", #"l", #"a", #"t", #"e", #"d",
                      #" ", #"b", #"y", #" ", #"t", #"h", #"e", #" ", #"g",
                      #"i", #"v", #"e", #"n", #" ", #"s", #"e", #"t", #" ",
                      #"o", #"f", #" ", #"u", #"s", #"a", #"b", #"l", #"e",
                      #" ", #"r", #"u", #"l", #"e", #"s"])))))))))))))))
                        end))
                  r)
                (fn x => Inl (snd x))
            end))
      (supteq_list s))
    (fn x => Inl (snd x));

fun check_usable_instantiation (A1_, A2_, A3_) r u s =
  let
    val uu =
      set (ceq_prod (ceq_term A2_ (equal_list equal_char))
             (ceq_term A2_ (equal_list equal_char)),
            ccompare_prod (ccompare_term A1_ (compare_list compare_char))
              (ccompare_term A1_ (compare_list compare_char)),
            set_impl_prod set_impl_term set_impl_term)
        u;
  in
    bindb (catch_errora (check_contains_U0 (A1_, A2_, A3_) r uu s)
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"U", #" ", #"<", #"=", #" ", #"U", #"0", #"(", #"R",
                       #",", #"s", #")", #" ", #"r", #"e", #"q", #"u", #"i",
                       #"r", #"e", #"d"] o
                    (shows_nl o x))))
      (fn _ =>
        catch_errora
          (forallM
            (fn ra =>
              catch_errora (check_contains_U0 (A1_, A2_, A3_) r uu ra)
                (fn x =>
                  Inl (shows_prec_list show_char zero_nata
                         [#"U", #" ", #"<", #"=", #" ", #"U", #"0", #"(", #"R",
                           #",", #"r", #")", #" ", #"f", #"o", #"r", #" ", #"r",
                           #"h", #"s", #" ", #"r", #" ", #"=", #" "] o
                        (shows_prec_term A3_ (show_list show_char) zero_nata
                           ra o
                          (shows_prec_list show_char zero_nata
                             [#" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e",
                               #"d"] o
                            (shows_nl o x))))))
            (map snd u))
          (fn x => Inl (snd x)))
  end;

fun check_usable_rules_unif (A1_, A2_, A3_) r u s =
  catch_errora
    (bindb
      (check (ground s orelse list_all (fn l => not (is_Var l)) (map fst r))
        (shows_string [#"s", #"i", #"n", #"c", #"e", #" "] o
          (shows_prec_term A3_ (show_list show_char) zero_nata s o
            shows_prec_list show_char zero_nata
              [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"g", #"r", #"o",
                #"u", #"n", #"d", #",", #" ", #"l", #"e", #"f", #"t", #"-",
                #"h", #"a", #"n", #"d", #" ", #"s", #"i", #"d", #"e", #"s",
                #" ", #"o", #"f", #" ", #"R", #" ", #"m", #"u", #"s", #"t",
                #" ", #"n", #"o", #"t", #" ", #"b", #"e", #" ", #"v", #"a",
                #"r", #"i", #"a", #"b", #"l", #"e", #"s"])))
      (fn _ =>
        bindb (check_varcond_subset A3_
                (equal_list equal_char, show_list show_char) u)
          (fn _ =>
            catch_errora (check_usable_instantiation (A1_, A2_, A3_) r u s)
              (fn x =>
                Inl (shows_string
                       [#"c", #"l", #"o", #"s", #"u", #"r", #"e", #" ", #"p",
                         #"r", #"o", #"p", #"e", #"r", #"t", #"i", #"e", #"s",
                         #" ", #"o", #"f", #" ", #"u", #"s", #"a", #"b", #"l",
                         #"e", #" ", #"r", #"u", #"l", #"e", #"s", #" ", #"n",
                         #"o", #"t", #" ", #"s", #"a", #"t", #"i", #"s", #"f",
                         #"i", #"e", #"d"] o
                      (shows_nl o x))))))
    (fn x =>
      Inl (shows_string
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ", #"v", #"a",
               #"l", #"i", #"d", #"i", #"t", #"y", #" ", #"o", #"f", #" ", #"u",
               #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"u", #"l", #"e", #"s",
               #" ", #"U", #" ", #"=", #" "] o
            (shows_nl o
              (shows_trs (shows_prec A3_ zero_nata)
                 (shows_prec_list show_char zero_nata)
                 [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s", #"y",
                   #"s", #"t", #"e", #"m", #":"]
                 [#" ", #"-", #">", #" "] u o
                (shows_nl o
                  (shows_prec_list show_char zero_nata
                     [#"f", #"o", #"r", #" ", #"t", #"e", #"r", #"m", #" "] o
                    (shows_prec_term A3_ (show_list show_char) zero_nata s o
                      (shows_nl o
                        (shows_string
                           [#"w", #"r", #"t", #" ", #"T", #"R", #"S", #" ",
                             #"R", #" ", #"=", #" "] o
                          (shows_nl o
                            (shows_trs (shows_prec A3_ zero_nata)
                               (shows_prec_list show_char zero_nata)
                               [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                                 #"s", #"y", #"s", #"t", #"e", #"m", #":"]
                               [#" ", #"-", #">", #" "] r o
                              (shows_nl o x))))))))))));

fun sl_c
  (Sl_ops_ext
    (sl_La, sl_LSa, sl_I, sl_C, sl_c, sl_check_decr, sl_L, sl_LS, sl_lgen,
      sl_LS_gen, more))
  = sl_c;

fun check_qmodel_rule_ass A_ B_ C_ i cge alpha (l, r) =
  let
    val cl = eval i alpha l;
    val cr = eval i alpha r;
  in
    check (cge cl cr)
      (shows_string [#"r", #"u", #"l", #"e", #" "] o
        (shows_rule (shows_prec A_ zero_nata) (shows_prec C_ zero_nata)
           [#" ", #"-", #">", #" "] (l, r) o
          (shows_string
             [#" ", #"v", #"i", #"o", #"l", #"a", #"t", #"e", #"s", #" ", #"t",
               #"h", #"e", #" ", #"m", #"o", #"d", #"e", #"l", #" ", #"c", #"o",
               #"n", #"d", #"i", #"t", #"i", #"o", #"n", #",", #" ", #"[", #"l",
               #"h", #"s", #"]", #" ", #"=", #" "] o
            (shows_prec B_ zero_nata cl o
              (shows_string
                 [#",", #" ", #"[", #"r", #"h", #"s", #"]", #" ", #"=", #" "] o
                shows_prec B_ zero_nata cr)))))
  end;

fun check_qmodel_rule A_ B_ (C1_, C2_) i c cge lr =
  catch_errora
    (forallM (fn alpha => check_qmodel_rule_ass A_ B_ C2_ i cge alpha lr)
      (map (fun_of C1_) (enum_vectors c (insert_vars_rule C1_ lr []))))
    (fn x => Inl (snd x));

fun check_qmodel A_ B_ (C1_, C2_) i c cge r =
  catch_errora (forallM (check_qmodel_rule A_ B_ (C1_, C2_) i c cge) r)
    (fn x => Inl (snd x));

fun check_non_join_model A_ B_ (D1_, D2_) cge gen rs rt s t =
  catch_errora
    (bindb (gen (funas_trs_list (rs @ rt)) [])
      (fn ops =>
        let
          val i = sl_I ops;
          val e = eval i (fn _ => sl_c ops);
          val es = e s;
          val et = e t;
        in
          bindb (check (not (cge et es))
                  (shows_prec_list show_char zero_nata
                     [#"t", #"h", #"e", #" ", #"i", #"n", #"e", #"q", #"u",
                       #"a", #"l", #"i", #"t", #"y", #" ", #"m", #"u", #"s",
                       #"t", #" ", #"n", #"o", #"t", #" ", #"h", #"o", #"l",
                       #"d", #":", #" ", #"["] o
                    (shows_prec_term B_ D2_ zero_nata t o
                      (shows_prec_list show_char zero_nata
                         [#"]", #" ", #"=", #" "] o
                        (shows_prec A_ zero_nata et o
                          (shows_prec_list show_char zero_nata
                             [#" ", #">", #"=", #" "] o
                            (shows_prec A_ zero_nata es o
                              (shows_prec_list show_char zero_nata
                                 [#" ", #"=", #" ", #"["] o
                                (shows_prec_term B_ D2_ zero_nata s o
                                  shows_prec_list show_char zero_nata
                                    [#"]"])))))))))
            (fn _ =>
              check_qmodel B_ A_ (D1_, D2_) i (sl_C ops) cge
                (reverse_rules rs @ rt))
        end))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"d", #"i", #"s", #"p", #"r", #"o", #"v", #"i", #"n", #"g", #" ",
               #"n", #"o", #"n", #"-", #"j", #"o", #"i", #"n", #"a", #"b", #"i",
               #"l", #"i", #"t", #"y", #" ", #"v", #"i", #"a", #" ", #"i", #"n",
               #"t", #"e", #"r", #"p", #"r", #"e", #"t", #"a", #"t", #"i", #"o",
               #"n", #"s"] o
            (shows_nl o x)));

fun check_non_join_finite_model (A1_, A2_) (B1_, B2_, B3_, B4_) (Rootlab x) rs
  rt s t =
  check_non_join_model (show_lab A2_ (show_list show_nat))
    (show_lab A2_ (show_list show_nat)) (B2_, B4_)
    (equal_laba A1_ (equal_list equal_nat))
    (slm_gen_to_sl_gen (rl_slm A1_ (equal_list equal_nat) x)) rs rt s t
  | check_non_join_finite_model (A1_, A2_) (B1_, B2_, B3_, B4_) (Finitelab sli)
    rs rt s t =
    check_non_join_model show_nat (show_lab A2_ (show_list show_nat)) (B2_, B4_)
      equal_nata (slm_gen_to_sl_gen (fn _ => fn _ => Inr (sli_to_slm A1_ sli)))
      rs rt s t
  | check_non_join_finite_model (A1_, A2_) (B1_, B2_, B3_, B4_)
    (QuasiFinitelab (sli, v)) rs rt s t =
    check_non_join_model show_nat (show_lab A2_ (show_list show_nat)) (B2_, B4_)
      qmodel_cge
      (fn f => fn g => qsli_to_sl (B1_, B2_, B3_) (A1_, A2_) v f g sli) rs rt s
      t;

fun match_tcap_below_impl A_ B_ l r (Fun (f, ts)) =
  matchb A_ B_ (GCFun (f, map (tcapI A_ B_ r) ts)) l
  | match_tcap_below_impl A_ B_ l r (Var x) = false;

fun usable_rules_reach_U0_impl A_ B_ r t =
  inductive_set_impl (equal_prod (equal_term A_ B_) (equal_term A_ B_))
    (equal_term A_ B_) r
    (fn ta => fn (l, _) =>
      is_Var l orelse
        list_ex
          (fn u => not (is_Var u) andalso match_tcap_below_impl A_ B_ l r u)
          (supteq_list ta))
    (fn lr => [snd lr]) [t];

fun usable_rules_reach_impl (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) r t =
  let
    val u0t = usable_rules_reach_U0_impl A2_ B6_ r t;
  in
    (if list_all
          (fn (l, ra) =>
            less_eq_set (B2_, B3_, ccompare_cproper_interval B4_)
              (vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) ra)
              (vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) l))
          u0t
      then u0t else r)
  end;

fun check_non_join_redpair (A1_, A2_) B_ rp rs rt sa t =
  catch_errora
    (bindb (valid rp)
      (fn _ =>
        bindb (catch_errora (forallM (ns rp) (reverse_rules rs @ rt))
                (fn x => Inl (snd x)))
          (fn _ => s rp (sa, t))))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"d", #"i", #"s", #"p", #"r", #"o", #"v", #"i", #"n", #"g", #" ",
               #"n", #"o", #"n", #"-", #"j", #"o", #"i", #"n", #"a", #"b", #"i",
               #"l", #"i", #"t", #"y", #" ", #"v", #"i", #"a", #" ", #"d", #"i",
               #"s", #"c", #"r", #"i", #"m", #"i", #"n", #"a", #"t", #"i", #"o",
               #"n", #" ", #"p", #"a", #"i", #"r", #"s"] o
            (shows_nl o x)));

fun non_join_with_ta (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_)
  D_ (E1_, E2_, E3_, E4_, E5_, E6_, E7_, E8_)
  (F1_, F2_, F3_, F4_, F5_, F6_, F7_, F8_) G_ ta1 rel1 r1 t1 ta2 rel2 r2 t2 =
  let
    val tA1 =
      ta_of_ta (A3_, ccompare_cproper_interval A4_, A6_, A7_) (B2_, B5_) ta1;
    val tA2 =
      ta_of_ta (E3_, ccompare_cproper_interval E4_, E6_, E7_) (B2_, B5_) ta2;
  in
    bindb (check
            (ta_member (B2_, B5_)
              (A2_, A3_, ccompare_cproper_interval A4_, A6_, A7_) t1 tA1)
            (shows_prec_term B7_ D_ zero_nata t1 o
              shows_prec_list show_char zero_nata
                [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"c",
                  #"c", #"e", #"p", #"t", #"e", #"d", #" ", #"b", #"y", #" ",
                  #"f", #"i", #"r", #"s", #"t", #" ", #"a", #"u", #"t", #"o",
                  #"m", #"a", #"t", #"o", #"n"]))
      (fn _ =>
        bindb (check
                (ta_member (B2_, B5_)
                  (E2_, E3_, ccompare_cproper_interval E4_, E6_, E7_) t2 tA2)
                (shows_prec_term B7_ G_ zero_nata t2 o
                  shows_prec_list show_char zero_nata
                    [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"c",
                      #"c", #"e", #"p", #"t", #"e", #"d", #" ", #"b", #"y",
                      #" ", #"f", #"i", #"r", #"s", #"t", #" ", #"a", #"u",
                      #"t", #"o", #"m", #"a", #"t", #"o", #"n"]))
          (fn _ =>
            bindb (check
                    (ta_empty
                      (cenum_prod A2_ E2_, ceq_prod A3_ E3_,
                        ccompare_prod (ccompare_cproper_interval A4_)
                          (ccompare_cproper_interval E4_),
                        equal_prod A6_ E6_, set_impl_prod A7_ E7_)
                      (B2_, B4_, B5_)
                      (intersect_ta
                        (finite_UNIV_card_UNIV A1_, A2_, A3_, A4_, A6_, A7_)
                        (B1_, B2_, B5_, B6_)
                        (finite_UNIV_card_UNIV E1_, E2_, E3_, E4_, E6_, E7_) tA1
                        tA2))
                    (shows_prec_list show_char zero_nata
                      [#"i", #"n", #"t", #"e", #"r", #"s", #"e", #"c", #"t",
                        #"i", #"o", #"n", #" ", #"o", #"f", #" ", #"a", #"u",
                        #"t", #"o", #"m", #"a", #"t", #"a", #" ", #"i", #"s",
                        #" ", #"n", #"o", #"n", #"-", #"e", #"m", #"p", #"t",
                        #"y"]))
              (fn _ =>
                bindb (catch_errora
                        (tree_aut_trs_closed
                          (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_)
                          (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
                          (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_) ta1 rel1 r1)
                        (fn x =>
                          Inl (shows_prec_list show_char zero_nata
                                 [#"c", #"o", #"u", #"l", #"d", #" ", #"n",
                                   #"o", #"t", #" ", #"e", #"n", #"s", #"u",
                                   #"r", #"e", #" ", #"c", #"l", #"o", #"s",
                                   #"u", #"r", #"e", #" ", #"u", #"n", #"d",
                                   #"e", #"r", #" ", #"r", #"e", #"w", #"r",
                                   #"i", #"t", #"i", #"n", #"g", #" ", #"f",
                                   #"o", #"r", #" ", #"f", #"i", #"r", #"s",
                                   #"t", #" ", #"a", #"u", #"t", #"o", #"m",
                                   #"a", #"t", #"o", #"n"] o
                                (shows_nl o x))))
                  (fn _ =>
                    catch_errora
                      (tree_aut_trs_closed
                        (E1_, E2_, E3_, E4_, E5_, E6_, E7_, E8_)
                        (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
                        (F1_, F2_, F3_, F4_, F5_, F6_, F7_, F8_) ta2 rel2 r2)
                      (fn x =>
                        Inl (shows_prec_list show_char zero_nata
                               [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
                                 #"t", #" ", #"e", #"n", #"s", #"u", #"r", #"e",
                                 #" ", #"c", #"l", #"o", #"s", #"u", #"r", #"e",
                                 #" ", #"u", #"n", #"d", #"e", #"r", #" ", #"r",
                                 #"e", #"w", #"r", #"i", #"t", #"i", #"n", #"g",
                                 #" ", #"f", #"o", #"r", #" ", #"s", #"e", #"c",
                                 #"o", #"n", #"d", #" ", #"a", #"u", #"t", #"o",
                                 #"m", #"a", #"t", #"o", #"n"] o
                              (shows_nl o x)))))))
  end;

fun check_non_join (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
  rs rt s t Diff_NFs =
  bindb (check
          (not (equal_terma (equal_lab A2_ (equal_list equal_nat))
                 (equal_list equal_char) s t))
          (shows_prec_list show_char zero_nata
             [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #"s", #" "] o
            (shows_prec_term (show_lab A4_ (show_list show_nat))
               (show_list show_char) zero_nata s o
              (shows_prec_list show_char zero_nata
                 [#" ", #"a", #"n", #"d", #" "] o
                (shows_prec_term (show_lab A4_ (show_list show_nat))
                   (show_list show_char) zero_nata t o
                  shows_prec_list show_char zero_nata
                    [#" ", #"a", #"r", #"e", #" ", #"i", #"d", #"e", #"n", #"t",
                      #"i", #"c", #"a", #"l"])))))
    (fn _ =>
      let
        val chknf =
          (fn sa => fn r =>
            check (is_NF_trs
                    (equal_lab A2_ (equal_list equal_nat),
                      key_lab A3_ (key_list (equal_nat, key_nat)))
                    (ccompare_list ccompare_char, equal_list equal_char,
                      mapping_impl_list)
                    r sa)
              (shows_prec_list show_char zero_nata
                 [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #" "] o
                (shows_term (shows_prec_lab A4_ (show_list show_nat) zero_nata)
                   (shows_prec_list show_char zero_nata) sa o
                  shows_prec_list show_char zero_nata
                    [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"i", #"n",
                      #" ", #"n", #"o", #"r", #"m", #"a", #"l", #" ", #"f",
                      #"o", #"r", #"m"])));
      in
        bindb (chknf s rs) (fn _ => chknf t rt)
      end)
  | check_non_join (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    rs rt s t (Grounding (sigma, prf)) =
    let
      val sigmaa = mk_subst (equal_list equal_char) Var sigma;
    in
      check_non_join (A1_, A2_, A3_, A4_)
        (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) rs rt
        (subst_apply_term s sigmaa) (subst_apply_term t sigmaa) prf
    end
  | check_non_join (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    rs rt s t (Subterm_NJ (p, prf)) =
    bindb (check
            (member (ceq_pos, ccompare_pos) p
              (pos_gctxt
                (compare_lab ((compare_compare_order o compare_order_key) A3_)
                   (compare_list compare_nat),
                  equal_lab A2_ (equal_list equal_nat))
                (compare_list compare_char)
                (tcapI (equal_lab A2_ (equal_list equal_nat))
                  (equal_list equal_char) rs s)))
            (shows_prec_list show_char zero_nata
               [#"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n", #" "] o
              (shows_prec_pos zero_nata p o
                (shows_prec_list show_char zero_nata
                   [#" ", #"n", #"o", #"t", #" ", #"i", #"n", #" ", #"c", #"a",
                     #"p", #"p", #"e", #"d", #" ", #"t", #"e", #"r", #"m", #" ",
                     #" ", #"o", #"f", #" "] o
                  shows_prec_term (show_lab A4_ (show_list show_nat))
                    (show_list show_char) zero_nata s))))
      (fn _ =>
        bindb (check
                (member (ceq_pos, ccompare_pos) p
                  (pos_gctxt
                    (compare_lab
                       ((compare_compare_order o compare_order_key) A3_)
                       (compare_list compare_nat),
                      equal_lab A2_ (equal_list equal_nat))
                    (compare_list compare_char)
                    (tcapI (equal_lab A2_ (equal_list equal_nat))
                      (equal_list equal_char) rt t)))
                (shows_prec_list show_char zero_nata
                   [#"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n", #" "] o
                  (shows_prec_pos zero_nata p o
                    (shows_prec_list show_char zero_nata
                       [#" ", #"n", #"o", #"t", #" ", #"i", #"n", #" ", #"c",
                         #"a", #"p", #"p", #"e", #"d", #" ", #"t", #"e", #"r",
                         #"m", #" ", #" ", #"o", #"f", #" "] o
                      shows_prec_term (show_lab A4_ (show_list show_nat))
                        (show_list show_char) zero_nata t))))
          (fn _ =>
            check_non_join (A1_, A2_, A3_, A4_)
              (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) rs rt (subt_at s p)
              (subt_at t p) prf))
  | check_non_join (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    rs rt s t (Tcap_Non_Unif grd_subst) =
    let
      val sigma = grd_subst s t;
      val cs =
        tcapI (equal_lab A2_ (equal_list equal_nat)) (equal_list equal_char) rs
          (subst_apply_term s sigma);
      val ct =
        tcapI (equal_lab A2_ (equal_list equal_nat)) (equal_list equal_char) rt
          (subst_apply_term t sigma);
    in
      check (is_none (mergea (equal_lab A2_ (equal_list equal_nat)) cs ct))
        (shows_prec_list show_char zero_nata
           [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"i",
             #"n", #"f", #"e", #"r", #" ", #"t", #"h", #"a", #"t", #" "] o
          (shows_prec_term (show_lab A4_ (show_list show_nat))
             (show_list show_char) zero_nata s o
            (shows_prec_list show_char zero_nata
               [#" ", #"a", #"n", #"d", #" "] o
              (shows_prec_term (show_lab A4_ (show_list show_nat))
                 (show_list show_char) zero_nata t o
                shows_prec_list show_char zero_nata
                  [#" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ", #"j",
                    #"o", #"i", #"n", #"a", #"b", #"l", #"e"]))))
    end
  | check_non_join (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    rs rt s t (Tree_Aut_Intersect_Empty (ta1, rel1, ta2, rel2)) =
    catch_errora
      (non_join_with_ta (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
        (ceq_lab A2_ (equal_list equal_nat),
          ccompare_lab ((compare_compare_order o compare_order_key) A3_)
            (compare_list compare_nat),
          compare_order_lab ((compare_compare_order o compare_order_key) A3_)
            (compare_list compare_nat),
          default_lab A1_, equal_lab A2_ (equal_list equal_nat), set_impl_lab,
          show_lab A4_ (show_list show_nat))
        (finite_UNIV_list, cenum_list, ceq_list ceq_char,
          cproper_interval_list ccompare_char,
          compare_order_list (compare_order_char, equal_char),
          equal_list equal_char, set_impl_list, show_list show_char)
        (show_list show_char) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
        (finite_UNIV_list, cenum_list, ceq_list ceq_char,
          cproper_interval_list ccompare_char,
          compare_order_list (compare_order_char, equal_char),
          equal_list equal_char, set_impl_list, show_list show_char)
        (show_list show_char) ta1 rel1 rs s ta2 rel2 rt t)
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                 #"i", #"n", #"f", #"e", #"r", #" ", #"t", #"h", #"a", #"t",
                 #" "] o
              (shows_prec_term (show_lab A4_ (show_list show_nat))
                 (show_list show_char) zero_nata s o
                (shows_prec_list show_char zero_nata
                   [#" ", #"a", #"n", #"d", #" "] o
                  (shows_prec_term (show_lab A4_ (show_list show_nat))
                     (show_list show_char) zero_nata t o
                    (shows_prec_list show_char zero_nata
                       [#" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ",
                         #"j", #"o", #"i", #"n", #"a", #"b", #"l", #"e"] o
                      (shows_nl o x)))))))
  | check_non_join (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    rs rt s t (Finite_Model_Gt i) =
    catch_errora
      (check_non_join_finite_model (A2_, A4_)
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list,
          show_list show_char)
        i rs rt s t)
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                 #"i", #"n", #"f", #"e", #"r", #" ", #"t", #"h", #"a", #"t",
                 #" "] o
              (shows_prec_term (show_lab A4_ (show_list show_nat))
                 (show_list show_char) zero_nata s o
                (shows_prec_list show_char zero_nata
                   [#" ", #"a", #"n", #"d", #" "] o
                  (shows_prec_term (show_lab A4_ (show_list show_nat))
                     (show_list show_char) zero_nata t o
                    (shows_prec_list show_char zero_nata
                       [#" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ",
                         #"j", #"o", #"i", #"n", #"a", #"b", #"l", #"e"] o
                      (shows_nl o x)))))))
  | check_non_join (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    rs rt s t (Reduction_Pair_Gt rp) =
    catch_errora
      (check_non_join_redpair
        (key_lab A3_ (key_list (equal_nat, key_nat)),
          show_lab A4_ (show_list show_nat))
        (show_list show_char)
        (get_redtriple
          (ceq_lab A2_ (equal_list equal_nat),
            ccompare_lab ((compare_compare_order o compare_order_key) A3_)
              ((compare_compare_order o compare_order_key)
                (key_list (equal_nat, key_nat))),
            equal_lab A2_ (equal_list equal_nat),
            key_lab A3_ (key_list (equal_nat, key_nat)), set_impl_lab,
            show_lab A4_ (show_list show_nat))
          rp)
        rs rt s t)
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                 #"i", #"n", #"f", #"e", #"r", #" ", #"t", #"h", #"a", #"t",
                 #" "] o
              (shows_prec_term (show_lab A4_ (show_list show_nat))
                 (show_list show_char) zero_nata s o
                (shows_prec_list show_char zero_nata
                   [#" ", #"a", #"n", #"d", #" "] o
                  (shows_prec_term (show_lab A4_ (show_list show_nat))
                     (show_list show_char) zero_nata t o
                    (shows_prec_list show_char zero_nata
                       [#" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ",
                         #"j", #"o", #"i", #"n", #"a", #"b", #"l", #"e"] o
                      (shows_nl o x)))))))
  | check_non_join (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    rs rt s t (Usable_Rules_Reach_NJ prf) =
    check_non_join (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
      (usable_rules_reach_impl
        (compare_lab ((compare_compare_order o compare_order_key) A3_)
           (compare_list compare_nat),
          equal_lab A2_ (equal_list equal_nat))
        (finite_UNIV_list, cenum_list, ceq_list ceq_char,
          cproper_interval_list ccompare_char, compare_list compare_char,
          equal_list equal_char, set_impl_list)
        rs s)
      (usable_rules_reach_impl
        (compare_lab ((compare_compare_order o compare_order_key) A3_)
           (compare_list compare_nat),
          equal_lab A2_ (equal_list equal_nat))
        (finite_UNIV_list, cenum_list, ceq_list ceq_char,
          cproper_interval_list ccompare_char, compare_list compare_char,
          equal_list equal_char, set_impl_list)
        rt t)
      s t prf
  | check_non_join (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    rs rt s t (Usable_Rules_Reach_Unif_NJ (u_sum, prf)) =
    (case u_sum
      of Inl u =>
        bindb (check_usable_rules_unif
                (compare_lab ((compare_compare_order o compare_order_key) A3_)
                   (compare_list compare_nat),
                  equal_lab A2_ (equal_list equal_nat),
                  show_lab A4_ (show_list show_nat))
                rs u s)
          (fn _ =>
            check_non_join (A1_, A2_, A3_, A4_)
              (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) u rt s t prf)
      | Inr u =>
        bindb (check_usable_rules_unif
                (compare_lab ((compare_compare_order o compare_order_key) A3_)
                   (compare_list compare_nat),
                  equal_lab A2_ (equal_list equal_nat),
                  show_lab A4_ (show_list show_nat))
                rt u t)
          (fn _ =>
            check_non_join (A1_, A2_, A3_, A4_)
              (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) rs u s t prf))
  | check_non_join (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    rs rt s t (Argument_Filter_NJ (pi, prf)) =
    (case afs_of
            (ceq_lab A2_ (equal_list equal_nat),
              ccompare_lab ((compare_compare_order o compare_order_key) A3_)
                ((compare_compare_order o compare_order_key)
                  (key_list (equal_nat, key_nat))),
              key_lab A3_ (key_list (equal_nat, key_nat)), set_impl_lab)
            pi
      of NONE =>
        Inl (shows_prec_list show_char zero_nata
              [#"i", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"a", #"r", #"g",
                #"u", #"m", #"e", #"n", #"t", #" ", #"f", #"i", #"l", #"t",
                #"e", #"r"])
      | SOME pia =>
        let
          val af = af_term pia;
          val afs = af_rules pia;
        in
          check_non_join (A1_, A2_, A3_, A4_)
            (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) (afs rs) (afs rt) (af s)
            (af t) prf
        end);

fun ru_impl r = map fst r;

fun check_conditional_non_cr (A1_, A2_, A3_, A4_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r s t u ps qs reason =
  bindb (check_csteps
          (equal_lab A2_ (equal_list equal_nat),
            show_lab A4_ (show_list show_nat))
          (ccompare_list ccompare_char, equal_list equal_char,
            mapping_impl_list, show_list show_char)
          r s t ps)
    (fn _ =>
      bindb (check_csteps
              (equal_lab A2_ (equal_list equal_nat),
                show_lab A4_ (show_list show_nat))
              (ccompare_list ccompare_char, equal_list equal_char,
                mapping_impl_list, show_list show_char)
              r s u qs)
        (fn _ =>
          check_non_join (A1_, A2_, A3_, A4_)
            (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) (ru_impl r) (ru_impl r) t u
            reason));

fun find_index A_ i x [] = Inl ()
  | find_index A_ i x (y :: ys) =
    (if eq A_ x y then Inr i else find_index A_ (suc i) x ys);

fun check_inline_conds_rule (A1_, A2_, A3_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r rho [] = Inr (r, rho)
  | check_inline_conds_rule (A1_, A2_, A3_)
    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r rho (c :: cs) =
    catch_errora
      let
        val a = rho;
        val (aa, b) = a;
      in
        let
          val (l, _) = aa;
        in
          (fn csa =>
            let
              val (s, t) = c;
            in
              bindb (check (is_Var t)
                      (shows_prec_list show_char zero_nata
                        [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
                          #" ", #"w", #"i", #"t", #"h", #" ", #"n", #"o", #"n",
                          #"-", #"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e",
                          #" ", #"r", #"h", #"s"]))
                (fn _ =>
                  let
                    val x = the_Var t;
                  in
                    bindb (catch_errora
                            (find_index
                              (equal_prod (equal_term A2_ B6_)
                                (equal_term A2_ B6_))
                              zero_nata c csa)
                            (fn xa =>
                              Inl let
                                    val () = xa;
                                  in
                                    shows_prec_list show_char zero_nata
                                      [#"c", #"o", #"n", #"d", #"i", #"t", #"i",
#"o", #"n", #" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"o",
#"c", #"c", #"u", #"r", #" ", #"i", #"n", #" ", #"r", #"u", #"l", #"e"]
                                  end))
                      (fn i =>
                        bindb (check (not (contains_var_term B6_ x s))
                                (shows_prec_list show_char zero_nata
                                  [#"o", #"c", #"c", #"u", #"r", #"s", #" ",
                                    #"c", #"h", #"e", #"c", #"k", #" ", #"f",
                                    #"a", #"i", #"l", #"e", #"d"]))
                          (fn _ =>
                            bindb (check (not (contains_var_term B6_ x l))
                                    (shows_prec_list show_char zero_nata
                                      [#"i", #"n", #"l", #"i", #"n", #"i", #"n",
#"g", #" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o", #"w", #"e", #"d",
#" ", #"i", #"n", #" ", #"l", #"h", #"s", #" ", #"o", #"f", #" ", #"r", #"u",
#"l", #"e"]))
                              (fn _ =>
                                bindb (check
(not (member (B3_, ccompare_cproper_interval B4_) x
       (sup_seta (B3_, ccompare_cproper_interval B4_)
         (sup_setb (B1_, B2_, B3_, B4_, B7_)
           (image (ceq_term A2_ B6_, ccompare_term A1_ B5_)
             (ceq_set (B2_, B3_, ccompare_cproper_interval B4_),
               ccompare_set (B1_, B3_, B4_, B7_), set_impl_set)
             (vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_))
             (image
               (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_),
                 ccompare_prod (ccompare_term A1_ B5_) (ccompare_term A1_ B5_))
               (ceq_term A2_ B6_, ccompare_term A1_ B5_, set_impl_term) snd
               (set (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_),
                      ccompare_prod (ccompare_term A1_ B5_)
                        (ccompare_term A1_ B5_),
                      set_impl_prod set_impl_term set_impl_term)
                 (take i csa)))))
         (sup_setb (B1_, B2_, B3_, B4_, B7_)
           (image (ceq_term A2_ B6_, ccompare_term A1_ B5_)
             (ceq_set (B2_, B3_, ccompare_cproper_interval B4_),
               ccompare_set (B1_, B3_, B4_, B7_), set_impl_set)
             (vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_))
             (image
               (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_),
                 ccompare_prod (ccompare_term A1_ B5_) (ccompare_term A1_ B5_))
               (ceq_term A2_ B6_, ccompare_term A1_ B5_, set_impl_term) snd
               (set (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_),
                      ccompare_prod (ccompare_term A1_ B5_)
                        (ccompare_term A1_ B5_),
                      set_impl_prod set_impl_term set_impl_term)
                 (drop (suc i) csa))))))))
(shows_prec_list show_char zero_nata
  [#"i", #"n", #"l", #"i", #"n", #"i", #"n", #"g", #" ", #"n", #"o", #"t", #" ",
    #"a", #"l", #"l", #"o", #"w", #"e", #"d", #" ", #"i", #"n", #" ", #"r",
    #"h", #"s", #"s", #" ", #"o", #"f", #" ", #"c", #"o", #"n", #"d", #"i",
    #"t", #"i", #"o", #"n", #"s"]))
                                  (fn _ =>
                                    check_inline_conds_rule (A1_, A2_, A3_)
                                      (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
                                      (inline B6_ i rho ::
removeAll
  (equal_prod (equal_prod (equal_term A2_ B6_) (equal_term A2_ B6_))
    (equal_list (equal_prod (equal_term A2_ B6_) (equal_term A2_ B6_))))
  rho r)
                                      (inline B6_ i rho)
                                      (map
(fn (u, ab) => (subst_apply_term u (subst B6_ x s), ab)) cs)))))
                  end)
            end)
        end
          b
      end
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"i", #"l",
                 #"e", #" ", #"i", #"n", #"l", #"i", #"n", #"i", #"n", #"g",
                 #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
                 #" "] o
               shows_eq (shows_prec A3_ zero_nata) (shows_prec B8_ zero_nata)
                 c o
               shows_prec_list show_char zero_nata
                 [#" ", #"o", #"f", #" ", #"r", #"u", #"l", #"e", #" "] o
               shows_crule (shows_prec A3_ zero_nata) (shows_prec B8_ zero_nata)
                 rho o
               shows_nl o
              x));

fun check_inline_conds_ctrs (A1_, A2_, A3_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r [] = Inr r
  | check_inline_conds_ctrs (A1_, A2_, A3_)
    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) ra ((r, cs) :: rcs) =
    catch_errora
      (bindb
        (check
          (membera
            (equal_prod (equal_prod (equal_term A2_ B6_) (equal_term A2_ B6_))
              (equal_list
                (equal_prod (equal_term A2_ B6_) (equal_term A2_ B6_))))
            ra r)
          (shows_crule (shows_prec A3_ zero_nata) (shows_prec B8_ zero_nata) r o
            shows_prec_list show_char zero_nata
              [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"o",
                #"c", #"c", #"u", #"r", #" ", #"i", #"n", #" ", #"t", #"h",
                #"e", #" ", #"i", #"n", #"p", #"u", #"t", #" ", #"C", #"T",
                #"R", #"S"]))
        (fn _ =>
          bindb (check_inline_conds_rule (A1_, A2_, A3_)
                  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) ra r cs)
            (fn (rb, raa) =>
              check_inline_conds_ctrs (A1_, A2_, A3_)
                (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
                (raa ::
                  removeAll
                    (equal_prod
                      (equal_prod (equal_term A2_ B6_) (equal_term A2_ B6_))
                      (equal_list
                        (equal_prod (equal_term A2_ B6_) (equal_term A2_ B6_))))
                    raa rb)
                rcs)))
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"i", #"l",
                 #"e", #" ", #"i", #"n", #"l", #"i", #"n", #"i", #"n", #"g",
                 #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
                 #"s"] o
               shows_nl o
              x));

fun check_inline_conds (A1_, A2_, A3_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
  ra r rcs =
  bindb (check_inline_conds_ctrs (A1_, A2_, A3_)
          (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) ra rcs)
    (fn raa =>
      catch_errora
        (check_same_set
          (equal_prod (equal_prod (equal_term A2_ B6_) (equal_term A2_ B6_))
            (equal_list (equal_prod (equal_term A2_ B6_) (equal_term A2_ B6_))))
          r raa)
        (fn _ =>
          Inl (shows_prec_list show_char zero_nata
                 [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"i", #"l",
                   #"e", #" ", #"i", #"n", #"l", #"i", #"n", #"i", #"n", #"g",
                   #":"] o
                 shows_nl o
                 shows_prec_list show_char zero_nata
                   [#"i", #"n", #"t", #"e", #"r", #"n", #"a", #"l", #"l", #"y",
                     #" ", #"c", #"o", #"m", #"p", #"u", #"t", #"e", #"d", #" ",
                     #"C", #"T", #"R", #"S"] o
                 shows_nl o
                 shows_ctrs (shows_prec A3_ zero_nata)
                   (shows_prec B8_ zero_nata) raa o
                 shows_nl o
                 shows_prec_list show_char zero_nata
                   [#"b", #"u", #"t", #" ", #"c", #"e", #"r", #"t", #"i", #"f",
                     #"i", #"c", #"a", #"t", #"e", #" ", #"c", #"o", #"n", #"t",
                     #"a", #"i", #"n", #"s", #" ", #"C", #"T", #"R", #"S"] o
                 shows_nl o
                shows_ctrs (shows_prec A3_ zero_nata) (shows_prec B8_ zero_nata)
                  r)));

fun check_infeasible_rules (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r =
  (fn xs =>
    catch_errora
      (forallM
        (fn (ra, ps) =>
          catch_errora
            (check_infeasibleb (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
              (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r (snd ra) ps)
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"r", #"u", #"l", #"e", #" "] o
                     shows_crule (shows_prec A9_ zero_nata)
                       (shows_prec B9_ zero_nata) ra o
                     shows_prec_list show_char zero_nata
                       [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"i",
                         #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e",
                         #" "] o
                     shows_nl o
                    x)))
        xs)
      (fn x => Inl (snd x)));

fun check_ccr_trans (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
  (D1_, D2_, D3_, D4_, D5_, D6_, D7_, D8_, D9_) i ra
  (Inline_Conditions_CCRT (r, rcs)) =
  debug (i [])
    [#"I", #"n", #"l", #"i", #"n", #"e", #" ", #"C", #"o", #"n", #"d", #"i",
      #"t", #"i", #"o", #"n", #"s"]
    (bindb
      (check_inline_conds
        (compare_lab ((compare_compare_order o compare_order_key) B3_)
           ((compare_compare_order o compare_order_key) C2_),
          equal_lab B2_ C1_, show_lab B4_ C3_)
        (D1_, D2_, D3_, D4_, (compare_compare_order o compare_order_key) D6_,
          D5_, D8_, D9_)
        ra r rcs)
      (fn _ => Inr r))
  | check_ccr_trans (B1_, B2_, B3_, B4_) (C1_, C2_, C3_)
    (D1_, D2_, D3_, D4_, D5_, D6_, D7_, D8_, D9_) i r
    (Infeasible_Rule_Removal_CCRT rps) =
    debug (i [])
      [#"I", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e", #" ", #"R",
        #"u", #"l", #"e", #" ", #"R", #"e", #"m", #"o", #"v", #"a", #"l"]
      (bindb
        (check_infeasible_rules
          (finite_UNIV_lab, cenum_lab, ceq_lab B2_ C1_,
            cproper_interval_lab
              ((compare_compare_order o compare_order_key) B3_)
              ((compare_compare_order o compare_order_key) C2_),
            default_lab B1_, equal_lab B2_ C1_, key_lab B3_ C2_, set_impl_lab,
            show_lab B4_ C3_)
          (D1_, D2_, D3_, D4_, D5_, D6_, D7_, D8_, D9_) r rps)
        (fn _ =>
          Inr (list_diff
                (equal_prod
                  (equal_prod (equal_term (equal_lab B2_ C1_) D5_)
                    (equal_term (equal_lab B2_ C1_) D5_))
                  (equal_list
                    (equal_prod (equal_term (equal_lab B2_ C1_) D5_)
                      (equal_term (equal_lab B2_ C1_) D5_))))
                r (map fst rps))));

fun check_redundant_rules_ncr (A1_, A2_) (B1_, B2_, B3_, B4_) ra r n =
  bindb (catch_errora
          (check_subseteq (equal_prod (equal_term A1_ B2_) (equal_term A1_ B2_))
            ra r)
          (fn _ =>
            Inl (shows_prec_list show_char zero_nata
                  [#"o", #"l", #"d", #" ", #"T", #"R", #"S", #" ", #"i", #"s",
                    #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"s", #"u", #"b",
                    #"s", #"y", #"s", #"t", #"e", #"m", #" ", #"o", #"f", #" ",
                    #"g", #"i", #"v", #"e", #"n", #" ", #"T", #"R", #"S"])))
    (fn _ =>
      let
        val s =
          list_diff (equal_prod (equal_term A1_ B2_) (equal_term A1_ B2_)) r ra;
        val t =
          list_diff (equal_prod (equal_term A1_ B2_) (equal_term A1_ B2_)) ra r;
      in
        bindb (catch_errora
                (forallM
                  (fn (l, rb) =>
                    check (membera (equal_term A1_ B2_)
                            (reachable_terms A1_ (B1_, B2_, B3_) ra l n) rb)
                      (shows_prec_list show_char zero_nata
                         [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                           #" ", #"s", #"i", #"m", #"u", #"l", #"a", #"t", #"e",
                           #" ", #"r", #"u", #"l", #"e", #" "] o
                        shows_rule (shows_prec A2_ zero_nata)
                          (shows_prec B4_ zero_nata) [#" ", #"-", #">", #" "]
                          (l, rb)))
                  s)
                (fn x => Inl (snd x)))
          (fn _ =>
            catch_errora
              (forallM
                (fn (l, raa) =>
                  check (membera (equal_term A1_ B2_)
                          (reachable_terms A1_ (B1_, B2_, B3_) r l n) raa)
                    (shows_prec_list show_char zero_nata
                       [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                         #" ", #"s", #"i", #"m", #"u", #"l", #"a", #"t", #"e",
                         #" ", #"r", #"u", #"l", #"e", #" "] o
                      shows_rule (shows_prec A2_ zero_nata)
                        (shows_prec B4_ zero_nata) [#" ", #"-", #">", #" "]
                        (l, raa)))
                t)
              (fn x => Inl (snd x)))
      end);

fun check_modularity_ncr (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) ra r =
  bindb (catch_errora
          (check_subseteq (equal_prod (equal_term A4_ B1_) (equal_term A4_ B1_))
            r ra)
          (fn _ =>
            Inl (shows_prec_list show_char zero_nata
                  [#"n", #"e", #"w", #" ", #"T", #"R", #"S", #" ", #"i", #"s",
                    #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"s", #"u", #"b",
                    #"s", #"y", #"s", #"t", #"e", #"m", #" ", #"o", #"f", #" ",
                    #"g", #"i", #"v", #"e", #"n", #" ", #"T", #"R", #"S"])))
    (fn _ =>
      let
        val s =
          list_diff (equal_prod (equal_term A4_ B1_) (equal_term A4_ B1_)) ra r;
        val f = funas_trs_list r;
        val g = funas_trs_list s;
      in
        bindb (check
                (less_eq_set
                  (cenum_prod A1_ cenum_nat, ceq_prod A2_ ceq_nat,
                    ccompare_prod A3_ ccompare_nat)
                  (inf_seta
                    (ceq_prod A2_ ceq_nat, ccompare_prod A3_ ccompare_nat)
                    (set (ceq_prod A2_ ceq_nat, ccompare_prod A3_ ccompare_nat,
                           set_impl_prod A5_ set_impl_nat)
                      f)
                    (set (ceq_prod A2_ ceq_nat, ccompare_prod A3_ ccompare_nat,
                           set_impl_prod A5_ set_impl_nat)
                      g))
                  (bot_set
                    (ceq_prod A2_ ceq_nat, ccompare_prod A3_ ccompare_nat,
                      set_impl_prod A5_ set_impl_nat)))
                (shows_prec_list show_char zero_nata
                  [#"s", #"i", #"g", #"n", #"a", #"t", #"u", #"r", #"e", #"s",
                    #" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ", #"d",
                    #"i", #"s", #"j", #"o", #"i", #"n", #"t"]))
          (fn _ =>
            bindb (check_varcond_subset A6_ (B1_, B2_) r)
              (fn _ =>
                catch_errora
                  (catch_errora
                    (forallM
                      (fn x => (if let
                                     val (l, _) = x;
                                   in
                                     not (is_Var l)
                                   end
                                 then Inr () else Inl x))
                      s)
                    (fn x => Inl (snd x)))
                  (fn _ =>
                    Inl (shows_prec_list show_char zero_nata
                          [#"l", #"h", #"s", #"s", #" ", #"m", #"u", #"s", #"t",
                            #" ", #"n", #"o", #"t", #" ", #"b", #"e", #" ",
                            #"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e",
                            #"s"]))))
      end);

fun check_non_cr (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r
  s seq1 seq2 reason =
  let
    val chk =
      check_rsteps_last
        (equal_lab A2_ (equal_list equal_nat),
          show_lab A4_ (show_list show_nat))
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list,
          show_list show_char)
        r s;
  in
    bindb (chk seq1)
      (fn _ =>
        bindb (chk seq2)
          (fn _ =>
            check_non_join (A1_, A2_, A3_, A4_)
              (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r r (rseq_last s seq1)
              (rseq_last s seq2) reason))
  end;

fun check_ncr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j r (SN_NWCR prf) =
  debug (ia []) [#"S", #"N", #"_", #"N", #"W", #"C", #"R"]
    let
      val tp = mkc i false [] r [];
    in
      bindb (catch_errora
              (check_trs_termination_proof (B1_, B3_, B4_, B5_) i j a
                (ia o shows_string [#".", #"1"]) tp prf)
              (fn x =>
                Inl (ia o (shows_string
                             [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                               #"b", #"e", #"l", #"o", #"w", #" ", #"s", #"t",
                               #"r", #"o", #"n", #"g", #" ", #"n", #"o", #"r",
                               #"m", #"a", #"l", #"i", #"z", #"a", #"t", #"i",
                               #"o", #"n", #" ", #"+", #" ", #"w", #"c", #"r"] o
                            (shows_nl o indent x)))))
        (fn _ =>
          catch_errora
            (check
              (not (isOK (check_critical_pairs_NF
                           (equal_lab B3_ (equal_list equal_nat),
                             show_lab B5_ (show_list show_nat))
                           (ccompare_list ccompare_char, equal_list equal_char,
                             mapping_impl_list, show_list show_char)
                           r (critical_pairs_impl
                               (equal_lab B3_ (equal_list equal_nat)) r r))))
              (shows_prec_list show_char zero_nata
                [#"a", #"l", #"l", #" ", #"c", #"r", #"i", #"t", #"i", #"c",
                  #"a", #"l", #" ", #"p", #"a", #"i", #"r", #"s", #" ", #"a",
                  #"r", #"e", #" ", #"j", #"o", #"i", #"n", #"a", #"b", #"l",
                  #"e"]))
            (fn x =>
              Inl (ia o (shows_prec_list show_char zero_nata
                           [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h",
                             #"e", #"n", #" ", #"d", #"i", #"s", #"p", #"r",
                             #"o", #"v", #"i", #"n", #"g", #" ", #"l", #"o",
                             #"c", #"a", #"l", #" ", #"c", #"o", #"n", #"f",
                             #"l", #"u", #"e", #"n", #"c", #"e", #" ", #"o",
                             #"f", #" "] o
                          (shows_tp
                             (shows_prec_lab B5_ (show_list show_nat) zero_nata)
                             (shows_prec_list show_char zero_nata) i tp o
                            (shows_nl o indent x))))))
    end
  | check_ncr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j r
    (Non_Join (s, seq1, seq2, prf)) =
    debug (ia []) [#"N", #"o", #"n", #"_", #"J", #"o", #"i", #"n"]
      (catch_errora
        (check_non_cr (B2_, B3_, B4_, B5_)
          (card_UNIV_list, cenum_list, ceq_list ceq_char,
            cproper_interval_list ccompare_char,
            compare_order_list (compare_order_char, equal_char),
            equal_list equal_char, set_impl_list, show_list show_char)
          r s seq1 seq2 prf)
        (fn x =>
          Inl (ia o (shows_prec_list show_char zero_nata
                       [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e",
                         #"n", #" ", #"d", #"i", #"s", #"p", #"r", #"o", #"v",
                         #"i", #"n", #"g", #" ", #"C", #"R", #" ", #"o", #"f",
                         #" "] o
                      (shows_trs
                         (shows_prec_lab B5_ (show_list show_nat) zero_nata)
                         (shows_prec_list show_char zero_nata)
                         [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s",
                           #"y", #"s", #"t", #"e", #"m", #":"]
                         [#" ", #"-", #">", #" "] r o
                        (shows_nl o indent x))))))
  | check_ncr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j ra
    (NCR_Disj_Subtrs (r, prf)) =
    debug (ia []) [#"M", #"o", #"d", #"u", #"l", #"a", #"r", #"i", #"t", #"y"]
      (bindb
        (catch_errora
          (check_modularity_ncr
            (cenum_lab, ceq_lab B3_ (equal_list equal_nat),
              ccompare_lab ((compare_compare_order o compare_order_key) B4_)
                (compare_list compare_nat),
              equal_lab B3_ (equal_list equal_nat), set_impl_lab,
              show_lab B5_ (show_list show_nat))
            (equal_list equal_char, show_list show_char) ra r)
          (fn x =>
            Inl (ia o (shows_prec_list show_char zero_nata
                         [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e",
                           #"n", #" ", #"a", #"p", #"p", #"l", #"y", #"i", #"n",
                           #"g", #" ", #"m", #"o", #"d", #"u", #"l", #"a", #"r",
                           #"i", #"t", #"y", #" ", #"t", #"o", #" ", #"s", #"w",
                           #"i", #"t", #"c", #"h", #" ", #"t", #"o", #" "] o
                        (shows_trs
                           (shows_prec_lab B5_ (show_list show_nat) zero_nata)
                           (shows_prec_list show_char zero_nata)
                           [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                             #"s", #"y", #"s", #"t", #"e", #"m", #":"]
                           [#" ", #"-", #">", #" "] r o
                          (shows_nl o indent x))))))
        (fn _ =>
          catch_errora
            (check_ncr_proof (B1_, B2_, B3_, B4_, B5_) a
              (ia o shows_string [#".", #"1"]) i j r prf)
            (fn x =>
              Inl (ia o (shows_string
                           [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                             #"b", #"e", #"l", #"o", #"w", #" ", #"t", #"h",
                             #"e", #" ", #"m", #"o", #"d", #"u", #"l", #"a",
                             #"r", #" ", #"d", #"e", #"c", #"o", #"m", #"p",
                             #"o", #"s", #"i", #"t", #"i", #"o", #"n"] o
                          (shows_nl o indent x))))))
  | check_ncr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j r
    (NCR_Redundant_Rules (rs, n, prf)) =
    debug (ia [])
      [#"R", #"e", #"d", #"u", #"n", #"d", #"a", #"n", #"t", #" ", #"R", #"u",
        #"l", #"e", #"s"]
      (bindb
        (catch_errora
          (check_ncr_proof (B1_, B2_, B3_, B4_, B5_) a
            (ia o shows_string [#".", #"1"]) i j rs prf)
          (fn x =>
            Inl (ia o (shows_prec_list show_char zero_nata
                         [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                           #"h", #"e", #"n", #" ", #"p", #"r", #"o", #"v", #"i",
                           #"n", #"g", #" ", #"n", #"o", #"n", #"c", #"o", #"n",
                           #"f", #"l", #"u", #"e", #"n", #"c", #"e", #" ", #"o",
                           #"f", #" ", #"m", #"o", #"d", #"i", #"f", #"i", #"e",
                           #"d", #" ", #"T", #"R", #"S"] o
                        (shows_nl o
                          (shows_trs
                             (shows_prec_lab B5_ (show_list show_nat) zero_nata)
                             (shows_prec_list show_char zero_nata)
                             [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                               #"s", #"y", #"s", #"t", #"e", #"m", #":"]
                             [#" ", #"-", #">", #" "] rs o
                            indent x))))))
        (fn _ =>
          catch_errora
            (check_redundant_rules_ncr
              (equal_lab B3_ (equal_list equal_nat),
                show_lab B5_ (show_list show_nat))
              (ccompare_list ccompare_char, equal_list equal_char,
                mapping_impl_list, show_list show_char)
              r rs n)
            (fn x =>
              Inl (ia o (shows_prec_list show_char zero_nata
                           [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n",
                             #" ", #"c", #"h", #"e", #"c", #"k", #"i", #"n",
                             #"g", #" ", #"r", #"e", #"d", #"u", #"n", #"d",
                             #"a", #"n", #"t", #" ", #"r", #"u", #"l", #"e",
                             #"s", #" ", #"t", #"r", #"a", #"n", #"s", #"f",
                             #"o", #"r", #"m", #"a", #"t", #"i", #"o", #"n",
                             #" ", #"o", #"f", #" ", #"t", #"h", #"e", #" ",
                             #"T", #"R", #"S"] o
                          (shows_nl o
                            (shows_trs
                               (shows_prec_lab B5_ (show_list show_nat)
                                 zero_nata)
                               (shows_prec_list show_char zero_nata)
                               [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                                 #"s", #"y", #"s", #"t", #"e", #"m", #":"]
                               [#" ", #"-", #">", #" "] r o
                              indent x)))))));

fun check_conditional_ncr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j r
  (Unconditional_CNCR prf) =
  debug (ia [])
    [#"U", #"n", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a",
      #"l"]
    (bindb
      (catch_errora
        (catch_errora
          (forallM (fn x => (if null (snd x) then Inr () else Inl x)) r)
          (fn x => Inl (snd x)))
        (fn x =>
          Inl (shows_prec_list show_char zero_nata
                 [#"r", #"u", #"l", #"e", #" ", #"w", #"i", #"t", #"h", #" ",
                   #"n", #"o", #"n", #"-", #"e", #"m", #"p", #"t", #"y", #" ",
                   #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s"] o
                 shows_nl o
                shows_crule (shows_prec_lab B5_ (show_list show_nat) zero_nata)
                  (shows_prec_list show_char zero_nata) x)))
      (fn _ =>
        check_ncr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j (map fst r) prf))
  | check_conditional_ncr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j r
    (Transformation_CNCR (t, prf)) =
    debug (ia [])
      [#"C", #"R", #" ", #"P", #"r", #"e", #"s", #"e", #"r", #"v", #"i", #"n",
        #"g", #" ", #"T", #"r", #"a", #"n", #"s", #"f", #"o", #"r", #"m", #"a",
        #"t", #"i", #"o", #"n"]
      (bindb
        (check_ccr_trans (B2_, B3_, B4_, B5_)
          (equal_list equal_nat, key_list (equal_nat, key_nat),
            show_list show_nat)
          (finite_UNIV_list, cenum_list, ceq_list ceq_char,
            cproper_interval_list ccompare_char, equal_list equal_char,
            key_list (equal_char, key_char), mapping_impl_list, set_impl_list,
            show_list show_char)
          ia r t)
        (fn ra =>
          check_conditional_ncr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j ra
            prf))
  | check_conditional_ncr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j r
    (Non_Join_CNCR (s, t, u, ps, qs, prf)) =
    debug (ia [])
      [#"C", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a", #"l", #" ",
        #"N", #"o", #"n", #"-", #"J", #"o", #"i", #"n", #"a", #"b", #"i", #"l",
        #"i", #"t", #"y"]
      (catch_errora
        (check_conditional_non_cr (B2_, B3_, B4_, B5_)
          (card_UNIV_list, cenum_list, ceq_list ceq_char,
            cproper_interval_list ccompare_char,
            compare_order_list (compare_order_char, equal_char),
            equal_list equal_char, set_impl_list, show_list show_char)
          r s t u ps qs prf)
        (fn x =>
          Inl (ia o (shows_prec_list show_char zero_nata
                       [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e",
                         #"n", #" ", #"d", #"i", #"s", #"p", #"r", #"o", #"v",
                         #"i", #"n", #"g", #" ", #"C", #"R", #" ", #"o", #"f",
                         #" "] o
                      (shows_ctrs
                         (shows_prec_lab B5_ (show_list show_nat) zero_nata)
                         (shows_prec_list show_char zero_nata) r o
                        (shows_nl o indent x))))));

fun check_subsumptions_guided (A1_, A2_) (B1_, B2_, B3_, B4_) e [] = Inr ()
  | check_subsumptions_guided (A1_, A2_) (B1_, B2_, B3_, B4_) ea
    ((e, seq) :: convs) =
    bindb (catch_errora
            (check_conversiona (A1_, A2_) (B1_, B2_, B3_, B4_) ea seq (fst e)
              (snd e))
            (fn x =>
              Inl (shows_string
                     [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i",
                       #"n", #" ", #"c", #"o", #"n", #"v", #"e", #"r", #"s",
                       #"i", #"o", #"n", #" ", #"f", #"o", #"r", #" ", #"e",
                       #"q", #"u", #"a", #"t", #"i", #"o", #"n", #" "] o
                    (shows_rule (shows_prec A2_ zero_nata)
                       (shows_prec B4_ zero_nata) [#" ", #"=", #" "] e o
                      (shows_nl o x)))))
      (fn _ =>
        check_subsumptions_guided (A1_, A2_) (B1_, B2_, B3_, B4_) (e :: ea)
          convs);

fun check_convertible_instance (A1_, A2_) (B1_, B2_, B3_, B4_) eq e convs =
  bindb (catch_errora
          (existsM
            (fn c =>
              check (instance_rule A1_ B2_ (B1_, B2_, B3_) (fst c) eq)
                (shows_string
                   [#"n", #"o", #"t", #" ", #"a", #"n", #" ", #"i", #"n", #"s",
                     #"t", #"a", #"n", #"c", #"e", #" ", #"o", #"f", #" "] o
                  shows_rule (shows_prec A2_ zero_nata)
                    (shows_prec B4_ zero_nata) [#" ", #"=", #" "] eq))
            convs)
          (fn _ =>
            Inl (shows_prec_list show_char zero_nata
                  [#" ", #"n", #"o", #" ", #"i", #"n", #"s", #"t", #"a", #"n",
                    #"c", #"e", #" ", #"f", #"o", #"u", #"n", #"d"])))
    (fn _ => check_subsumptions_guided (A1_, A2_) (B1_, B2_, B3_, B4_) e convs);

fun check_subsumption_guided (A1_, A2_) (B1_, B2_, B3_, B4_) ea e convs =
  bindb (catch_errora
          (check_subseteq (equal_prod (equal_term A1_ B2_) (equal_term A1_ B2_))
            ea (map fst convs))
          (fn x =>
            Inl (shows_string
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"f", #"i", #"n", #"d", #" ", #"c", #"o", #"n", #"v", #"e",
                     #"r", #"s", #"i", #"o", #"n", #" ", #"f", #"o", #"r", #" ",
                     #"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #" "] o
                  shows_rule (shows_prec A2_ zero_nata)
                    (shows_prec B4_ zero_nata) [#" ", #"=", #" "] x)))
    (fn _ => check_subsumptions_guided (A1_, A2_) (B1_, B2_, B3_, B4_) e convs);

fun check_subsumption_NF (A1_, A2_) (B1_, B2_, B3_, B4_) e r =
  catch_errora
    (forallM
      (fn ea =>
        catch_errora
          (check_join_NF (A1_, A2_) (B1_, B2_, B3_, B4_) r (fst ea) (snd ea))
          (fn x =>
            Inl (shows_string
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"j", #"o", #"i", #"n", #" ", #"e", #"q", #"u", #"a", #"t",
                     #"i", #"o", #"n", #" "] o
                  (shows_rule (shows_prec A2_ zero_nata)
                     (shows_prec B4_ zero_nata) [#" ", #"=", #" "] ea o
                    (shows_nl o x)))))
      e)
    (fn x => Inl (snd x));

fun check_subsumption (A1_, A2_) (B1_, B2_, B3_, B4_) e r convs_o =
  (case convs_o
    of NONE => check_subsumption_NF (A1_, A2_) (B1_, B2_, B3_, B4_) e r
    | SOME a => check_subsumption_guided (A1_, A2_) (B1_, B2_, B3_, B4_) e r a);

fun check_completion_proof (B1_, B2_, B3_, B4_) a ia i j e r
  (SN_WCR_Eq (joins_i, prf, conv1, conv2)) =
  debug (ia []) [#"S", #"N", #"_", #"W", #"C", #"R", #"_", #"E", #"q"]
    let
      val tp = mkc i false [] r [];
    in
      bindb (catch_errora
              (check_trs_termination_proof (B1_, B2_, B3_, B4_) i j a
                (ia o shows_string [#".", #"1"]) tp prf)
              (fn x =>
                Inl (ia o (shows_string
                             [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                               #"b", #"e", #"l", #"o", #"w", #" ", #"s", #"t",
                               #"r", #"o", #"n", #"g", #" ", #"n", #"o", #"r",
                               #"m", #"a", #"l", #"i", #"z", #"a", #"t", #"i",
                               #"o", #"n", #" ", #"+", #" ", #"w", #"c", #"r"] o
                            (shows_nl o indent x)))))
        (fn _ =>
          bindb (catch_errora
                  (check_subsumption_guided
                    (equal_lab B2_ (equal_list equal_nat),
                      show_lab B4_ (show_list show_nat))
                    (ccompare_list ccompare_char, equal_list equal_char,
                      mapping_impl_list, show_list show_char)
                    r e conv1)
                  (fn x =>
                    Inl (ia o (shows_prec_list show_char zero_nata
                                 [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                   #" ", #"w", #"h", #"e", #"n", #" ", #"s",
                                   #"h", #"o", #"w", #"i", #"n", #"g", #" ",
                                   #"t", #"h", #"a", #"t", #" ", #"r", #"e",
                                   #"w", #"r", #"i", #"t", #"e", #" ", #"r",
                                   #"e", #"l", #"a", #"t", #"i", #"o", #"n",
                                   #" ", #"c", #"a", #"n", #" ", #"b", #"e",
                                   #" ", #"s", #"i", #"m", #"u", #"l", #"a",
                                   #"t", #"e", #"d", #" ", #"b", #"y", #" ",
                                   #"e", #"q", #"u", #"a", #"t", #"i", #"o",
                                   #"n", #"s"] o
                                (shows_nl o indent x)))))
            (fn _ =>
              bindb (catch_errora
                      (check_subsumption
                        (equal_lab B2_ (equal_list equal_nat),
                          show_lab B4_ (show_list show_nat))
                        (ccompare_list ccompare_char, equal_list equal_char,
                          mapping_impl_list, show_list show_char)
                        e r conv2)
                      (fn x =>
                        Inl (ia o (shows_prec_list show_char zero_nata
                                     [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                       #" ", #"w", #"h", #"e", #"n", #" ", #"s",
                                       #"h", #"o", #"w", #"i", #"n", #"g", #" ",
                                       #"t", #"h", #"a", #"t", #" ", #"e", #"q",
                                       #"u", #"a", #"t", #"i", #"o", #"n", #"s",
                                       #" ", #"c", #"a", #"n", #" ", #"b", #"e",
                                       #" ", #"s", #"i", #"m", #"u", #"l", #"a",
                                       #"t", #"e", #"d", #" ", #"b", #"y", #" ",
                                       #"r", #"e", #"w", #"r", #"i", #"t", #"e",
                                       #" ", #"s", #"y", #"s", #"t", #"e",
                                       #"m"] o
                                    (shows_nl o indent x)))))
                (fn _ =>
                  catch_errora
                    (check_critical_pairs
                      (equal_lab B2_ (equal_list equal_nat),
                        show_lab B4_ (show_list show_nat))
                      r (critical_pairs_impl
                          (equal_lab B2_ (equal_list equal_nat)) r r)
                      joins_i)
                    (fn x =>
                      Inl (ia o (shows_prec_list show_char zero_nata
                                   [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                     #" ", #"w", #"h", #"e", #"n", #" ", #"p",
                                     #"r", #"o", #"v", #"i", #"n", #"g", #" ",
                                     #"l", #"o", #"c", #"a", #"l", #" ", #"c",
                                     #"o", #"n", #"f", #"l", #"u", #"e", #"n",
                                     #"c", #"e", #" ", #"o", #"f", #" "] o
                                  (shows_nl o
                                    (shows_tp
                                       (shows_prec_lab B4_ (show_list show_nat)
 zero_nata)
                                       (shows_prec_list show_char zero_nata) i
                                       tp o
                                      (shows_nl o indent x)))))))))
    end;

fun check_equational_disproof (B1_, B2_, B3_, B4_) a ia i j e (Equation eq)
  (Completion_and_Normalization_Different (r, p)) =
  debug (ia [])
    [#"C", #"o", #"m", #"p", #"l", #"e", #"t", #"i", #"o", #"n", #"_", #"a",
      #"n", #"d", #"_", #"N", #"o", #"r", #"m", #"a", #"l", #"i", #"z", #"a",
      #"t", #"i", #"o", #"n"]
    (bindb (check_completion_proof (B1_, B2_, B3_, B4_) a ia i j e r p)
      (fn _ =>
        let
          val s = fst eq;
          val t = snd eq;
        in
          (case (compute_rstep_NF (equal_lab B2_ (equal_list equal_nat))
                   (ccompare_list ccompare_char, equal_list equal_char,
                     mapping_impl_list)
                   r s,
                  compute_rstep_NF (equal_lab B2_ (equal_list equal_nat))
                    (ccompare_list ccompare_char, equal_list equal_char,
                      mapping_impl_list)
                    r t)
            of (NONE, _) =>
              Inl (shows_string
                     [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e",
                       #"n", #" ", #"c", #"o", #"m", #"p", #"u", #"t", #"i",
                       #"n", #"g", #" ", #"n", #"o", #"r", #"m", #"a", #"l",
                       #" ", #"f", #"o", #"r", #"m", #"s", #" ", #"o", #"f",
                       #" "] o
                    (shows_term
                       (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                       (shows_prec_list show_char zero_nata) s o
                      (shows_string [#" ", #"a", #"n", #"d", #" "] o
                        shows_term
                          (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                          (shows_prec_list show_char zero_nata) t)))
            | (SOME _, NONE) =>
              Inl (shows_string
                     [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e",
                       #"n", #" ", #"c", #"o", #"m", #"p", #"u", #"t", #"i",
                       #"n", #"g", #" ", #"n", #"o", #"r", #"m", #"a", #"l",
                       #" ", #"f", #"o", #"r", #"m", #"s", #" ", #"o", #"f",
                       #" "] o
                    (shows_term
                       (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                       (shows_prec_list show_char zero_nata) s o
                      (shows_string [#" ", #"a", #"n", #"d", #" "] o
                        shows_term
                          (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                          (shows_prec_list show_char zero_nata) t)))
            | (SOME sa, SOME ta) =>
              (if not (equal_terma (equal_lab B2_ (equal_list equal_nat))
                        (equal_list equal_char) sa ta)
                then Inr ()
                else Inl (shows_term
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) s o
                           (shows_string [#" ", #"a", #"n", #"d", #" "] o
                             (shows_term
                                (shows_prec_lab B4_ (show_list show_nat)
                                  zero_nata)
                                (shows_prec_list show_char zero_nata) t o
                               (shows_string
                                  [#" ", #"h", #"a", #"v", #"e", #" ", #"s",
                                    #"a", #"m", #"e", #" ", #"n", #"o", #"r",
                                    #"m", #"a", #"l", #" ", #"f", #"o", #"r",
                                    #"m", #" "] o
                                 shows_term
                                   (shows_prec_lab B4_ (show_list show_nat)
                                     zero_nata)
                                   (shows_prec_list show_char zero_nata)
                                   sa))))))
        end))
  | check_equational_disproof (B1_, B2_, B3_, B4_) a ia i j e (Inequality eq)
    (Convertible_Instance convs) =
    debug (ia [])
      [#"C", #"o", #"n", #"v", #"e", #"r", #"t", #"i", #"b", #"l", #"e", #"_",
        #"I", #"n", #"s", #"t", #"a", #"n", #"c", #"e"]
      (check_convertible_instance
        (equal_lab B2_ (equal_list equal_nat),
          show_lab B4_ (show_list show_nat))
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list,
          show_list show_char)
        eq e convs)
  | check_equational_disproof (B1_, B2_, B3_, B4_) a ia i j e (Inequality v)
    (Completion_and_Normalization_Different (va, vb)) =
    Inl (shows_string
          [#"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
            #" ", #"d", #"i", #"s", #"p", #"r", #"o", #"o", #"f"])
  | check_equational_disproof (B1_, B2_, B3_, B4_) a ia i j e (Equation va)
    (Convertible_Instance v) =
    Inl (shows_string
          [#"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
            #" ", #"d", #"i", #"s", #"p", #"r", #"o", #"o", #"f"]);

fun match_crule A_ (B1_, B2_, B3_) rho_1 rho_2 =
  bind (zip_option
         (fst (fst rho_2) ::
           snd (fst rho_2) :: map fst (snd rho_2) @ map snd (snd rho_2))
         (fst (fst rho_1) ::
           snd (fst rho_1) :: map fst (snd rho_1) @ map snd (snd rho_1)))
    (match_list (B1_, B2_, B3_) A_ B2_ Var);

fun check_overlapa (A1_, A2_, A3_, A4_, A5_) (B1_, B2_) xvar yvar
  check_infeasible r rho_1 rho_2 p =
  catch_errora
    (case mgu_var_disjoint_generic A2_ B1_ xvar yvar
            (subt_at (fst (fst rho_1)) p) (fst (fst rho_2))
      of NONE => Inr ()
      | SOME (sigma_1, sigma_2) =>
        catch_errora
          (choice
            [check (equal_posa p Empty andalso
                     equal_terma B1_ A2_
                       (subst_apply_term (snd (fst rho_1)) sigma_1)
                       (subst_apply_term (snd (fst rho_2)) sigma_2))
               (shows_prec_list show_char zero_nata
                 [#"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"t",
                   #"r", #"i", #"v", #"i", #"a", #"l", #" ", #"r", #"o", #"o",
                   #"t", #"-", #"o", #"v", #"e", #"r", #"l", #"a", #"p"]),
              check (equal_posa p Empty andalso
                      (not (is_none
                             (match_crule B1_ (A1_, A2_, A3_) rho_1
                               rho_2)) andalso
                        not (is_none
                              (match_crule B1_ (A1_, A2_, A3_) rho_2 rho_1))))
                (shows_prec_list show_char zero_nata
                  [#"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"r",
                    #"o", #"o", #"t", #"-", #"o", #"v", #"e", #"r", #"l", #"a",
                    #"p", #" ", #"o", #"f", #" ", #"v", #"a", #"r", #"i", #"a",
                    #"n", #"t", #"s", #" ", #"o", #"f", #" ", #"t", #"h", #"e",
                    #" ", #"s", #"a", #"m", #"e", #" ", #"r", #"u", #"l",
                    #"e"]),
              catch_errora
                (check_infeasible r (subst_list sigma_1 (snd rho_1))
                  (subst_list sigma_2 (snd rho_2)))
                (fn x =>
                  Inl (shows_prec_list show_char zero_nata
                         [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                           #" ", #"b", #"e", #" ", #"s", #"h", #"o", #"w", #"n",
                           #" ", #"t", #"o", #" ", #"b", #"e", #" ", #"i", #"n",
                           #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e"] o
                         shows_nl o
                        x))])
          (fn x => Inl (shows_sep id shows_nl x)))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata [#"t", #"h", #"e", #" "] o
             shows_coverlap B2_ A5_ B2_ A5_ show_pos rho_1 rho_2 p o
             shows_nl o
            x));

fun check_ao_infeasiblea (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r cs_1 cs_2
  (AO_Infeasibility_Proof p) =
  check_infeasibleb (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r (cs_1 @ cs_2) p
  | check_ao_infeasiblea (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r cs_1 cs_2
    (AO_Lhss_Equal (s, t, u, p)) =
    bindb (check
            (membera (equal_prod (equal_term A6_ B5_) (equal_term A6_ B5_)) cs_1
              (s, t))
            (shows_eq (shows_prec A9_ zero_nata) (shows_prec B9_ zero_nata)
               (s, t) o
               shows_prec_list show_char zero_nata
                 [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"n",
                   #" ", #"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #" ",
                   #"i", #"n", #" "] o
              shows_conditions (shows_prec A9_ zero_nata)
                (shows_prec B9_ zero_nata) cs_1))
      (fn _ =>
        bindb (check
                (membera (equal_prod (equal_term A6_ B5_) (equal_term A6_ B5_))
                  cs_2 (s, u))
                (shows_eq (shows_prec A9_ zero_nata) (shows_prec B9_ zero_nata)
                   (s, u) o
                   shows_prec_list show_char zero_nata
                     [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                       #"n", #" ", #"e", #"q", #"u", #"a", #"t", #"i", #"o",
                       #"n", #" ", #"i", #"n", #" "] o
                  shows_conditions (shows_prec A9_ zero_nata)
                    (shows_prec B9_ zero_nata) cs_2))
          (fn _ =>
            check_nonjoinable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
              (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) (map fst r) t u p));

fun check_ao_infeasible (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) css r cs_1 cs_2 =
  catch_errora
    (existsM
      (fn (cs_1a, (cs_2a, p)) =>
        let
          val cs = cs_1 @ cs_2;
          val csa = cs_1a @ cs_2a;
        in
          bindb (check
                  (equal_nata (size_list cs_1a) (size_list cs_1) andalso
                    equal_nata (size_list cs_2a) (size_list cs_2))
                  (shows_prec_list show_char zero_nata
                    [#"l", #"e", #"n", #"g", #"t", #"h", #"s", #" ", #"d", #"i",
                      #"f", #"f", #"e", #"r"]))
            (fn _ =>
              bindb (check
                      (not (is_none
                             (match_rules A6_
                               (ccompare_cproper_interval B4_, B5_, B7_) csa
                               cs)) andalso
                        not (is_none
                              (match_rules A6_
                                (ccompare_cproper_interval B4_, B5_, B7_) cs
                                csa)))
                      id)
                (fn _ =>
                  check_ao_infeasiblea
                    (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
                    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r cs_1a cs_2a
                    p))
        end)
      css)
    (fn x => Inl (shows_sep id shows_nl x));

fun check_almost_orthogonal_modulo_infeasibilitya
  (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_) css r =
  bindb (check_left_linear_trs A9_
          (ceq_list ceq_char, ccompare_list ccompare_char, set_impl_list,
            show_list show_char)
          (map fst r))
    (fn _ =>
      catch_errora
        (forallM
          (fn rho_1 =>
            let
              val l_1 = fst (fst rho_1);
            in
              catch_errora
                (forallM
                  (fn rho_2 =>
                    catch_errora
                      (forallM
                        (check_overlapa
                          (ccompare_list ccompare_char, equal_list equal_char,
                            mapping_impl_list, infinite_list,
                            show_list show_char)
                          (A6_, A9_) (fn a => #"x" :: a) (fn a => #"y" :: a)
                          (check_ao_infeasible
                            (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
                            (finite_UNIV_list, cenum_list, ceq_list ceq_char,
                              cproper_interval_list ccompare_char,
                              equal_list equal_char,
                              key_list (equal_char, key_char),
                              mapping_impl_list, set_impl_list,
                              show_list show_char)
                            css)
                          r rho_1 rho_2)
                        (funposs_list l_1))
                      (fn x => Inl (snd x)))
                  r)
                (fn x => Inl (snd x))
            end)
          r)
        (fn x => Inl (snd x)));

fun x_vars (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) rho i =
  sup_seta (B3_, ccompare_cproper_interval B4_)
    (vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) (fst (fst rho)))
    (sup_setb (B1_, B2_, B3_, B4_, B7_)
      (image (ceq_term A2_ B6_, ccompare_term A1_ B5_)
        (ceq_set (B2_, B3_, ccompare_cproper_interval B4_),
          ccompare_set (B1_, B3_, B4_, B7_), set_impl_set)
        (vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_))
        (image
          (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_),
            ccompare_prod (ccompare_term A1_ B5_) (ccompare_term A1_ B5_))
          (ceq_term A2_ B6_, ccompare_term A1_ B5_, set_impl_term) snd
          (set (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_),
                 ccompare_prod (ccompare_term A1_ B5_) (ccompare_term A1_ B5_),
                 set_impl_prod set_impl_term set_impl_term)
            (take i (snd rho))))));

fun extended_properly_oriented (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) r
  = ball (ceq_prod (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_))
            (ceq_list (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_))),
           ccompare_prod
             (ccompare_prod (ccompare_term A1_ B5_) (ccompare_term A1_ B5_))
             (ccompare_list
               (ccompare_prod (ccompare_term A1_ B5_) (ccompare_term A1_ B5_))))
      r (fn rho =>
          less_eq_set (B2_, B3_, ccompare_cproper_interval B4_)
            (vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
              (snd (fst rho)))
            (vars_term (A1_, A2_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
              (fst (fst rho))) orelse
            not (all_interval_nat
                  (not o
                    (fn m =>
                      all_interval_nat
                        (fn i =>
                          less_eq_set (B2_, B3_, ccompare_cproper_interval B4_)
                            (vars_term (A1_, A2_)
                              (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
                              (fst (nth (snd rho) i)))
                            (x_vars (A1_, A2_)
                              (B1_, B2_, B3_, B4_, B5_, B6_, B7_) rho i))
                        zero_nata m andalso
                        all_interval_nat
                          (fn i =>
                            less_eq_set
                              (B2_, B3_, ccompare_cproper_interval B4_)
                              (inf_seta (B3_, ccompare_cproper_interval B4_)
                                (vars_term (A1_, A2_)
                                  (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
                                  (snd (fst rho)))
                                (vars_rule (A1_, A2_)
                                  (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
                                  (nth (snd rho) i)))
                              (x_vars (A1_, A2_)
                                (B1_, B2_, B3_, B4_, B5_, B6_, B7_) rho m))
                          m (size_list (snd rho))))
                  zero_nata (suc (size_list (snd rho)))));

fun check_extended_properly_oriented (A1_, A2_, A3_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r =
  check (extended_properly_oriented (A1_, A2_)
          (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
          (set (ceq_prod (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_))
                  (ceq_list (ceq_prod (ceq_term A2_ B6_) (ceq_term A2_ B6_))),
                 ccompare_prod
                   (ccompare_prod (ccompare_term A1_ B5_)
                     (ccompare_term A1_ B5_))
                   (ccompare_list
                     (ccompare_prod (ccompare_term A1_ B5_)
                       (ccompare_term A1_ B5_))),
                 set_impl_prod (set_impl_prod set_impl_term set_impl_term)
                   set_impl_list)
            r))
    (shows_prec_list show_char zero_nata
       [#"t", #"h", #"e", #" ", #"g", #"i", #"v", #"e", #"n", #" ", #"C", #"T",
         #"R", #"S", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"e", #"x",
         #"t", #"e", #"n", #"d", #"e", #"d", #" ", #"p", #"r", #"o", #"p", #"e",
         #"r", #"l", #"y", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"e",
         #"d"] o
      shows_nl);

fun funas_crule (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_) rho =
  sup_seta
    (ceq_prod A3_ ceq_nat,
      ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat)
    (funas_rule (A3_, ccompare_cproper_interval A4_, A7_) (fst rho))
    (funas_trs (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_)
      (set (ceq_prod (ceq_term A6_ B2_) (ceq_term A6_ B2_),
             ccompare_prod (ccompare_term A5_ B1_) (ccompare_term A5_ B1_),
             set_impl_prod set_impl_term set_impl_term)
        (snd rho)));

fun funas_ctrs (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_) r =
  sup_setb
    (finite_UNIV_prod A1_ finite_UNIV_nat, cenum_prod A2_ cenum_nat,
      ceq_prod A3_ ceq_nat, cproper_interval_prod A4_ cproper_interval_nat,
      set_impl_prod A7_ set_impl_nat)
    (image
      (ceq_prod (ceq_prod (ceq_term A6_ B2_) (ceq_term A6_ B2_))
         (ceq_list (ceq_prod (ceq_term A6_ B2_) (ceq_term A6_ B2_))),
        ccompare_prod
          (ccompare_prod (ccompare_term A5_ B1_) (ccompare_term A5_ B1_))
          (ccompare_list
            (ccompare_prod (ccompare_term A5_ B1_) (ccompare_term A5_ B1_))))
      (ceq_set
         (cenum_prod A2_ cenum_nat, ceq_prod A3_ ceq_nat,
           ccompare_cproper_interval
             (cproper_interval_prod A4_ cproper_interval_nat)),
        ccompare_set
          (finite_UNIV_prod A1_ finite_UNIV_nat, ceq_prod A3_ ceq_nat,
            cproper_interval_prod A4_ cproper_interval_nat,
            set_impl_prod A7_ set_impl_nat),
        set_impl_set)
      (funas_crule (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_)) r);

fun check_constructor_term (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_)
  (B1_, B2_, B3_) s r =
  check (less_eq_set
          (cenum_prod A2_ cenum_nat, ceq_prod A3_ ceq_nat,
            ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat)
          (funas_term (A3_, ccompare_cproper_interval A4_, A7_) s)
          (minus_set
            (ceq_prod A3_ ceq_nat,
              ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat)
            (funas_ctrs (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_)
              (set (ceq_prod (ceq_prod (ceq_term A6_ B2_) (ceq_term A6_ B2_))
                      (ceq_list
                        (ceq_prod (ceq_term A6_ B2_) (ceq_term A6_ B2_))),
                     ccompare_prod
                       (ccompare_prod (ccompare_term A5_ B1_)
                         (ccompare_term A5_ B1_))
                       (ccompare_list
                         (ccompare_prod (ccompare_term A5_ B1_)
                           (ccompare_term A5_ B1_))),
                     set_impl_prod (set_impl_prod set_impl_term set_impl_term)
                       set_impl_list)
                r))
            (set (ceq_prod A3_ ceq_nat,
                   ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat,
                   set_impl_prod A7_ set_impl_nat)
              (defined_list (map fst r)))))
    (shows_prec_list show_char zero_nata
       [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #" "] o
       shows_term (shows_prec A8_ zero_nata) (shows_prec B3_ zero_nata) s o
       shows_prec_list show_char zero_nata
         [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"c",
           #"o", #"n", #"s", #"t", #"r", #"u", #"c", #"t", #"o", #"r", #" ",
           #"t", #"e", #"r", #"m"] o
      shows_nl);

fun check_Ru_NF (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) s r =
  check (is_NF_trs (A1_, A2_) (B1_, B2_, B3_) (map fst r) s)
    (shows_prec_list show_char zero_nata
       [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #" "] o
       shows_term (shows_prec A3_ zero_nata) (shows_prec B4_ zero_nata) s o
       shows_prec_list show_char zero_nata
         [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"n", #" ",
           #"R", #"u", #" ", #"n", #"o", #"r", #"m", #"a", #"l", #" ", #"f",
           #"o", #"r", #"m"] o
      shows_nl);

fun check_linear_term A_ (B1_, B2_, B3_, B4_) s =
  check (linear_term (B1_, B2_, B3_) s)
    (shows_prec_list show_char zero_nata
       [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #" "] o
       shows_term (shows_prec A_ zero_nata) (shows_prec B4_ zero_nata) s o
       shows_prec_list show_char zero_nata
         [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"l", #"i", #"n",
           #"e", #"a", #"r"] o
      shows_nl);

fun check_ground_term A_ B_ s =
  check (ground s)
    (shows_prec_list show_char zero_nata
       [#"t", #"h", #"e", #" ", #"t", #"e", #"r", #"m", #" "] o
       shows_term (shows_prec A_ zero_nata) (shows_prec B_ zero_nata) s o
       shows_prec_list show_char zero_nata
         [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #" ", #"g",
           #"r", #"o", #"u", #"n", #"d", #" ", #"t", #"e", #"r", #"m"] o
      shows_nl);

fun check_right_stable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_) r =
  catch_errora
    (catch_errora
      (forallM
        (fn ra =>
          catch_errora
            (forallM
              (fn i =>
                let
                  val t_i = snd (nth (snd ra) i);
                in
                  bindb (catch_errora
                          (check_disjoint B4_
                            (vars_term_list (fst (fst ra)) @
                              maps (fn (s, _) => vars_term_list s)
                                (take (suc i) (snd ra)) @
                                maps (fn (_, a) => vars_term_list a)
                                  (take i (snd ra)))
                            (vars_term_list t_i))
                          (fn x =>
                            Inl (shows_prec_list show_char zero_nata
                                   [#"v", #"a", #"r", #"i", #"a", #"b", #"l",
                                     #"e", #" "] o
                                   shows_prec B7_ zero_nata x o
                                   shows_prec_list show_char zero_nata
                                     [#" ", #"i", #"n", #" ", #"r", #"h", #"s",
                                       #" ", #"o", #"f", #" ", #"c", #"o", #"n",
                                       #"d", #"i", #"t", #"i", #"o", #"n",
                                       #" "] o
                                   shows_prec_nat zero_nata i o
                                   shows_prec_list show_char zero_nata
                                     [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
                                       #" ", #"f", #"r", #"e", #"s", #"h"] o
                                  shows_nl)))
                    (fn _ =>
                      catch_errora
                        (choice
                          [bindb (check_linear_term A8_ (B1_, B2_, B6_, B7_)
                                   t_i)
                             (fn _ =>
                               check_constructor_term
                                 (A1_, A2_, A3_, A4_,
                                   (compare_compare_order o compare_order_key)
                                     A6_,
                                   A5_, A7_, A8_)
                                 (B3_, B4_, B7_) t_i r),
                            bindb (check_ground_term A8_ B7_ t_i)
                              (fn _ =>
                                check_Ru_NF (A5_, A6_, A8_) (B2_, B4_, B5_, B7_)
                                  t_i r)])
                        (fn x => Inl (shows_sep id shows_nl x)))
                end)
              (upt zero_nata (size_list (snd ra))))
            (fn x => Inl (snd x)))
        r)
      (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"t", #"h", #"e", #" ", #"C", #"T", #"R", #"S", #" ", #"i", #"s",
               #" ", #"n", #"o", #"t", #" ", #"r", #"i", #"g", #"h", #"t", #" ",
               #"s", #"t", #"a", #"b", #"l", #"e"] o
             shows_nl o
            x));

fun check_level_confluence_modulo_infeasibilitya
  (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_) css r =
  bindb (check_varcond_no_Var_lhs A9_ (show_list show_char) (map fst r))
    (fn _ =>
      bindb (check_type3 A9_ (equal_list equal_char, show_list show_char) r)
        (fn _ =>
          bindb (check_extended_properly_oriented
                  ((compare_compare_order o compare_order_key) A7_, A6_, A9_)
                  (finite_UNIV_list, cenum_list, ceq_list ceq_char,
                    cproper_interval_list ccompare_char,
                    compare_list compare_char, equal_list equal_char,
                    set_impl_list, show_list show_char)
                  r)
            (fn _ =>
              bindb (check_right_stable (A1_, A2_, A3_, A4_, A6_, A7_, A8_, A9_)
                      (ceq_list ceq_char, ccompare_list ccompare_char,
                        compare_list compare_char, equal_list equal_char,
                        mapping_impl_list, set_impl_list, show_list show_char)
                      r)
                (fn _ =>
                  check_almost_orthogonal_modulo_infeasibilitya
                    (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_) css r))));

fun trancl_of_list A_ xs =
  maps (fn x => map (fn a => (x, a)) (trancl_list_impl A_ xs [x])) (map fst xs);

fun check_infeasiblea (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) css r cs_1 cs_2 =
  catch_errora
    (existsM
      (fn (cs, p) =>
        let
          val csa = cs_1 @ cs_2;
        in
          bindb (check
                  (not (is_none
                         (match_rules A6_
                           (ccompare_cproper_interval B4_, B5_, B7_) cs
                           csa)) andalso
                    not (is_none
                          (match_rules A6_
                            (ccompare_cproper_interval B4_, B5_, B7_) csa cs)))
                  id)
            (fn _ =>
              check_infeasibleb (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
                (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_, B9_) r
                (trancl_of_list (equal_term A6_ B5_) cs) p)
        end)
      css)
    (fn x => Inl (shows_sep id shows_nl x));

fun check_almost_orthogonal_modulo_infeasibility
  (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_) css r =
  bindb (check_left_linear_trs A9_
          (ceq_list ceq_char, ccompare_list ccompare_char, set_impl_list,
            show_list show_char)
          (map fst r))
    (fn _ =>
      catch_errora
        (forallM
          (fn rho_1 =>
            let
              val l_1 = fst (fst rho_1);
            in
              catch_errora
                (forallM
                  (fn rho_2 =>
                    catch_errora
                      (forallM
                        (check_overlapa
                          (ccompare_list ccompare_char, equal_list equal_char,
                            mapping_impl_list, infinite_list,
                            show_list show_char)
                          (A6_, A9_) (fn a => #"x" :: a) (fn a => #"y" :: a)
                          (check_infeasiblea
                            (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_)
                            (finite_UNIV_list, cenum_list, ceq_list ceq_char,
                              cproper_interval_list ccompare_char,
                              equal_list equal_char,
                              key_list (equal_char, key_char),
                              mapping_impl_list, set_impl_list,
                              show_list show_char)
                            css)
                          r rho_1 rho_2)
                        (funposs_list l_1))
                      (fn x => Inl (snd x)))
                  r)
                (fn x => Inl (snd x))
            end)
          r)
        (fn x => Inl (snd x)));

fun check_level_confluence_modulo_infeasibility
  (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_) css r =
  bindb (check_varcond_no_Var_lhs A9_ (show_list show_char) (map fst r))
    (fn _ =>
      bindb (check_type3 A9_ (equal_list equal_char, show_list show_char) r)
        (fn _ =>
          bindb (check_extended_properly_oriented
                  ((compare_compare_order o compare_order_key) A7_, A6_, A9_)
                  (finite_UNIV_list, cenum_list, ceq_list ceq_char,
                    cproper_interval_list ccompare_char,
                    compare_list compare_char, equal_list equal_char,
                    set_impl_list, show_list show_char)
                  r)
            (fn _ =>
              bindb (check_right_stable (A1_, A2_, A3_, A4_, A6_, A7_, A8_, A9_)
                      (ceq_list ceq_char, ccompare_list ccompare_char,
                        compare_list compare_char, equal_list equal_char,
                        mapping_impl_list, set_impl_list, show_list show_char)
                      r)
                (fn _ =>
                  check_almost_orthogonal_modulo_infeasibility
                    (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_, A9_) css r))));

fun check_almost_orthogonal (A1_, A2_) r =
  bindb (check_left_linear_trs A2_
          (ceq_list ceq_char, ccompare_list ccompare_char, set_impl_list,
            show_list show_char)
          (map fst r))
    (fn _ =>
      catch_errora
        (forallM
          (fn rho_1 =>
            let
              val l_1 = fst (fst rho_1);
            in
              catch_errora
                (forallM
                  (fn rho_2 =>
                    catch_errora
                      (forallM
                        (check_overlapa
                          (ccompare_list ccompare_char, equal_list equal_char,
                            mapping_impl_list, infinite_list,
                            show_list show_char)
                          (A1_, A2_) (fn a => #"x" :: a) (fn a => #"y" :: a)
                          (fn _ => fn _ => fn _ =>
                            Inl (shows_string
                                  [#"i", #"n", #"f", #"e", #"a", #"s", #"i",
                                    #"b", #"i", #"l", #"i", #"t", #"y", #" ",
                                    #"c", #"h", #"e", #"c", #"k", #" ", #"n",
                                    #"o", #"t", #" ", #"s", #"u", #"p", #"p",
                                    #"o", #"r", #"t", #"e", #"d"]))
                          r rho_1 rho_2)
                        (funposs_list l_1))
                      (fn x => Inl (snd x)))
                  r)
                (fn x => Inl (snd x))
            end)
          r)
        (fn x => Inl (snd x)));

fun check_level_confluence (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_) r =
  bindb (check_varcond_no_Var_lhs A8_ (show_list show_char) (map fst r))
    (fn _ =>
      bindb (check_type3 A8_ (equal_list equal_char, show_list show_char) r)
        (fn _ =>
          bindb (check_extended_properly_oriented
                  ((compare_compare_order o compare_order_key) A6_, A5_, A8_)
                  (finite_UNIV_list, cenum_list, ceq_list ceq_char,
                    cproper_interval_list ccompare_char,
                    compare_list compare_char, equal_list equal_char,
                    set_impl_list, show_list show_char)
                  r)
            (fn _ =>
              bindb (check_right_stable (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_)
                      (ceq_list ceq_char, ccompare_list ccompare_char,
                        compare_list compare_char, equal_list equal_char,
                        mapping_impl_list, set_impl_list, show_list show_char)
                      r)
                (fn _ => check_almost_orthogonal (A5_, A8_) r))));

fun funs_crule_list r = add_funs_rule (fst r) (funs_trs_list (snd r));

fun funs_ctrs_list trs = maps funs_crule_list trs;

fun check_source_preserving A_ (B1_, B2_) crs zv =
  catch_errora
    (forallM
      (fn cr =>
        catch_errora
          (forallM
            (fn i =>
              catch_errora
                (catch_errora
                  (check_subseteq B1_ (vars_term_list (fst (fst cr))) (zv cr i))
                  (fn _ =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"S", #"o", #"m", #"e", #" ", #"v", #"a", #"r",
                             #"i", #"a", #"b", #"l", #"e", #" ", #"i", #"n",
                             #" ", #"l", #"h", #"s", #" ", #"d", #"o", #"e",
                             #"s", #" ", #"n", #"o", #"t", #" ", #"o", #"c",
                             #"c", #"u", #"r", #" ", #"i", #"n", #" ", #"Z",
                             #"_"] o
                          (shows_prec_nat zero_nata i o
                            shows_prec_list show_char zero_nata
                              [#".", #" ", #"\n"]))))
                (fn x =>
                  Inl (shows_string
                         [#"T", #"h", #"e", #" ", #"u", #"n", #"r", #"a", #"v",
                           #"e", #"l", #"i", #"n", #"g", #" ", #"i", #"s", #" ",
                           #"n", #"o", #"t", #" ", #"s", #"o", #"u", #"r", #"c",
                           #"e", #" ", #"p", #"r", #"e", #"s", #"e", #"r", #"v",
                           #"i", #"n", #"g", #" ", #"f", #"o", #"r", #" ", #"r",
                           #"u", #"l", #"e", #" "] o
                        (shows_crule (shows_prec A_ zero_nata)
                           (shows_prec B2_ zero_nata) cr o
                          (shows_nl o x)))))
            (upt zero_nata (size_list (snd cr))))
          (fn x => Inl (snd x)))
      crs)
    (fn x => Inl (snd x));

fun y_impl cr i =
  vars_term_list (snd (fst cr)) @
    vars_term_list (snd (nth (snd cr) i)) @
      vars_trs_list (drop (suc i) (snd cr));

fun check_Z_vars A_ (B1_, B2_) crs z =
  catch_errora
    (catch_errora
      (forallM
        (fn cr =>
          catch_errora
            (forallM
              (fn i =>
                catch_errora
                  (bindb
                    (catch_errora
                      (check_subseteq B1_
                        (list_inter B1_ (x_impl cr i) (y_impl cr i)) (z cr i))
                      (fn x =>
                        Inl (shows_string
                               [#"V", #"a", #"r", #"i", #"a", #"b", #"l", #"e",
                                 #" "] o
                              (shows_prec B2_ zero_nata x o
                                (shows_string
                                   [#" ", #"d", #"o", #"e", #"s", #" ", #"n",
                                     #"o", #"t", #" ", #"o", #"c", #"c", #"u",
                                     #"r", #" ", #"i", #"n", #" ", #"v", #"a",
                                     #"r", #"i", #"a", #"b", #"l", #"e", #" ",
                                     #"l", #"i", #"s", #"t", #" ", #"o", #"f",
                                     #" "] o
                                  (shows_prec_nat zero_nata (suc i) o
                                    (shows_string
                                       [#".", #" ", #"U", #"-", #"s", #"y",
 #"m", #"b", #"o", #"l"] o
                                      shows_nl)))))))
                    (fn _ =>
                      check (distinct B1_ (z cr i))
                        (shows_string
                           [#" ", #"v", #"a", #"r", #"i", #"a", #"b", #"l",
                             #"e", #"s", #" ", #"i", #"n", #" ", #"a", #"d",
                             #"d", #"i", #"t", #"i", #"o", #"n", #"a", #"l",
                             #" ", #"a", #"r", #"g", #"u", #"m", #"e", #"n",
                             #"t", #"s", #" ", #"o", #"f", #" ", #"U", #"-",
                             #"s", #"y", #"m", #"b", #"o", #"l", #"s", #" ",
                             #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ",
                             #"d", #"i", #"s", #"t", #"i", #"n", #"c", #"t",
                             #".", #" "] o
                          shows_nl)))
                  (fn x =>
                    Inl (shows_string
                           [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o",
                             #"n", #"s", #" ", #"f", #"o", #"r", #" ", #"v",
                             #"a", #"r", #"i", #"a", #"b", #"l", #"e", #"-",
                             #"l", #"i", #"s", #"t", #"s", #" ", #"i", #"n",
                             #" ", #"U", #"-", #"s", #"y", #"m", #"b", #"o",
                             #"l", #"s", #" ", #"f", #"o", #"r", #" "] o
                          (shows_crule (shows_prec A_ zero_nata)
                             (shows_prec B2_ zero_nata) cr o
                            (shows_string
                               [#" ", #"a", #"r", #"e", #" ", #"v", #"i", #"o",
                                 #"l", #"a", #"t", #"e", #"d", #"."] o
                              (shows_nl o x))))))
              (upt zero_nata (size_list (snd cr))))
            (fn x => Inl (snd x)))
        crs)
      (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_string
             [#"T", #"h", #"e", #" ", #"C", #"T", #"R", #"S", #" ", #"d", #"o",
               #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"f", #"u", #"l", #"f",
               #"i", #"l", #"l", #" ", #"t", #"h", #"e", #" ", #"c", #"o", #"n",
               #"d", #"i", #"t", #"i", #"o", #"n", #" ", #"o", #"n", #" ", #"Z",
               #" ", #"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #"s", #".",
               #" "] o
            (shows_nl o x)));

fun check_U_cond (A1_, A2_) (B1_, B2_) u crs f z =
  catch_errora
    (catch_errora
      (forallM
        (fn cr =>
          catch_errora
            (forallM
              (fn i =>
                (case u cr i
                  of Hole =>
                    Inl (shows_prec_list show_char zero_nata
                          [#" ", #"U", #"n", #"e", #"x", #"p", #"e", #"c", #"t",
                            #"e", #"d", #" ", #"e", #"m", #"p", #"t", #"y",
                            #" ", #"c", #"o", #"n", #"t", #"e", #"x", #"t",
                            #"."])
                  | More (fa, [], Hole, aft) =>
                    catch_errora
                      (bindb
                        (catch_errora (check_disjoint A1_ [fa] f)
                          (fn _ =>
                            Inl (shows_string
                                   [#"T", #"h", #"e", #" ", #"f", #"u", #"n",
                                     #"c", #"t", #"i", #"o", #"n", #" ", #"s",
                                     #"y", #"m", #"b", #"o", #"l", #" "] o
                                  (shows_string
                                     (shows_prec A2_ zero_nata fa []) o
                                    (shows_string
                                       [#" ", #"i", #"s", #" ", #"n", #"o",
 #"t", #" ", #"f", #"r", #"e", #"s", #"h", #".", #" "] o
                                      shows_nl)))))
                        (fn _ =>
                          bindb (check
                                  (equal_lista (equal_term A1_ B1_) aft
                                    (map Var (z cr i)))
                                  (shows_prec_list show_char zero_nata
                                    [#" ", #"U", #" ", #"d", #"o", #"e", #"s",
                                      #" ", #"n", #"o", #"t", #" ", #"m", #"a",
                                      #"p", #" ", #"t", #"o", #" ", #"Z", #" ",
                                      #"v", #"a", #"r", #"s", #" "]))
                            (fn _ =>
                              check_f (A1_, A2_) (B1_, B2_) cr i fa crs u)))
                      (fn x =>
                        Inl (shows_string
                               [#"C", #"o", #"n", #"d", #"i", #"t", #"i", #"o",
                                 #"n", #"s", #" ", #"f", #"o", #"r", #" "] o
                              (shows_crule (shows_prec A2_ zero_nata)
                                 (shows_prec B2_ zero_nata) cr o
                                (shows_string [#" ", #"a", #"t", #" ", #" "] o
                                  (shows_prec_nat zero_nata i o
                                    (shows_string
                                       [#" ", #"a", #"r", #"e", #" ", #"v",
 #"i", #"o", #"l", #"a", #"t", #"e", #"d", #"."] o
                                      (shows_nl o x)))))))
                  | More (_, [], More (_, _, _, _), _) =>
                    Inl (shows_prec_list show_char zero_nata
                          [#" ", #"U", #"n", #"e", #"x", #"p", #"e", #"c", #"t",
                            #"e", #"d", #" ", #"e", #"m", #"p", #"t", #"y",
                            #" ", #"c", #"o", #"n", #"t", #"e", #"x", #"t",
                            #"."])
                  | More (_, _ :: _, _, _) =>
                    Inl (shows_prec_list show_char zero_nata
                          [#" ", #"U", #"n", #"e", #"x", #"p", #"e", #"c", #"t",
                            #"e", #"d", #" ", #"e", #"m", #"p", #"t", #"y",
                            #" ", #"c", #"o", #"n", #"t", #"e", #"x", #"t",
                            #"."])))
              (upt zero_nata (size_list (snd cr))))
            (fn x => Inl (snd x)))
        crs)
      (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_string
             [#"T", #"h", #"e", #" ", #"C", #"T", #"R", #"S", #" ", #"d", #"o",
               #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"f", #"u", #"l", #"f",
               #"i", #"l", #"l", #" ", #"t", #"h", #"e", #" ", #"c", #"o", #"n",
               #"d", #"i", #"t", #"i", #"o", #"n", #" ", #"o", #"n", #" ", #"t",
               #"h", #"e", #" ", #"U", #" ", #"s", #"y", #"m", #"b", #"o", #"l",
               #"s", #"."] o
            (shows_nl o x)));

fun create_Umap_cr cr r =
  (case r of [] => NONE
    | _ :: rr =>
      mapMa (fn (a, b) =>
              let
                val (l, _) = a;
              in
                (fn i =>
                  (case l of Var _ => NONE | Fun (_, []) => NONE
                    | Fun (u, _ :: _) => SOME (u, (cr, i))))
              end
                b)
        (zip rr (upt zero_nata (size_list rr))));

fun create_Umap A_ c_rs =
  (case mapMa (fn (a, b) => create_Umap_cr a b) c_rs of NONE => (fn _ => NONE)
    | SOME u => map_of A_ (concat u));

fun create_zs r =
  (case r of [] => NONE
    | _ :: rr =>
      bind (mapMa
             (fn a =>
               (case a of (Var _, _) => NONE | (Fun (_, []), _) => NONE
                 | (Fun (_, _ :: ts), _) => SOME (map the_Var ts)))
             rr)
        (fn cs =>
          SOME (fn i => (if less_nat i (size_list cs) then nth cs i else []))));

fun create_Z A_ B_ c_rs =
  bind (mapMa (fn (cr, rs) => bind (create_zs rs) (fn zs => SOME (cr, zs)))
         c_rs)
    (fn cr_zs =>
      let
        val mc =
          map_of
            (equal_prod (equal_prod (equal_term A_ B_) (equal_term A_ B_))
              (equal_list (equal_prod (equal_term A_ B_) (equal_term A_ B_))))
            cr_zs;
      in
        SOME (fn cr => (case mc cr of NONE => (fn _ => []) | SOME zs => zs))
      end);

fun check_sp_unraveling (A1_, A2_) (B1_, B2_, B3_, B4_, B5_) c_rs ctrs =
  catch_errora
    (bindb
      (catch_errora
        (check_same_set
          (equal_prod (equal_prod (equal_term A1_ B3_) (equal_term A1_ B3_))
            (equal_list (equal_prod (equal_term A1_ B3_) (equal_term A1_ B3_))))
          ctrs (map fst c_rs))
        (fn x =>
          Inl (shows_prec_list show_char zero_nata
                 [#"d", #"i", #"d", #" ", #"n", #"o", #"t", #" ", #"f", #"i",
                   #"n", #"d", #" ", #"r", #"u", #"l", #"e", #" "] o
                (shows_crule (shows_prec A2_ zero_nata)
                   (shows_prec B5_ zero_nata) x o
                  shows_nl))))
      (fn _ =>
        bindb (case create_U A1_ B3_ c_rs
                of NONE =>
                  Inl (shows_prec_list show_char zero_nata
                        [#"u", #"n", #"a", #"b", #"l", #"e", #" ", #"t", #"o",
                          #" ", #"e", #"x", #"t", #"r", #"a", #"c", #"t", #" ",
                          #"u", #"n", #"r", #"a", #"v", #"e", #"l", #"i", #"n",
                          #"g", #" ", #"c", #"o", #"n", #"t", #"e", #"x", #"t",
                          #"s"])
                | SOME a => Inr a)
          (fn u =>
            bindb (case create_Z A1_ B3_ c_rs
                    of NONE =>
                      Inl (shows_prec_list show_char zero_nata
                            [#"u", #"n", #"a", #"b", #"l", #"e", #" ", #"t",
                              #"o", #" ", #"e", #"x", #"t", #"r", #"a", #"c",
                              #"t", #" ", #"Z", #" ", #"v", #"a", #"r", #"i",
                              #"a", #"b", #"l", #"e", #"s"])
                    | SOME a => Inr a)
              (fn z =>
                bindb (Inr (create_Umap A1_ c_rs))
                  (fn _ =>
                    bindb (check_U_cond (A1_, A2_) (B3_, B5_) u ctrs
                            (funs_ctrs_list ctrs) z)
                      (fn _ =>
                        bindb (check_Z_vars A2_ (B3_, B5_) ctrs z)
                          (fn _ =>
                            bindb (check_dctrs A2_ (B3_, B5_) ctrs)
                              (fn _ =>
                                bindb (check_type3 A2_ (B3_, B5_) ctrs)
                                  (fn _ =>
                                    bindb (catch_errora
    (forallM
      (fn (c, rs) =>
        check (equal_lista
                (equal_prod (equal_term A1_ B3_) (equal_term A1_ B3_))
                (rules_impl u c) rs)
          (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"i", #"t",
               #"h", #" ", #"r", #"u", #"l", #"e", #"s", #" ", #"o", #"f",
               #" "] o
            (shows_crule (shows_prec A2_ zero_nata) (shows_prec B5_ zero_nata)
               c o
              shows_nl)))
      c_rs)
    (fn x => Inl (snd x)))
                                      (fn _ =>
bindb (catch_errora
        (check_left_linear_trs A2_ (B1_, B2_, B4_, B5_) (maps snd c_rs))
        (fn x =>
          Inl (shows_prec_list show_char zero_nata
                 [#"t", #"h", #"e", #" ", #"u", #"n", #"r", #"a", #"v", #"e",
                   #"l", #"e", #"d", #" ", #"T", #"R", #"S", #" ", #"i", #"s",
                   #" ", #"n", #"o", #"t", #" ", #"l", #"e", #"f", #"t", #"-",
                   #"l", #"i", #"n", #"e", #"a", #"r", #" "] o
                (shows_nl o x))))
  (fn _ =>
    bindb (catch_errora (check_wf_ctrs A2_ (B3_, B5_) ctrs)
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"t", #"h", #"e", #" ", #"C", #"T", #"R", #"S", #" ",
                       #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"w", #"e",
                       #"l", #"l", #"-", #"f", #"o", #"r", #"m", #"e", #"d",
                       #" "] o
                    (shows_nl o x))))
      (fn _ =>
        bindb (catch_errora (check_source_preserving A2_ (B3_, B5_) ctrs z)
                (fn x =>
                  Inl (shows_prec_list show_char zero_nata
                         [#"u", #"n", #"r", #"a", #"v", #"e", #"l", #"i", #"n",
                           #"g", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                           #"s", #"o", #"u", #"r", #"c", #"e", #" ", #"p", #"r",
                           #"e", #"s", #"e", #"r", #"v", #"i", #"n", #"g",
                           #" "] o
                        (shows_nl o x))))
          (fn _ => Inr (maps snd c_rs))))))))))))))
    (fn x =>
      Inl (shows_string
             [#"p", #"r", #"e", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o",
               #"n", #"s", #" ", #"o", #"n", #" ", #"t", #"h", #"e", #" ", #"u",
               #"n", #"r", #"a", #"v", #"e", #"l", #"i", #"n", #"g", #" ", #"a",
               #"r", #"e", #" ", #"n", #"o", #"t", #" ", #"s", #"a", #"t", #"i",
               #"s", #"f", #"i", #"e", #"d"] o
            (shows_nl o x)));

fun check_conditional_cr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j ctrs
  (Unconditional_CR prf) =
  debug (ia [])
    [#"U", #"n", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a",
      #"l"]
    (bindb
      (catch_errora
        (catch_errora
          (forallM (fn x => (if null (snd x) then Inr () else Inl x)) ctrs)
          (fn x => Inl (snd x)))
        (fn x =>
          Inl (shows_prec_list show_char zero_nata
                 [#"r", #"u", #"l", #"e", #" ", #"w", #"i", #"t", #"h", #" ",
                   #"n", #"o", #"n", #"-", #"e", #"m", #"p", #"t", #"y", #" ",
                   #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s"] o
                 shows_nl o
                shows_crule (shows_prec_lab B5_ (show_list show_nat) zero_nata)
                  (shows_prec_list show_char zero_nata) x)))
      (fn _ => check_cr_proof (B1_, B3_, B4_, B5_) a ia i j (map fst ctrs) prf))
  | check_conditional_cr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j ctrs
    (Unravel_CR (u_info, prf)) =
    debug (ia []) [#"U", #"n", #"r", #"a", #"v", #"e", #"l"]
      (bindb
        (catch_errora
          (check_sp_unraveling
            (equal_lab B3_ (equal_list equal_nat),
              show_lab B5_ (show_list show_nat))
            (ceq_list ceq_char, ccompare_list ccompare_char,
              equal_list equal_char, set_impl_list, show_list show_char)
            u_info ctrs)
          (fn x =>
            Inl (ia o shows_prec_list show_char zero_nata
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                          #"n", #" ", #"u", #"n", #"r", #"a", #"v", #"e", #"l",
                          #"i", #"n", #"g"] o
                   shows_nl o
                  indent x)))
        (fn r =>
          catch_errora
            (check_cr_proof (B1_, B3_, B4_, B5_) a
              (ia o shows_string [#".", #"1"]) i j r prf)
            (fn x =>
              Inl (ia o shows_prec_list show_char zero_nata
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"c", #"o", #"n",
                            #"f", #"l", #"u", #"e", #"n", #"c", #"e", #" ",
                            #"p", #"r", #"o", #"o", #"f"] o
                     shows_nl o
                    indent x))))
  | check_conditional_cr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j ctrs
    (Transformation_CR (t, prf)) =
    debug (ia [])
      [#"C", #"R", #" ", #"R", #"e", #"f", #"l", #"e", #"c", #"t", #"i", #"n",
        #"g", #" ", #"T", #"r", #"a", #"n", #"s", #"f", #"o", #"r", #"m", #"a",
        #"t", #"i", #"o", #"n"]
      (bindb
        (check_ccr_trans (B2_, B3_, B4_, B5_)
          (equal_list equal_nat, key_list (equal_nat, key_nat),
            show_list show_nat)
          (finite_UNIV_list, cenum_list, ceq_list ceq_char,
            cproper_interval_list ccompare_char, equal_list equal_char,
            key_list (equal_char, key_char), mapping_impl_list, set_impl_list,
            show_list show_char)
          ia ctrs t)
        (fn ctrsa =>
          check_conditional_cr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j ctrsa
            prf))
  | check_conditional_cr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j ctrs
    Almost_Orthogonal_CR =
    debug (ia [])
      [#"A", #"l", #"m", #"o", #"s", #"t", #"-", #"O", #"r", #"t", #"h", #"o",
        #"g", #"o", #"n", #"a", #"l"]
      (check_level_confluence
        (finite_UNIV_lab, cenum_lab, ceq_lab B3_ (equal_list equal_nat),
          cproper_interval_lab ((compare_compare_order o compare_order_key) B4_)
            ((compare_compare_order o compare_order_key)
              (key_list (equal_nat, key_nat))),
          equal_lab B3_ (equal_list equal_nat),
          key_lab B4_ (key_list (equal_nat, key_nat)), set_impl_lab,
          show_lab B5_ (show_list show_nat))
        ctrs)
  | check_conditional_cr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j ctrs
    (Almost_Orthogonal_Modulo_Infeasibility_CR cps) =
    debug (ia [])
      [#"A", #"l", #"m", #"o", #"s", #"t", #"-", #"O", #"r", #"t", #"h", #"o",
        #"g", #"o", #"n", #"a", #"l", #" ", #"m", #"o", #"d", #"u", #"l", #"o",
        #" ", #"I", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"i", #"l", #"i",
        #"t", #"y"]
      (check_level_confluence_modulo_infeasibility
        (finite_UNIV_lab, cenum_lab, ceq_lab B3_ (equal_list equal_nat),
          cproper_interval_lab ((compare_compare_order o compare_order_key) B4_)
            ((compare_compare_order o compare_order_key)
              (key_list (equal_nat, key_nat))),
          default_lab B2_, equal_lab B3_ (equal_list equal_nat),
          key_lab B4_ (key_list (equal_nat, key_nat)), set_impl_lab,
          show_lab B5_ (show_list show_nat))
        cps ctrs)
  | check_conditional_cr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j ctrs
    (Almost_Orthogonal_Modulo_Infeasibility_CRa cps) =
    debug (ia [])
      [#"A", #"l", #"m", #"o", #"s", #"t", #"-", #"O", #"r", #"t", #"h", #"o",
        #"g", #"o", #"n", #"a", #"l", #" ", #"m", #"o", #"d", #"u", #"l", #"o",
        #" ", #"I", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"i", #"l", #"i",
        #"t", #"y", #" ", #"+", #" ", #"m", #"e", #"e", #"t", #"-", #"t", #"o",
        #"-", #"j", #"o", #"i", #"n"]
      (check_level_confluence_modulo_infeasibilitya
        (finite_UNIV_lab, cenum_lab, ceq_lab B3_ (equal_list equal_nat),
          cproper_interval_lab ((compare_compare_order o compare_order_key) B4_)
            ((compare_compare_order o compare_order_key)
              (key_list (equal_nat, key_nat))),
          default_lab B2_, equal_lab B3_ (equal_list equal_nat),
          key_lab B4_ (key_list (equal_nat, key_nat)), set_impl_lab,
          show_lab B5_ (show_list show_nat))
        cps ctrs)
  | check_conditional_cr_proof (B1_, B2_, B3_, B4_, B5_) a ia i j ctrs
    (AL94_CR (qrp, cj, icp, ucp)) =
    debug (ia []) [#"A", #"L", #"9", #"4"]
      (bindb
        (check_quasi_reductive_proof (B1_, B3_, B4_, B5_) a ia i j ctrs qrp)
        (fn _ =>
          check_al94
            (finite_UNIV_lab, cenum_lab, ceq_lab B3_ (equal_list equal_nat),
              cproper_interval_lab
                ((compare_compare_order o compare_order_key) B4_)
                ((compare_compare_order o compare_order_key)
                  (key_list (equal_nat, key_nat))),
              default_lab B2_, equal_lab B3_ (equal_list equal_nat),
              key_lab B4_ (key_list (equal_nat, key_nat)), set_impl_lab,
              show_lab B5_ (show_list show_nat))
            cj icp ucp ctrs));

fun check_fptrs_termination_proof (B1_, B2_, B3_, B4_) ia j a i tp prf =
  check_fptrs_termination_proof_main (B1_, B2_, B3_, B4_) ia j a i tp
    (unlab_to_split_otrs (B2_, B3_)
      (equal_list equal_nat, key_list (equal_nat, key_nat))
      (equal_list equal_char, key_list (equal_char, key_char)) prf);

fun check_E_reachable A_ (B1_, B2_, B3_) e s t =
  membera (equal_term A_ B2_)
    (mk_rtrancl_list (equal_terma A_ B2_) (rewrite A_ (B1_, B2_, B3_) e) [s]) t;

fun check_AC_rule (A1_, A2_, A3_, A4_, A5_) B_ lr =
  let
    val (l, r) = lr;
  in
    (if is_Var l then false
      else let
             val f = fst (the (root l));
           in
             set_eq
               (cenum_prod A1_ cenum_nat, ceq_prod A2_ ceq_nat,
                 ccompare_prod A3_ ccompare_nat)
               (funas_term (A2_, A3_, A5_) l)
               (inserta (ceq_prod A2_ ceq_nat, ccompare_prod A3_ ccompare_nat)
                 (f, nat_of_integer (2 : IntInf.int))
                 (bot_set
                   (ceq_prod A2_ ceq_nat, ccompare_prod A3_ ccompare_nat,
                     set_impl_prod A5_ set_impl_nat))) andalso
               (set_eq
                  (cenum_prod A1_ cenum_nat, ceq_prod A2_ ceq_nat,
                    ccompare_prod A3_ ccompare_nat)
                  (funas_term (A2_, A3_, A5_) r)
                  (inserta
                    (ceq_prod A2_ ceq_nat, ccompare_prod A3_ ccompare_nat)
                    (f, nat_of_integer (2 : IntInf.int))
                    (bot_set
                      (ceq_prod A2_ ceq_nat, ccompare_prod A3_ ccompare_nat,
                        set_impl_prod A5_ set_impl_nat))) andalso
                 (eq (equal_multiset B_) (vars_term_ms B_ l)
                    (vars_term_ms B_ r) andalso
                   eq (equal_multiset A4_) (funs_term_ms A4_ l)
                     (funs_term_ms A4_ r)))
           end)
  end;

fun check_AC_theory (A1_, A2_, A3_, A4_, A5_, A6_) (B1_, B2_) e =
  catch_errora
    (forallM
      (fn lr =>
        check (check_AC_rule (A1_, A2_, A3_, A4_, A5_) B1_ lr)
          (shows_prec_list show_char zero_nata [#"r", #"u", #"l", #"e", #" "] o
             shows_rule (shows_prec A6_ zero_nata) (shows_prec B2_ zero_nata)
               [#" ", #"-", #">", #" "] lr o
            shows_prec_list show_char zero_nata
              [#" ", #"v", #"i", #"o", #"l", #"a", #"t", #"e", #"s", #" ", #"A",
                #"C", #"-", #"p", #"r", #"o", #"p", #"e", #"r", #"t", #"y"]))
      e)
    (fn x => Inl (snd x));

fun check_symmetric_AC_theory (A1_, A2_, A3_, A4_, A5_, A6_)
  (B1_, B2_, B3_, B4_) e =
  bindb (check_AC_theory (A1_, A2_, A3_, A4_, A5_, A6_) (B2_, B4_) e)
    (fn _ =>
      catch_errora
        (catch_errora
          (forallM
            (fn (l, r) =>
              check (check_E_reachable A4_ (B1_, B2_, B3_) e r l)
                (shows_prec_list show_char zero_nata [#"r", #"h", #"s", #" "] o
                   shows_prec_term A6_ B4_ zero_nata r o
                   shows_prec_list show_char zero_nata
                     [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t",
                       #" ", #"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ",
                       #"t", #"o", #" ", #"l", #"h", #"s", #" "] o
                  shows_prec_term A6_ B4_ zero_nata l))
            e)
          (fn x => Inl (snd x)))
        (fn x =>
          Inl (shows_prec_list show_char zero_nata
                 [#"t", #"h", #"e", #"o", #"r", #"y", #" ", #"i", #"s", #" ",
                   #"n", #"o", #"t", #" ", #"s", #"y", #"m", #"m", #"e", #"t",
                   #"r", #"i", #"c", #"\n"] o
                x)));

fun rf (Ac_tp_ops_ext (ac_tp, r, a, c, mk, delete_rules, e, more)) = r;

fun c (Ac_tp_ops_ext (ac_tp, r, a, c, mk, delete_rules, e, more)) = c;

fun a (Ac_tp_ops_ext (ac_tp, r, a, c, mk, delete_rules, e, more)) = a;

fun check_only_C_rule (A1_, A2_, A3_) B_ oc lr =
  (case lr of (Var _, _) => true | (Fun (_, []), _) => true
    | (Fun (_, [_]), _) => true
    | (Fun (f, [s, t]), r) =>
      (if member (A1_, A2_) f oc then equal_terma A3_ B_ r (Fun (f, [t, s]))
        else true)
    | (Fun (_, _ :: _ :: _ :: _), _) => true);

fun check_only_C_theory (A1_, A2_, A3_, A4_) (B1_, B2_) oc e =
  catch_errora
    (forallM
      (fn lr =>
        check (check_only_C_rule (A1_, A2_, A3_) B1_ oc lr)
          (shows_prec_list show_char zero_nata [#"r", #"u", #"l", #"e", #" "] o
             shows_rule (shows_prec A4_ zero_nata) (shows_prec B2_ zero_nata)
               [#" ", #"-", #">", #" "] lr o
            shows_prec_list show_char zero_nata
              [#" ", #"v", #"i", #"o", #"l", #"a", #"t", #"e", #"s", #" ", #"o",
                #"n", #"l", #"y", #"-", #"C", #"-", #"p", #"r", #"o", #"p",
                #"e", #"r", #"t", #"y"]))
      e)
    (fn x => Inl (snd x));

fun check_AC_same_as_E (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_, B5_) x y z a c
  e = catch_errora
        let
          val xa = Var x;
          val ya = Var y;
          val za = Var z;
        in
          bindb (catch_errora
                  (catch_errora
                    (forallM
                      (fn f =>
                        check (check_E_reachable B3_ (A1_, A2_, A3_) e
                                (Fun (f, [xa, ya])) (Fun (f, [ya, xa])))
                          f)
                      c)
                    (fn xb => Inl (snd xb)))
                  (fn xb =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
                             #"t", #" ", #"s", #"i", #"m", #"u", #"l", #"a",
                             #"t", #"e", #" ", #"C", #"-", #"r", #"u", #"l",
                             #"e", #"s", #" ", #"f", #"o", #"r", #" "] o
                           shows_prec B5_ zero_nata xb o
                          shows_prec_list show_char zero_nata
                            [#" ", #"b", #"y", #" ", #"E"])))
            (fn _ =>
              bindb (catch_errora
                      (catch_errora
                        (forallM
                          (fn f =>
                            check (check_E_reachable B3_ (A1_, A2_, A3_) e
                                    (Fun (f, [xa, Fun (f, [ya, za])]))
                                    (Fun (f, [Fun (f, [xa, ya]), za])))
                              f)
                          a)
                        (fn xb => Inl (snd xb)))
                      (fn xb =>
                        Inl (shows_prec_list show_char zero_nata
                               [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
                                 #"t", #" ", #"s", #"i", #"m", #"u", #"l", #"a",
                                 #"t", #"e", #" ", #"A", #"-", #"r", #"u", #"l",
                                 #"e", #"s", #" ", #"f", #"o", #"r", #" "] o
                               shows_prec B5_ zero_nata xb o
                              shows_prec_list show_char zero_nata
                                [#" ", #"b", #"y", #" ", #"E"])))
                (fn _ =>
                  bindb (catch_errora
                          (catch_errora
                            (forallM
                              (fn f =>
                                check (check_E_reachable B3_ (A1_, A2_, A3_) e
(Fun (f, [Fun (f, [xa, ya]), za])) (Fun (f, [xa, Fun (f, [ya, za])])))
                                  f)
                              a)
                            (fn xb => Inl (snd xb)))
                          (fn xb =>
                            Inl (shows_prec_list show_char zero_nata
                                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n",
                                     #"o", #"t", #" ", #"s", #"i", #"m", #"u",
                                     #"l", #"a", #"t", #"e", #" ", #"A", #"-",
                                     #"r", #"u", #"l", #"e", #"s", #" ", #"f",
                                     #"o", #"r", #" "] o
                                   shows_prec B5_ zero_nata xb o
                                  shows_prec_list show_char zero_nata
                                    [#" ", #"b", #"y", #" ", #"E"])))
                    (fn _ =>
                      catch_errora
                        (catch_errora
                          (forallM
                            (fn (l, r) =>
                              check (equal_acterma B3_ A2_
                                      (aocnf (B1_, B2_, B3_) A2_
(set (B1_, B2_, B4_) a) (set (B1_, B2_, B4_) c) l)
                                      (aocnf (B1_, B2_, B3_) A2_
(set (B1_, B2_, B4_) a) (set (B1_, B2_, B4_) c) r))
                                (l, r))
                            e)
                          (fn xb => Inl (snd xb)))
                        (fn xb =>
                          Inl (shows_prec_list show_char zero_nata
                                 [#"e", #"q", #"u", #"a", #"t", #"i", #"o",
                                   #"n", #" "] o
                                 shows_rule (shows_prec B5_ zero_nata)
                                   (shows_prec A4_ zero_nata)
                                   [#" ", #"-", #">", #" "] xb o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
                                    #" ", #"A", #"C", #"-", #"e", #"q", #"u",
                                    #"i", #"v", #"a", #"l", #"e", #"n",
                                    #"t"])))))
        end
        (fn xa =>
          Inl (shows_prec_list show_char zero_nata
                 [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                   #"e", #"n", #"s", #"u", #"r", #"e", #" ", #"t", #"h", #"a",
                   #"t", #" ", #"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n",
                   #"s", #" ", #"s", #"i", #"m", #"u", #"l", #"a", #"t", #"e",
                   #" ", #"A", #"C", #"-", #"e", #"q", #"u", #"i", #"v", #"a",
                   #"l", #"e", #"n", #"c", #"e", #"\n"] o
                xa));

fun check_ext_rule3 A_ (B1_, B2_, B3_) (la, ra) f xb
  (Fun (ga, [Fun (ha, [Var xa, l]), Var ya]),
    Fun (g, [Fun (h, [Var x, r]), Var y]))
  = equal_proda (equal_term A_ B3_)
      (equal_prod (equal_term A_ B3_)
        (equal_prod A_
          (equal_prod A_ (equal_prod A_ (equal_prod A_ (equal_prod B3_ B3_))))))
      (la, (ra, (f, (f, (f, (f, (xa, ya)))))))
      (l, (r, (ga, (g, (ha, (h, (x, y))))))) andalso
      (not (eq B3_ x y) andalso
        (not (member (B1_, B2_) x xb) andalso not (member (B1_, B2_) y xb)))
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw (Var vb, va) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw (Fun (vb, []), va) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw (Fun (vb, Var vf :: ve), va) =
    false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw
    (Fun (vb, Fun (vf, []) :: ve), va) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw
    (Fun (vb, Fun (vf, Fun (vj, vk) :: vi) :: ve), va) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw
    (Fun (vb, Fun (vf, [vh]) :: ve), va) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw
    (Fun (vb, Fun (vf, vh :: vj :: vl :: vm) :: ve), va) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw (Fun (vb, [vd]), va) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw
    (Fun (vb, vd :: Fun (vh, vi) :: vg), va) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw
    (Fun (vb, vd :: vf :: vh :: vi), va) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw (v, Var vb) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw (v, Fun (vb, [])) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw (v, Fun (vb, Var vf :: ve)) =
    false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw
    (v, Fun (vb, Fun (vf, []) :: ve)) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw
    (v, Fun (vb, Fun (vf, Fun (vj, vk) :: vi) :: ve)) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw
    (v, Fun (vb, Fun (vf, [vh]) :: ve)) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw
    (v, Fun (vb, Fun (vf, vh :: vj :: vl :: vm) :: ve)) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw (v, Fun (vb, [vd])) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw
    (v, Fun (vb, vd :: Fun (vh, vi) :: vg)) = false
  | check_ext_rule3 A_ (B1_, B2_, B3_) uu uv uw
    (v, Fun (vb, vd :: vf :: vh :: vi)) = false;

fun check_ext_rule2 A_ (B1_, B2_, B3_) (la, ra) f xb
  (Fun (ga, [Var xa, l]), Fun (g, [Var x, r])) =
  equal_proda (equal_term A_ B3_)
    (equal_prod (equal_term A_ B3_) (equal_prod A_ (equal_prod A_ B3_)))
    (la, (ra, (f, (f, xa)))) (l, (r, (ga, (g, x)))) andalso
    not (member (B1_, B2_) xa xb)
  | check_ext_rule2 A_ (B1_, B2_, B3_) uu uv uw (Var vb, va) = false
  | check_ext_rule2 A_ (B1_, B2_, B3_) uu uv uw (Fun (vb, []), va) = false
  | check_ext_rule2 A_ (B1_, B2_, B3_) uu uv uw
    (Fun (vb, Fun (vf, vg) :: ve), va) = false
  | check_ext_rule2 A_ (B1_, B2_, B3_) uu uv uw (Fun (vb, [vd]), va) = false
  | check_ext_rule2 A_ (B1_, B2_, B3_) uu uv uw
    (Fun (vb, vd :: vf :: vh :: vi), va) = false
  | check_ext_rule2 A_ (B1_, B2_, B3_) uu uv uw (v, Var vb) = false
  | check_ext_rule2 A_ (B1_, B2_, B3_) uu uv uw (v, Fun (vb, [])) = false
  | check_ext_rule2 A_ (B1_, B2_, B3_) uu uv uw
    (v, Fun (vb, Fun (vf, vg) :: ve)) = false
  | check_ext_rule2 A_ (B1_, B2_, B3_) uu uv uw (v, Fun (vb, [vd])) = false
  | check_ext_rule2 A_ (B1_, B2_, B3_) uu uv uw
    (v, Fun (vb, vd :: vf :: vh :: vi)) = false;

fun check_ext_rule1 A_ (B1_, B2_, B3_) (la, ra) f xb
  (Fun (ga, [l, Var xa]), Fun (g, [r, Var x])) =
  equal_proda (equal_term A_ B3_)
    (equal_prod (equal_term A_ B3_) (equal_prod A_ (equal_prod A_ B3_)))
    (la, (ra, (f, (f, xa)))) (l, (r, (ga, (g, x)))) andalso
    not (member (B1_, B2_) xa xb)
  | check_ext_rule1 A_ (B1_, B2_, B3_) uu uv uw (Var vb, va) = false
  | check_ext_rule1 A_ (B1_, B2_, B3_) uu uv uw (Fun (vb, []), va) = false
  | check_ext_rule1 A_ (B1_, B2_, B3_) uu uv uw (Fun (vb, [vd]), va) = false
  | check_ext_rule1 A_ (B1_, B2_, B3_) uu uv uw
    (Fun (vb, vd :: Fun (vh, vi) :: vg), va) = false
  | check_ext_rule1 A_ (B1_, B2_, B3_) uu uv uw
    (Fun (vb, vd :: vf :: vh :: vi), va) = false
  | check_ext_rule1 A_ (B1_, B2_, B3_) uu uv uw (v, Var vb) = false
  | check_ext_rule1 A_ (B1_, B2_, B3_) uu uv uw (v, Fun (vb, [])) = false
  | check_ext_rule1 A_ (B1_, B2_, B3_) uu uv uw (v, Fun (vb, [vd])) = false
  | check_ext_rule1 A_ (B1_, B2_, B3_) uu uv uw
    (v, Fun (vb, vd :: Fun (vh, vi) :: vg)) = false
  | check_ext_rule1 A_ (B1_, B2_, B3_) uu uv uw
    (v, Fun (vb, vd :: vf :: vh :: vi)) = false;

fun check_ext_rule (A1_, A2_, A3_, A4_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) rext
  a c lr =
  let
    val (l, _) = lr;
  in
    (if is_Var l orelse
          (not (equal_nata (size_list (args l))
                 (nat_of_integer (2 : IntInf.int))) orelse
            not (member (A1_, A2_) (fst (the (root l))) a))
      then true
      else let
             val f = fst (the (root l));
             val x =
               vars_rule (A3_, A4_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_) lr;
           in
             list_ex
               (check_ext_rule1 A4_ (B3_, ccompare_cproper_interval B4_, B6_) lr
                 f x)
               rext andalso
               (if not (member (A1_, A2_) f c)
                 then list_ex
                        (check_ext_rule2 A4_
                          (B3_, ccompare_cproper_interval B4_, B6_) lr f x)
                        rext andalso
                        list_ex
                          (check_ext_rule3 A4_
                            (B3_, ccompare_cproper_interval B4_, B6_) lr f x)
                          rext
                 else true)
           end)
  end;

fun check_ext_trs (A1_, A2_, A3_, A4_, A5_, A6_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) r a c rext =
  let
    val aa = set (A1_, A2_, A5_) a;
    val ca = set (A1_, A2_, A5_) c;
  in
    catch_errora
      (catch_errora
        (forallM
          (fn lr =>
            check (check_ext_rule (A1_, A2_, A3_, A4_)
                    (B1_, B2_, B3_, B4_, B5_, B6_, B7_) rext aa ca lr)
              (shows_prec_list show_char zero_nata
                 [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                   #"f", #"i", #"n", #"d", #" ", #"e", #"x", #"t", #"e", #"n",
                   #"d", #"e", #"d", #" ", #"r", #"u", #"l", #"e", #"s", #" ",
                   #"f", #"o", #"r", #" ", #"r", #"u", #"l", #"e", #" ", #"l",
                   #" ", #"-", #">", #" ", #"r", #":", #"\n", #" ", #" "] o
                 shows_rule (shows_prec A6_ zero_nata)
                   (shows_prec B8_ zero_nata) [#" ", #"-", #">", #" "] lr o
                 shows_prec_list show_char zero_nata
                   [#"\n", #" ", #" ", #"e", #"x", #"p", #"e", #"c", #"t", #"i",
                     #"n", #"g", #" ", #"r", #"u", #"l", #"e", #" ", #"f", #"(",
                     #"l", #",", #"x", #")", #" ", #"-", #">", #" ", #"f", #"(",
                     #"r", #",", #"x", #")", #" ", #"f", #"o", #"r", #" ", #"a",
                     #"l", #"l", #" ", #"A", #" ", #"a", #"n", #"d", #" ", #"A",
                     #"C", #" ", #"s", #"y", #"m", #"b", #"o", #"l", #"s", #",",
                     #"\n"] o
                shows_prec_list show_char zero_nata
                  [#"a", #"n", #"d", #" ", #"r", #"u", #"l", #"e", #"s", #" ",
                    #"f", #"(", #"x", #",", #"l", #")", #" ", #"-", #">", #" ",
                    #"f", #"(", #"x", #",", #"r", #")", #" ", #"a", #"n", #"d",
                    #" ", #"f", #"(", #"f", #"(", #"x", #",", #"l", #")", #",",
                    #"y", #")", #" ", #"-", #">", #" ", #"f", #"(", #"f", #"(",
                    #"x", #",", #"r", #")", #",", #"y", #")", #" ", #"f", #"o",
                    #"r", #" ", #"a", #"l", #"l", #" ", #"A", #" ", #"s", #"y",
                    #"m", #"b", #"o", #"l", #"s"]))
          r)
        (fn x => Inl (snd x)))
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                 #"e", #"n", #"s", #"u", #"r", #"e", #" ", #"v", #"a", #"l",
                 #"i", #"d", #"i", #"t", #"y", #" ", #"o", #"f", #" ", #"A",
                 #"C", #"-", #"e", #"x", #"t", #"e", #"n", #"d", #"e", #"d",
                 #" ", #"s", #"y", #"s", #"t", #"e", #"m", #"\n"] o
              x))
  end;

fun ac_dependency_pairs_checks (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
  (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_, C9_) i shp x y z
  (AC_dependency_pairs_proof (e, dpr, dpe, rext)) tp =
  catch_errora
    let
      val aa = a i tp;
      val ca = c i tp;
      val r = rf i tp;
      val oc = list_diff B5_ ca aa;
      val d = defined_list r;
      val _ =
        set (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat,
              set_impl_prod B6_ set_impl_nat)
          d;
      val da = defined_list (r @ e);
    in
      bindb (catch_errora
              (forallM
                (fn (f, n) =>
                  check (not (membera (equal_prod B5_ equal_nat) da (shp f, n)))
                    (shows_string
                       [#"s", #"h", #"a", #"r", #"p", #"i", #"n", #"g", #" "] o
                      (shows_prec B7_ zero_nata f o
                        (shows_string
                           [#" ", #"y", #"i", #"e", #"l", #"d", #"s", #" ",
                             #"t", #"h", #"e", #" ", #"d", #"e", #"f", #"i",
                             #"n", #"e", #"d", #" ", #"s", #"y", #"m", #"b",
                             #"o", #"l", #" "] o
                          shows_prec B7_ zero_nata (shp f)))))
                da)
              (fn xa => Inl (snd xa)))
        (fn _ =>
          bindb (catch_errora (check_wf_trs B7_ (C6_, C9_) (r @ e))
                  (fn xa =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"T", #"R", #"S", #" ", #"o", #"r", #" ", #"e",
                             #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"s",
                             #" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t",
                             #" ", #"w", #"e", #"l", #"l", #"-", #"f", #"o",
                             #"r", #"m", #"e", #"d"] o
                          xa)))
            (fn _ =>
              bindb (catch_errora
                      (check_symmetric_AC_theory (B1_, B2_, B3_, B5_, B6_, B7_)
                        (ccompare_cproper_interval C4_, C6_, C7_, C9_) e)
                      (fn xa =>
                        Inl (shows_prec_list show_char zero_nata
                               [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n",
                                 #"s", #" ", #"d", #"o", #" ", #"n", #"o", #"t",
                                 #" ", #"f", #"o", #"r", #"m", #" ", #"a", #" ",
                                 #"s", #"y", #"m", #"m", #"e", #"t", #"r", #"i",
                                 #"c", #" ", #"A", #"C", #"-", #"t", #"h", #"e",
                                 #"o", #"r", #"y", #"\n"] o
                              xa)))
                (fn _ =>
                  bindb (catch_errora
                          (check_only_C_theory (B2_, B3_, B5_, B7_) (C6_, C9_)
                            (set (B2_, B3_, B6_) oc) e)
                          (fn xa =>
                            Inl (shows_prec_list show_char zero_nata
                                   [#"e", #"q", #"u", #"a", #"t", #"i", #"o",
                                     #"n", #"s", #" ", #"d", #"o", #" ", #"n",
                                     #"o", #"t", #" ", #"f", #"o", #"r", #"m",
                                     #" ", #"A", #"C", #"_", #"C", #"-", #"t",
                                     #"h", #"e", #"o", #"r", #"y", #"\n"] o
                                  xa)))
                    (fn _ =>
                      bindb (catch_errora
                              (check_subseteq B5_ (funs_trs_list e) (aa @ ca))
                              (fn xa =>
                                Inl (shows_prec_list show_char zero_nata
                                       [#"e", #"q", #"u", #"a", #"t", #"i",
 #"o", #"n", #"s", #" ", #"c", #"o", #"n", #"t", #"a", #"i", #"n", #" ", #"s",
 #"y", #"m", #"b", #"o", #"l", #" "] o
                                       shows_prec B7_ zero_nata xa o
                                      shows_prec_list show_char zero_nata
[#" ", #"w", #"h", #"i", #"c", #"h", #" ", #"i", #"s", #" ", #"n", #"o", #"t",
  #" ", #"A", #"C", #"-", #"s", #"y", #"m", #"b", #"o", #"l"])))
                        (fn _ =>
                          bindb (catch_errora
                                  (check_AC_same_as_E
                                    (ccompare_cproper_interval C4_, C6_, C7_,
                                      C9_)
                                    (B2_, B3_, B5_, B6_, B7_) x y z aa ca e)
                                  (fn xa =>
                                    Inl (shows_prec_list show_char zero_nata
   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"e", #"n",
     #"s", #"u", #"r", #"e", #" ", #"t", #"h", #"a", #"t", #" ", #"e", #"q",
     #"u", #"a", #"t", #"i", #"o", #"n", #"s", #" ", #"c", #"o", #"r", #"r",
     #"e", #"s", #"p", #"o", #"n", #"d", #" ", #"t", #"o", #" ", #"A", #"C",
     #" ", #"e", #"q", #"u", #"i", #"v", #"a", #"l", #"e", #"n", #"c", #"e",
     #"\n"] o
  xa)))
                            (fn _ =>
                              bindb (catch_errora
                                      (check_subseteq
(equal_prod (equal_term B5_ C6_) (equal_term B5_ C6_)) (dP_list B5_ C6_ shp r d)
dpr)
                                      (fn xa =>
Inl (shows_prec_list show_char zero_nata
       [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"f", #"i",
         #"n", #"d", #" ", #"D", #"P", #" ", #"f", #"o", #"r", #" ", #"R", #":",
         #" "] o
      shows_rule (shows_prec B7_ zero_nata) (shows_prec C9_ zero_nata)
        [#" ", #"-", #">", #" "] xa)))
                                (fn _ =>
                                  bindb (catch_errora
  (check_subseteq (equal_prod (equal_term B5_ C6_) (equal_term B5_ C6_))
    (dP_list B5_ C6_ shp e d) dpe)
  (fn xa =>
    Inl (shows_prec_list show_char zero_nata
           [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"f",
             #"i", #"n", #"d", #" ", #"D", #"P", #" ", #"f", #"o", #"r", #" ",
             #"E", #":", #" "] o
          shows_rule (shows_prec B7_ zero_nata) (shows_prec C9_ zero_nata)
            [#" ", #"-", #">", #" "] xa)))
                                    (fn _ =>
                                      catch_errora
(check_ext_trs (B2_, B3_, B4_, B5_, B6_, B7_)
  (C1_, C2_, C3_, C4_, C5_, C6_, C8_, C9_) r aa ca rext)
(fn xa =>
  Inl (shows_prec_list show_char zero_nata
         [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"e",
           #"n", #"s", #"u", #"r", #"e", #" ", #"v", #"a", #"l", #"i", #"d",
           #"i", #"t", #"y", #" ", #"o", #"f", #" ", #"e", #"x", #"t", #"e",
           #"n", #"d", #"e", #"d", #" ", #"T", #"R", #"S", #" ", #"R", #"_",
           #"e", #"x", #"t", #"\n"] o
        xa))))))))))
    end
    (fn xa =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"a", #"p", #"p", #"l", #"y", #"i", #"n", #"g", #" ", #"A", #"C",
               #"-", #"d", #"e", #"p", #"e", #"n", #"d", #"e", #"n", #"c", #"y",
               #" ", #"p", #"a", #"i", #"r", #"s", #"\n"] o
            xa));

fun mkf
  (Ac_dpp_ops_ext
    (ac_dpp, p, pw, pairs, r, rw, rules, e, mk, eq_rules_map,
      reverse_eq_rules_map, delete_pairs_rules, eq_rules_no_left_var,
      eq_rules_non_collapsing, intersect_pairs, more))
  = mk;

fun ac_dependency_pairs_proc_simple (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
  (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_, C9_) i j shp x y z
  (AC_dependency_pairs_proof (e, dpr, dpe, rext)) tp =
  bindb (ac_dependency_pairs_checks (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
          (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_, C9_) i shp x y z
          (AC_dependency_pairs_proof (e, dpr, dpe, rext)) tp)
    (fn _ =>
      let
        val r = rf i tp;
      in
        Inr (mkf j
              (dpr @
                map (fn (l, ra) => (sharp_term shp l, sharp_term shp ra)) rext)
              dpe [] r e)
      end);

fun delete_pairs_rulesa
  (Ac_dpp_ops_ext
    (ac_dpp, p, pw, pairs, r, rw, rules, e, mk, eq_rules_map,
      reverse_eq_rules_map, delete_pairs_rules, eq_rules_no_left_var,
      eq_rules_non_collapsing, intersect_pairs, more))
  = delete_pairs_rules;

fun rulesf
  (Ac_dpp_ops_ext
    (ac_dpp, p, pw, pairs, r, rw, rules, e, mk, eq_rules_map,
      reverse_eq_rules_map, delete_pairs_rules, eq_rules_no_left_var,
      eq_rules_non_collapsing, intersect_pairs, more))
  = rules;

fun pairsc
  (Ac_dpp_ops_ext
    (ac_dpp, p, pw, pairs, r, rw, rules, e, mk, eq_rules_map,
      reverse_eq_rules_map, delete_pairs_rules, eq_rules_no_left_var,
      eq_rules_non_collapsing, intersect_pairs, more))
  = pairs;

fun rwe
  (Ac_dpp_ops_ext
    (ac_dpp, p, pw, pairs, r, rw, rules, e, mk, eq_rules_map,
      reverse_eq_rules_map, delete_pairs_rules, eq_rules_no_left_var,
      eq_rules_non_collapsing, intersect_pairs, more))
  = rw;

fun rg
  (Ac_dpp_ops_ext
    (ac_dpp, p, pw, pairs, r, rw, rules, e, mk, eq_rules_map,
      reverse_eq_rules_map, delete_pairs_rules, eq_rules_no_left_var,
      eq_rules_non_collapsing, intersect_pairs, more))
  = r;

fun ec
  (Ac_dpp_ops_ext
    (ac_dpp, p, pw, pairs, r, rw, rules, e, mk, eq_rules_map,
      reverse_eq_rules_map, delete_pairs_rules, eq_rules_no_left_var,
      eq_rules_non_collapsing, intersect_pairs, more))
  = e;

fun ac_mono_ur_redpair_proc (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
  (C1_, C2_, C3_, C4_, C5_) i rp p_remove r_remove ur dpp =
  (case catch_errora
          let
            val p = pairsc i dpp;
            val _ = rulesf i dpp;
            val e = ec i dpp;
            val premove =
              set (ceq_prod (ceq_term B5_ C3_) (ceq_term B5_ C3_),
                    ccompare_prod (ccompare_term B4_ C2_)
                      (ccompare_term B4_ C2_),
                    set_impl_prod set_impl_term set_impl_term)
                p_remove;
            val rremove =
              set (ceq_prod (ceq_term B5_ C3_) (ceq_term B5_ C3_),
                    ccompare_prod (ccompare_term B4_ C2_)
                      (ccompare_term B4_ C2_),
                    set_impl_prod set_impl_term set_impl_term)
                r_remove;
            val us =
              foldr (sup_seta
                       (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat) o
                      (funas_term (B2_, B3_, B6_) o snd))
                (p @ ur)
                (bot_set
                  (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat,
                    set_impl_prod B6_ set_impl_nat));
            val filt =
              (fn lr =>
                ball (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat)
                  (funas_term (B2_, B3_, B6_) (fst lr))
                  (fn f =>
                    member
                      (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat) f
                      us));
            val (ps, pns) =
              partition
                (fn lr =>
                  member
                    (ceq_prod (ceq_term B5_ C3_) (ceq_term B5_ C3_),
                      ccompare_prod (ccompare_term B4_ C2_)
                        (ccompare_term B4_ C2_))
                    lr premove andalso
                    filt lr)
                p;
            val (urs, urns) =
              partition
                (fn lr =>
                  member
                    (ceq_prod (ceq_term B5_ C3_) (ceq_term B5_ C3_),
                      ccompare_prod (ccompare_term B4_ C2_)
                        (ccompare_term B4_ C2_))
                    lr rremove andalso
                    filt lr)
                ur;
            val rm = eq_rules_map i dpp;
          in
            bindb (valid rp)
              (fn _ =>
                bindb (mono rp (ps @ urs @ urns @ pns))
                  (fn _ =>
                    bindb (catch_errora
                            (check_symmetric_AC_theory
                              (B1_, B2_, B3_, B5_, B6_, B7_)
                              (C1_, C3_, C4_, C5_) e)
                            (fn x =>
                              Inl (shows_prec_list show_char zero_nata
                                     [#"u", #"s", #"a", #"b", #"l", #"e", #" ",
                                       #"r", #"u", #"l", #"e", #"s", #" ", #"d",
                                       #"e", #"m", #"a", #"n", #"d", #" ", #"s",
                                       #"y", #"m", #"m", #"e", #"t", #"r", #"i",
                                       #"c", #" ", #"A", #"C", #" ", #"t", #"h",
                                       #"e", #"o", #"r", #"y", #"\n"] o
                                    x)))
                      (fn _ =>
                        bindb (catch_errora
                                (forallM
                                  (fn (l, _) =>
                                    check (not (is_Var l))
                                      (shows_prec_list show_char zero_nata
[#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #"s", #" ", #"a", #"s", #" ",
  #"l", #"h", #"s", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o",
  #"w", #"e", #"d"]))
                                  (rg i dpp @ rwe i dpp))
                                (fn x => Inl (snd x)))
                          (fn _ =>
                            bindb (check_ur_P_closed_rm_af (B5_, B7_) (C3_, C5_)
                                    rm ur full_af p)
                              (fn _ =>
                                bindb (catch_errora
(catch_errora (forallM (ns rp) urns) (fn x => Inl (snd x)))
(fn x =>
  Inl (shows_prec_list show_char zero_nata
         [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
           #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g",
           #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"u", #"l",
           #"e", #"s", #"\n"] o
        x)))
                                  (fn _ =>
                                    bindb (catch_errora
    (catch_errora (forallM (s rp) urs) (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
               #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g",
               #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"u", #"l",
               #"e", #"s", #"\n"] o
            x)))
                                      (fn _ =>
bindb (catch_errora (catch_errora (forallM (ns rp) pns) (fn x => Inl (snd x)))
        (fn x =>
          Inl (shows_prec_list show_char zero_nata
                 [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h",
                   #"e", #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i",
                   #"n", #"g", #" ", #"D", #"P", #"s", #"\n"] o
                x)))
  (fn _ =>
    catch_errora (catch_errora (forallM (s rp) ps) (fn x => Inl (snd x)))
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h",
                 #"e", #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i",
                 #"n", #"g", #" ", #"D", #"P", #"s", #"\n"] o
              x))))))))))
          end
          (fn x =>
            Inl (shows_prec_list show_char zero_nata
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"a", #"p", #"p", #"l", #"y", #" ", #"t", #"h", #"e", #" ",
                     #"m", #"o", #"n", #"o", #"t", #"o", #"n", #"i", #"c", #" ",
                     #"A", #"C", #" ", #"r", #"e", #"d", #"u", #"c", #"t", #"i",
                     #"o", #"n", #" ", #"p", #"a", #"i", #"r", #" ", #"p", #"r",
                     #"o", #"c", #"e", #"s", #"s", #"o", #"r", #" ", #"w", #"i",
                     #"t", #"h", #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ",
                     #"r", #"u", #"l", #"e", #"s", #" ", #"a", #"n", #"d", #" ",
                     #"t", #"h", #"e", #" ", #"f", #"o", #"l", #"l", #"o", #"w",
                     #"i", #"n", #"g", #"\n"] o
                   desc rp o
                   shows_nl o
                  x))
    of Inl a => Inl a
    | Inr _ => Inr (delete_pairs_rulesa i dpp p_remove r_remove));

fun pwc
  (Ac_dpp_ops_ext
    (ac_dpp, p, pw, pairs, r, rw, rules, e, mk, eq_rules_map,
      reverse_eq_rules_map, delete_pairs_rules, eq_rules_no_left_var,
      eq_rules_non_collapsing, intersect_pairs, more))
  = pw;

fun pc
  (Ac_dpp_ops_ext
    (ac_dpp, p, pw, pairs, r, rw, rules, e, mk, eq_rules_map,
      reverse_eq_rules_map, delete_pairs_rules, eq_rules_no_left_var,
      eq_rules_non_collapsing, intersect_pairs, more))
  = p;

fun ac_dpp_trivial_check i dpp =
  bindb (check (null (pc i dpp))
          (shows_prec_list show_char zero_nata
            [#"t", #"h", #"e", #"r", #"e", #" ", #"a", #"r", #"e", #" ", #"s",
              #"t", #"r", #"i", #"c", #"t", #" ", #"p", #"a", #"i", #"r",
              #"s"]))
    (fn _ =>
      check (null (pwc i dpp) orelse null (rg i dpp))
        (shows_prec_list show_char zero_nata
          [#"t", #"h", #"e", #"r", #"e", #" ", #"a", #"r", #"e", #" ", #"w",
            #"e", #"a", #"k", #" ", #"p", #"a", #"i", #"r", #"s", #" ", #"a",
            #"n", #"d", #" ", #"s", #"t", #"r", #"i", #"c", #"t", #" ", #"r",
            #"u", #"l", #"e", #"s"]));

fun ac_ur_redpair_proc (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
  (C1_, C2_, C3_, C4_, C5_) i rp p_remove ur dpp =
  (case catch_errora
          let
            val p = pairsc i dpp;
            val _ = rulesf i dpp;
            val e = ec i dpp;
            val premove =
              set (ceq_prod (ceq_term B5_ C3_) (ceq_term B5_ C3_),
                    ccompare_prod (ccompare_term B4_ C2_)
                      (ccompare_term B4_ C2_),
                    set_impl_prod set_impl_term set_impl_term)
                p_remove;
            val (ps, pns) =
              partition
                (fn lr =>
                  member
                    (ceq_prod (ceq_term B5_ C3_) (ceq_term B5_ C3_),
                      ccompare_prod (ccompare_term B4_ C2_)
                        (ccompare_term B4_ C2_))
                    lr premove)
                p;
            val rm = eq_rules_map i dpp;
            val pi = af rp;
          in
            bindb (valid rp)
              (fn _ =>
                bindb (catch_errora
                        (check_symmetric_AC_theory
                          (B1_, B2_, B3_, B5_, B6_, B7_) (C1_, C3_, C4_, C5_) e)
                        (fn x =>
                          Inl (shows_prec_list show_char zero_nata
                                 [#"u", #"s", #"a", #"b", #"l", #"e", #" ",
                                   #"r", #"u", #"l", #"e", #"s", #" ", #"d",
                                   #"e", #"m", #"a", #"n", #"d", #" ", #"s",
                                   #"y", #"m", #"m", #"e", #"t", #"r", #"i",
                                   #"c", #" ", #"A", #"C", #" ", #"t", #"h",
                                   #"e", #"o", #"r", #"y", #"\n"] o
                                x)))
                  (fn _ =>
                    bindb (catch_errora
                            (forallM
                              (fn (l, _) =>
                                check (not (is_Var l))
                                  (shows_prec_list show_char zero_nata
                                    [#"v", #"a", #"r", #"i", #"a", #"b", #"l",
                                      #"e", #"s", #" ", #"a", #"s", #" ", #"l",
                                      #"h", #"s", #"s", #" ", #"n", #"o", #"t",
                                      #" ", #"a", #"l", #"l", #"o", #"w", #"e",
                                      #"d"]))
                              (rg i dpp @ rwe i dpp))
                            (fn x => Inl (snd x)))
                      (fn _ =>
                        bindb (check_ur_P_closed_rm_af (B5_, B7_) (C3_, C5_) rm
                                ur pi p)
                          (fn _ =>
                            bindb (catch_errora
                                    (catch_errora (forallM (ns rp) ur)
                                      (fn x => Inl (snd x)))
                                    (fn x =>
                                      Inl
(shows_prec_list show_char zero_nata
   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n",
     #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"u",
     #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"u", #"l", #"e", #"s", #"\n"] o
  x)))
                              (fn _ =>
                                bindb (catch_errora
(catch_errora (forallM (nst rp) pns) (fn x => Inl (snd x)))
(fn x =>
  Inl (shows_prec_list show_char zero_nata
         [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
           #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g",
           #" ", #"D", #"P", #"s", #"\n"] o
        x)))
                                  (fn _ =>
                                    catch_errora
                                      (catch_errora (forallM (s rp) ps)
(fn x => Inl (snd x)))
                                      (fn x =>
Inl (shows_prec_list show_char zero_nata
       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n",
         #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"D",
         #"P", #"s", #"\n"] o
      x))))))))
          end
          (fn x =>
            Inl (shows_prec_list show_char zero_nata
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"a", #"p", #"p", #"l", #"y", #" ", #"t", #"h", #"e", #" ",
                     #"A", #"C", #" ", #"r", #"e", #"d", #"u", #"c", #"t", #"i",
                     #"o", #"n", #" ", #"p", #"a", #"i", #"r", #" ", #"p", #"r",
                     #"o", #"c", #"e", #"s", #"s", #"o", #"r", #" ", #"w", #"i",
                     #"t", #"h", #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ",
                     #"r", #"u", #"l", #"e", #"s", #" ", #"a", #"n", #"d", #" ",
                     #"t", #"h", #"e", #" ", #"f", #"o", #"l", #"l", #"o", #"w",
                     #"i", #"n", #"g", #"\n"] o
                   desc rp o
                   shows_nl o
                  x))
    of Inl a => Inl a | Inr _ => Inr (delete_pairs_rulesa i dpp p_remove []));

fun check_size_preserving_trs A_ (B1_, B2_) e =
  catch_errora
    (catch_errora
      (forallM
        (fn (l, r) =>
          check (equal_nata (num_symbs l) (num_symbs r) andalso
                  eq (equal_multiset B1_) (vars_term_ms B1_ l)
                    (vars_term_ms B1_ r))
            (shows_prec_list show_char zero_nata
               [#"r", #"u", #"l", #"e", #" "] o
               shows_rule (shows_prec A_ zero_nata) (shows_prec B2_ zero_nata)
                 [#" ", #"-", #">", #" "] (l, r) o
              shows_prec_list show_char zero_nata
                [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"s", #"i",
                  #"z", #"e", #" ", #"p", #"r", #"e", #"s", #"e", #"r", #"v",
                  #"i", #"n", #"g"]))
        e)
      (fn x => Inl (snd x)))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"T", #"R", #"S", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
               #"s", #"i", #"z", #"e", #"-", #"p", #"r", #"e", #"s", #"e", #"r",
               #"v", #"i", #"n", #"g", #"\n"] o
            x));

fun ac_subterm_proc (B1_, B2_, B3_, B4_, B5_, B6_) (C1_, C2_, C3_) i pi p_remove
  dpp =
  (case catch_errora
          let
            val p = pairsc i dpp;
            val r = rulesf i dpp;
            val e = ec i dpp;
            val re = r @ e;
            val f = map fst pi;
            val ff =
              set (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat,
                    set_impl_prod B5_ set_impl_nat)
                f;
            val pi_opt = status_of B4_ pi;
          in
            bindb (check (not (is_none pi_opt))
                    (shows_prec_list show_char zero_nata
                      [#"a", #"r", #"g", #"u", #"m", #"e", #"n", #"t", #" ",
                        #"f", #"i", #"l", #"t", #"e", #"r", #" ", #"l", #"i",
                        #"s", #"t", #"s", #" ", #"i", #"n", #"v", #"a", #"l",
                        #"i", #"d", #" ", #"p", #"o", #"s", #"i", #"t", #"i",
                        #"o", #"n", #"s"]))
              (fn _ =>
                let
                  val pia = the pi_opt;
                  val premove =
                    set (ceq_prod (ceq_term B4_ C2_) (ceq_term B4_ C2_),
                          ccompare_prod (ccompare_term B3_ C1_)
                            (ccompare_term B3_ C1_),
                          set_impl_prod set_impl_term set_impl_term)
                      p_remove;
                  val (ps, pns) =
                    partition
                      (fn lr =>
                        member
                          (ceq_prod (ceq_term B4_ C2_) (ceq_term B4_ C2_),
                            ccompare_prod (ccompare_term B3_ C1_)
                              (ccompare_term B3_ C1_))
                          lr premove)
                      p;
                in
                  bindb (catch_errora
                          (forallM
                            (fn fa =>
                              check (not (null (status pia fa)))
                                (shows_prec_list show_char zero_nata
                                   [#"s", #"t", #"a", #"t", #"u", #"s", #" ",
                                     #"o", #"f", #" ", #"s", #"y", #"m", #"b",
                                     #"o", #"l", #" "] o
                                   shows_prec_prod B6_ show_nat zero_nata fa o
                                  shows_prec_list show_char zero_nata
                                    [#" ", #"i", #"n", #" ", #"F", #" ", #"m",
                                      #"u", #"s", #"t", #" ", #"b", #"e", #" ",
                                      #"n", #"o", #"n", #"-", #"e", #"m", #"p",
                                      #"t", #"y"]))
                            f)
                          (fn x => Inl (snd x)))
                    (fn _ =>
                      bindb (catch_errora
                              (check_size_preserving_trs B6_ (C2_, C3_) e)
                              (fn x =>
                                Inl (shows_prec_list show_char zero_nata
                                       [#"E", #" ", #"i", #"s", #" ", #"n",
 #"o", #"t", #" ", #"s", #"i", #"z", #"e", #" ", #"p", #"r", #"e", #"s", #"e",
 #"r", #"v", #"i", #"n", #"g", #"\n"] o
                                      x)))
                        (fn _ =>
                          bindb (catch_errora
                                  (forallM
                                    (fn (l, _) =>
                                      check (not (is_Var l))
(shows_prec_list show_char zero_nata
  [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #"s", #" ", #"a", #"s", #" ",
    #"l", #"h", #"s", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l",
    #"o", #"w", #"e", #"d"]))
                                    re)
                                  (fn x => Inl (snd x)))
                            (fn _ =>
                              bindb (catch_errora
                                      (catch_errora
(forallM
  (check_supteqproj_pred (B1_, B2_, B3_, B4_, B6_) (C1_, C2_, C3_) pia ff)
  (filtera
    (fn lr =>
      member (ceq_prod B1_ ceq_nat, ccompare_prod B2_ ccompare_nat)
        (the (root (fst lr))) ff)
    re))
(fn x => Inl (snd x)))
                                      (fn x =>
Inl (shows_prec_list show_char zero_nata
       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n",
         #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"r",
         #"u", #"l", #"e", #"s", #" ", #"w", #"i", #"t", #"h", #" ", #"r", #"o",
         #"o", #"t", #" ", #"i", #"n", #" ", #"F", #"\n"] o
      x)))
                                (fn _ =>
                                  bindb (catch_errora
  (catch_errora
    (forallM
      (check_supteqproj_pred (B1_, B2_, B3_, B4_, B6_) (C1_, C2_, C3_) pia ff)
      pns)
    (fn x => Inl (snd x)))
  (fn x =>
    Inl (shows_prec_list show_char zero_nata
           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
             #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g",
             #" ", #"D", #"P", #"s", #"\n"] o
          x)))
                                    (fn _ =>
                                      catch_errora
(catch_errora
  (forallM
    (check_suptproj_pred (B1_, B2_, B3_, B4_, B6_) (C1_, C2_, C3_) pia ff) ps)
  (fn x => Inl (snd x)))
(fn x =>
  Inl (shows_prec_list show_char zero_nata
         [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
           #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g",
           #" ", #"D", #"P", #"s", #"\n"] o
        x)))))))
                end)
          end
          (fn x =>
            Inl (shows_prec_list show_char zero_nata
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"a", #"p", #"p", #"l", #"y", #" ", #"t", #"h", #"e", #" ",
                     #"A", #"C", #" ", #"s", #"u", #"b", #"t", #"e", #"r", #"m",
                     #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r",
                     #"\n"] o
                  x))
    of Inl a => Inl a | Inr _ => Inr (delete_pairs_rulesa i dpp p_remove []));

fun intersect_pairsc
  (Ac_dpp_ops_ext
    (ac_dpp, p, pw, pairs, r, rw, rules, e, mk, eq_rules_map,
      reverse_eq_rules_map, delete_pairs_rules, eq_rules_no_left_var,
      eq_rules_non_collapsing, intersect_pairs, more))
  = intersect_pairs;

fun graph_approx_edg_rt_sym (A1_, A2_) m (uu, (uv, ct)) =
  graph_approx_rt_sym_main (A1_, A2_) m ct;

fun eq_rules_non_collapsinga
  (Ac_dpp_ops_ext
    (ac_dpp, p, pw, pairs, r, rw, rules, e, mk, eq_rules_map,
      reverse_eq_rules_map, delete_pairs_rules, eq_rules_no_left_var,
      eq_rules_non_collapsing, intersect_pairs, more))
  = eq_rules_non_collapsing;

fun reverse_eq_rules_map
  (Ac_dpp_ops_ext
    (ac_dpp, p, pw, pairs, r, rw, rules, e, mk, eq_rules_map,
      reverse_eq_rules_map, delete_pairs_rules, eq_rules_no_left_var,
      eq_rules_non_collapsing, intersect_pairs, more))
  = reverse_eq_rules_map;

fun reverse_tcapRM_ac_dpp B_ C_ i dpp =
  tcapRM B_ C_ (eq_rules_non_collapsinga i dpp) (reverse_eq_rules_map i dpp);

fun check_ac_dep_graph_proc (B1_, B2_, B3_, B4_, B5_) i dpp dps =
  let
    val c = tcapRM_ac_dpp B2_ (equal_list equal_char) i dpp;
    val rc = reverse_tcapRM_ac_dpp B2_ (equal_list equal_char) i dpp;
    val p = pairsc i dpp;
  in
    bindb (catch_errora
            (check_subseteq
              (equal_prod (equal_term B2_ (equal_list equal_char))
                (equal_term B2_ (equal_list equal_char)))
              p (maps snd dps))
            (fn x =>
              Inl (shows_string
                     [#"D", #"e", #"p", #"e", #"n", #"d", #"e", #"n", #"c",
                       #"y", #" ", #"P", #"a", #"i", #"r", #" "] o
                    (shows_rule (shows_prec B5_ zero_nata)
                       (shows_prec_list show_char zero_nata)
                       [#" ", #"-", #">", #" "] x o
                      (shows_string
                         [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i",
                           #"n", #"g", #" ", #"i", #"n", #" ", #"d", #"e", #"c",
                           #"o", #"m", #"p", #"o", #"s", #"i", #"t", #"i", #"o",
                           #"n"] o
                        shows_nl)))))
      (fn _ =>
        catch_errora
          (check_graph_decomp
            (shows_prec_prod (show_term B5_ (show_list show_char))
               (show_term B5_ (show_list show_char)) zero_nata o
              fst)
            (emptyd
              (ccompare_option (ccompare_prod B1_ ccompare_nat),
                mapping_impl_option (mapping_impl_prod B4_ mapping_impl_nat))
              (root o fst o fst))
            (graph_approx_edg_rt_sym (B1_, B2_))
            (insertd
              (ccompare_option (ccompare_prod B1_ ccompare_nat),
                equal_option (equal_prod B2_ equal_nat)))
            (fn (a, b) =>
              let
                val (aa, ba) = a;
              in
                let
                  val (_, t) = aa;
                in
                  (fn (_, ct) => fn (ab, bb) =>
                    let
                      val (u, _) = ab;
                    in
                      (fn (cu, _) =>
                        matchb B2_ (equal_list equal_char) ct u andalso
                          matchb B2_ (equal_list equal_char) cu t)
                    end
                      bb)
                end
                  ba
              end
                b)
            (map (fn (real, cs) =>
                   (not (is_none real),
                     map (fn (s, t) => ((s, t), (rc s, c t))) cs))
              dps))
          (fn x =>
            Inl (shows_string
                   [#"o", #"u", #"r", #" ", #"e", #"s", #"t", #"i", #"m", #"a",
                     #"t", #"i", #"o", #"n", #" ", #"(", #"E", #"D", #"G", #"*",
                     #"*", #"*", #")", #" ", #"c", #"o", #"u", #"l", #"d", #" ",
                     #"n", #"o", #"t", #" ", #"s", #"h", #"o", #"w", #" ", #"t",
                     #"h", #"a", #"t", #" ", #"y", #"o", #"u", #" ", #"h", #"a",
                     #"v", #"e", #" ", #"a", #" ", #"v", #"a", #"l", #"i", #"d",
                     #" ", #"d", #"e", #"c", #"o", #"m", #"p", #"o", #"s", #"i",
                     #"t", #"i", #"o", #"n", #" "] o
                  (shows_string
                     [#"d", #"u", #"e", #" ", #"t", #"o", #" ", #"t", #"h",
                       #"e", #" ", #"f", #"o", #"l", #"l", #"o", #"w", #"i",
                       #"n", #"g", #" ", #"r", #"e", #"a", #"s", #"o", #"n"] o
                    (shows_nl o x)))))
  end;

fun ac_dep_graph_proc (B1_, B2_, B3_, B4_, B5_) i d dps =
  (case check_ac_dep_graph_proc (B1_, B2_, B3_, B4_, B5_) i d dps
    of Inl a => Inl a
    | Inr _ =>
      Inr (map_filter
            (fn x =>
              (if not (is_none (fst x))
                then SOME (the (fst x), intersect_pairsc i d (snd x))
                else NONE))
            dps));

fun shows_ac_dpp funa var i d =
  let
    val p = pc i d;
    val pw = pwc i d;
    val r = rg i d;
    val rw = rwe i d;
    val e = ec i d;
  in
    (if null p then id
      else shows_trs funa var [#"p", #"a", #"i", #"r", #"s", #":"]
             [#" ", #"-", #">", #" "] p) o
      (if null pw then id
        else shows_trs funa var
               [#"w", #"e", #"a", #"k", #" ", #"p", #"a", #"i", #"r", #"s",
                 #":"]
               [#" ", #"-", #">", #"=", #" "] pw) o
      (if null r then id
        else shows_trs funa var
               [#"s", #"t", #"r", #"i", #"c", #"t", #" ", #"r", #"u", #"l",
                 #"e", #"s", #":"]
               [#" ", #"-", #">", #"!", #" "] r) o
      (if null rw then id
        else shows_trs funa var [#"r", #"u", #"l", #"e", #"s", #":"]
               [#" ", #"-", #">", #" "] rw) o
      (if null e then id
        else shows_trs funa var
               [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"s", #":"]
               [#" ", #"-", #">", #" "] e)
  end;

fun check_ac_dp_termination_proof (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) ia i
  dpp AC_P_is_Empty =
  debug (i []) [#"P", #" ", #"i", #"s", #" ", #"e", #"m", #"p", #"t", #"y"]
    (catch_errora (ac_dpp_trivial_check ia dpp)
      (fn x =>
        Inl (i o shows_prec_list show_char zero_nata
                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n",
                     #" ", #"a", #"p", #"p", #"l", #"y", #"i", #"n", #"g", #" ",
                     #"t", #"r", #"i", #"v", #"i", #"a", #"l", #" ", #"c", #"h",
                     #"e", #"c", #"k", #" ", #"o", #"n", #"\n"] o
               shows_ac_dpp (shows_prec B8_ zero_nata)
                 (shows_prec_list show_char zero_nata) ia dpp o
              x)))
  | check_ac_dp_termination_proof (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) ia i
    dpp (AC_Redpair_UR_Proc (redp, del_p, ur, prf)) =
    debug (i [])
      [#"A", #"C", #"_", #"R", #"e", #"d", #"p", #"a", #"i", #"r", #"_", #"U",
        #"R", #"_", #"P", #"r", #"o", #"c"]
      (bindb
        (catch_errora
          (ac_ur_redpair_proc
            (B1_, B2_, B3_, (compare_compare_order o compare_order_key) B5_,
              B4_, B7_, B8_)
            (ccompare_list ccompare_char, compare_list compare_char,
              equal_list equal_char, mapping_impl_list, show_list show_char)
            ia (get_redtriple (B2_, B3_, B4_, B5_, B7_, B8_) redp) del_p ur dpp)
          (fn x =>
            Inl (i o shows_prec_list show_char zero_nata
                       [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                         #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                         #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"a",
                         #"c", #"-", #"r", #"e", #"d", #"u", #"c", #"t", #"i",
                         #"o", #"n", #" ", #"p", #"a", #"i", #"r", #" ", #"p",
                         #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r", #" ",
                         #"t", #"o", #" ", #"r", #"e", #"m", #"o", #"v", #"e",
                         #" ", #"f", #"r", #"o", #"m", #" ", #"t", #"h", #"e",
                         #" ", #"D", #"P", #" ", #"p", #"r", #"o", #"b", #"l",
                         #"e", #"m", #"\n"] o
                   shows_ac_dpp (shows_prec B8_ zero_nata)
                     (shows_prec_list show_char zero_nata) ia dpp o
                   shows_prec_list show_char zero_nata
                     [#"\n", #" ", #"t", #"h", #"e", #" ", #"p", #"a", #"i",
                       #"r", #"s", #"\n"] o
                   shows_rules (shows_prec B8_ zero_nata)
                     (shows_prec_list show_char zero_nata)
                     [#" ", #"-", #">", #" "] del_p o
                   shows_nl o
                  x)))
        (fn dppa =>
          catch_errora
            (check_ac_dp_termination_proof
              (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) ia
              (i o shows_prec_list show_char zero_nata [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o shows_prec_list show_char zero_nata
                         [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                           #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e", #" ",
                           #"a", #"c", #"-", #"r", #"e", #"d", #"u", #"c", #"t",
                           #"i", #"o", #"n", #" ", #"p", #"a", #"i", #"r", #" ",
                           #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r",
                           #"\n"] o
                    indent x))))
  | check_ac_dp_termination_proof (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) ia i
    dpp (AC_Subterm_Proc (pi, del_p, prf)) =
    debug (i [])
      [#"A", #"C", #"_", #"S", #"u", #"b", #"t", #"e", #"r", #"m", #"_", #"P",
        #"r", #"o", #"c"]
      (bindb
        (catch_errora
          (ac_subterm_proc
            (B2_, B3_, (compare_compare_order o compare_order_key) B5_, B4_,
              B7_, B8_)
            (compare_list compare_char, equal_list equal_char,
              show_list show_char)
            ia pi del_p dpp)
          (fn x =>
            Inl (i o shows_prec_list show_char zero_nata
                       [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                         #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                         #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"a",
                         #"c", #"-", #"s", #"u", #"b", #"t", #"e", #"r", #"m",
                         #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o",
                         #"r", #" ", #"t", #"o", #" ", #"r", #"e", #"m", #"o",
                         #"v", #"e", #" ", #"f", #"r", #"o", #"m", #" ", #"t",
                         #"h", #"e", #" ", #"D", #"P", #" ", #"p", #"r", #"o",
                         #"b", #"l", #"e", #"m", #"\n"] o
                   shows_ac_dpp (shows_prec B8_ zero_nata)
                     (shows_prec_list show_char zero_nata) ia dpp o
                   shows_prec_list show_char zero_nata
                     [#"\n", #" ", #"t", #"h", #"e", #" ", #"p", #"a", #"i",
                       #"r", #"s", #"\n"] o
                   shows_rules (shows_prec B8_ zero_nata)
                     (shows_prec_list show_char zero_nata)
                     [#" ", #"-", #">", #" "] del_p o
                   shows_nl o
                  x)))
        (fn dppa =>
          catch_errora
            (check_ac_dp_termination_proof
              (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) ia
              (i o shows_prec_list show_char zero_nata [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o shows_prec_list show_char zero_nata
                         [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                           #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e", #" ",
                           #"a", #"c", #"-", #"r", #"e", #"d", #"u", #"c", #"t",
                           #"i", #"o", #"n", #" ", #"p", #"a", #"i", #"r", #" ",
                           #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r",
                           #"\n"] o
                    indent x))))
  | check_ac_dp_termination_proof (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) ia i
    dpp (AC_Mono_Redpair_UR_Proc (redp, del_p, del_r, ur, prf)) =
    debug (i [])
      [#"A", #"C", #"_", #"M", #"o", #"n", #"o", #"_", #"R", #"e", #"d", #"p",
        #"a", #"i", #"r", #"_", #"U", #"R", #"_", #"P", #"r", #"o", #"c"]
      (bindb
        (catch_errora
          (ac_mono_ur_redpair_proc
            (B1_, B2_, B3_, (compare_compare_order o compare_order_key) B5_,
              B4_, B7_, B8_)
            (ccompare_list ccompare_char, compare_list compare_char,
              equal_list equal_char, mapping_impl_list, show_list show_char)
            ia (get_redtriple (B2_, B3_, B4_, B5_, B7_, B8_) redp) del_p del_r
            ur dpp)
          (fn x =>
            Inl (i o shows_prec_list show_char zero_nata
                       [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                         #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                         #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"m",
                         #"o", #"n", #"o", #"t", #"o", #"n", #"e", #" ", #"a",
                         #"c", #"-", #"r", #"e", #"d", #"u", #"c", #"t", #"i",
                         #"o", #"n", #" ", #"p", #"a", #"i", #"r", #" ", #"p",
                         #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r", #" ",
                         #"t", #"o", #" ", #"r", #"e", #"m", #"o", #"v", #"e",
                         #" ", #"f", #"r", #"o", #"m", #" ", #"t", #"h", #"e",
                         #" ", #"D", #"P", #" ", #"p", #"r", #"o", #"b", #"l",
                         #"e", #"m", #"\n"] o
                   shows_ac_dpp (shows_prec B8_ zero_nata)
                     (shows_prec_list show_char zero_nata) ia dpp o
                   shows_prec_list show_char zero_nata
                     [#"\n", #" ", #"t", #"h", #"e", #" ", #"p", #"a", #"i",
                       #"r", #"s", #"\n"] o
                   shows_rules (shows_prec B8_ zero_nata)
                     (shows_prec_list show_char zero_nata)
                     [#" ", #"-", #">", #" "] del_p o
                   shows_prec_list show_char zero_nata
                     [#"\n", #" ", #"a", #"n", #"d", #" ", #"t", #"h", #"e",
                       #" ", #"r", #"u", #"l", #"e", #"s", #"\n"] o
                   shows_rules (shows_prec B8_ zero_nata)
                     (shows_prec_list show_char zero_nata)
                     [#" ", #"-", #">", #" "] del_r o
                   shows_nl o
                  x)))
        (fn dppa =>
          catch_errora
            (check_ac_dp_termination_proof
              (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) ia
              (i o shows_prec_list show_char zero_nata [#".", #"1"]) dppa prf)
            (fn x =>
              Inl (i o shows_prec_list show_char zero_nata
                         [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                           #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e", #" ",
                           #"m", #"o", #"n", #"o", #"t", #"o", #"n", #"e", #" ",
                           #"a", #"c", #"-", #"r", #"e", #"d", #"u", #"c", #"t",
                           #"i", #"o", #"n", #" ", #"p", #"a", #"i", #"r", #" ",
                           #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r",
                           #"\n"] o
                    indent x))))
  | check_ac_dp_termination_proof (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) ia i
    dpp (AC_Dep_Graph_Proc edpts) =
    debug (i [])
      [#"D", #"e", #"p", #"_", #"G", #"r", #"a", #"p", #"h", #"_", #"P", #"r",
        #"o", #"c"]
      (bindb
        (catch_errora (ac_dep_graph_proc (B3_, B4_, B5_, B6_, B8_) ia dpp edpts)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"i", #"l", #"e", #" ", #"t", #"r", #"y", #"i",
                          #"n", #"g", #" ", #"t", #"o", #" ", #"p", #"e", #"r",
                          #"f", #"o", #"r", #"m", #" ", #"S", #"c", #"t", #"x",
                          #"t", #"_", #"c", #"l", #"o", #"s", #"u", #"r", #"e",
                          #"-", #"d", #"e", #"c", #"o", #"m", #"p", #"o", #"s",
                          #"i", #"t", #"i", #"o", #"n", #" ", #" ", #"o", #"n",
                          #" "] o
                       (shows_nl o
                         (shows_ac_dpp (shows_prec B8_ zero_nata)
                            (shows_prec_list show_char zero_nata) ia dpp o
                           (shows_nl o x)))))))
        (fn pdpps =>
          catch_errora
            (catch_errora
              (forallM_index
                (fn (prof, dppa) => fn j =>
                  check_ac_dp_termination_proof
                    (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) ia
                    (i o (shows_string [#"."] o
                           shows_prec_nat zero_nata (suc j)))
                    dppa prof)
                pdpps)
              (fn x => Inl (snd x)))
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"d", #"e", #"p", #"e", #"n", #"d", #"e",
                            #"n", #"c", #"y", #" ", #"g", #"r", #"a", #"p",
                            #"h", #" ", #"p", #"r", #"o", #"c", #"e", #"s",
                            #"s", #"o", #"r"] o
                         (shows_nl o indent x))))));

fun ac_dependency_pairs_proc (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
  (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_, C9_) i j shp x y z
  (AC_dependency_pairs_proof (e, dpr, dpe, rext)) tp =
  bindb (ac_dependency_pairs_checks (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
          (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_, C9_) i shp x y z
          (AC_dependency_pairs_proof (e, dpr, dpe, rext)) tp)
    (fn _ =>
      let
        val r = rf i tp;
      in
        Inr (mkf j dpr dpe [] r e,
              mkf j (map (fn (l, ra) => (sharp_term shp l, sharp_term shp ra))
                      rext)
                dpe [] r e)
      end);

fun delete_rulesa (Ac_tp_ops_ext (ac_tp, r, a, c, mk, delete_rules, e, more)) =
  delete_rules;

fun eb (Ac_tp_ops_ext (ac_tp, r, a, c, mk, delete_rules, e, more)) = e;

fun ac_rule_removal (B1_, B2_, B3_) (C1_, C2_, C3_) i rp r_remove tp =
  (case catch_errora
          let
            val r = rf i tp;
            val e = eb i tp;
            val rremove =
              set (ceq_prod (ceq_term B2_ C2_) (ceq_term B2_ C2_),
                    ccompare_prod (ccompare_term B1_ C1_)
                      (ccompare_term B1_ C1_),
                    set_impl_prod set_impl_term set_impl_term)
                r_remove;
            val rns =
              filtera
                (fn lr =>
                  not (member
                        (ceq_prod (ceq_term B2_ C2_) (ceq_term B2_ C2_),
                          ccompare_prod (ccompare_term B1_ C1_)
                            (ccompare_term B1_ C1_))
                        lr rremove))
                r;
          in
            bindb (valid rp)
              (fn _ =>
                bindb (mono rp (r_remove @ rns @ e))
                  (fn _ =>
                    bindb (catch_errora
                            (catch_errora (forallM (ns rp) rns)
                              (fn x => Inl (snd x)))
                            (fn x =>
                              Inl (shows_prec_list show_char zero_nata
                                     [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                       #" ", #"w", #"h", #"e", #"n", #" ", #"o",
                                       #"r", #"i", #"e", #"n", #"t", #"i", #"n",
                                       #"g", #" ", #"w", #"e", #"a", #"k", #" ",
                                       #"r", #"u", #"l", #"e", #"s", #"\n"] o
                                    x)))
                      (fn _ =>
                        bindb (catch_errora
                                (catch_errora (forallM (ns rp) e)
                                  (fn x => Inl (snd x)))
                                (fn x =>
                                  Inl (shows_prec_list show_char zero_nata
 [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n", #" ",
   #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"e", #"q", #"u",
   #"a", #"t", #"i", #"o", #"n", #"s", #"\n"] o
x)))
                          (fn _ =>
                            catch_errora
                              (catch_errora (forallM (s rp) r_remove)
                                (fn x => Inl (snd x)))
                              (fn x =>
                                Inl (shows_prec_list show_char zero_nata
                                       [#"p", #"r", #"o", #"b", #"l", #"e",
 #"m", #" ", #"w", #"h", #"e", #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t",
 #"i", #"n", #"g", #" ", #"s", #"t", #"r", #"i", #"c", #"t", #" ", #"r", #"u",
 #"l", #"e", #"s", #"\n"] o
                                      x))))))
          end
          (fn x =>
            Inl (shows_prec_list show_char zero_nata
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"a", #"p", #"p", #"l", #"y", #" ", #"A", #"C", #" ", #"r",
                     #"u", #"l", #"e", #" ", #"r", #"e", #"m", #"o", #"v", #"a",
                     #"l", #" ", #"w", #"i", #"t", #"h", #" ", #"t", #"h", #"e",
                     #" ", #"f", #"o", #"l", #"l", #"o", #"w", #"i", #"n", #"g",
                     #"\n"] o
                   desc rp o
                   shows_nl o
                  x))
    of Inl a => Inl a | Inr _ => Inr (delete_rulesa i tp r_remove));

fun shows_ac_tp B_ C_ i t =
  let
    val r = rf i t;
    val aa = a i t;
    val ca = c i t;
  in
    shows_trs (shows_prec B_ zero_nata) (shows_prec C_ zero_nata)
      [#"r", #"u", #"l", #"e", #"s", #":"] [#" ", #"-", #">", #" "] r o
      (if null aa then id
        else shows_prec_list show_char zero_nata
               [#"A", #"-", #"s", #"y", #"m", #"b", #"o", #"l", #"s", #":",
                 #" "] o
               shows_prec_list B_ zero_nata aa o
               shows_nl) o
      (if null ca then id
        else shows_prec_list show_char zero_nata
               [#"C", #"-", #"s", #"y", #"m", #"b", #"o", #"l", #"s", #":",
                 #" "] o
               shows_prec_list B_ zero_nata ca o
               shows_nl)
  end;

fun check_ac_termination_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia j i tp
  (AC_DP_Trans (info, prf1, prf2)) =
  debug (i [])
    [#"A", #"C", #" ", #"D", #"e", #"p", #"e", #"n", #"d", #"e", #"n", #"c",
      #"y", #" ", #"P", #"a", #"i", #"r", #"s"]
    (bindb
      (catch_errora
        (ac_dependency_pairs_proc
          (cenum_lab, ceq_lab B1_ C1_,
            ccompare_lab ((compare_compare_order o compare_order_key) B2_)
              ((compare_compare_order o compare_order_key) C2_),
            compare_lab ((compare_compare_order o compare_order_key) B2_)
              ((compare_compare_order o compare_order_key) C2_),
            equal_lab B1_ C1_, set_impl_lab, show_lab B3_ C3_)
          (finite_UNIV_list, cenum_list, ceq_list ceq_char,
            cproper_interval_list ccompare_char, compare_list compare_char,
            equal_list equal_char, mapping_impl_list, set_impl_list,
            show_list show_char)
          j ia Sharp [#"x"] [#"y"] [#"z"] info tp)
        (fn x =>
          Inl (i o shows_prec_list show_char zero_nata
                     [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                       #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                       #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"a",
                       #"c", #"-", #"d", #"e", #"p", #"e", #"n", #"d", #"e",
                       #"n", #"c", #"y", #" ", #"p", #"a", #"i", #"r", #" ",
                       #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r",
                       #" ", #"o", #"n", #"\n"] o
                 shows_ac_tp (show_lab B3_ C3_) (show_list show_char) j tp o
                x)))
      (fn (dp1, dp2) =>
        bindb (catch_errora
                (check_ac_dp_termination_proof
                  (cenum_lab, ceq_lab B1_ C1_,
                    ccompare_lab
                      ((compare_compare_order o compare_order_key) B2_)
                      ((compare_compare_order o compare_order_key) C2_),
                    equal_lab B1_ C1_, key_lab B2_ C2_, mapping_impl_lab,
                    set_impl_lab, show_lab B3_ C3_)
                  ia (i o shows_prec_list show_char zero_nata [#".", #"1"]) dp1
                  prf1)
                (fn x =>
                  Inl (i o shows_prec_list show_char zero_nata
                             [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                               #"b", #"e", #"l", #"o", #"w", #" ", #"t", #"h",
                               #"e", #" ", #"a", #"c", #"-", #"d", #"e", #"p",
                               #"e", #"n", #"d", #"e", #"n", #"c", #"y", #" ",
                               #"p", #"a", #"i", #"r", #" ", #"p", #"r", #"o",
                               #"c", #"e", #"s", #"s", #"o", #"r", #"\n"] o
                        indent x)))
          (fn _ =>
            catch_errora
              (check_ac_dp_termination_proof
                (cenum_lab, ceq_lab B1_ C1_,
                  ccompare_lab ((compare_compare_order o compare_order_key) B2_)
                    ((compare_compare_order o compare_order_key) C2_),
                  equal_lab B1_ C1_, key_lab B2_ C2_, mapping_impl_lab,
                  set_impl_lab, show_lab B3_ C3_)
                ia (i o shows_prec_list show_char zero_nata [#".", #"2"]) dp2
                prf2)
              (fn x =>
                Inl (i o shows_prec_list show_char zero_nata
                           [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                             #"b", #"e", #"l", #"o", #"w", #" ", #"t", #"h",
                             #"e", #" ", #"a", #"c", #"-", #"d", #"e", #"p",
                             #"e", #"n", #"d", #"e", #"n", #"c", #"y", #" ",
                             #"p", #"a", #"i", #"r", #" ", #"p", #"r", #"o",
                             #"c", #"e", #"s", #"s", #"o", #"r", #"\n"] o
                      indent x)))))
  | check_ac_termination_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia j i tp
    (AC_DP_Trans_Single (info, prf1)) =
    debug (i [])
      [#"A", #"C", #" ", #"D", #"e", #"p", #"e", #"n", #"d", #"e", #"n", #"c",
        #"y", #" ", #"P", #"a", #"i", #"r", #"s"]
      (bindb
        (catch_errora
          (ac_dependency_pairs_proc_simple
            (cenum_lab, ceq_lab B1_ C1_,
              ccompare_lab ((compare_compare_order o compare_order_key) B2_)
                ((compare_compare_order o compare_order_key) C2_),
              compare_lab ((compare_compare_order o compare_order_key) B2_)
                ((compare_compare_order o compare_order_key) C2_),
              equal_lab B1_ C1_, set_impl_lab, show_lab B3_ C3_)
            (finite_UNIV_list, cenum_list, ceq_list ceq_char,
              cproper_interval_list ccompare_char, compare_list compare_char,
              equal_list equal_char, mapping_impl_list, set_impl_list,
              show_list show_char)
            j ia Sharp [#"x"] [#"y"] [#"z"] info tp)
          (fn x =>
            Inl (i o shows_prec_list show_char zero_nata
                       [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                         #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                         #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"a",
                         #"c", #"-", #"d", #"e", #"p", #"e", #"n", #"d", #"e",
                         #"n", #"c", #"y", #" ", #"p", #"a", #"i", #"r", #" ",
                         #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o", #"r",
                         #" ", #"o", #"n", #"\n"] o
                   shows_ac_tp (show_lab B3_ C3_) (show_list show_char) j tp o
                  x)))
        (fn dp1 =>
          catch_errora
            (check_ac_dp_termination_proof
              (cenum_lab, ceq_lab B1_ C1_,
                ccompare_lab ((compare_compare_order o compare_order_key) B2_)
                  ((compare_compare_order o compare_order_key) C2_),
                equal_lab B1_ C1_, key_lab B2_ C2_, mapping_impl_lab,
                set_impl_lab, show_lab B3_ C3_)
              ia (i o shows_prec_list show_char zero_nata [#".", #"1"]) dp1
              prf1)
            (fn x =>
              Inl (i o shows_prec_list show_char zero_nata
                         [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                           #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e", #" ",
                           #"a", #"c", #"-", #"d", #"e", #"p", #"e", #"n", #"d",
                           #"e", #"n", #"c", #"y", #" ", #"p", #"a", #"i", #"r",
                           #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o",
                           #"r", #"\n"] o
                    indent x))))
  | check_ac_termination_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia j i tp
    (AC_Rule_Removal (redp, del_r, prf)) =
    debug (i [])
      [#"A", #"C", #"_", #"M", #"o", #"n", #"o", #"_", #"R", #"e", #"d", #"p",
        #"a", #"i", #"r", #"_", #"U", #"R", #"_", #"P", #"r", #"o", #"c"]
      (bindb
        (catch_errora
          (ac_rule_removal
            (compare_lab ((compare_compare_order o compare_order_key) B2_)
               ((compare_compare_order o compare_order_key) C2_),
              equal_lab B1_ C1_, show_lab B3_ C3_)
            (compare_list compare_char, equal_list equal_char,
              show_list show_char)
            j (get_redtriple
                (ceq_lab B1_ C1_,
                  ccompare_lab ((compare_compare_order o compare_order_key) B2_)
                    ((compare_compare_order o compare_order_key) C2_),
                  equal_lab B1_ C1_, key_lab B2_ C2_, set_impl_lab,
                  show_lab B3_ C3_)
                redp)
            del_r tp)
          (fn x =>
            Inl (i o shows_prec_list show_char zero_nata
                       [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                         #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                         #"i", #"n", #"g", #" ", #"a", #"c", #"-", #"r", #"u",
                         #"l", #"e", #" ", #"r", #"e", #"m", #"o", #"v", #"a",
                         #"l", #" ", #"t", #"o", #" ", #"r", #"e", #"m", #"o",
                         #"v", #"e", #" ", #"f", #"r", #"o", #"m", #" ", #"t",
                         #"h", #"e", #" ", #"A", #"C", #" ", #"t", #"e", #"r",
                         #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n", #" ",
                         #"p", #"r", #"o", #"b", #"l", #"e", #"m", #"\n"] o
                   shows_ac_tp (show_lab B3_ C3_) (show_list show_char) j tp o
                   shows_prec_list show_char zero_nata
                     [#"\n", #" ", #"t", #"h", #"e", #" ", #"r", #"u", #"l",
                       #"e", #"s", #"\n"] o
                   shows_rules (shows_prec_lab B3_ C3_ zero_nata)
                     (shows_prec_list show_char zero_nata)
                     [#" ", #"-", #">", #" "] del_r o
                   shows_nl o
                  x)))
        (fn tpa =>
          catch_errora
            (check_ac_termination_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia j
              (i o shows_prec_list show_char zero_nata [#".", #"1"]) tpa prf)
            (fn x =>
              Inl (i o shows_prec_list show_char zero_nata
                         [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                           #"e", #"l", #"o", #"w", #" ", #"a", #"c", #"-", #"r",
                           #"u", #"l", #"e", #" ", #"r", #"e", #"m", #"o", #"v",
                           #"a", #"l", #"\n"] o
                    indent x))))
  | check_ac_termination_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia j i tp
    AC_R_is_Empty =
    debug (i [])
      [#"A", #"C", #"_", #"R", #"_", #"i", #"s", #"_", #"E", #"m", #"p", #"t",
        #"y"]
      (catch_errora
        (check (null (rf j tp))
          (shows_prec_list show_char zero_nata
            [#"T", #"h", #"e", #" ", #"T", #"R", #"S", #" ", #"i", #"s", #" ",
              #"n", #"o", #"t", #" ", #"e", #"m", #"p", #"t", #"y"]))
        (fn x =>
          Inl (i o shows_prec_list show_char zero_nata
                     [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                       #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                       #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"R",
                       #"-", #"i", #"s", #"-", #"E", #"m", #"p", #"t", #"y",
                       #" ", #"c", #"h", #"e", #"c", #"k", #" ", #"o", #"n",
                       #" ", #"t", #"h", #"e", #" ", #"A", #"C", #" ", #"t",
                       #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o",
                       #"n", #" ", #"p", #"r", #"o", #"b", #"l", #"e", #"m",
                       #"\n"] o
                 shows_ac_tp (show_lab B3_ C3_) (show_list show_char) j tp o
                 shows_nl o
                x)));

fun equal_strategy A_ B_ Innermost (Innermost_Q x3) = false
  | equal_strategy A_ B_ (Innermost_Q x3) Innermost = false
  | equal_strategy A_ B_ No_Strategy (Innermost_Q x3) = false
  | equal_strategy A_ B_ (Innermost_Q x3) No_Strategy = false
  | equal_strategy A_ B_ No_Strategy Innermost = false
  | equal_strategy A_ B_ Innermost No_Strategy = false
  | equal_strategy A_ B_ (Innermost_Q x3) (Innermost_Q y3) =
    equal_lista (equal_term A_ B_) x3 y3
  | equal_strategy A_ B_ Innermost Innermost = true
  | equal_strategy A_ B_ No_Strategy No_Strategy = true;

fun shows_transition D_ shows_tatom (Transition (s, t, phi)) =
  shows_prec D_ zero_nata s o
    shows_prec_list show_char zero_nata [#" ", #"-", #"-", #"-", #">", #" "] o
    shows_prec D_ zero_nata t o
    shows_prec_list show_char zero_nata [#":", #" "] o
    shows_formula shows_tatom phi;

fun transition_hintsa
  (Hinter_ext (nodes, succ_trans_list, cover_hints, transition_hints, more)) =
  transition_hints;

fun node_invariant
  (Art_ext (initial_nodes, nodes, edge, node_location, node_invariant, more)) =
  node_invariant;

fun rename_vars_exp r = map_term id (map_prod r id);

fun nodesa
  (Hinter_ext (nodes, succ_trans_list, cover_hints, transition_hints, more)) =
  nodes;

fun map_formula f (Atom x1) = Atom (f x1)
  | map_formula f (NegAtom x2) = NegAtom (f x2)
  | map_formula f (Conjunction x3) = Conjunction (map (map_formula f) x3)
  | map_formula f (Disjunction x4) = Disjunction (map (map_formula f) x4);

fun edge
  (Art_ext (initial_nodes, nodes, edge, node_location, node_invariant, more)) =
  edge;

fun check_children_edges_cond (A1_, A2_) (B1_, B2_) (C1_, C2_) (D1_, D2_) E_ F_
  tc2 sa2 ne2 a p h =
  let
    val lc = assertion p;
  in
    catch_errora
      (catch_errora
        (forallM
          (fn aa =>
            (case edge a aa of Cover _ => Inr ()
              | Children children =>
                (case transition_hintsa h aa
                  of NONE =>
                    Inl (shows_prec_list show_char zero_nata
                          [#"n", #"o", #"t", #" ", #"y", #"e", #"t"])
                  | SOME hints =>
                    catch_errora
                      (bindb
                        (check
                          (equal_nata (size_list hints) (size_list children))
                          (shows_prec_list show_char zero_nata
                            [#"t", #"h", #"e", #" ", #"n", #"u", #"m", #"b",
                              #"e", #"r", #" ", #"o", #"f", #" ", #"h", #"i",
                              #"n", #"t", #"s", #" ", #"d", #"i", #"f", #"f",
                              #"e", #"r", #"s", #" ", #"f", #"r", #"o", #"m",
                              #" ", #"t", #"h", #"e", #" ", #"n", #"u", #"m",
                              #"b", #"e", #"r", #" ", #"o", #"f", #" ", #"c",
                              #"h", #"i", #"l", #"d", #"r", #"e", #"n"]))
                        (fn _ =>
                          catch_errora
                            (forallM
                              (fn (b, c) =>
                                let
                                  val (tau, ba) = b;
                                in
                                  (fn ha =>
                                    let
                                      val Transition (l, _, phi) = tau;
                                    in
                                      catch_errora
(check_formula B1_ (equal_trans_var C1_, show_trans_var C2_) D1_ (A1_, A2_) sa2
  tc2 ne2 ha
  (Disjunction
    [map_formula (rename_vars_exp Post) (node_invariant a ba),
      form_not (map_formula (rename_vars_exp Pre) (node_invariant a aa)),
      form_not (map_formula (rename_vars_exp Pre) (lc l)), form_not phi]))
(fn x =>
  Inl (shows_prec_list show_char zero_nata
         [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
           #"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ", #"e", #"d",
           #"g", #"e", #" "] o
         shows_prec F_ zero_nata aa o
         shows_prec_list show_char zero_nata [#" ", #"-", #"-", #">", #" "] o
         shows_prec F_ zero_nata ba o
         shows_prec_list show_char zero_nata
           [#" ", #"f", #"o", #"r", #" ", #"t", #"r", #"a", #"n", #"s", #"i",
             #"t", #"i", #"o", #"n"] o
         shows_nl o
         shows_transition E_ sa2 tau o
         shows_nl o
        x))
                                    end)
                                end
                                  c)
                              (zip children hints))
                            (fn x => Inl (snd x))))
                      (fn x =>
                        Inl (shows_prec_list show_char zero_nata
                               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                                 #"i", #"n", #" ", #"c", #"h", #"e", #"c", #"k",
                                 #"i", #"n", #"g", #" ", #"t", #"r", #"a", #"n",
                                 #"s", #"i", #"t", #"i", #"o", #"n", #"s", #" ",
                                 #"o", #"f", #" ", #"n", #"o", #"d", #"e",
                                 #" "] o
                               shows_prec F_ zero_nata aa o
                               shows_nl o
                              x)))))
          (nodesa h))
        (fn x => Inl (snd x)))
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                 #"e", #"n", #"s", #"u", #"r", #"e", #" ", #"t", #"r", #"a",
                 #"n", #"s", #"i", #"t", #"i", #"o", #"n", #" ", #"e", #"d",
                 #"g", #"e", #" ", #"c", #"o", #"n", #"d", #"i", #"t", #"i",
                 #"o", #"n", #" ", #"o", #"f", #" ", #"A", #"R", #"T", #"\n"] o
              x))
  end;

fun is_cover_nodea (Cover x1) = true
  | is_cover_nodea (Children x2) = false;

fun cover_hintsa
  (Hinter_ext (nodes, succ_trans_list, cover_hints, transition_hints, more)) =
  cover_hints;

fun node_location
  (Art_ext (initial_nodes, nodes, edge, node_location, node_invariant, more)) =
  node_location;

fun nodes
  (Art_ext (initial_nodes, nodes, edge, node_location, node_invariant, more)) =
  nodes;

fun check_cover_edges_cond (A1_, A2_) (B1_, B2_) (C1_, C2_) (D1_, D2_) E_
  (F1_, F2_) tc sa ne a p h =
  let
    val _ = assertion p;
  in
    catch_errora
      (catch_errora
        (forallM
          (fn aa =>
            (case edge a aa
              of Cover b =>
                catch_errora
                  (bindb
                    (check (membera F1_ (nodes a) b)
                      (shows_prec_list show_char zero_nata
                        [#"t", #"a", #"r", #"g", #"e", #"t", #" ", #"n", #"o",
                          #"d", #"e", #" ", #"i", #"s", #" ", #"n", #"o", #"t",
                          #" ", #"l", #"i", #"s", #"t", #"e", #"d", #" ", #"a",
                          #"s", #" ", #"a", #"r", #"t", #"-", #"n", #"o", #"d",
                          #"e"]))
                    (fn _ =>
                      bindb (check
                              (eq E_ (node_location a aa) (node_location a b))
                              (shows_prec_list show_char zero_nata
                                [#"n", #"o", #"d", #"e", #"-", #"l", #"o", #"c",
                                  #"a", #"t", #"i", #"o", #"n", #"s", #" ",
                                  #"d", #"i", #"f", #"f", #"e", #"r"]))
                        (fn _ =>
                          bindb (check (not (is_cover_nodea (edge a b)))
                                  (shows_prec_list show_char zero_nata
                                    [#"t", #"a", #"r", #"g", #"e", #"t", #" ",
                                      #"n", #"o", #"d", #"e", #" ", #"m", #"u",
                                      #"s", #"t", #" ", #"n", #"o", #"t", #" ",
                                      #"h", #"a", #"v", #"e", #" ", #"c", #"o",
                                      #"v", #"e", #"r", #" ", #"e", #"d", #"g",
                                      #"e"]))
                            (fn _ =>
                              check_formula B1_ (C1_, C2_) D1_ (A1_, A2_) sa tc
                                ne (cover_hintsa h aa)
                                (Disjunction
                                  [node_invariant a b,
                                    form_not (node_invariant a aa)])))))
                  (fn x =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                             #"i", #"n", #" ", #"c", #"h", #"e", #"c", #"k",
                             #"i", #"n", #"g", #" ", #"c", #"o", #"v", #"e",
                             #"r", #" ", #"e", #"d", #"g", #"e", #" ", #"o",
                             #"f", #" ", #"n", #"o", #"d", #"e", #" "] o
                           shows_prec F2_ zero_nata aa o
                           shows_nl o
                          x))
              | Children _ => Inr ()))
          (nodesa h))
        (fn x => Inl (snd x)))
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                 #"e", #"n", #"s", #"u", #"r", #"e", #" ", #"c", #"o", #"v",
                 #"e", #"r", #" ", #"e", #"d", #"g", #"e", #" ", #"c", #"o",
                 #"n", #"d", #"i", #"t", #"i", #"o", #"n", #" ", #"o", #"f",
                 #" ", #"A", #"R", #"T", #"\n"] o
              x))
  end;

fun succ_trans_list
  (Hinter_ext (nodes, succ_trans_list, cover_hints, transition_hints, more)) =
  succ_trans_list;

fun initial_nodes
  (Art_ext (initial_nodes, nodes, edge, node_location, node_invariant, more)) =
  initial_nodes;

fun check_simulation_cond (A1_, A2_) (B1_, B2_) (C1_, C2_) (D1_, D2_)
  (E1_, E2_, E3_, E4_, E5_, E6_) (F1_, F2_) tc sa ne a p h =
  catch_errora
    (bindb
      (check
        (less_eq_set (E1_, E2_, E3_) (initial p)
          (set (E2_, E3_, E5_) (map (node_location a) (initial_nodes a))))
        (shows_prec_list show_char zero_nata
          [#"n", #"o", #"t", #" ", #"a", #"l", #"l", #" ", #"i", #"n", #"i",
            #"t", #"i", #"a", #"l", #" ", #"n", #"o", #"d", #"e", #"s", #" ",
            #"o", #"f", #" ", #"L", #"T", #"S", #" ", #"a", #"r", #"e", #" ",
            #"r", #"e", #"p", #"r", #"e", #"s", #"e", #"n", #"t", #"e", #"d",
            #" ", #"b", #"y", #" ", #"i", #"n", #"i", #"t", #"i", #"a", #"l",
            #" ", #"n", #"o", #"d", #"e", #"s", #" ", #"i", #"n", #" ", #"A",
            #"R", #"T"]))
      (fn _ =>
        catch_errora
          (forallM
            (fn aa =>
              (case edge a aa of Cover _ => Inr ()
                | Children children =>
                  let
                    val l = node_location a aa;
                  in
                    catch_errora
                      (catch_errora
                        (forallM
                          (fn tau =>
                            check (list_ex
                                    (fn (taua, b) =>
                                      equal_transition_rule B1_ C1_ D1_ E4_ taua
tau andalso
(eq E4_ (node_location a b) (target tau) andalso membera F1_ (nodes a) b))
                                    children)
                              (shows_prec_list show_char zero_nata
                                 [#"c", #"o", #"u", #"l", #"d", #" ", #"n",
                                   #"o", #"t", #" ", #"f", #"i", #"n", #"d",
                                   #" ", #"m", #"a", #"t", #"c", #"h", #"i",
                                   #"n", #"g", #" ", #"t", #"r", #"a", #"n",
                                   #"s", #"i", #"t", #"i", #"o", #"n", #" ",
                                   #"i", #"n", #" ", #"A", #"R", #"T", #" ",
                                   #"f", #"o", #"r", #" ", #"n", #"o", #"d",
                                   #"e", #" "] o
                                 shows_prec F2_ zero_nata aa o
                                 shows_prec_list show_char zero_nata
                                   [#" ", #"a", #"n", #"d", #" ", #"t", #"r",
                                     #"a", #"n", #"s", #"i", #"t", #"i", #"o",
                                     #"n", #" "] o
                                 shows_prec E6_ zero_nata (source tau) o
                                 shows_prec_list show_char zero_nata
                                   [#" ", #"-", #"-", #">", #" "] o
                                shows_prec E6_ zero_nata (target tau)))
                          (succ_trans_list h l))
                        (fn x => Inl (snd x)))
                      (fn e1 =>
                        catch_errora
                          (check_valid_formula B1_ (C1_, C2_) D1_ (A1_, A2_) sa
                            tc ne (form_not (node_invariant a aa)))
                          (fn _ =>
                            Inl (e1 o shows_nl o
                                  shows_prec_list show_char zero_nata
                                    [#"a", #"n", #"d", #" ", #"c", #"o", #"u",
                                      #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                                      #"p", #"r", #"o", #"v", #"e", #" ", #"u",
                                      #"n", #"s", #"a", #"t", #"i", #"s", #"f",
                                      #"i", #"a", #"b", #"i", #"l", #"i", #"t",
                                      #"y", #" ", #"o", #"f", #" ", #"t", #"h",
                                      #"e", #" ", #"n", #"o", #"d", #"e", #" ",
                                      #"i", #"n", #"v", #"a", #"r", #"i", #"a",
                                      #"n", #"t"])))
                  end))
            (nodesa h))
          (fn x => Inl (snd x))))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"e",
               #"n", #"s", #"u", #"r", #"e", #" ", #"s", #"i", #"m", #"u", #"l",
               #"a", #"t", #"i", #"o", #"n", #" ", #"c", #"o", #"n", #"d", #"i",
               #"t", #"i", #"o", #"n", #" ", #"o", #"f", #" ", #"A", #"R", #"T",
               #"\n"] o
            x));

fun check_initial_cond (A1_, A2_) (B1_, B2_) (C1_, C2_) (E1_, E2_) sa a =
  catch_errora
    (forallM
      (fn init =>
        bindb (check (membera E1_ (nodes a) init)
                (shows_prec_list show_char zero_nata
                   [#"i", #"n", #"i", #"t", #"i", #"a", #"l", #" ", #"n", #"o",
                     #"d", #"e", #" ", #"o", #"f", #" ", #"A", #" ", #"("] o
                   shows_prec E2_ zero_nata init o
                  shows_prec_list show_char zero_nata
                    [#")", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"m",
                      #"e", #"n", #"t", #"i", #"o", #"n", #"e", #"d", #" ",
                      #"a", #"s", #" ", #"n", #"o", #"d", #"e", #" ", #"o",
                      #"f", #" ", #"A", #"R", #"T"]))
          (fn _ =>
            check (equal_formulaa (equal_term A1_ (equal_prod B1_ C1_))
                    (node_invariant a init) (Conjunction []))
              (shows_prec_list show_char zero_nata
                 [#"t", #"h", #"e", #" ", #"n", #"o", #"d", #"e", #" ", #"i",
                   #"n", #"v", #"a", #"r", #"i", #"a", #"n", #"t", #" ", #"f",
                   #"o", #"r", #" ", #"t", #"h", #"e", #" ", #"i", #"n", #"i",
                   #"t", #"i", #"a", #"l", #" ", #"A", #"R", #"T", #" ", #"n",
                   #"o", #"d", #"e", #" ", #"("] o
                 shows_prec E2_ zero_nata init o
                 shows_prec_list show_char zero_nata
                   [#")", #" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e", #" ",
                     #"T", #"R", #"U", #"E", #",", #" ", #" ", #"b", #"u", #"t",
                     #" ", #"i", #"t", #" ", #"i", #"s", #" "] o
                shows_formula sa (node_invariant a init))))
      (initial_nodes a))
    (fn x => Inl (snd x));

fun art A_ (B1_, B2_, B3_, B4_) type_of_fun bool_types a =
  list_all
    (fn aa =>
      formula (is_bool (B1_, B2_, B3_) type_of_fun bool_types)
        (node_invariant a aa))
    (nodes a);

fun check_art A_ (B1_, B2_, B3_, B4_) type_of_fun bool_types a =
  check (art A_ (B1_, B2_, B3_, B4_) type_of_fun bool_types a)
    (shows_prec_list show_char zero_nata
      [#"i", #"l", #"l", #"-", #"f", #"o", #"r", #"m", #"e", #"d", #" ", #"i",
        #"n", #"v", #"a", #"r", #"i", #"a", #"n", #"t"]);

fun check_art_invariants (A1_, A2_) (B1_, B2_, B3_, B4_) (C1_, C2_) (D1_, D2_)
  (E1_, E2_, E3_, E4_, E5_, E6_) (F1_, F2_) type_of_fun bool_types tc tc2 sa sa2
  ne ne2 a p h =
  catch_errora
    (bindb (check_art A2_ (B1_, B2_, B3_, B4_) type_of_fun bool_types a)
      (fn _ =>
        bindb (check_initial_cond (A1_, A2_) (D1_, D2_) (B3_, B4_) (F1_, F2_) sa
                a)
          (fn _ =>
            bindb (check_simulation_cond (C1_, C2_) (A1_, A2_) (D1_, D2_)
                    (B3_, B4_) (E1_, E2_, E3_, E4_, E5_, E6_) (F1_, F2_) tc sa
                    ne a p h)
              (fn _ =>
                bindb (check_cover_edges_cond (C1_, C2_) (A1_, A2_) (D1_, D2_)
                        (B3_, B4_) E4_ (F1_, F2_) tc sa ne a p h)
                  (fn _ =>
                    check_children_edges_cond (C1_, C2_) (A1_, A2_) (D1_, D2_)
                      (B3_, B4_) E6_ F2_ tc2 sa2 ne2 a p h)))))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"e",
               #"n", #"s", #"u", #"r", #"e", #" ", #"v", #"a", #"l", #"i", #"d",
               #"i", #"t", #"y", #" ", #"o", #"f", #" ", #"a", #"r", #"t", #"-",
               #"g", #"r", #"a", #"p", #"h", #":", #"\n"] o
            x));

fun is_cover_node (Art_Node (uu, uv, uw, Cover_Edge (ux, uy))) = true
  | is_cover_node (Art_Node (uz, va, vb, Children_Edge vc)) = false;

fun transition_hints E_ ai =
  map_of E_
    (map_filter
      (fn x =>
        (if not (is_cover_node x)
          then SOME (name x, let
                               val Children_Edge a = edgea x;
                             in
                               map (fn (_, (_, h)) => h) a
                             end)
          else NONE))
      (nodesb ai));

fun cover_hints (E1_, E2_, E3_) G_ ai =
  map_of_default (E1_, E2_, E3_) (default G_)
    (map_filter
      (fn x =>
        (if is_cover_node x
          then SOME (name x, let
                               val Cover_Edge (_, h) = edgea x;
                             in
                               h
                             end)
          else NONE))
      (nodesb ai));

fun make_hinter D_ (J1_, J2_, J3_) L_ pi ai =
  Hinter_ext
    (art_nodes ai, succ_transitions D_ pi, cover_hints (J1_, J2_, J3_) L_ ai,
      transition_hints J2_ ai, ());

fun check_art_invariants_impl (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
  (D1_, D2_, D3_) (E1_, E2_, E3_, E4_, E5_, E6_, E7_) (F1_, F2_, F3_, F4_)
  (G1_, G2_, G3_, G4_, G5_, G6_) type_of_fun bool_types tc tc2 sa sa2 ne ne2 ai
  pi =
  check_art_invariants (A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_) (D2_, D3_)
    (E1_, E2_, E3_, E4_, E6_, E7_) (F2_, F4_) type_of_fun bool_types tc tc2 sa
    sa2 ne ne2 (art_of (G2_, G3_, G4_, G6_) (F1_, F2_, F3_, F4_) pi ai)
    (lts_of (A1_, A2_) (D1_, D2_) (B2_, B3_) (E2_, E3_, E4_, E5_, E6_)
      (G1_, G2_, G5_) pi)
    (make_hinter E4_ (F1_, F2_, F3_) (default_hint C1_) pi ai);

fun check_unique_names E_ ai =
  check (distinct E_ (map name (nodesb ai)))
    (shows_prec_list show_char zero_nata
      [#"N", #"o", #"d", #"e", #"s", #" ", #"i", #"n", #" ", #"a", #"r", #"t",
        #" ", #"g", #"r", #"a", #"p", #"h", #" ", #"m", #"u", #"s", #"t", #" ",
        #"h", #"a", #"v", #"e", #" ", #"u", #"n", #"i", #"q", #"u", #"e", #" ",
        #"n", #"a", #"m", #"e", #"s"]);

fun restrict_invariants (A1_, A2_) i la l =
  (if member (A1_, A2_) l la then i l else Conjunction []);

fun get_disj_invariant D_ a l =
  Disjunction
    (map_filter
      (fn x =>
        (if eq D_ (node_location a x) l andalso not (is_cover_nodea (edge a x))
          then SOME (node_invariant a x) else NONE))
      (nodes a));

fun shows_labeled_transition D_ E_ shows_tatom (lab, tran) =
  shows_prec D_ zero_nata lab o
    shows_prec_list show_char zero_nata [#":", #" "] o
    shows_transition E_ shows_tatom tran;

fun shows_lts D_ E_ shows_atom shows_tatom (Lts_Impl (i, tran, lc)) =
  shows_prec_list show_char zero_nata
    [#"L", #"T", #"S", #":", #"\n", #"I", #"n", #"i", #"t", #"i", #"a", #"l",
      #" ", #"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n", #"s", #":", #" "] o
    shows_prec_list D_ zero_nata i o
    shows_prec_list show_char zero_nata
      [#"\n", #"T", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n", #"s",
        #"\n"] o
    shows_sep (shows_labeled_transition E_ D_ shows_tatom) shows_nl tran o
    shows_prec_list show_char zero_nata
      [#"\n", #"L", #"o", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"c", #"o",
        #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s"] o
    shows_sep
      (fn (l, f) =>
        shows_prec D_ zero_nata l o
          shows_prec_list show_char zero_nata [#":", #" "] o
          shows_formula shows_atom f)
      shows_nl lc o
    shows_nl;

fun check_trivial_implication A_ phi psi =
  list_all
    (fn phia =>
      let
        val c_phis = get_conjunctions phia;
      in
        list_ex
          (fn psia =>
            list_all (membera (equal_formula A_) c_phis)
              (get_conjunctions psia))
          (get_disjunctions psi)
      end)
    (get_disjunctions phi);

fun shows_art_node D_ E_ F_ (Art_Node (n, uu, l, Cover_Edge (m, uv))) =
  shows_prec E_ zero_nata n o
    shows_prec_list show_char zero_nata [#"(", #"@", #" "] o
    shows_prec D_ zero_nata l o
    shows_prec_list show_char zero_nata
      [#")", #":", #" ", #"c", #"o", #"v", #"e", #"r", #"e", #"d", #" ", #"b",
        #"y", #" "] o
    shows_prec E_ zero_nata m
  | shows_art_node D_ E_ F_ (Art_Node (n, uw, l, Children_Edge ls)) =
    shows_prec E_ zero_nata n o
      shows_prec_list show_char zero_nata [#"(", #"@", #" "] o
      shows_prec D_ zero_nata l o
      shows_prec_list show_char zero_nata
        [#")", #":", #" ", #"g", #"o", #"e", #"s", #" ", #"t", #"o", #" "] o
      shows_list_gen
        (fn (tr, (na, _)) =>
          shows_prec_list show_char zero_nata [#"-"] o
            shows_prec F_ zero_nata tr o
            shows_prec_list show_char zero_nata [#"-", #">"] o
            shows_prec E_ zero_nata na)
        [#"[", #"]"] [#"["] [#",", #" "] [#"]"] ls;

fun shows_art D_ E_ F_ a =
  shows_prec_list show_char zero_nata
    [#"A", #"R", #"T", #":", #"\n", #"I", #"n", #"i", #"t", #"i", #"a", #"l",
      #" ", #"n", #"o", #"d", #"e", #":", #" "] o
    shows_prec_list E_ zero_nata (initial_nodesa a) o
    shows_prec_list show_char zero_nata [#"\n", #"A", #"r", #"c", #"s", #"\n"] o
    shows_sep (shows_art_node D_ E_ F_) shows_nl (nodesb a) o
    shows_nl;

fun invariant_proof_checker (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
  (D1_, D2_, D3_) (E1_, E2_, E3_, E4_, E5_, E6_, E7_)
  (F1_, F2_, F3_, F4_, F5_, F6_) (G1_, G2_, G3_, G4_) type_of_fun bool_types tc
  tc2 sa sa2 ne ne2 pi (Impact (ii, ai)) =
  debug [#"i", #"n", #"v", #"a", #"r", #"i", #"a", #"n", #"t", #" ", #"c", #"h",
          #"e", #"c", #"k", #"i", #"n", #"g", #":"]
    [#"I", #"m", #"p", #"a", #"c", #"t"]
    let
      val i = map_of_default (E3_, E4_, E5_) (Conjunction []) ii;
    in
      (case catch_errora
              (bindb (check_unique_names G2_ ai)
                (fn _ =>
                  bindb (debug []
                          [#"p", #"r", #"o", #"v", #"i", #"d", #"e", #"d", #" ",
                            #"i", #"n", #"v", #"a", #"r", #"i", #"a", #"n",
                            #"t", #"s", #" ", #"a", #"g", #"a", #"i", #"n",
                            #"s", #"t", #" ", #"d", #"e", #"d", #"u", #"c",
                            #"e", #"d", #" ", #"i", #"n", #"v", #"a", #"r",
                            #"i", #"a", #"n", #"t", #"s", #" ", #"f", #"r",
                            #"o", #"m", #" ", #"A", #"R", #"T", #" ", #"g",
                            #"r", #"a", #"p", #"h"]
                          (catch_errora
                            (forallM
                              (fn l =>
                                let
                                  val il = i l;
                                in
                                  bindb (check
  (formula (is_bool (B1_, B2_, B3_) type_of_fun bool_types) il)
  (shows_prec_list show_char zero_nata
     [#"i", #"l", #"l", #"-", #"f", #"o", #"r", #"m", #"e", #"d", #" ", #"f",
       #"o", #"r", #"m", #"u", #"l", #"a", #" ", #"f", #"o", #"r", #" ", #"l",
       #"o", #"c", #"a", #"t", #"i", #"o", #"n", #" "] o
    shows_prec E7_ zero_nata l))
                                    (fn _ =>
                                      check
(check_trivial_implication (equal_term A2_ (equal_prod D2_ B3_))
  (get_disj_invariant E4_
    (art_of (F2_, F3_, F4_, F6_) (G1_, G2_, G3_, G4_) pi ai) l)
  il)
(shows_prec_list show_char zero_nata
   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"m", #"a",
     #"t", #"c", #"h", #" ", #"p", #"r", #"o", #"v", #"i", #"d", #"e", #"d",
     #" ", #"i", #"n", #"v", #"a", #"r", #"i", #"a", #"n", #"t", #" ", #"w",
     #"i", #"t", #"h", #" ", #"i", #"n", #"v", #"a", #"r", #"i", #"a", #"n",
     #"t", #" ", #"e", #"x", #"t", #"r", #"a", #"c", #"t", #"e", #"d", #" ",
     #"f", #"r", #"o", #"m", #" ", #"a", #"r", #"t", #"-", #"g", #"r", #"a",
     #"p", #"h", #" ", #"a", #"t", #" ", #"l", #"o", #"c", #"a", #"t", #"i",
     #"o", #"n", #" "] o
  shows_prec E7_ zero_nata l))
                                end)
                              (nodes_lts_impl E4_ pi))
                            (fn x => Inl (snd x))))
                    (fn _ =>
                      debug []
                        [#"c", #"h", #"e", #"c", #"k", #"i", #"n", #"g", #" ",
                          #"A", #"R", #"T", #" ", #"g", #"r", #"a", #"p", #"h"]
                        (check_art_invariants_impl (A1_, A2_, A3_)
                          (B1_, B2_, B3_, B4_) (C1_, C2_) (D1_, D2_, D3_)
                          (E1_, E2_, E3_, E4_, E5_, E6_, E7_)
                          (G1_, G2_, G3_, G4_) (F1_, F2_, F3_, F4_, F5_, F6_)
                          type_of_fun bool_types tc tc2 sa sa2 ne ne2 ai pi))))
              (fn x =>
                Inl (shows_prec_list show_char zero_nata
                       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i",
                         #"n", #" ", #"e", #"n", #"s", #"u", #"r", #"i", #"n",
                         #"g", #" ", #"i", #"n", #"v", #"a", #"r", #"i", #"a",
                         #"n", #"t", #"s", #" ", #"f", #"o", #"r", #" "] o
                       shows_lts E7_ F6_ sa sa2 pi o
                       shows_prec_list show_char zero_nata
                         [#"\n", #"v", #"i", #"a", #" "] o
                       shows_art E7_ G4_ F6_ ai o
                      x))
        of Inl a => Inl a
        | Inr _ =>
          Inr (restrict_invariants (E2_, E3_) i
                (set (E2_, E3_, E6_) (nodes_lts_impl E4_ pi))))
    end;

fun safe_by_assertion_checker A_ (B1_, B2_) C_ (D1_, D2_) (E1_, E2_, E3_, E4_)
  shows_atom logic_checker negate_atom pi err =
  catch_errora
    (forallM
      (fn l =>
        catch_errora
          (check_valid_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom
            logic_checker negate_atom
            (form_not (assertion_of (E1_, E2_, E3_) pi l)))
          (fn _ =>
            Inl (shows_prec_list show_char zero_nata
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"d", #"e", #"d", #"u", #"c", #"e", #" ", #"f", #"r", #"o",
                     #"m", #" ", #"a", #"s", #"s", #"e", #"r", #"t", #"i", #"o",
                     #"n", #" ", #"t", #"h", #"a", #"t", #" "] o
                   shows_prec E4_ zero_nata l o
                  shows_prec_list show_char zero_nata
                    [#" ", #"i", #"s", #" ", #"u", #"n", #"r", #"e", #"a", #"c",
                      #"h", #"a", #"b", #"l", #"e"])))
      err)
    (fn x => Inl (snd x));

fun fix_invariants (D1_, D2_, D3_, D4_) E_ p phi =
  catch_errora
    let
      val ls = nodes_lts_impl D2_ p;
      val _ = assertion_of (D1_, D2_, D3_) p;
    in
      Inr (Lts_Impl
            (initiala p, transitions_impl p, map (fn l => (l, phi l)) ls))
    end
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
               #"n", #" ", #"f", #"i", #"x", #"i", #"n", #"g", #" ", #"i", #"n",
               #"v", #"a", #"r", #"i", #"a", #"n", #"t", #"s", #" ", #"a", #"s",
               #" ", #"a", #"s", #"s", #"e", #"r", #"t", #"i", #"o", #"n", #"s",
               #"\n"] o
            x));

fun check_safety_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
  (D1_, D2_, D3_) (E1_, E2_, E3_, E4_, E5_, E6_, E7_)
  (F1_, F2_, F3_, F4_, F5_, F6_) (G1_, G2_, G3_, G4_) type_of_fun bool_types tc
  tc2 sa sa2 ne ne2 pi err (Invariant_Assertion (inv_prf, inner)) =
  debug []
    [#"A", #"d", #"d", #" ", #"I", #"n", #"v", #"a", #"r", #"i", #"a", #"n",
      #"t", #"s"]
    (bindb
      (invariant_proof_checker (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
        (D1_, D2_, D3_) (E1_, E2_, E3_, E4_, E5_, E6_, E7_)
        (F1_, F2_, F3_, F4_, F5_, F6_) (G1_, G2_, G3_, G4_) type_of_fun
        bool_types tc tc2 sa sa2 ne ne2 pi inv_prf)
      (fn i =>
        bindb (fix_invariants (E3_, E4_, E5_, E7_) F6_ pi i)
          (fn qi =>
            check_safety_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
              (D1_, D2_, D3_) (E1_, E2_, E3_, E4_, E5_, E6_, E7_)
              (F1_, F2_, F3_, F4_, F5_, F6_) (G1_, G2_, G3_, G4_) type_of_fun
              bool_types tc tc2 sa sa2 ne ne2 qi err inner)))
  | check_safety_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
    (D1_, D2_, D3_) (E1_, E2_, E3_, E4_, E5_, E6_, E7_)
    (F1_, F2_, F3_, F4_, F5_, F6_) (G1_, G2_, G3_, G4_) type_of_fun bool_types
    tc tc2 sa sa2 ne ne2 pi err Trivial =
    debug []
      [#"U", #"n", #"s", #"a", #"t", #"i", #"s", #"f", #"i", #"a", #"b", #"l",
        #"e", #" ", #"E", #"r", #"r", #"o", #"r", #" ", #"s", #"t", #"a", #"t",
        #"e", #"s"]
      (safe_by_assertion_checker A2_ (D2_, D3_) B3_ (C1_, C2_)
        (E3_, E4_, E5_, E7_) sa tc ne pi err);

fun check_safety (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_) (D1_, D2_, D3_)
  (E1_, E2_, E3_, E4_, E5_, E6_, E7_) (F1_, F2_, F3_, F4_, F5_, F6_)
  (G1_, G2_, G3_, G4_) type_of_fun bool_types tc tc2 sa sa2 ne ne2 pi err prf =
  bindb (debug [#"i", #"n", #"i", #"t"]
          [#"C", #"h", #"e", #"c", #"k", #" ", #"w", #"e", #"l", #"l", #"-",
            #"f", #"o", #"r", #"m", #"e", #"d", #"n", #"e", #"s", #"s"]
          (check_lts_impl (B1_, B2_, B3_) type_of_fun bool_types pi))
    (fn _ =>
      check_safety_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
        (D1_, D2_, D3_) (E1_, E2_, E3_, E4_, E5_, E6_, E7_)
        (F1_, F2_, F3_, F4_, F5_, F6_) (G1_, G2_, G3_, G4_) type_of_fun
        bool_types tc tc2 sa sa2 ne ne2 pi err prf);

fun check_single_subsumption (A1_, A2_) (B1_, B2_, B3_, B4_) eq e convs =
  bindb (check
          (membera (equal_prod (equal_term A1_ B2_) (equal_term A1_ B2_))
            (map fst convs) eq)
          (shows_string
             [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"f",
               #"i", #"n", #"d", #" ", #"c", #"o", #"n", #"v", #"e", #"r", #"s",
               #"i", #"o", #"n", #" ", #"f", #"o", #"r", #" ", #"e", #"q", #"u",
               #"a", #"t", #"i", #"o", #"n", #" "] o
            shows_rule (shows_prec A2_ zero_nata) (shows_prec B4_ zero_nata)
              [#" ", #"=", #" "] eq))
    (fn _ => check_subsumptions_guided (A1_, A2_) (B1_, B2_, B3_, B4_) e convs);

fun eq_proof_lines A_ B_ (Refl s) i =
  (shows_nl o (shows_prec_nat zero_nata (suc i) o shows_string [#":", #" "]) o
     (shows_rule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata)
        [#" ", #"=", #" "] (s, s) o
       shows_string [#" ", #"[", #"r", #"e", #"f", #"l", #"]"]),
    (suc i, (s, s)))
  | eq_proof_lines A_ B_ (Sym p) i =
    let
      val (s, (ia, (l, r))) = eq_proof_lines A_ B_ p i;
    in
      (s o (shows_nl o
              (shows_prec_nat zero_nata (suc ia) o shows_string [#":", #" "]) o
             (shows_rule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata)
                [#" ", #"=", #" "] (r, l) o
               (shows_string [#" ", #"[", #"s", #"y", #"m", #" "] o
                 (shows_prec_nat zero_nata ia o shows_string [#"]"])))),
        (suc ia, (r, l)))
    end
  | eq_proof_lines A_ B_ (Trans (p1, p2)) i =
    let
      val (s1, (i1, (s, _))) = eq_proof_lines A_ B_ p1 i;
      val (s2, (i2, (_, v))) = eq_proof_lines A_ B_ p2 i1;
    in
      (s1 o (s2 o (shows_nl o
                     (shows_prec_nat zero_nata (suc i2) o
                       shows_string [#":", #" "]) o
                    (shows_rule (shows_prec A_ zero_nata)
                       (shows_prec B_ zero_nata) [#" ", #"=", #" "] (s, v) o
                      (shows_string
                         [#" ", #"[", #"t", #"r", #"a", #"n", #"s", #" "] o
                        (shows_prec_nat zero_nata i1 o
                          (shows_string [#",", #" "] o
                            (shows_prec_nat zero_nata i2 o
                              shows_string [#"]"]))))))),
        (suc i2, (s, v)))
    end
  | eq_proof_lines A_ B_ (Assm ((l, r), sigma)) i =
    let
      val eq = (subst_apply_term l sigma, subst_apply_term r sigma);
    in
      (shows_nl o
         (shows_prec_nat zero_nata (suc i) o shows_string [#":", #" "]) o
         (shows_rule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata)
            [#" ", #"=", #" "] eq o
           (shows_string [#" ", #"[", #"a", #"s", #"s", #"m", #" "] o
             (shows_rule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata)
                [#" ", #"=", #" "] (l, r) o
               shows_string [#"]"]))),
        (suc i, eq))
    end
  | eq_proof_lines A_ B_ (Cong (f, ps)) i =
    let
      val (s, (is, (ls, rs))) = eq_proofs_lines A_ B_ ps i;
      val eq = (Fun (f, ls), Fun (f, rs));
      val ia = last is;
      val isa = butlast is;
    in
      (s o (shows_nl o
              (shows_prec_nat zero_nata (suc ia) o shows_string [#":", #" "]) o
             (shows_rule (shows_prec A_ zero_nata) (shows_prec B_ zero_nata)
                [#" ", #"=", #" "] eq o
               shows_list_gen (shows_prec_nat zero_nata)
                 [#" ", #"[", #"c", #"o", #"n", #"g", #"]"]
                 [#" ", #"[", #"c", #"o", #"n", #"g", #" "] [#",", #" "] [#"]"]
                 isa)),
        (suc ia, eq))
    end
and eq_proofs_lines A_ B_ [] i = (id, ([i], ([], [])))
  | eq_proofs_lines A_ B_ (p :: ps) i =
    let
      val (s1, (ia, (l, r))) = eq_proof_lines A_ B_ p i;
      val (s2, (is, (ls, rs))) = eq_proofs_lines A_ B_ ps ia;
    in
      (s1 o s2, (ia :: is, (l :: ls, r :: rs)))
    end;

fun check_proves (A1_, A2_) (B1_, B2_) e (Refl s) = Inr (s, s)
  | check_proves (A1_, A2_) (B1_, B2_) e (Sym p) =
    bindb (check_proves (A1_, A2_) (B1_, B2_) e p) (fn (s, t) => Inr (t, s))
  | check_proves (A1_, A2_) (B1_, B2_) e (Trans (p1, p2)) =
    bindb (check_proves (A1_, A2_) (B1_, B2_) e p1)
      (fn (s, t) =>
        bindb (check_proves (A1_, A2_) (B1_, B2_) e p2)
          (fn (ta, u) =>
            (if equal_terma A1_ B1_ t ta then Inr (s, u)
              else Inl (shows_string
                          [#"t", #"h", #"e", #" ", #"e", #"r", #"r", #"o", #"r",
                            #" ", #"o", #"c", #"c", #"u", #"r", #"s", #" ",
                            #"i", #"n", #" ", #"t", #"h", #"e", #" ", #"f",
                            #"o", #"l", #"l", #"o", #"w", #"i", #"n", #"g",
                            #" ", #"p", #"a", #"r", #"t", #" "] o
                         (shows_nl o
                           (fst (eq_proof_lines A2_ B2_ (Trans (p1, p2))
                                  zero_nata) o
                             (shows_nl o
                               (shows_nl o
                                 (shows_prec_term A2_ B2_ zero_nata t o
                                   (shows_string
                                      [#" ", #"i", #"s", #" ", #"n", #"o", #"t",
#" ", #"e", #"q", #"u", #"a", #"l", #" ", #"t", #"o", #" "] o
                                     shows_prec_term A2_ B2_ zero_nata
                                       ta))))))))))
  | check_proves (A1_, A2_) (B1_, B2_) e (Assm ((l, r), sigma)) =
    (if membera (equal_prod (equal_term A1_ B1_) (equal_term A1_ B1_)) e (l, r)
      then Inr (subst_apply_term l sigma, subst_apply_term r sigma)
      else Inl (shows_string
                  [#"t", #"h", #"e", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                    #"o", #"c", #"c", #"u", #"r", #"s", #" ", #"i", #"n", #" ",
                    #"t", #"h", #"e", #" ", #"f", #"o", #"l", #"l", #"o", #"w",
                    #"i", #"n", #"g", #" ", #"p", #"a", #"r", #"t", #" "] o
                 (shows_nl o
                   (fst (eq_proof_lines A2_ B2_ (Assm ((l, r), sigma))
                          zero_nata) o
                     (shows_nl o
                       (shows_nl o
                         (shows_eq (shows_prec A2_ zero_nata)
                            (shows_prec B2_ zero_nata) (l, r) o
                           (shows_string
                              [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                                #"i", #"n", #" ", #"t", #"h", #"e", #" "] o
                             shows_trs (shows_prec A2_ zero_nata)
                               (shows_prec B2_ zero_nata)
                               [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n",
                                 #"a", #"l", #" ", #"s", #"y", #"s", #"t", #"e",
                                 #"m", #":"]
                               [#" ", #"=", #" "] e))))))))
  | check_proves (A1_, A2_) (B1_, B2_) e (Cong (f, ps)) =
    bindb (mapM (check_proves (A1_, A2_) (B1_, B2_) e) ps)
      (fn sts => Inr (Fun (f, map fst sts), Fun (f, map snd sts)));

fun check_eq_proof (A1_, A2_) (B1_, B2_) e p eq =
  catch_errora
    (bindb (check_proves (A1_, A2_) (B1_, B2_) e p)
      (fn eqa =>
        (if equal_proda (equal_term A1_ B1_) (equal_term A1_ B1_) eq eqa
          then Inr ()
          else Inl (shows_string
                     [#"t", #"h", #"e", #" ", #"p", #"r", #"o", #"o", #"f",
                       #" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t",
                       #" ", #"f", #"i", #"t", #" ", #"t", #"h", #"e", #" ",
                       #"g", #"o", #"a", #"l"]))))
    (fn x =>
      Inl (shows_string
             [#"t", #"h", #"e", #"r", #"e", #" ", #"i", #"s", #" ", #"a", #"n",
               #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"t",
               #"h", #"e", #" ", #"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n",
               #"a", #"l", #" ", #"l", #"o", #"g", #"i", #"c", #" ", #"p", #"r",
               #"o", #"o", #"f"] o
            (shows_nl o
              (fst (eq_proof_lines A2_ B2_ p zero_nata) o
                (shows_nl o
                  (shows_nl o
                    (shows_string
                       [#"f", #"o", #"r", #" ", #"p", #"r", #"o", #"v", #"i",
                         #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"e", #"q",
                         #"u", #"a", #"t", #"i", #"o", #"n"] o
                      (shows_nl o
                        (shows_nl o
                          (shows_eq (shows_prec A2_ zero_nata)
                             (shows_prec B2_ zero_nata) eq o
                            (shows_nl o
                              (shows_nl o
                                (shows_string
                                   [#"u", #"s", #"i", #"n", #"g", #" ", #"t",
                                     #"h", #"e", #" "] o
                                  (shows_trs (shows_prec A2_ zero_nata)
                                     (shows_prec B2_ zero_nata)
                                     [#"e", #"q", #"u", #"a", #"t", #"i", #"o",
                                       #"n", #"a", #"l", #" ", #"s", #"y", #"s",
                                       #"t", #"e", #"m", #":"]
                                     [#" ", #"=", #" "] e o
                                    (shows_nl o x)))))))))))))));

fun check_equational_proof (B1_, B2_, B3_, B4_) a ia i j e (Equation eq)
  (Equational_Proof_Tree p) =
  debug (ia [])
    [#"E", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"_", #"P",
      #"r", #"o", #"o", #"f", #"_", #"T", #"r", #"e", #"e"]
    (check_eq_proof
      (equal_lab B2_ (equal_list equal_nat), show_lab B4_ (show_list show_nat))
      (equal_list equal_char, show_list show_char) e p eq)
  | check_equational_proof (B1_, B2_, B3_, B4_) a ia i j e (Equation eq)
    (Conversion eseq) =
    debug (ia []) [#"C", #"o", #"n", #"v", #"e", #"r", #"s", #"i", #"o", #"n"]
      (check_conversiona
        (equal_lab B2_ (equal_list equal_nat),
          show_lab B4_ (show_list show_nat))
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list,
          show_list show_char)
        e eseq (fst eq) (snd eq))
  | check_equational_proof (B1_, B2_, B3_, B4_) a ia i j e (Equation eq)
    (Conversion_With_History convs) =
    debug (ia [])
      [#"C", #"o", #"n", #"v", #"e", #"r", #"s", #"i", #"o", #"n", #" ", #"w",
        #"i", #"t", #"h", #" ", #"H", #"i", #"s", #"t", #"o", #"r", #"y"]
      (check_single_subsumption
        (equal_lab B2_ (equal_list equal_nat),
          show_lab B4_ (show_list show_nat))
        (ccompare_list ccompare_char, equal_list equal_char, mapping_impl_list,
          show_list show_char)
        eq e convs)
  | check_equational_proof (B1_, B2_, B3_, B4_) a ia i j e (Equation eq)
    (Completion_and_Normalization (r, p)) =
    debug (ia [])
      [#"C", #"o", #"m", #"p", #"l", #"e", #"t", #"i", #"o", #"n", #"_", #"a",
        #"n", #"d", #"_", #"N", #"o", #"r", #"m", #"a", #"l", #"i", #"z", #"a",
        #"t", #"i", #"o", #"n"]
      (bindb (check_completion_proof (B1_, B2_, B3_, B4_) a ia i j e r p)
        (fn _ =>
          let
            val s = fst eq;
            val t = snd eq;
          in
            (case (compute_rstep_NF (equal_lab B2_ (equal_list equal_nat))
                     (ccompare_list ccompare_char, equal_list equal_char,
                       mapping_impl_list)
                     r s,
                    compute_rstep_NF (equal_lab B2_ (equal_list equal_nat))
                      (ccompare_list ccompare_char, equal_list equal_char,
                        mapping_impl_list)
                      r t)
              of (NONE, _) =>
                Inl (shows_string
                       [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e",
                         #"n", #" ", #"c", #"o", #"m", #"p", #"u", #"t", #"i",
                         #"n", #"g", #" ", #"n", #"o", #"r", #"m", #"a", #"l",
                         #" ", #"f", #"o", #"r", #"m", #"s", #" ", #"o", #"f",
                         #" "] o
                      (shows_term
                         (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                         (shows_prec_list show_char zero_nata) s o
                        (shows_string [#" ", #"a", #"n", #"d", #" "] o
                          shows_term
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) t)))
              | (SOME _, NONE) =>
                Inl (shows_string
                       [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e",
                         #"n", #" ", #"c", #"o", #"m", #"p", #"u", #"t", #"i",
                         #"n", #"g", #" ", #"n", #"o", #"r", #"m", #"a", #"l",
                         #" ", #"f", #"o", #"r", #"m", #"s", #" ", #"o", #"f",
                         #" "] o
                      (shows_term
                         (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                         (shows_prec_list show_char zero_nata) s o
                        (shows_string [#" ", #"a", #"n", #"d", #" "] o
                          shows_term
                            (shows_prec_lab B4_ (show_list show_nat) zero_nata)
                            (shows_prec_list show_char zero_nata) t)))
              | (SOME sa, SOME ta) =>
                (if equal_terma (equal_lab B2_ (equal_list equal_nat))
                      (equal_list equal_char) sa ta
                  then Inr ()
                  else Inl (shows_term
                              (shows_prec_lab B4_ (show_list show_nat)
                                zero_nata)
                              (shows_prec_list show_char zero_nata) s o
                             (shows_string [#" ", #"a", #"n", #"d", #" "] o
                               (shows_term
                                  (shows_prec_lab B4_ (show_list show_nat)
                                    zero_nata)
                                  (shows_prec_list show_char zero_nata) t o
                                 shows_string
                                   [#" ", #"h", #"a", #"v", #"e", #" ", #"d",
                                     #"i", #"f", #"f", #"e", #"r", #"e", #"n",
                                     #"t", #" ", #"n", #"o", #"r", #"m", #"a",
                                     #"l", #" ", #"f", #"o", #"r", #"m",
                                     #"s"])))))
          end))
  | check_equational_proof (B1_, B2_, B3_, B4_) uu uv uw ux uy (Inequality v) va
    = Inl (shows_string
            [#"u", #"n", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d",
              #" ", #"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"a", #"l",
              #" ", #"p", #"r", #"o", #"o", #"f", #" "]);

val set_impl_ty : (ty, set_impla) phantom = Phantom Set_RBT;

fun check_dp_termination_proof (B1_, B2_, B3_, B4_) ia j a i dpp prf =
  check_dp_termination_proof_main (B1_, B2_, B3_, B4_) ia j a i dpp
    (fst (unlab_to_split_dp (B2_, B3_)
           (equal_list equal_nat, key_list (equal_nat, key_nat))
           (equal_list equal_char, key_list (equal_char, key_char)) prf));

fun equal_claim Ordered_Completed Anything = false
  | equal_claim Anything Ordered_Completed = false
  | equal_claim Completed Anything = false
  | equal_claim Anything Completed = false
  | equal_claim Completed Ordered_Completed = false
  | equal_claim Ordered_Completed Completed = false
  | equal_claim Nonconfluent Anything = false
  | equal_claim Anything Nonconfluent = false
  | equal_claim Nonconfluent Ordered_Completed = false
  | equal_claim Ordered_Completed Nonconfluent = false
  | equal_claim Nonconfluent Completed = false
  | equal_claim Completed Nonconfluent = false
  | equal_claim Confluent Anything = false
  | equal_claim Anything Confluent = false
  | equal_claim Confluent Ordered_Completed = false
  | equal_claim Ordered_Completed Confluent = false
  | equal_claim Confluent Completed = false
  | equal_claim Completed Confluent = false
  | equal_claim Confluent Nonconfluent = false
  | equal_claim Nonconfluent Confluent = false
  | equal_claim Nonterminating Anything = false
  | equal_claim Anything Nonterminating = false
  | equal_claim Nonterminating Ordered_Completed = false
  | equal_claim Ordered_Completed Nonterminating = false
  | equal_claim Nonterminating Completed = false
  | equal_claim Completed Nonterminating = false
  | equal_claim Nonterminating Nonconfluent = false
  | equal_claim Nonconfluent Nonterminating = false
  | equal_claim Nonterminating Confluent = false
  | equal_claim Confluent Nonterminating = false
  | equal_claim (Upperbound x4) Anything = false
  | equal_claim Anything (Upperbound x4) = false
  | equal_claim (Upperbound x4) Ordered_Completed = false
  | equal_claim Ordered_Completed (Upperbound x4) = false
  | equal_claim (Upperbound x4) Completed = false
  | equal_claim Completed (Upperbound x4) = false
  | equal_claim (Upperbound x4) Nonconfluent = false
  | equal_claim Nonconfluent (Upperbound x4) = false
  | equal_claim (Upperbound x4) Confluent = false
  | equal_claim Confluent (Upperbound x4) = false
  | equal_claim (Upperbound x4) Nonterminating = false
  | equal_claim Nonterminating (Upperbound x4) = false
  | equal_claim Terminating Anything = false
  | equal_claim Anything Terminating = false
  | equal_claim Terminating Ordered_Completed = false
  | equal_claim Ordered_Completed Terminating = false
  | equal_claim Terminating Completed = false
  | equal_claim Completed Terminating = false
  | equal_claim Terminating Nonconfluent = false
  | equal_claim Nonconfluent Terminating = false
  | equal_claim Terminating Confluent = false
  | equal_claim Confluent Terminating = false
  | equal_claim Terminating Nonterminating = false
  | equal_claim Nonterminating Terminating = false
  | equal_claim Terminating (Upperbound x4) = false
  | equal_claim (Upperbound x4) Terminating = false
  | equal_claim No Anything = false
  | equal_claim Anything No = false
  | equal_claim No Ordered_Completed = false
  | equal_claim Ordered_Completed No = false
  | equal_claim No Completed = false
  | equal_claim Completed No = false
  | equal_claim No Nonconfluent = false
  | equal_claim Nonconfluent No = false
  | equal_claim No Confluent = false
  | equal_claim Confluent No = false
  | equal_claim No Nonterminating = false
  | equal_claim Nonterminating No = false
  | equal_claim No (Upperbound x4) = false
  | equal_claim (Upperbound x4) No = false
  | equal_claim No Terminating = false
  | equal_claim Terminating No = false
  | equal_claim Yes Anything = false
  | equal_claim Anything Yes = false
  | equal_claim Yes Ordered_Completed = false
  | equal_claim Ordered_Completed Yes = false
  | equal_claim Yes Completed = false
  | equal_claim Completed Yes = false
  | equal_claim Yes Nonconfluent = false
  | equal_claim Nonconfluent Yes = false
  | equal_claim Yes Confluent = false
  | equal_claim Confluent Yes = false
  | equal_claim Yes Nonterminating = false
  | equal_claim Nonterminating Yes = false
  | equal_claim Yes (Upperbound x4) = false
  | equal_claim (Upperbound x4) Yes = false
  | equal_claim Yes Terminating = false
  | equal_claim Terminating Yes = false
  | equal_claim Yes No = false
  | equal_claim No Yes = false
  | equal_claim (Upperbound x4) (Upperbound y4) = equal_nata x4 y4
  | equal_claim Anything Anything = true
  | equal_claim Ordered_Completed Ordered_Completed = true
  | equal_claim Completed Completed = true
  | equal_claim Nonconfluent Nonconfluent = true
  | equal_claim Confluent Confluent = true
  | equal_claim Nonterminating Nonterminating = true
  | equal_claim Terminating Terminating = true
  | equal_claim No No = true
  | equal_claim Yes Yes = true;

fun type_of_fun LessF = ([IntT, IntT], BoolT)
  | type_of_fun LeF = ([IntT, IntT], BoolT)
  | type_of_fun EqF = ([IntT, IntT], BoolT)
  | type_of_fun (SumF n) = (replicate n IntT, IntT)
  | type_of_fun (ConstF uu) = ([], IntT)
  | type_of_fun (ProdF n) = (replicate n IntT, IntT);

fun mke (Ac_tp_ops_ext (ac_tp, r, a, c, mk, delete_rules, e, more)) = mk;

fun fresh_variable_checker A_ (B1_, B2_, B3_, B4_) (C1_, C2_) D_ E_ type_of_fun
  bool_types definability_checker sa2 p f x ty =
  catch_errora
    (bindb
      (catch_errora
        (forallM
          (fn (l, fa) =>
            check (not (in_vars_formula (equal_prod C1_ B3_) (x, ty) fa))
              (shows_prec C2_ zero_nata x o
                 shows_prec_list show_char zero_nata
                   [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"f", #"r",
                     #"e", #"s", #"h", #",", #" ", #"i", #"t", #" ", #"o", #"c",
                     #"c", #"u", #"r", #"s", #" ", #"i", #"n", #" ", #"l", #"o",
                     #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"c", #"o", #"n",
                     #"d", #"i", #"t", #"i", #"o", #"n", #" ", #"o", #"f",
                     #" "] o
                shows_prec D_ zero_nata l))
          (assertion_impl p))
        (fn xa => Inl (snd xa)))
      (fn _ =>
        catch_errora
          (forallM
            (fn (tr, tau) =>
              let
                val psi = f tr;
              in
                bindb (check
                        (formula
                          (is_bool (B1_, B2_, B3_) type_of_fun bool_types) psi)
                        (shows_prec_list show_char zero_nata
                          [#"n", #"e", #"w", #" ", #"t", #"r", #"a", #"n", #"s",
                            #"i", #"t", #"i", #"o", #"n", #" ", #"f", #"o",
                            #"r", #"m", #"u", #"l", #"a", #" ", #"s", #"e",
                            #"e", #"m", #"s", #" ", #"t", #"o", #" ", #"b",
                            #"e", #" ", #"n", #"o", #"t", #" ", #"w", #"e",
                            #"l", #"l", #"-", #"f", #"o", #"r", #"m", #"e",
                            #"d"]))
                  (fn _ =>
                    catch_errora
                      let
                        val Transition (_, _, phi) = tau;
                      in
                        bindb (definability_checker (Post x) ty psi)
                          (fn _ =>
                            bindb (check
                                    (not (in_vars_formula
   (equal_prod (equal_trans_var C1_) B3_) (Post x, ty) phi))
                                    (shows_prec_list show_char zero_nata
                                       [#"P", #"o", #"s", #"t", #" ", #"x",
 #" ", #"i", #"n", #" ", #"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o",
 #"n", #" ", #"f", #"o", #"r", #"m", #"u", #"l", #"a"] o
                                      shows_formula sa2 phi))
                              (fn _ =>
                                check (not
(in_vars_formula (equal_prod (equal_trans_var C1_) B3_) (Pre x, ty) phi))
                                  (shows_prec_list show_char zero_nata
                                     [#"P", #"r", #"e", #" ", #"x", #" ", #"i",
                                       #"n", #" ", #"t", #"r", #"a", #"n", #"s",
                                       #"i", #"t", #"i", #"o", #"n", #" ", #"f",
                                       #"o", #"r", #"m", #"u", #"l", #"a"] o
                                    shows_formula sa2 phi)))
                      end
                      (fn xa =>
                        Inl (shows_prec_list show_char zero_nata
                               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                                 #"i", #"n", #" ", #"t", #"r", #"a", #"n", #"s",
                                 #"i", #"t", #"i", #"o", #"n", #" ", #"f", #"o",
                                 #"r", #"m", #"u", #"l", #"a", #" ", #"o", #"f",
                                 #" ", #"t", #"r", #"a", #"n", #"s", #"i", #"t",
                                 #"i", #"o", #"n", #" "] o
                               shows_prec E_ zero_nata tr o
                               shows_nl o
                              xa)))
              end)
            (transitions_impl p))
          (fn xa => Inl (snd xa))))
    (fn xa =>
      Inl (shows_prec_list show_char zero_nata
             [#"f", #"r", #"e", #"s", #"h", #"_", #"v", #"a", #"r", #"i", #"a",
               #"b", #"l", #"e", #"_", #"c", #"h", #"e", #"c", #"k", #"e", #"r",
               #" ", #"f", #"a", #"i", #"l", #"e", #"d", #"\n"] o
            xa));

fun shows_prec_formula A_ = showsp_formula (shows_prec A_);

fun refine_transition_formula (Transition (l, r, phi)) psi =
  Transition (l, r, form_and phi psi);

fun refine_transition_formulas p f =
  Lts_Impl
    (initiala p,
      map (fn (tr, tau) => (tr, refine_transition_formula tau (f tr)))
        (transitions_impl p),
      assertion_impl p);

fun fresh_variable_addition A_ (B1_, B2_, B3_, B4_) (C1_, C2_) D_
  (E1_, E2_, E3_, E4_) type_of_fun bool_types definability_checker sa2 p
  (Fresh_Variable_Addition_Info (x, ty, forms)) =
  let
    val m = of_alist (E1_, E2_, E3_) forms;
    val f = lookup_default (E1_, E2_) (Conjunction []) m;
  in
    (case catch_errora
            (bindb
              (catch_errora
                (forallM
                  (fn fa =>
                    check (formula
                            (is_bool (B1_, B2_, B3_) type_of_fun bool_types) fa)
                      (shows_prec_formula
                         (show_term A_ (show_prod (show_trans_var C2_) B4_))
                         zero_nata fa o
                        shows_prec_list show_char zero_nata
                          [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                            #" ", #"v", #"a", #"l", #"i", #"d", #" ", #"f",
                            #"o", #"r", #"m", #"u", #"l", #"a"]))
                  (map snd forms))
                (fn xa => Inl (snd xa)))
              (fn _ =>
                fresh_variable_checker A_ (B1_, B2_, B3_, B4_) (C1_, C2_) D_ E4_
                  type_of_fun bool_types definability_checker sa2 p f x ty))
            (fn xa =>
              Inl (shows_prec_list show_char zero_nata
                     [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i",
                       #"n", #" ", #"a", #"d", #"d", #"i", #"n", #"g", #" ",
                       #"f", #"r", #"e", #"s", #"h", #" ", #"v", #"a", #"r",
                       #"i", #"a", #"b", #"l", #"e", #" "] o
                     shows_prec C2_ zero_nata x o
                     shows_nl o
                    xa))
      of Inl a => Inl a | Inr _ => Inr (refine_transition_formulas p f))
  end;

fun is_sharp (Flat uu) = false
  | is_sharp (Sharpa uv) = true;

fun trivial_termination_checker D_ E_ shows_atom shows_tatom p =
  check (null (filtera (fn tau => is_sharp (source tau))
                (map snd (transitions_impl p))))
    (shows_prec_list show_char zero_nata
       [#"t", #"h", #"e", #"r", #"e", #" ", #"a", #"r", #"e", #" ", #"r", #"e",
         #"m", #"a", #"i", #"n", #"i", #"n", #"g", #" ", #"s", #"h", #"a", #"r",
         #"p", #" ", #"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n",
         #"s", #" ", #"i", #"n", #" "] o
      shows_lts (show_sharp D_) E_ shows_atom shows_tatom p);

fun lex_less_formula A_ B_ C_ less_eq_formula less_formula uu [va]
  (v :: vb :: vc) = Disjunction []
  | lex_less_formula A_ B_ C_ less_eq_formula less_formula uu [] (v :: vb :: vc)
    = Disjunction []
  | lex_less_formula A_ B_ C_ less_eq_formula less_formula [va] uv
    (v :: vb :: vc) = Disjunction []
  | lex_less_formula A_ B_ C_ less_eq_formula less_formula [] uv (v :: vb :: vc)
    = Disjunction []
  | lex_less_formula A_ B_ C_ less_eq_formula less_formula uu uv [] =
    Disjunction []
  | lex_less_formula A_ B_ C_ less_eq_formula less_formula uu (v :: vb :: vc)
    [va] = Disjunction []
  | lex_less_formula A_ B_ C_ less_eq_formula less_formula [va] (v :: vb :: vc)
    uw = Disjunction []
  | lex_less_formula A_ B_ C_ less_eq_formula less_formula [] (v :: vb :: vc) uw
    = Disjunction []
  | lex_less_formula A_ B_ C_ less_eq_formula less_formula uu [] uw =
    Disjunction []
  | lex_less_formula A_ B_ C_ less_eq_formula less_formula (v :: vb :: vc) uv
    [va] = Disjunction []
  | lex_less_formula A_ B_ C_ less_eq_formula less_formula (v :: vb :: vc) [va]
    uw = Disjunction []
  | lex_less_formula A_ B_ C_ less_eq_formula less_formula [] uv uw =
    Disjunction []
  | lex_less_formula A_ B_ C_ less_eq_formula less_formula (ba :: b :: bs)
    (xa :: x :: xs) (ya :: y :: ys) =
    form_or (form_and (less_formula xa ya) (less_eq_formula ba ya))
      (Conjunction
        [less_eq_formula xa ya,
          lex_less_formula A_ B_ C_ less_eq_formula less_formula (b :: bs)
            (x :: xs) (y :: ys)])
  | lex_less_formula A_ B_ C_ less_eq_formula less_formula [b] [x] [y] =
    form_and (less_formula x y) (less_eq_formula b y);

fun bound_exp (Transition_removal_info (x1, x2, x3, x4, x5)) = x4;

fun hinter (Transition_removal_info (x1, x2, x3, x4, x5)) = x5;

fun rank (Transition_removal_info (x1, x2, x3, x4, x5)) = x1;

fun check_lex_strict (A1_, A2_) (B1_, B2_, B3_, B4_) (C1_, C2_) (D1_, D2_)
  (E1_, E2_, E3_) F_ type_of_fun bool_types shows_atom logic_checker negate_atom
  less_eq_formula less_formula info pi (tr, Transition (l, r, phi)) =
  let
    val psi =
      lex_less_formula A2_ C2_ B4_ less_eq_formula less_formula
        (map (rename_vars_exp Pre) (bound_exp info))
        (map (rename_vars_exp Post) (rank info r))
        (map (rename_vars_exp Pre) (rank info l));
  in
    bindb (check (formula (is_bool (B1_, B2_, B3_) type_of_fun bool_types) psi)
            (shows_prec_list show_char zero_nata
               [#"l", #"e", #"x", #"-", #"l", #"e", #"s", #"s", #" ", #"d",
                 #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"e", #"n",
                 #"c", #"o", #"d", #"e", #" ", #"v", #"a", #"l", #"i", #"d",
                 #" ", #"f", #"o", #"r", #"m", #"u", #"l", #"a"] o
               shows_nl o
              shows_prec_formula
                (show_term A2_ (show_prod (show_trans_var C2_) B4_)) zero_nata
                psi))
      (fn _ =>
        check_formula A1_ (equal_trans_var C1_, show_trans_var C2_) B3_
          (D1_, D2_) shows_atom logic_checker negate_atom (hinter info tr)
          (Disjunction
            [psi, Disjunction [],
              form_not
                (map_formula (rename_vars_exp Pre)
                  (assertion_of
                    (ccompare_sharp E1_, equal_sharp E2_, mapping_impl_sharp) pi
                    l)),
              form_not phi]))
  end;

fun lex_leq_formula A_ B_ C_ less_eq_formula less_formula uu [va]
  (v :: vb :: vc) = Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula uu [] (v :: vb :: vc)
    = Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula [va] uv
    (v :: vb :: vc) = Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula [] uv (v :: vb :: vc)
    = Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula uu (v :: va) [] =
    Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula (v :: va) uv [] =
    Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula uu (v :: vb :: vc)
    [va] = Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula [va] (v :: vb :: vc)
    uw = Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula [] (v :: vb :: vc) uw
    = Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula uu [] (v :: va) =
    Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula (v :: va) [] uw =
    Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula (v :: vb :: vc) uv
    [va] = Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula (v :: vb :: vc) [va]
    uw = Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula [] uv (v :: va) =
    Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula [] (v :: va) uw =
    Disjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula [] [] [] =
    Conjunction []
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula (ba :: b :: bs)
    (xa :: x :: xs) (ya :: y :: ys) =
    form_or (form_and (less_formula xa ya) (less_eq_formula ba ya))
      (Conjunction
        [less_eq_formula xa ya,
          lex_leq_formula A_ B_ C_ less_eq_formula less_formula (b :: bs)
            (x :: xs) (y :: ys)])
  | lex_leq_formula A_ B_ C_ less_eq_formula less_formula [b] [x] [y] =
    less_eq_formula x y;

fun check_lex_weak (A1_, A2_) (B1_, B2_, B3_, B4_) (C1_, C2_) (D1_, D2_)
  (E1_, E2_, E3_) F_ type_of_fun bool_types shows_atom logic_checker negate_atom
  less_eq_formula less_formula info pi (tr, Transition (l, r, phi)) =
  let
    val psi =
      lex_leq_formula A2_ C2_ B4_ less_eq_formula less_formula
        (map (rename_vars_exp Pre) (bound_exp info))
        (map (rename_vars_exp Post) (rank info r))
        (map (rename_vars_exp Pre) (rank info l));
  in
    bindb (check (formula (is_bool (B1_, B2_, B3_) type_of_fun bool_types) psi)
            (shows_prec_list show_char zero_nata
               [#"l", #"e", #"x", #"-", #"l", #"e", #"q", #" ", #"d", #"o",
                 #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"e", #"n", #"c",
                 #"o", #"d", #"e", #" ", #"v", #"a", #"l", #"i", #"d", #" ",
                 #"f", #"o", #"r", #"m", #"u", #"l", #"a"] o
               shows_nl o
              shows_prec_formula
                (show_term A2_ (show_prod (show_trans_var C2_) B4_)) zero_nata
                psi))
      (fn _ =>
        check_formula A1_ (equal_trans_var C1_, show_trans_var C2_) B3_
          (D1_, D2_) shows_atom logic_checker negate_atom (hinter info tr)
          (Disjunction
            [psi, Disjunction [],
              form_not
                (map_formula (rename_vars_exp Pre)
                  (assertion_of
                    (ccompare_sharp E1_, equal_sharp E2_, mapping_impl_sharp) pi
                    l)),
              form_not phi]))
  end;

fun update_transitions_impl (Lts_Impl (i, tsa, lc)) ts = Lts_Impl (i, ts, lc);

fun del_transitions_impl (E1_, E2_, E3_) p td =
  update_transitions_impl p
    (diff_by_label (E1_, E2_) (transitions_impl p) (set (E1_, E2_, E3_) td));

fun processor (A1_, A2_, A3_, A4_, A5_) check_weak check_strict td pi =
  catch_errora
    (bindb
      (catch_errora
        (forallM
          (fn (tr, tau) =>
            (if membera A3_ td tr
              then bindb (check (is_sharp (source tau))
                           (shows_prec_list show_char zero_nata
                              [#"n", #"o", #"n", #"-", #"s", #"h", #"a", #"r",
                                #"p", #" ", #"t", #"r", #"a", #"n", #"s", #"i",
                                #"t", #"i", #"o", #"n", #" "] o
                              shows_prec A5_ zero_nata tr o
                             shows_prec_list show_char zero_nata
                               [#" ", #"c", #"a", #"n", #"n", #"o", #"t", #" ",
                                 #"b", #"e", #" ", #"r", #"e", #"m", #"o", #"v",
                                 #"e", #"d"]))
                     (fn _ =>
                       catch_errora (check_strict (tr, tau))
                         (fn x =>
                           Inl (shows_prec_list show_char zero_nata
                                  [#"F", #"a", #"i", #"l", #"e", #"d", #" ",
                                    #"t", #"o", #" ", #"s", #"t", #"r", #"i",
                                    #"c", #"t", #"l", #"y", #" ", #"o", #"r",
                                    #"i", #"e", #"n", #"t", #" ", #"t", #"r",
                                    #"a", #"n", #"s", #"i", #"t", #"i", #"o",
                                    #"n", #" "] o
                                  shows_prec A5_ zero_nata tr o
                                  shows_nl o
                                 x)))
              else (if is_sharp (source tau)
                     then catch_errora (check_weak (tr, tau))
                            (fn x =>
                              Inl (shows_prec_list show_char zero_nata
                                     [#"F", #"a", #"i", #"l", #"e", #"d", #" ",
                                       #"t", #"o", #" ", #"w", #"e", #"a", #"k",
                                       #"l", #"y", #" ", #"o", #"r", #"i", #"e",
                                       #"n", #"t", #" ", #"t", #"r", #"a", #"n",
                                       #"s", #"i", #"t", #"i", #"o", #"n",
                                       #" "] o
                                     shows_prec A5_ zero_nata tr o
                                     shows_nl o
                                    x))
                     else Inr ())))
          (transitions_impl pi))
        (fn x => Inl (snd x)))
      (fn _ => Inr (del_transitions_impl (A1_, A2_, A4_) pi td)))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"F", #"a", #"i", #"l", #"e", #"d", #" ", #"t", #"o", #" ", #"e",
               #"l", #"i", #"m", #"i", #"n", #"a", #"t", #"e", #" ", #"t", #"r",
               #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n", #"s", #" "] o
             shows_prec_list A5_ zero_nata td o
             shows_prec_list show_char zero_nata [#":", #"\n"] o
            x));

fun removed (Transition_removal_info (x1, x2, x3, x4, x5)) = x2;

fun lex_processor (A1_, A2_) (B1_, B2_, B3_, B4_) (C1_, C2_) (D1_, D2_)
  (E1_, E2_, E3_) (F1_, F2_, F3_, F4_, F5_) type_of_fun bool_types shows_atom
  logic_checker negate_atom dom_type less_eq_formula less_formula is_constant
  info pi =
  bindb (catch_errora
          (forallM
            (fn l =>
              catch_errora
                (forallM
                  (fn e =>
                    check (has_type B3_ type_of_fun e dom_type)
                      (shows_prec_list show_char zero_nata
                         [#"U", #"n", #"e", #"x", #"p", #"e", #"c", #"t", #"e",
                           #"d", #" ", #"t", #"y", #"p", #"e", #" ", #"o", #"f",
                           #" ", #"e", #"x", #"p", #"r", #"e", #"s", #"s", #"i",
                           #"o", #"n", #":", #"\n"] o
                        shows_prec_term A2_ (show_prod C2_ B4_) zero_nata e))
                  (rank info l))
                (fn x => Inl (snd x)))
            (nodes_lts_impl (equal_sharp E2_) pi))
          (fn x => Inl (snd x)))
    (fn _ =>
      bindb (catch_errora
              (forallM
                (fn e =>
                  check (has_type B3_ type_of_fun e dom_type)
                    (shows_prec_list show_char zero_nata
                       [#"U", #"n", #"e", #"x", #"p", #"e", #"c", #"t", #"e",
                         #"d", #" ", #"t", #"y", #"p", #"e", #" ", #"o", #"f",
                         #" ", #"b", #"o", #"u", #"n", #"d", #":", #" "] o
                      shows_prec_term A2_ (show_prod C2_ B4_) zero_nata e))
                (bound_exp info))
              (fn x => Inl (snd x)))
        (fn _ =>
          bindb (catch_errora
                  (forallM
                    (fn e =>
                      check (is_constant e)
                        (shows_prec_list show_char zero_nata
                           [#"N", #"o", #"n", #"-", #"c", #"o", #"n", #"s",
                             #"t", #"a", #"n", #"t", #" ", #"b", #"o", #"u",
                             #"n", #"d", #":", #" "] o
                          shows_prec_term A2_
                            (show_prod (show_trans_var C2_) B4_) zero_nata e))
                    (map (rename_vars_exp Pre) (bound_exp info)))
                  (fn x => Inl (snd x)))
            (fn _ =>
              processor (F1_, F2_, F3_, F4_, F5_)
                (check_lex_weak (A1_, A2_) (B1_, B2_, B3_, B4_) (C1_, C2_)
                  (D1_, D2_) (E1_, E2_, E3_) F5_ type_of_fun bool_types
                  shows_atom logic_checker negate_atom less_eq_formula
                  less_formula info pi)
                (check_lex_strict (A1_, A2_) (B1_, B2_, B3_, B4_) (C1_, C2_)
                  (D1_, D2_) (E1_, E2_, E3_) F5_ type_of_fun bool_types
                  shows_atom logic_checker negate_atom less_eq_formula
                  less_formula info pi)
                (removed info) pi)));

fun check_skip_transition A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
  negate_atom tau =
  let
    val Transition (_, _, phi) = tau;
  in
    check_valid_formula A_ (B1_, B2_) C_ (D1_, D2_) shows_atom logic_checker
      negate_atom (map_formula (rename_vars_exp untrans_var) phi)
  end;

fun change_source l (Transition (src, tgt, phi)) = Transition (l, tgt, phi);

fun location_addition_outgoing A_ (B1_, B2_, B3_) (C1_, C2_) (D1_, D2_)
  (E1_, E2_, E3_) F_ type_of_fun bool_types shows_atom logic_checker negate_atom
  p (Location_Addition_Info (old, new, skip_ID, skip)) =
  bindb (check
          (not (membera (equal_sharp E2_) (nodes_lts_impl (equal_sharp E2_) p)
                 new))
          (shows_prec_list show_char zero_nata
             [#"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n", #"-", #"i", #"d",
               #" "] o
             shows_prec_sharp E3_ zero_nata new o
            shows_prec_list show_char zero_nata
              [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"f", #"r", #"e",
                #"s", #"h"]))
    (fn _ =>
      bindb (check (is_sharp new)
              (shows_prec_list show_char zero_nata
                 [#"n", #"e", #"w", #" ", #"l", #"o", #"c", #"a", #"t", #"i",
                   #"o", #"n", #" "] o
                 shows_prec_sharp E3_ zero_nata new o
                shows_prec_list show_char zero_nata
                  [#" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e", #" ", #"s",
                    #"h", #"a", #"r", #"p", #" ", #"l", #"o", #"c", #"a", #"t",
                    #"i", #"o", #"n"]))
        (fn _ =>
          bindb (check (is_sharp old)
                  (shows_prec_list show_char zero_nata
                     [#"c", #"o", #"p", #"i", #"e", #"d", #" ", #"l", #"o",
                       #"c", #"a", #"t", #"i", #"o", #"n", #" "] o
                     shows_prec_sharp E3_ zero_nata old o
                    shows_prec_list show_char zero_nata
                      [#" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e", #" ",
                        #"s", #"h", #"a", #"r", #"p", #" ", #"l", #"o", #"c",
                        #"a", #"t", #"i", #"o", #"n"]))
            (fn _ =>
              bindb (check
                      (transition_rule (B1_, B2_, B3_) type_of_fun bool_types
                        skip)
                      (shows_prec_list show_char zero_nata
                         [#"n", #"e", #"w", #" ", #"t", #"r", #"a", #"n", #"s",
                           #"i", #"t", #"i", #"o", #"n", #" "] o
                         shows_prec F_ zero_nata skip_ID o
                        shows_prec_list show_char zero_nata
                          [#" ", #"s", #"e", #"e", #"m", #"s", #" ", #"t", #"o",
                            #" ", #"b", #"e", #" ", #"i", #"l", #"l", #"-",
                            #"f", #"o", #"r", #"m", #"e", #"d"]))
                (fn _ =>
                  bindb (catch_errora
                          (check_skip_transition A_ (C1_, C2_) B3_ (D1_, D2_)
                            shows_atom logic_checker negate_atom skip)
                          (fn x =>
                            Inl (shows_prec_list show_char zero_nata
                                   [#"n", #"e", #"w", #" ", #"t", #"r", #"a",
                                     #"n", #"s", #"i", #"t", #"i", #"o", #"n",
                                     #" "] o
                                   shows_prec F_ zero_nata skip_ID o
                                   shows_prec_list show_char zero_nata
                                     [#" ", #"m", #"u", #"s", #"t", #" ", #"b",
                                       #"e", #" ", #"s", #"k", #"i", #"p", #" ",
                                       #"t", #"r", #"a", #"n", #"s", #"i", #"t",
                                       #"i", #"o", #"n", #"\n"] o
                                  x)))
                    (fn _ =>
                      bindb (check
                              (equal_sharpa E2_ (source skip) old andalso
                                equal_sharpa E2_ (target skip) new)
                              (shows_prec_list show_char zero_nata
                                 [#"n", #"e", #"w", #" ", #"s", #"k", #"i",
                                   #"p", #" ", #"t", #"r", #"a", #"n", #"s",
                                   #"i", #"t", #"i", #"o", #"n", #" "] o
                                 shows_prec F_ zero_nata skip_ID o
                                 shows_prec_list show_char zero_nata
                                   [#" ", #"m", #"u", #"s", #"t", #" ", #"b",
                                     #"e", #" ", #"f", #"r", #"o", #"m", #" "] o
                                 shows_prec_sharp E3_ zero_nata old o
                                 shows_prec_list show_char zero_nata
                                   [#" ", #"t", #"o", #" "] o
                                shows_prec_sharp E3_ zero_nata new))
                        (fn _ =>
                          let
                            val trans = transitions_impl p;
                            val (sharp, flat) =
                              partition (fn tau => is_sharp (source (snd tau)))
                                trans;
                            val (sharp_modify, sharp_keep) =
                              partition
                                (fn tau =>
                                  equal_sharpa E2_ (source (snd tau)) old)
                                sharp;
                            val q =
                              Lts_Impl
                                (initiala p,
                                  (skip_ID, skip) ::
                                    flat @
                                      sharp_keep @
map (fn tau => (fst tau, change_source new (snd tau))) sharp_modify,
                                  (new, assertion_of
  (ccompare_sharp E1_, equal_sharp E2_, mapping_impl_sharp) p old) ::
                                    assertion_impl p);
                          in
                            bindb (catch_errora
                                    (forallM
                                      (fn l =>
check (equal_formulaa (equal_term A_ (equal_prod C1_ B3_))
        (assertion_of (ccompare_sharp E1_, equal_sharp E2_, mapping_impl_sharp)
          p l)
        (assertion_of (ccompare_sharp E1_, equal_sharp E2_, mapping_impl_sharp)
          q l))
  (shows_prec_list show_char zero_nata
     [#"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"c", #"o", #"n",
       #"d", #"i", #"t", #"i", #"o", #"n", #" ", #"o", #"f", #" ", #"i", #"n",
       #"i", #"t", #"i", #"a", #"l", #" ", #"s", #"t", #"a", #"t", #"e", #" "] o
     shows_prec_sharp E3_ zero_nata l o
    shows_prec_list show_char zero_nata
      [#" ", #"h", #"a", #"s", #" ", #"b", #"e", #"e", #"n", #" ", #"c", #"h",
        #"a", #"n", #"g", #"e", #"d"]))
                                      (initiala p))
                                    (fn x => Inl (snd x)))
                              (fn _ => Inr q)
                          end))))));

fun change_target l (Transition (src, tgt, phi)) = Transition (src, l, phi);

fun location_addition_incoming A_ (B1_, B2_, B3_) (C1_, C2_) (D1_, D2_)
  (E1_, E2_, E3_) F_ type_of_fun bool_types shows_atom logic_checker negate_atom
  p (Location_Addition_Info (new, old, skip_ID, skip)) =
  bindb (check
          (not (membera (equal_sharp E2_) (nodes_lts_impl (equal_sharp E2_) p)
                 new))
          (shows_prec_list show_char zero_nata
             [#"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n", #"-", #"i", #"d",
               #" "] o
             shows_prec_sharp E3_ zero_nata new o
            shows_prec_list show_char zero_nata
              [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"f", #"r", #"e",
                #"s", #"h"]))
    (fn _ =>
      bindb (check (is_sharp new)
              (shows_prec_list show_char zero_nata
                 [#"n", #"e", #"w", #" ", #"l", #"o", #"c", #"a", #"t", #"i",
                   #"o", #"n", #" "] o
                 shows_prec_sharp E3_ zero_nata new o
                shows_prec_list show_char zero_nata
                  [#" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e", #" ", #"s",
                    #"h", #"a", #"r", #"p", #" ", #"l", #"o", #"c", #"a", #"t",
                    #"i", #"o", #"n"]))
        (fn _ =>
          bindb (check (is_sharp old)
                  (shows_prec_list show_char zero_nata
                     [#"c", #"o", #"p", #"i", #"e", #"d", #" ", #"l", #"o",
                       #"c", #"a", #"t", #"i", #"o", #"n", #" "] o
                     shows_prec_sharp E3_ zero_nata old o
                    shows_prec_list show_char zero_nata
                      [#" ", #"m", #"u", #"s", #"t", #" ", #"b", #"e", #" ",
                        #"s", #"h", #"a", #"r", #"p", #" ", #"l", #"o", #"c",
                        #"a", #"t", #"i", #"o", #"n"]))
            (fn _ =>
              bindb (check
                      (transition_rule (B1_, B2_, B3_) type_of_fun bool_types
                        skip)
                      (shows_prec_list show_char zero_nata
                         [#"n", #"e", #"w", #" ", #"t", #"r", #"a", #"n", #"s",
                           #"i", #"t", #"i", #"o", #"n", #" "] o
                         shows_prec F_ zero_nata skip_ID o
                        shows_prec_list show_char zero_nata
                          [#" ", #"s", #"e", #"e", #"m", #"s", #" ", #"t", #"o",
                            #" ", #"b", #"e", #" ", #"i", #"l", #"l", #"-",
                            #"f", #"o", #"r", #"m", #"e", #"d"]))
                (fn _ =>
                  bindb (catch_errora
                          (check_skip_transition A_ (C1_, C2_) B3_ (D1_, D2_)
                            shows_atom logic_checker negate_atom skip)
                          (fn x =>
                            Inl (shows_prec_list show_char zero_nata
                                   [#"n", #"e", #"w", #" ", #"t", #"r", #"a",
                                     #"n", #"s", #"i", #"t", #"i", #"o", #"n",
                                     #" "] o
                                   shows_prec F_ zero_nata skip_ID o
                                   shows_prec_list show_char zero_nata
                                     [#" ", #"m", #"u", #"s", #"t", #" ", #"b",
                                       #"e", #" ", #"s", #"k", #"i", #"p", #" ",
                                       #"t", #"r", #"a", #"n", #"s", #"i", #"t",
                                       #"i", #"o", #"n", #"\n"] o
                                  x)))
                    (fn _ =>
                      bindb (check
                              (equal_sharpa E2_ (source skip) new andalso
                                equal_sharpa E2_ (target skip) old)
                              (shows_prec_list show_char zero_nata
                                 [#"n", #"e", #"w", #" ", #"s", #"k", #"i",
                                   #"p", #" ", #"t", #"r", #"a", #"n", #"s",
                                   #"i", #"t", #"i", #"o", #"n", #" "] o
                                 shows_prec F_ zero_nata skip_ID o
                                 shows_prec_list show_char zero_nata
                                   [#" ", #"m", #"u", #"s", #"t", #" ", #"b",
                                     #"e", #" ", #"f", #"r", #"o", #"m", #" "] o
                                 shows_prec_sharp E3_ zero_nata new o
                                 shows_prec_list show_char zero_nata
                                   [#" ", #"t", #"o", #" "] o
                                shows_prec_sharp E3_ zero_nata old))
                        (fn _ =>
                          let
                            val trans = transitions_impl p;
                            val (sharp, flat) =
                              partition (fn tau => is_sharp (source (snd tau)))
                                trans;
                            val (sharp_modify, sharp_keep) =
                              partition
                                (fn tau =>
                                  equal_sharpa E2_ (target (snd tau)) old)
                                sharp;
                            val q =
                              Lts_Impl
                                (initiala p,
                                  (skip_ID, skip) ::
                                    flat @
                                      sharp_keep @
map (fn tau => (fst tau, change_target new (snd tau))) sharp_modify,
                                  (new, assertion_of
  (ccompare_sharp E1_, equal_sharp E2_, mapping_impl_sharp) p old) ::
                                    assertion_impl p);
                          in
                            bindb (catch_errora
                                    (forallM
                                      (fn l =>
check (equal_formulaa (equal_term A_ (equal_prod C1_ B3_))
        (assertion_of (ccompare_sharp E1_, equal_sharp E2_, mapping_impl_sharp)
          p l)
        (assertion_of (ccompare_sharp E1_, equal_sharp E2_, mapping_impl_sharp)
          q l))
  (shows_prec_list show_char zero_nata
     [#"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"c", #"o", #"n",
       #"d", #"i", #"t", #"i", #"o", #"n", #" ", #"o", #"f", #" ", #"i", #"n",
       #"i", #"t", #"i", #"a", #"l", #" ", #"s", #"t", #"a", #"t", #"e", #" "] o
     shows_prec_sharp E3_ zero_nata l o
    shows_prec_list show_char zero_nata
      [#" ", #"h", #"a", #"s", #" ", #"b", #"e", #"e", #"n", #" ", #"c", #"h",
        #"a", #"n", #"g", #"e", #"d"]))
                                      (initiala p))
                                    (fn x => Inl (snd x)))
                              (fn _ => Inr q)
                          end))))));

fun location_addition A_ (B1_, B2_, B3_) (C1_, C2_) (D1_, D2_) (E1_, E2_, E3_)
  F_ type_of_fun bool_types shows_atom logic_checker negate_atom p info =
  let
    val Location_Addition_Info (src, _, _, _) = info;
  in
    (if not (membera (equal_sharp E2_) (nodes_lts_impl (equal_sharp E2_) p) src)
      then location_addition_incoming A_ (B1_, B2_, B3_) (C1_, C2_) (D1_, D2_)
             (E1_, E2_, E3_) F_ type_of_fun bool_types shows_atom logic_checker
             negate_atom p info
      else location_addition_outgoing A_ (B1_, B2_, B3_) (C1_, C2_) (D1_, D2_)
             (E1_, E2_, E3_) F_ type_of_fun bool_types shows_atom logic_checker
             negate_atom p info)
  end;

fun call_graph_sharp_impl D_ r =
  remdups (equal_prod (equal_sharp D_) (equal_sharp D_))
    (maps (fn tau =>
            (if is_sharp (source (snd tau))
              then [(source (snd tau), target (snd tau))] else []))
      (transitions_impl r));

fun scc_decomposition (D1_, D2_, D3_, D4_) cp sccs_info =
  let
    val cg = call_graph_sharp_impl D2_ cp;
    val sccs =
      scc_decomp
        (ceq_sharp D2_, ccompare_sharp D1_, equal_sharp D2_,
          key_sharp ((compare_compare_order o compare_order_key) D3_),
          set_impl_sharp)
        cg;
  in
    bindb (catch_errora
            (forallM
              (fn c =>
                check (list_ex
                        (fn d =>
                          set_eq
                            (cenum_sharp, ceq_sharp D2_, ccompare_sharp D1_)
                            (set (ceq_sharp D2_, ccompare_sharp D1_,
                                   set_impl_sharp)
                              c)
                            (set (ceq_sharp D2_, ccompare_sharp D1_,
                                   set_impl_sharp)
                              d))
                        sccs_info)
                  (shows_prec_list show_char zero_nata
                     [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                       #" ", #"f", #"i", #"n", #"d", #" ", #"S", #"C", #"C",
                       #" "] o
                     shows_prec_list (show_sharp D4_) zero_nata c o
                    shows_prec_list show_char zero_nata
                      [#" ", #"i", #"n", #" ", #"p", #"r", #"o", #"v", #"i",
                        #"d", #"e", #"d", #" ", #"d", #"e", #"c", #"o", #"m",
                        #"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n"]))
              sccs)
            (fn x => Inl (snd x)))
      (fn _ =>
        let
          val trans = transitions_impl cp;
          val (sharp, flat) =
            partition (fn tau => is_sharp (source (snd tau))) trans;
          val cPs =
            map (fn c =>
                  let
                    val l =
                      set (ceq_sharp D2_, ccompare_sharp D1_, set_impl_sharp) c;
                  in
                    Lts_Impl
                      (initiala cp,
                        flat @
                          filtera
                            (fn tau =>
                              member (ceq_sharp D2_, ccompare_sharp D1_)
                                (source (snd tau)) l andalso
                                member (ceq_sharp D2_, ccompare_sharp D1_)
                                  (target (snd tau)) l)
                            sharp,
                        assertion_impl cp)
                  end)
              sccs_info;
        in
          catch_errora (Inr cPs)
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"s", #" ",
                       #"S", #"C", #"C", #"-", #"d", #"e", #"c", #"o", #"m",
                       #"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n", #" ",
                       #"w", #".", #"r", #".", #"t", #".", #" ", #"s", #"c",
                       #"c", #"s", #"_", #"i", #"n", #"f", #"o"] o
                     shows_prec_list (show_list (show_sharp D4_)) zero_nata
                       sccs_info o
                     shows_nl o
                    x))
        end)
  end;

fun cut_transition_split (A1_, A2_, A3_, A4_, A5_) (E1_, E2_, E3_)
  (Cut_Transition_Split_Info ct_ids) cp =
  catch_errora
    let
      val (p, r) =
        partition ((fn tau => is_sharp (source tau)) o snd)
          (transitions_impl cp);
      val (ct, rr) = partition (is_sharp o target o snd) r;
      val slist = map (source o snd) p;
      val s = set (ceq_sharp E2_, ccompare_sharp E1_, set_impl_sharp) slist;
      val cT_ids = set (A1_, A2_, A4_) (concat ct_ids);
    in
      bindb (catch_errora
              (forallM
                (fn l =>
                  check (not (is_sharp l))
                    (shows_prec_list show_char zero_nata
                       [#"i", #"n", #"i", #"t", #"i", #"a", #"l", #" ", #"s",
                         #"t", #"a", #"t", #"e", #" "] o
                       shows_prec_sharp E3_ zero_nata l o
                      shows_prec_list show_char zero_nata
                        [#" ", #"m", #"u", #"s", #"t", #" ", #"n", #"o", #"t",
                          #" ", #"b", #"e", #" ", #"s", #"h", #"a", #"r", #"p",
                          #"e", #"d"]))
                (initiala cp))
              (fn x => Inl (snd x)))
        (fn _ =>
          bindb (catch_errora
                  (forallM
                    (fn (t_id, cta) =>
                      check (if member (ceq_sharp E2_, ccompare_sharp E1_)
                                  (target cta) s
                              then member (A1_, A2_) t_id cT_ids else true)
                        (shows_prec_list show_char zero_nata
                           [#"d", #"i", #"d", #" ", #"n", #"o", #"t", #" ",
                             #"f", #"i", #"n", #"d", #" ", #"c", #"u", #"t",
                             #"-", #"t", #"r", #"a", #"n", #"s", #"i", #"t",
                             #"i", #"o", #"n", #" "] o
                           shows_prec A5_ zero_nata t_id o
                           shows_prec_list show_char zero_nata
                             [#" ", #"i", #"n", #" ", #"p", #"a", #"r", #"t",
                               #"i", #"t", #"i", #"o", #"n", #"\n", #"r", #"e",
                               #"l", #"e", #"v", #"a", #"n", #"t", #" ", #"c",
                               #"u", #"t", #"-", #"p", #"o", #"i", #"n", #"t",
                               #"s", #" ", #"a", #"r", #"e", #":", #" "] o
                          shows_prec_list (show_sharp E3_) zero_nata slist))
                    ct)
                  (fn x => Inl (snd x)))
            (fn _ =>
              let
                val rrp = rr @ p;
              in
                Inr (map (fn ct_idsa =>
                           Lts_Impl
                             (initiala cp,
                               filtera (fn cta => membera A3_ ct_idsa (fst cta))
                                 ct @
                                 rrp,
                               assertion_impl cp))
                      ct_ids)
              end))
    end
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"s", #"p",
               #"l", #"i", #"t", #"t", #"i", #"n", #"g", #" ", #"c", #"u", #"t",
               #" ", #"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n",
               #"s", #" ", #"o", #"n", #" ", #"L", #"T", #"S", #"\n"] o
            x));

fun shows_cooperation_program D_ E_ (Lts_Impl (i, tran, lc)) =
  let
    val trana = filtera (fn (_, tt) => is_sharp (target tt)) tran;
    val tranb =
      let
        val (ss, fs) = partition (fn (_, tt) => is_sharp (source tt)) trana;
      in
        fs @ ss
      end;
  in
    shows_prec_list show_char zero_nata
      [#"C", #"o", #"o", #"p", #"e", #"r", #"a", #"t", #"i", #"o", #"n", #" ",
        #"p", #"r", #"o", #"g", #"r", #"a", #"m", #" ", #"(", #"o", #"n", #"l",
        #"y", #" ", #"s", #"h", #"a", #"r", #"p", #"-", #"p", #"a", #"r", #"t",
        #")", #"\n"] o
      shows_sep
        (fn (t, tt) =>
          shows_prec E_ zero_nata t o
            shows_prec_list show_char zero_nata [#":", #" "] o
            shows_prec_sharp D_ zero_nata (source tt) o
            shows_prec_list show_char zero_nata [#" ", #"-", #"-", #">", #" "] o
            shows_prec_sharp D_ zero_nata (target tt))
        shows_nl tranb
  end o
    shows_nl;

fun check_cooperation_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
  (D1_, D2_, D3_) (E1_, E2_, E3_, E4_) (F1_, F2_, F3_, F4_, F5_, F6_)
  type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type less_eq_formula
  less_formula is_constant definability_checker pre i cPi
  (Cut_Transition_Split scc_proofs) =
  debug ((pre o shows_prec_nat zero_nata i) [])
    [#"C", #"u", #"t", #" ", #"T", #"r", #"a", #"n", #"s", #"i", #"t", #"i",
      #"o", #"n", #" ", #"S", #"p", #"l", #"i", #"t"]
    (bindb
      (catch_errora
        (cut_transition_split (F1_, F2_, F3_, F5_, F6_) (E1_, E2_, E4_)
          (Cut_Transition_Split_Info (map fst scc_proofs)) cPi)
        (fn x =>
          Inl (pre o shows_prec_nat zero_nata i o
                 shows_prec_list show_char zero_nata
                   [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n",
                     #" ", #"c", #"u", #"t", #"-", #"t", #"r", #"a", #"n", #"s",
                     #"i", #"t", #"i", #"o", #"n", #" ", #"s", #"p", #"l", #"i",
                     #"t", #"\n"] o
                 shows_cooperation_program E4_ F6_ cPi o
                x)))
      (fn sccs =>
        catch_errora
          (forallM_index
            (fn (scc, prof) => fn j =>
              catch_errora
                (check_cooperation_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_)
                  (C1_, C2_) (D1_, D2_, D3_) (E1_, E2_, E3_, E4_)
                  (F1_, F2_, F3_, F4_, F5_, F6_) type_of_fun bool_types tc tc2
                  sa sa2 ne ne2 dom_type less_eq_formula less_formula
                  is_constant definability_checker
                  (pre o shows_prec_nat zero_nata i o
                     shows_prec_list show_char zero_nata [#"."] o
                     shows_prec_nat zero_nata (suc j) o
                    shows_prec_list show_char zero_nata [#"."])
                  one_nata scc prof)
                (fn x =>
                  Inl (pre o shows_prec_nat zero_nata i o
                         shows_prec_list show_char zero_nata
                           [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                             #"b", #"e", #"l", #"o", #"w", #" ", #"c", #"u",
                             #"t", #"-", #"t", #"r", #"a", #"n", #"s", #"i",
                             #"t", #"i", #"o", #"n", #" ", #"s", #"p", #"l",
                             #"i", #"t", #"\n"] o
                        x)))
            (zip sccs (map snd scc_proofs)))
          (fn x => Inl (snd x))))
  | check_cooperation_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
    (D1_, D2_, D3_) (E1_, E2_, E3_, E4_) (F1_, F2_, F3_, F4_, F5_, F6_)
    type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type less_eq_formula
    less_formula is_constant definability_checker pre i cPi
    (Scc_Decomp scc_proofs) =
    debug ((pre o shows_prec_nat zero_nata i) [])
      [#"S", #"C", #"C", #" ", #"D", #"e", #"c", #"o", #"m", #"p"]
      (bindb
        (catch_errora
          (scc_decomposition (E1_, E2_, E3_, E4_) cPi (map fst scc_proofs))
          (fn x =>
            Inl (pre o shows_prec_nat zero_nata i o
                   shows_prec_list show_char zero_nata
                     [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                       #"n", #" ", #"S", #"c", #"c", #" ", #"d", #"e", #"c",
                       #"o", #"m", #"p", #"o", #"s", #"i", #"t", #"i", #"o",
                       #"n", #"\n"] o
                   shows_cooperation_program E4_ F6_ cPi o
                  x)))
        (fn sccs =>
          catch_errora
            (forallM_index
              (fn (scc, prof) => fn j =>
                catch_errora
                  (check_cooperation_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_)
                    (C1_, C2_) (D1_, D2_, D3_) (E1_, E2_, E3_, E4_)
                    (F1_, F2_, F3_, F4_, F5_, F6_) type_of_fun bool_types tc tc2
                    sa sa2 ne ne2 dom_type less_eq_formula less_formula
                    is_constant definability_checker
                    (pre o shows_prec_nat zero_nata i o
                       shows_prec_list show_char zero_nata [#"."] o
                       shows_prec_nat zero_nata (suc j) o
                      shows_prec_list show_char zero_nata [#"."])
                    one_nata scc prof)
                  (fn x =>
                    Inl (pre o shows_prec_nat zero_nata i o
                           shows_prec_list show_char zero_nata
                             [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                               #"b", #"e", #"l", #"o", #"w", #" ", #"S", #"c",
                               #"c", #" ", #"d", #"e", #"c", #"o", #"m", #"p",
                               #"o", #"s", #"i", #"t", #"i", #"o", #"n",
                               #"\n"] o
                          x)))
              (zip sccs (map snd scc_proofs)))
            (fn x => Inl (snd x))))
  | check_cooperation_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
    (D1_, D2_, D3_) (E1_, E2_, E3_, E4_) (F1_, F2_, F3_, F4_, F5_, F6_)
    type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type less_eq_formula
    less_formula is_constant definability_checker pre i cPi
    (Fresh_Variable_Addition (info, iproof)) =
    debug ((pre o shows_prec_nat zero_nata i) [])
      [#"F", #"r", #"e", #"s", #"h", #" ", #"V", #"a", #"r", #"i", #"a", #"b",
        #"l", #"e", #" ", #"A", #"d", #"d", #"i", #"t", #"i", #"o", #"n"]
      (bindb
        (catch_errora
          (fresh_variable_addition A3_ (B1_, B2_, B3_, B4_) (D2_, D3_)
            (show_sharp E4_) (F2_, F3_, F4_, F6_) type_of_fun bool_types
            definability_checker sa2 cPi info)
          (fn x =>
            Inl (pre o shows_prec_nat zero_nata i o
                   shows_prec_list show_char zero_nata
                     [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                       #"n", #" ", #"f", #"r", #"e", #"s", #"h", #" ", #"v",
                       #"a", #"r", #"i", #"a", #"b", #"l", #"e", #" ", #"a",
                       #"d", #"d", #"i", #"t", #"i", #"o", #"n", #"\n"] o
                   shows_cooperation_program E4_ F6_ cPi o
                  x)))
        (fn q =>
          catch_errora
            (check_cooperation_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_)
              (C1_, C2_) (D1_, D2_, D3_) (E1_, E2_, E3_, E4_)
              (F1_, F2_, F3_, F4_, F5_, F6_) type_of_fun bool_types tc tc2 sa
              sa2 ne ne2 dom_type less_eq_formula less_formula is_constant
              definability_checker pre (plus_nata i one_nata) q iproof)
            (fn x =>
              Inl (pre o shows_prec_nat zero_nata i o
                     shows_prec_list show_char zero_nata
                       [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                         #"e", #"l", #"o", #"w", #" ", #"f", #"r", #"e", #"s",
                         #"h", #" ", #"v", #"a", #"r", #"i", #"a", #"b", #"l",
                         #"e", #" ", #"a", #"d", #"d", #"i", #"t", #"i", #"o",
                         #"n", #"\n"] o
                    x))))
  | check_cooperation_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
    (D1_, D2_, D3_) (E1_, E2_, E3_, E4_) (F1_, F2_, F3_, F4_, F5_, F6_)
    type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type less_eq_formula
    less_formula is_constant definability_checker pre i cPi
    (Location_Addition (info, iproof)) =
    debug ((pre o shows_prec_nat zero_nata i) [])
      [#"L", #"o", #"c", #"a", #"t", #"i", #"o", #"n", #" ", #"A", #"d", #"d",
        #"i", #"t", #"i", #"o", #"n"]
      (bindb
        (catch_errora
          (location_addition A2_ (B1_, B2_, B3_) (D2_, D3_) (C1_, C2_)
            (E1_, E2_, E4_) F6_ type_of_fun bool_types sa tc ne cPi info)
          (fn x =>
            Inl (pre o shows_prec_list show_char zero_nata
                         [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                           #"n", #" ", #"l", #"o", #"c", #"a", #"t", #"i", #"o",
                           #"n", #" ", #"a", #"d", #"d", #"i", #"t", #"i", #"o",
                           #"n", #"\n"] o
                   shows_cooperation_program E4_ F6_ cPi o
                  x)))
        (fn q =>
          catch_errora
            (check_cooperation_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_)
              (C1_, C2_) (D1_, D2_, D3_) (E1_, E2_, E3_, E4_)
              (F1_, F2_, F3_, F4_, F5_, F6_) type_of_fun bool_types tc tc2 sa
              sa2 ne ne2 dom_type less_eq_formula less_formula is_constant
              definability_checker pre (plus_nata i one_nata) q iproof)
            (fn x =>
              Inl (pre o shows_prec_nat zero_nata i o
                     shows_prec_list show_char zero_nata
                       [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                         #"e", #"l", #"o", #"w", #" ", #"l", #"o", #"c", #"a",
                         #"t", #"i", #"o", #"n", #" ", #"a", #"d", #"d", #"i",
                         #"t", #"i", #"o", #"n", #"\n"] o
                    x))))
  | check_cooperation_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
    (D1_, D2_, D3_) (E1_, E2_, E3_, E4_) (F1_, F2_, F3_, F4_, F5_, F6_)
    type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type less_eq_formula
    less_formula is_constant definability_checker pre i cPi
    (Transition_Removal (info, iproof)) =
    debug ((pre o shows_prec_nat zero_nata i) [])
      [#"T", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n", #" ", #"R",
        #"e", #"m", #"o", #"v", #"a", #"l"]
      (bindb
        (catch_errora
          (lex_processor (A2_, A3_) (B1_, B2_, B3_, B4_) (D2_, D3_) (C1_, C2_)
            (E1_, E2_, E4_) (F1_, F2_, F3_, F5_, F6_) type_of_fun bool_types sa2
            tc2 ne2 dom_type less_eq_formula less_formula is_constant info cPi)
          (fn x =>
            Inl (pre o shows_prec_nat zero_nata i o
                   shows_prec_list show_char zero_nata
                     [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                       #"n", #" ", #"t", #"r", #"a", #"n", #"s", #"i", #"t",
                       #"i", #"o", #"n", #" ", #"r", #"e", #"m", #"o", #"v",
                       #"a", #"l", #"\n"] o
                   shows_cooperation_program E4_ F6_ cPi o
                  x)))
        (fn cPia =>
          catch_errora
            (check_cooperation_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_)
              (C1_, C2_) (D1_, D2_, D3_) (E1_, E2_, E3_, E4_)
              (F1_, F2_, F3_, F4_, F5_, F6_) type_of_fun bool_types tc tc2 sa
              sa2 ne ne2 dom_type less_eq_formula less_formula is_constant
              definability_checker pre (plus_nata i one_nata) cPia iproof)
            (fn x =>
              Inl (pre o shows_prec_nat zero_nata i o
                     shows_prec_list show_char zero_nata
                       [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                         #"e", #"l", #"o", #"w", #" ", #"t", #"r", #"a", #"n",
                         #"s", #"i", #"t", #"i", #"o", #"n", #" ", #"r", #"e",
                         #"m", #"o", #"v", #"a", #"l", #"\n"] o
                    x))))
  | check_cooperation_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
    (D1_, D2_, D3_) (E1_, E2_, E3_, E4_) (F1_, F2_, F3_, F4_, F5_, F6_)
    type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type less_eq_formula
    less_formula is_constant definability_checker pre i cPi
    (Invariants_Update (iproof, cproof)) =
    debug ((pre o shows_prec_nat zero_nata i) [])
      [#"I", #"n", #"v", #"a", #"r", #"i", #"a", #"n", #"t", #"s", #"_", #"U",
        #"p", #"d", #"a", #"t", #"e"]
      (bindb
        (catch_errora
          (invariant_proof_checker (A1_, A2_, A3_) (B1_, B2_, B3_, B4_)
            (C1_, C2_) (D1_, D2_, D3_)
            (cenum_sharp, ceq_sharp E2_, ccompare_sharp E1_, equal_sharp E2_,
              mapping_impl_sharp, set_impl_sharp, show_sharp E4_)
            (F1_, F2_, F3_, F4_, F5_, F6_)
            (ccompare_list ccompare_char, equal_list equal_char,
              mapping_impl_list, show_list show_char)
            type_of_fun bool_types tc tc2 sa sa2 ne ne2 cPi iproof)
          (fn x =>
            Inl (pre o shows_prec_nat zero_nata i o
                   shows_prec_list show_char zero_nata
                     [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                       #"n", #" ", #"i", #"n", #"v", #"a", #"r", #"i", #"a",
                       #"n", #"t", #" ", #"u", #"p", #"d", #"a", #"t", #"e",
                       #"\n"] o
                   shows_cooperation_program E4_ F6_ cPi o
                  x)))
        (fn ia =>
          bindb (fix_invariants
                  (ccompare_sharp E1_, equal_sharp E2_, mapping_impl_sharp,
                    show_sharp E4_)
                  F6_ cPi ia)
            (fn q =>
              catch_errora
                (check_cooperation_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_)
                  (C1_, C2_) (D1_, D2_, D3_) (E1_, E2_, E3_, E4_)
                  (F1_, F2_, F3_, F4_, F5_, F6_) type_of_fun bool_types tc tc2
                  sa sa2 ne ne2 dom_type less_eq_formula less_formula
                  is_constant definability_checker pre (plus_nata i one_nata) q
                  cproof)
                (fn x =>
                  Inl (pre o shows_prec_nat zero_nata i o
                         shows_prec_list show_char zero_nata
                           [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                             #"b", #"e", #"l", #"o", #"w", #" ", #"i", #"n",
                             #"v", #"a", #"r", #"i", #"a", #"n", #"t", #" ",
                             #"u", #"p", #"d", #"a", #"t", #"e", #"\n"] o
                        x)))))
  | check_cooperation_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
    (D1_, D2_, D3_) (E1_, E2_, E3_, E4_) (F1_, F2_, F3_, F4_, F5_, F6_)
    type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type less_eq_formula
    less_formula is_constant definability_checker pre i cPi Triviala =
    debug ((pre o shows_prec_nat zero_nata i) [])
      [#"T", #"r", #"i", #"v", #"i", #"a", #"l", #" ", #"C", #"P"]
      (catch_errora (trivial_termination_checker E4_ F6_ sa sa2 cPi)
        (fn x =>
          Inl (pre o shows_prec_nat zero_nata i o
                 shows_prec_list show_char zero_nata
                   [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n",
                     #" ", #"t", #"r", #"i", #"v", #"i", #"a", #"l", #" ", #"c",
                     #"o", #"o", #"p", #"e", #"r", #"a", #"t", #"i", #"o", #"n",
                     #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
                     #"o", #"n", #" ", #"c", #"h", #"e", #"c", #"k", #"e", #"r",
                     #"\n"] o
                x)));

fun check_exists_cut A_ (B1_, B2_) C_ (D1_, D2_) (E1_, E2_) shows_atom
  logic_checker negate_atom taus n =
  check (list_ex
          (fn tau =>
            equal_sharpa E1_ (source tau) (Flat n) andalso
              (equal_sharpa E1_ (target tau) (Sharpa n) andalso
                isOK (check_skip_transition A_ (B1_, B2_) C_ (D1_, D2_)
                       shows_atom logic_checker negate_atom tau)))
          taus)
    (shows_prec_list show_char zero_nata
      ([#"m", #"i", #"s", #"s", #"i", #"n", #"g", #" ", #"s", #"k", #"i", #"p",
         #" ", #"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n", #" ",
         #"f", #"o", #"r", #" "] @
        shows_prec E2_ zero_nata n []));

fun sharp_transition (Transition (l, r, phi)) =
  Transition (Sharpa l, Sharpa r, phi);

fun flat_transition (Transition (l, r, phi)) = Transition (Flat l, Flat r, phi);

fun make_copy_prog (Lts_Impl (init, tau_s, lc)) cutpoints =
  Lts_Impl
    (map Flat init,
      map (fn (tr, tau) => (Flat tr, flat_transition tau)) tau_s @
        cutpoints @
          map (fn (tr, tau) => (Sharpa tr, sharp_transition tau)) tau_s,
      map (fn (tr, a) => (Flat tr, a)) lc @
        map (fn (tr, a) => (Sharpa tr, a)) lc);

fun call_graph_impl D_ r =
  remdups (equal_prod D_ D_)
    (map (fn tau => (source (snd tau), target (snd tau))) (transitions_impl r));

fun check_cut_points (A1_, A2_, A3_, A4_, A5_, A6_) r x =
  check_acyclic (A1_, A2_, A3_, A4_, A5_, A6_)
    (filtera
      (fn ab =>
        not (member (A1_, A2_) (fst ab) x) andalso
          not (member (A1_, A2_) (snd ab) x))
      r);

fun natural (Sharpa l) = l
  | natural (Flat l) = l;

fun create_initial_cp_prog A_ (B1_, B2_, B3_) (C1_, C2_) (D1_, D2_)
  (E1_, E2_, E3_, E4_, E5_, E6_) F_ type_of_fun bool_types shows_atom
  logic_checker negate_atom p cp_trans_list =
  (case let
          val cp_trans = concat cp_trans_list;
          val cut_points =
            remdups E3_ (map (fn (_, tau) => natural (source tau)) cp_trans);
        in
          bindb (catch_errora
                  (check_cut_points (E1_, E2_, E3_, E4_, E5_, E6_)
                    (call_graph_impl E3_ p) (set (E1_, E2_, E5_) cut_points))
                  (fn x =>
                    Inl (shows_prec_list show_char zero_nata
                           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                             #"i", #"n", #" ", #"e", #"n", #"s", #"u", #"r",
                             #"i", #"n", #"g", #" ", #"v", #"a", #"l", #"i",
                             #"d", #"i", #"t", #"y", #" ", #"o", #"f", #" ",
                             #"c", #"u", #"t", #"p", #"o", #"i", #"n", #"t",
                             #"s", #"\n"] o
                          x)))
            (fn _ =>
              bindb (catch_errora
                      (forallM
                        (fn (n, cp) =>
                          check (transition_rule (B1_, B2_, B3_) type_of_fun
                                  bool_types cp)
                            (shows_prec_sharp F_ zero_nata n o
                              shows_prec_list show_char zero_nata
                                [#" ", #"i", #"s", #" ", #"n", #"o", #"n", #" ",
                                  #"v", #"a", #"l", #"i", #"d", #" ", #"t",
                                  #"r", #"a", #"n", #"s", #"i", #"t", #"i",
                                  #"o", #"n", #" ", #"r", #"u", #"l", #"e"]))
                        cp_trans)
                      (fn x => Inl (snd x)))
                (fn _ =>
                  catch_errora
                    (forallM
                      (check_exists_cut A_ (C1_, C2_) B3_ (D1_, D2_) (E3_, E6_)
                        shows_atom logic_checker negate_atom (map snd cp_trans))
                      cut_points)
                    (fn x => Inl (snd x))))
        end
    of Inl a => Inl a | Inr _ => Inr (map (make_copy_prog p) cp_trans_list));

fun check_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
  (D1_, D2_, D3_) (E1_, E2_, E3_, E4_, E5_, E6_, E7_, E8_)
  (F1_, F2_, F3_, F4_, F5_, F6_) type_of_fun bool_types tc tc2 sa sa2 ne ne2
  dom_type less_eq_formula less_formula is_constant definability_checker pre i
  pi (Via_Cooperation cp_proofs) =
  debug (pre [])
    [#"S", #"w", #"i", #"t", #"c", #"h", #" ", #"t", #"o", #" ", #"C", #"o",
      #"o", #"p", #"e", #"r", #"a", #"t", #"i", #"o", #"n", #" ", #"P", #"r",
      #"o", #"g", #"r", #"a", #"m"]
    (bindb
      (catch_errora
        (create_initial_cp_prog A2_ (B1_, B2_, B3_) (D2_, D3_) (C1_, C2_)
          (E2_, E3_, E4_, E5_, E7_, E8_) F6_ type_of_fun bool_types sa tc ne pi
          (map fst cp_proofs))
        (fn x =>
          Inl (pre o shows_prec_nat zero_nata i o
                 shows_prec_list show_char zero_nata
                   [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n",
                     #" ", #"c", #"r", #"e", #"a", #"t", #"i", #"n", #"g", #" ",
                     #"i", #"n", #"i", #"t", #"i", #"a", #"l", #" ", #"c", #"o",
                     #"o", #"p", #"e", #"r", #"a", #"t", #"i", #"o", #"n", #" ",
                     #"p", #"r", #"o", #"g", #"r", #"a", #"m", #"\n"] o
                x)))
      (fn cPi =>
        catch_errora
          (forallM_index
            (fn (r, prf) => fn _ =>
              catch_errora
                (check_cooperation_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_)
                  (C1_, C2_) (D1_, D2_, D3_) (E3_, E4_, E5_, E8_)
                  (ceq_sharp F3_, ccompare_sharp F2_, equal_sharp F3_,
                    mapping_impl_sharp, set_impl_sharp, show_sharp F6_)
                  type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type
                  less_eq_formula less_formula is_constant definability_checker
                  pre (suc i) r prf)
                (fn x =>
                  Inl (pre o shows_prec_nat zero_nata i o
                         shows_prec_list show_char zero_nata
                           [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                             #"b", #"e", #"l", #"o", #"w", #" ", #"s", #"w",
                             #"i", #"t", #"c", #"h", #"i", #"n", #"g", #" ",
                             #"t", #"o", #" ", #"i", #"n", #"i", #"t", #"i",
                             #"a", #"l", #" ", #"c", #"o", #"o", #"p", #"e",
                             #"r", #"a", #"t", #"i", #"o", #"n", #" ", #"p",
                             #"r", #"o", #"g", #"r", #"a", #"m", #"\n"] o
                        x)))
            (zip cPi (map snd cp_proofs)))
          (fn x => Inl (snd x))))
  | check_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
    (D1_, D2_, D3_) (E1_, E2_, E3_, E4_, E5_, E6_, E7_, E8_)
    (F1_, F2_, F3_, F4_, F5_, F6_) type_of_fun bool_types tc tc2 sa sa2 ne ne2
    dom_type less_eq_formula less_formula is_constant definability_checker pre i
    pi (Invariants_Update_LTS (iproof, cproof)) =
    debug (pre [])
      [#"I", #"n", #"v", #"a", #"r", #"i", #"a", #"n", #"t", #" ", #"U", #"p",
        #"d", #"a", #"t", #"e"]
      (bindb
        (catch_errora
          (invariant_proof_checker (A1_, A2_, A3_) (B1_, B2_, B3_, B4_)
            (C1_, C2_) (D1_, D2_, D3_) (E1_, E2_, E3_, E4_, E6_, E7_, E8_)
            (F1_, F2_, F3_, F4_, F5_, F6_)
            (ccompare_list ccompare_char, equal_list equal_char,
              mapping_impl_list, show_list show_char)
            type_of_fun bool_types tc tc2 sa sa2 ne ne2 pi iproof)
          (fn x =>
            Inl (pre o shows_prec_nat zero_nata i o
                   shows_prec_list show_char zero_nata
                     [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i",
                       #"n", #" ", #"i", #"n", #"v", #"a", #"r", #"i", #"a",
                       #"n", #"t", #" ", #"u", #"p", #"d", #"a", #"t", #"e",
                       #"\n"] o
                  x)))
        (fn ia =>
          bindb (fix_invariants (E3_, E4_, E6_, E8_) F6_ pi ia)
            (fn q =>
              catch_errora
                (check_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_)
                  (C1_, C2_) (D1_, D2_, D3_)
                  (E1_, E2_, E3_, E4_, E5_, E6_, E7_, E8_)
                  (F1_, F2_, F3_, F4_, F5_, F6_) type_of_fun bool_types tc tc2
                  sa sa2 ne ne2 dom_type less_eq_formula less_formula
                  is_constant definability_checker pre (plus_nata i one_nata) q
                  cproof)
                (fn x =>
                  Inl (pre o shows_prec_nat zero_nata i o
                         shows_prec_list show_char zero_nata
                           [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                             #"b", #"e", #"l", #"o", #"w", #" ", #"i", #"n",
                             #"v", #"a", #"r", #"i", #"a", #"n", #"t", #" ",
                             #"u", #"p", #"d", #"a", #"t", #"e", #"\n"] o
                        x)))))
  | check_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
    (D1_, D2_, D3_) (E1_, E2_, E3_, E4_, E5_, E6_, E7_, E8_)
    (F1_, F2_, F3_, F4_, F5_, F6_) type_of_fun bool_types tc tc2 sa sa2 ne ne2
    dom_type less_eq_formula less_formula is_constant definability_checker pre i
    pi Trivialb =
    debug (pre [])
      [#"T", #"r", #"i", #"v", #"i", #"a", #"l", #" ", #"T", #"e", #"r", #"m",
        #"i", #"n", #"a", #"t", #"i", #"o", #"n"]
      (catch_errora
        (check (null (transitions_impl pi))
          (shows_prec_list show_char zero_nata
            [#"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n", #" ",
              #"r", #"u", #"l", #"e", #"s", #" ", #"r", #"e", #"m", #"a", #"i",
              #"n", #"s", #" ", #"a", #"t", #" ", #"t", #"r", #"i", #"v", #"i",
              #"a", #"l", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t",
              #"i", #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"]))
        (fn x =>
          Inl (pre o shows_prec_nat zero_nata i o
                 shows_prec_list show_char zero_nata
                   [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n",
                     #" ", #"t", #"r", #"i", #"v", #"i", #"a", #"l", #" ", #"t",
                     #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n",
                     #" ", #"c", #"h", #"e", #"c", #"k", #"e", #"r", #"\n"] o
                x)));

fun checka (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_) (D1_, D2_, D3_)
  (E1_, E2_, E3_, E4_, E5_, E6_, E7_, E8_) (F1_, F2_, F3_, F4_, F5_, F6_)
  type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type less_eq_formula
  less_formula is_constant definability_checker pi prf =
  bindb (debug [#"i", #"n", #"i", #"t"]
          [#"C", #"h", #"e", #"c", #"k", #" ", #"w", #"e", #"l", #"l", #"-",
            #"f", #"o", #"r", #"m", #"e", #"d", #"n", #"e", #"s", #"s"]
          (catch_errora
            (check_lts_impl (B1_, B2_, B3_) type_of_fun bool_types pi)
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"i", #"n", #"p", #"u", #"t", #" ", #"L", #"T", #"S",
                       #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"w",
                       #"e", #"l", #"l", #"-", #"f", #"o", #"r", #"m", #"e",
                       #"d"] o
                    x))))
    (fn _ =>
      check_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_, B4_) (C1_, C2_)
        (D1_, D2_, D3_) (E1_, E2_, E3_, E4_, E5_, E6_, E7_, E8_)
        (F1_, F2_, F3_, F4_, F5_, F6_) type_of_fun bool_types tc tc2 sa sa2 ne
        ne2 dom_type less_eq_formula less_formula is_constant
        definability_checker (shows_prec_list show_char zero_nata []) one_nata
        pi prf);

fun def_checker_main A_ x ty l1 r1 l2 r2 =
  is_bool (ceq_ty, ccompare_ty, equal_ty) type_of_fun
    (inserta (ceq_ty, ccompare_ty) BoolT
      (set_empty (ceq_ty, ccompare_ty) (of_phantom set_impl_ty)))
    (Fun (LeF, [l1, r1])) andalso
    (has_type equal_ty type_of_fun r1 ty andalso
      (is_bool (ceq_ty, ccompare_ty, equal_ty) type_of_fun
         (inserta (ceq_ty, ccompare_ty) BoolT
           (set_empty (ceq_ty, ccompare_ty) (of_phantom set_impl_ty)))
         (Fun (LeF, [l2, r2])) andalso
        (equal_terma equal_sig (equal_prod A_ equal_ty) (Var (x, ty)) l1 andalso
          (equal_terma equal_sig (equal_prod A_ equal_ty) l1 r2 andalso
            (equal_terma equal_sig (equal_prod A_ equal_ty) l2 r1 andalso
              not (contains_var_term (equal_prod A_ equal_ty) (x, ty) r1))))));

fun def_checker_maina A_ x ty l1 r1 =
  is_bool (ceq_ty, ccompare_ty, equal_ty) type_of_fun
    (inserta (ceq_ty, ccompare_ty) BoolT
      (set_empty (ceq_ty, ccompare_ty) (of_phantom set_impl_ty)))
    (Fun (EqF, [l1, r1])) andalso
    (has_type equal_ty type_of_fun r1 ty andalso
      (equal_terma equal_sig (equal_prod A_ equal_ty) (Var (x, ty)) l1 andalso
        not (contains_var_term (equal_prod A_ equal_ty) (x, ty) r1)));

fun def_checker_eq A_ x ty eq =
  (case eq
    of Atom (Var _) =>
      Inl (shows_prec_list show_char zero_nata
            [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"l", #"i", #"t",
              #"e", #"r", #"a", #"l"])
    | Atom (Fun (LessF, _)) =>
      Inl (shows_prec_list show_char zero_nata
            [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"l", #"i", #"t",
              #"e", #"r", #"a", #"l"])
    | Atom (Fun (LeF, _)) =>
      Inl (shows_prec_list show_char zero_nata
            [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"l", #"i", #"t",
              #"e", #"r", #"a", #"l"])
    | Atom (Fun (SumF _, _)) =>
      Inl (shows_prec_list show_char zero_nata
            [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"l", #"i", #"t",
              #"e", #"r", #"a", #"l"])
    | Atom (Fun (ConstF _, _)) =>
      Inl (shows_prec_list show_char zero_nata
            [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"l", #"i", #"t",
              #"e", #"r", #"a", #"l"])
    | Atom (Fun (ProdF _, _)) =>
      Inl (shows_prec_list show_char zero_nata
            [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"l", #"i", #"t",
              #"e", #"r", #"a", #"l"])
    | Atom (Fun (EqF, [])) =>
      Inl (shows_prec_list show_char zero_nata
            [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"l", #"i", #"t",
              #"e", #"r", #"a", #"l"])
    | Atom (Fun (EqF, [_])) =>
      Inl (shows_prec_list show_char zero_nata
            [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"l", #"i", #"t",
              #"e", #"r", #"a", #"l"])
    | Atom (Fun (EqF, [l1, r1])) =>
      check (def_checker_maina A_ x ty l1 r1 orelse
              def_checker_maina A_ x ty r1 l1)
        (shows_prec_list show_char zero_nata
          [#"N", #"o", #"n", #"-", #"e", #"q", #"u", #"a", #"t", #"i", #"o",
            #"n", #" ", #"n", #"o", #"t", #" ", #"s", #"u", #"p", #"p", #"o",
            #"r", #"t", #"e", #"d"])
    | Atom (Fun (EqF, _ :: _ :: _ :: _)) =>
      Inl (shows_prec_list show_char zero_nata
            [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"l", #"i", #"t",
              #"e", #"r", #"a", #"l"])
    | NegAtom _ =>
      Inl (shows_prec_list show_char zero_nata
            [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"c", #"l", #"a",
              #"u", #"s", #"e"])
    | Conjunction _ =>
      Inl (shows_prec_list show_char zero_nata
            [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"c", #"l", #"a",
              #"u", #"s", #"e"])
    | Disjunction _ =>
      Inl (shows_prec_list show_char zero_nata
            [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"c", #"l", #"a",
              #"u", #"s", #"e"]));

fun def_checker (A1_, A2_, A3_) x ty phi =
  catch_errora
    (case phi of Atom _ => def_checker_eq A1_ x ty phi
      | NegAtom _ => def_checker_eq A1_ x ty phi | Conjunction [] => Inr ()
      | Conjunction [eq] => def_checker_eq A1_ x ty eq
      | Conjunction [Atom (Var _), _] =>
        Inl (shows_prec_list show_char zero_nata
              [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"1", #"s", #"t",
                #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
      | Conjunction [Atom (Fun (LessF, _)), _] =>
        Inl (shows_prec_list show_char zero_nata
              [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"1", #"s", #"t",
                #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
      | Conjunction [Atom (Fun (LeF, [])), _] =>
        Inl (shows_prec_list show_char zero_nata
              [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"1", #"s", #"t",
                #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
      | Conjunction [Atom (Fun (LeF, [_])), _] =>
        Inl (shows_prec_list show_char zero_nata
              [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"1", #"s", #"t",
                #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
      | Conjunction [Atom (Fun (LeF, [l1, r1])), lt2] =>
        (case lt2
          of Atom (Var _) =>
            Inl (shows_prec_list show_char zero_nata
                  [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"2", #"n",
                    #"d", #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
          | Atom (Fun (LessF, _)) =>
            Inl (shows_prec_list show_char zero_nata
                  [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"2", #"n",
                    #"d", #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
          | Atom (Fun (LeF, [])) =>
            Inl (shows_prec_list show_char zero_nata
                  [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"2", #"n",
                    #"d", #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
          | Atom (Fun (LeF, [_])) =>
            Inl (shows_prec_list show_char zero_nata
                  [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"2", #"n",
                    #"d", #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
          | Atom (Fun (LeF, [l2, r2])) =>
            check (def_checker_main A1_ x ty l1 r1 l2 r2 orelse
                    def_checker_main A1_ x ty l2 r2 l1 r1)
              (shows_prec_list show_char zero_nata
                [#"N", #"o", #"n", #"-", #"e", #"q", #"u", #"a", #"t", #"i",
                  #"o", #"n", #" ", #"n", #"o", #"t", #" ", #"s", #"u", #"p",
                  #"p", #"o", #"r", #"t", #"e", #"d"])
          | Atom (Fun (LeF, _ :: _ :: _ :: _)) =>
            Inl (shows_prec_list show_char zero_nata
                  [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"2", #"n",
                    #"d", #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
          | Atom (Fun (SumF _, _)) =>
            Inl (shows_prec_list show_char zero_nata
                  [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"2", #"n",
                    #"d", #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
          | Atom (Fun (ConstF _, _)) =>
            Inl (shows_prec_list show_char zero_nata
                  [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"2", #"n",
                    #"d", #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
          | Atom (Fun (ProdF _, _)) =>
            Inl (shows_prec_list show_char zero_nata
                  [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"2", #"n",
                    #"d", #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
          | Atom (Fun (EqF, _)) =>
            Inl (shows_prec_list show_char zero_nata
                  [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"2", #"n",
                    #"d", #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
          | NegAtom _ =>
            Inl (shows_prec_list show_char zero_nata
                  [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"2", #"n",
                    #"d", #" ", #"c", #"l", #"a", #"u", #"s", #"e"])
          | Conjunction _ =>
            Inl (shows_prec_list show_char zero_nata
                  [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"2", #"n",
                    #"d", #" ", #"c", #"l", #"a", #"u", #"s", #"e"])
          | Disjunction _ =>
            Inl (shows_prec_list show_char zero_nata
                  [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"2", #"n",
                    #"d", #" ", #"c", #"l", #"a", #"u", #"s", #"e"]))
      | Conjunction [Atom (Fun (LeF, _ :: _ :: _ :: _)), _] =>
        Inl (shows_prec_list show_char zero_nata
              [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"1", #"s", #"t",
                #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
      | Conjunction [Atom (Fun (SumF _, _)), _] =>
        Inl (shows_prec_list show_char zero_nata
              [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"1", #"s", #"t",
                #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
      | Conjunction [Atom (Fun (ConstF _, _)), _] =>
        Inl (shows_prec_list show_char zero_nata
              [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"1", #"s", #"t",
                #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
      | Conjunction [Atom (Fun (ProdF _, _)), _] =>
        Inl (shows_prec_list show_char zero_nata
              [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"1", #"s", #"t",
                #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
      | Conjunction [Atom (Fun (EqF, _)), _] =>
        Inl (shows_prec_list show_char zero_nata
              [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"1", #"s", #"t",
                #" ", #"l", #"i", #"t", #"e", #"r", #"a", #"l"])
      | Conjunction [NegAtom _, _] =>
        Inl (shows_prec_list show_char zero_nata
              [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"1", #"s", #"t",
                #" ", #"c", #"l", #"a", #"u", #"s", #"e"])
      | Conjunction [Conjunction _, _] =>
        Inl (shows_prec_list show_char zero_nata
              [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"1", #"s", #"t",
                #" ", #"c", #"l", #"a", #"u", #"s", #"e"])
      | Conjunction [Disjunction _, _] =>
        Inl (shows_prec_list show_char zero_nata
              [#"I", #"n", #"v", #"a", #"l", #"i", #"d", #" ", #"1", #"s", #"t",
                #" ", #"c", #"l", #"a", #"u", #"s", #"e"])
      | Conjunction (_ :: _ :: _ :: _) =>
        Inl (shows_prec_list show_char zero_nata
              [#"C", #"o", #"n", #"j", #"u", #"n", #"c", #"t", #"i", #"o", #"n",
                #" ", #"o", #"f", #" ", #"m", #"o", #"r", #"e", #" ", #"t",
                #"h", #"a", #"n", #" ", #"t", #"w", #"o"])
      | Disjunction _ => def_checker_eq A1_ x ty phi)
    (fn xa =>
      Inl (shows_prec_list show_char zero_nata
             [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"d", #"e",
               #"f", #"i", #"n", #"i", #"b", #"i", #"l", #"i", #"t", #"y", #" ",
               #"c", #"h", #"e", #"c", #"k", #"e", #"r", #" ", #"f", #"o", #"r",
               #" "] o
             shows_prec A3_ zero_nata x o
             shows_prec_list show_char zero_nata
               [#" ", #"o", #"n", #" ", #"f", #"o", #"r", #"m", #"u", #"l",
                 #"a", #"\n", #" ", #" "] o
             shows_formula (show_IA_exp (A1_, A2_, A3_)) phi o
             shows_nl o
            xa));

fun is_constant (Fun (uu, [])) = true
  | is_constant (Var v) = false
  | is_constant (Fun (v, vb :: vc)) = false;

fun check_termination (A1_, A2_, A3_, A4_, A5_, A6_)
  (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) (C1_, C2_, C3_, C4_, C5_, C6_) =
  checka (ccompare_sig, equal_sig, show_sig)
    (ceq_ty, ccompare_ty, equal_ty, show_ty) (default_hints, show_hints)
    (A1_, A3_, A6_) (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
    (C1_, C2_, C3_, C4_, C5_, C6_) type_of_fun
    (inserta (ceq_ty, ccompare_ty) BoolT
      (set_empty (ceq_ty, ccompare_ty) (of_phantom set_impl_ty)))
    (check_clause (A1_, A3_, A4_, A5_, A6_))
    (check_clause
      (ccompare_trans_var A1_, equal_trans_var A3_, mapping_impl_trans_var,
        linorder_trans_var A2_, show_trans_var A6_))
    (show_IA_exp (A3_, A5_, A6_))
    (show_IA_exp
      (equal_trans_var A3_, linorder_trans_var A2_, show_trans_var A6_))
    (negate A6_) (negate (show_trans_var A6_)) IntT
    (fn s => fn t => Atom (Fun (LeF, [s, t])))
    (fn s => fn t => Atom (Fun (LessF, [s, t]))) is_constant
    (def_checker
      (equal_trans_var A3_, linorder_trans_var A2_, show_trans_var A6_));

fun get_args_impl true t = args t
  | get_args_impl false t = [t];

fun innermost_repl_map_impl (A1_, A2_, A3_) r ecap p =
  remdups (equal_prod (equal_prod A1_ equal_nat) equal_nat)
    (maps (fn ((l, ra), b) =>
            maps (fn u =>
                   (if not (is_Var u)
                     then maps (fn rs =>
                                 maps (fn f =>
maps (fn n =>
       maps (fn i =>
              (if contains_var_term
                    (equal_sum equal_unit (equal_list equal_char)) (Inl ())
                    (ecap (get_args_impl b l) (nth rs i))
                then [(f, i)] else []))
         (upt zero_nata n))
  [snd f])
                                   [the (root u)])
                            [args u]
                     else []))
              (supteq_list ra))
      (map (fn lr => (lr, true)) r @ map (fn st => (st, false)) p));

fun mu_i_P_impl (A1_, A2_, A3_) r ecap p =
  let
    val fis = innermost_repl_map_impl (A1_, A2_, A3_) r ecap p;
    val fs = remdups (equal_prod A1_ equal_nat) (map fst fis);
    val mu =
      (fn f =>
        set (ceq_nat, ccompare_nat, set_impl_nat)
          (map_filter
            (fn x =>
              (if let
                    val (g, _) = x;
                  in
                    equal_proda A1_ equal_nat g f
                  end
                then SOME (snd x) else NONE))
            fis));
  in
    (fs, (precompute_fun (key_prod A2_ key_nat) mu fs,
           [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"U",
             #"R", #"M"]))
  end;

fun mu_i_impl (A1_, A2_, A3_) r ecap = mu_i_P_impl (A1_, A2_, A3_) r ecap [];

fun default_fs (A1_, A2_) r = funas_trs_list r;

fun full_empty A_ fs =
  let
    val fsa = filtera (fn (_, n) => not (equal_nata n zero_nata)) fs;
  in
    (fsa, ((fn f =>
             (if membera (equal_prod A_ equal_nat) fsa f then full_af f
               else set_empty (ceq_nat, ccompare_nat)
                      (of_phantom set_impl_nata))),
            [#"f", #"u", #"l", #"l", #" ", #"A", #"F"]))
  end;

fun get_fs_mu (A1_, A2_, A3_, A4_, A5_, A6_, A7_) r ecap inn
  (Runtime_Complexity (c, d)) =
  (if inn andalso
        less_eq_set
          (cenum_prod A1_ cenum_nat, ceq_prod A2_ ceq_nat,
            ccompare_prod A3_ ccompare_nat)
          (inf_seta (ceq_prod A2_ ceq_nat, ccompare_prod A3_ ccompare_nat)
            (set (ceq_prod A2_ ceq_nat, ccompare_prod A3_ ccompare_nat,
                   set_impl_prod A6_ set_impl_nat)
              c)
            (set (ceq_prod A2_ ceq_nat, ccompare_prod A3_ ccompare_nat,
                   set_impl_prod A6_ set_impl_nat)
              (defined_list r)))
          (bot_set
            (ceq_prod A2_ ceq_nat, ccompare_prod A3_ ccompare_nat,
              set_impl_prod A6_ set_impl_nat))
    then mu_i_impl (A4_, A5_, A7_) r ecap
    else full_empty A4_
           (remdups (equal_prod A4_ equal_nat)
             (c @ d @ default_fs (A5_, A7_) r)))
  | get_fs_mu (A1_, A2_, A3_, A4_, A5_, A6_, A7_) r ecap inn
    (Derivational_Complexity f) =
    full_empty A4_
      (remdups (equal_prod A4_ equal_nat) (f @ default_fs (A5_, A7_) r));

fun is_Fsharp_term (A1_, A2_, A3_, A4_) uu uv (Var uw) = false
  | is_Fsharp_term (A1_, A2_, A3_, A4_) fs fa (Fun (f, ts)) =
    member (ceq_prod A2_ ceq_nat, ccompare_prod A3_ ccompare_nat)
      (f, size_list ts) fs andalso
      less_eq_set
        (cenum_prod A1_ cenum_nat, ceq_prod A2_ ceq_nat,
          ccompare_prod A3_ ccompare_nat)
        (set (ceq_prod A2_ ceq_nat, ccompare_prod A3_ ccompare_nat,
               set_impl_prod A4_ set_impl_nat)
          (maps funas_term_list ts))
        fa;

fun funas_mctxt_list (MFun (f, cs)) =
  (f, size_list cs) :: maps funas_mctxt_list cs
  | funas_mctxt_list (MVar v) = []
  | funas_mctxt_list MHole = [];

fun split_term p (Var x) =
  (if p (Var x) then (MHole, [Var x]) else (MVar x, []))
  | split_term p (Fun (f, ts)) =
    (if p (Fun (f, ts)) then (MHole, [Fun (f, ts)])
      else let
             val us = map (split_term p) ts;
           in
             (MFun (f, map fst us), maps snd us)
           end);

fun split_DP (A1_, A2_) fs =
  (fn r =>
    split_term
      (fn t =>
        not (is_Var t) andalso
          member (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat)
            (the (root t)) fs)
      (snd r));

fun check_DP_complexity (A1_, A2_, A3_, A4_, A5_, A6_, A7_) B_ p
  (Derivational_Complexity uu) =
  Inl (shows_prec_list show_char zero_nata
        [#"r", #"e", #"q", #"u", #"i", #"r", #"e", #" ", #"r", #"u", #"n", #"t",
          #"i", #"m", #"e", #" ", #"c", #"o", #"m", #"p", #"l", #"e", #"x",
          #"i", #"t", #"y"])
  | check_DP_complexity (A1_, A2_, A3_, A4_, A5_, A6_, A7_) B_ p
    (Runtime_Complexity (c, fs)) =
    let
      val fsa =
        set (ceq_prod A3_ ceq_nat,
              ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat,
              set_impl_prod A6_ set_impl_nat)
          fs;
      val (rs, r) =
        partition
          (fn lr =>
            member
              (ceq_prod A3_ ceq_nat,
                ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat)
              (the (root (fst lr))) fsa)
          p;
      val cs_ts = map (split_DP (A3_, ccompare_cproper_interval A4_) fsa) rs;
      val cp =
        remdups (equal_prod A5_ equal_nat)
          (maps (funas_mctxt_list o fst) cs_ts);
      val cpa =
        set (ceq_prod A3_ ceq_nat,
              ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat,
              set_impl_prod A6_ set_impl_nat)
          cp;
      val f =
        remdups (equal_prod A5_ equal_nat)
          (c @ funas_trs_list r @
                 concat
                   (maps (fn (fsb, _) => map funas_term_list (args fsb)) rs) @
                   concat
                     (maps (fn (_, a) =>
                             maps (fn t => map funas_term_list (args t)) a)
                       cs_ts));
      val fa =
        set (ceq_prod A3_ ceq_nat,
              ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat,
              set_impl_prod A6_ set_impl_nat)
          f;
    in
      bindb (check
              (is_empty
                 (card_UNIV_prod A1_ card_UNIV_nat, ceq_prod A3_ ceq_nat,
                   cproper_interval_prod A4_ cproper_interval_nat,
                   set_impl_prod A6_ set_impl_nat)
                 (inf_seta
                   (ceq_prod A3_ ceq_nat,
                     ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat)
                   fa fsa) andalso
                (is_empty
                   (card_UNIV_prod A1_ card_UNIV_nat, ceq_prod A3_ ceq_nat,
                     cproper_interval_prod A4_ cproper_interval_nat,
                     set_impl_prod A6_ set_impl_nat)
                   (inf_seta
                     (ceq_prod A3_ ceq_nat,
                       ccompare_prod (ccompare_cproper_interval A4_)
                         ccompare_nat)
                     fa cpa) andalso
                  is_empty
                    (card_UNIV_prod A1_ card_UNIV_nat, ceq_prod A3_ ceq_nat,
                      cproper_interval_prod A4_ cproper_interval_nat,
                      set_impl_prod A6_ set_impl_nat)
                    (inf_seta
                      (ceq_prod A3_ ceq_nat,
                        ccompare_prod (ccompare_cproper_interval A4_)
                          ccompare_nat)
                      fsa cpa)))
              (shows_prec_list show_char zero_nata
                [#"s", #"y", #"m", #"b", #"o", #"l", #"s", #" ", #"a", #"r",
                  #"e", #" ", #"n", #"o", #"t", #" ", #"d", #"i", #"s", #"j",
                  #"o", #"i", #"n", #"t"]))
        (fn _ =>
          bindb (check
                  (list_all
                    (fn lr =>
                      is_Fsharp_term
                        (A2_, A3_, ccompare_cproper_interval A4_, A6_) fsa fa
                        (fst lr))
                    rs)
                  (shows_prec_list show_char zero_nata
                    [#"l", #"h", #"s", #"s", #" ", #"o", #"f", #" ", #"R", #"S",
                      #" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ",
                      #"s", #"h", #"a", #"r", #"p", #" ", #"t", #"e", #"r",
                      #"m", #"s"]))
            (fn _ => Inr (rs, (r, (cp, (fs, f))))))
    end;

fun get_fs_mu_DP (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_) r ecap inn s cm =
  let
    val (fs, (mu, info)) =
      get_fs_mu (A2_, A3_, ccompare_cproper_interval A4_, A5_, A6_, A7_, A8_) r
        ecap inn cm;
  in
    (case check_DP_complexity (A1_, A2_, A3_, A4_, A5_, A7_, A8_)
            (show_list show_char) r cm
      of Inl _ => (fs, (mu, info))
      | Inr (rs, (_, (cp, (_, _)))) =>
        (if list_all
              (membera
                (equal_prod (equal_term A5_ (equal_list equal_char))
                  (equal_term A5_ (equal_list equal_char)))
                rs)
              s
          then (list_inter (equal_prod A5_ equal_nat) fs cp,
                 ((fn f =>
                    (if membera (equal_prod A5_ equal_nat) cp f then mu f
                      else set_empty (ceq_nat, ccompare_nat)
                             (of_phantom set_impl_nata))),
                   info @
                     [#" ", #"w", #"i", #"t", #"h", #" ", #"D", #"P", #"s"]))
          else (fs, (mu, info))))
  end;

fun shows_prec_complexity_class d c =
  (if equal_nata (degree c) zero_nata
    then shows_prec_list show_char zero_nata [#"O", #"(", #"1", #")"]
    else (if equal_nata (degree c) one_nata
           then shows_prec_list show_char zero_nata [#"O", #"(", #"n", #")"]
           else shows_string [#"O", #"(", #"n", #"^"] o
                  (shows_prec_nat zero_nata (degree c) o
                    shows_prec_list show_char zero_nata [#")"])));

fun is_ur_closed_af_impl_tp_mv (B1_, B2_, B3_) i d pi =
  let
    val ic = icap_impl_tp B1_ i d;
    val qnf = is_QNFb i d;
    val r = rulesd i d;
    val urc =
      (fn s =>
        is_ur_closed_term_af_impl B1_ (equal_term B1_ (equal_list equal_char))
          qnf (ic s) pi r);
  in
    (fn u => fn s =>
      let
        val sa = map (map_term (fn x => x) (fn a => #"x" :: a)) s;
      in
        (fn t => urc sa u sa (map_term (fn x => x) (fn a => #"x" :: a) t))
      end)
  end;

fun extract_rt_C_D (Runtime_Complexity (c, d)) = Inr (c, d)
  | extract_rt_C_D (Derivational_Complexity v) =
    Inl (shows_prec_list show_char zero_nata
          [#"r", #"u", #"n", #"t", #"i", #"m", #"e", #" ", #"c", #"o", #"m",
            #"p", #"l", #"e", #"x", #"i", #"t", #"y", #" ", #"r", #"e", #"q",
            #"u", #"i", #"r", #"e", #"d"]);

fun cpx
  (Redtriple_ext
    (valid, s, ns, nst, af, mono_af, mono, desc, not_ws_ns, cpx, more))
  = cpx;

fun rule_shift_complexity_urm_ur_tt (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) i
  rp rdelete ur cm cc tp =
  let
    val rb = rulesd i tp;
    val r = rc i tp;
    val rw = rwc i tp;
    val r2 =
      ceta_list_diff
        (key_prod (key_term B6_ (key_list (equal_char, key_char)))
          (key_term B6_ (key_list (equal_char, key_char))))
        r rdelete;
    val rremain = rw @ r2;
    val isnf = is_QNFb i tp;
    val inn = nFQ_subset_NF_rulesb i tp;
  in
    (case catch_errora
            (bindb
              (catch_errora
                (check_subseteq
                  (equal_prod (equal_term B5_ (equal_list equal_char))
                    (equal_term B5_ (equal_list equal_char)))
                  rdelete rb)
                (fn x =>
                  Inl (shows_string [#"r", #"u", #"l", #"e", #" "] o
                        (shows_rule (shows_prec B8_ zero_nata)
                           (shows_prec_list show_char zero_nata)
                           [#" ", #"-", #">", #" "] x o
                          shows_prec_list show_char zero_nata
                            [#" ", #"s", #"h", #"o", #"u", #"l", #"d", #" ",
                              #"b", #"e", #" ", #"d", #"e", #"l", #"e", #"t",
                              #"e", #"d", #",", #" ", #"b", #"u", #"t", #" ",
                              #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t",
                              #" ", #"o", #"c", #"c", #"u", #"r", #" ", #"i",
                              #"n", #" ", #"p", #"r", #"o", #"b", #"l", #"e",
                              #"m"]))))
              (fn _ =>
                bindb (check_wf_trs B8_
                        (equal_list equal_char, show_list show_char) rb)
                  (fn _ =>
                    bindb (check (nFQ_subset_NF_rulesb i tp)
                            (shows_prec_list show_char zero_nata
                              [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s",
                                #"t", #" ", #"r", #"e", #"q", #"u", #"i", #"r",
                                #"e", #"d"]))
                      (fn _ =>
                        let
                          val (fs, (mu, info)) =
                            get_fs_mu_DP
                              (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) rb
                              (icap_impl B5_ isnf rb) inn rdelete cm;
                          val (_, (pi, _)) =
                            get_fs_mu_DP
                              (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) rb
                              (icap_impl B5_ isnf rb) inn rremain cm;
                        in
                          bindb (extract_rt_C_D cm)
                            (fn (cl, dl) =>
                              let
                                val c =
                                  set (ceq_prod B3_ ceq_nat,
ccompare_prod (ccompare_cproper_interval B4_) ccompare_nat,
set_impl_prod B7_ set_impl_nat)
                                    cl;
                                val d =
                                  set (ceq_prod B3_ ceq_nat,
ccompare_prod (ccompare_cproper_interval B4_) ccompare_nat,
set_impl_prod B7_ set_impl_nat)
                                    dl;
                              in
                                bindb (check
(null (list_inter (equal_prod B5_ equal_nat) cl (defined_list rb)))
(shows_prec_list show_char zero_nata
   [#"c", #"o", #"n", #"s", #"t", #"r", #"u", #"c", #"t", #"o", #"r", #"s",
     #" "] o
  (shows_prec_list (show_prod B8_ show_nat) zero_nata cl o
    shows_prec_list show_char zero_nata
      [#" ", #"m", #"u", #"s", #"t", #" ", #"n", #"o", #"t", #" ", #"b", #"e",
        #" ", #"d", #"e", #"f", #"i", #"n", #"e", #"d"])))
                                  (fn _ =>
                                    bindb (valid rp)
                                      (fn _ =>
bindb (catch_errora
        (forallM
          (fn (l, ra) =>
            check (not (member
                          (ceq_prod B3_ ceq_nat,
                            ccompare_prod (ccompare_cproper_interval B4_)
                              ccompare_nat)
                          (the (root l)) d andalso
                         less_eq_set
                           (cenum_prod B2_ cenum_nat, ceq_prod B3_ ceq_nat,
                             ccompare_prod (ccompare_cproper_interval B4_)
                               ccompare_nat)
                           (foldr
                             (sup_seta
                                (ceq_prod B3_ ceq_nat,
                                  ccompare_prod (ccompare_cproper_interval B4_)
                                    ccompare_nat) o
                               funas_term
                                 (B3_, ccompare_cproper_interval B4_, B7_))
                             (args l)
                             (bot_set
                               (ceq_prod B3_ ceq_nat,
                                 ccompare_prod (ccompare_cproper_interval B4_)
                                   ccompare_nat,
                                 set_impl_prod B7_ set_impl_nat)))
                           c))
              (shows_rule (shows_prec B8_ zero_nata)
                 (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "]
                 (l, ra) o
                shows_prec_list show_char zero_nata
                  [#" ", #"s", #"h", #"o", #"u", #"l", #"d", #" ", #"b", #"e",
                    #" ", #"u", #"s", #"a", #"b", #"l", #"e"]))
          (list_diff
            (equal_prod (equal_term B5_ (equal_list equal_char))
              (equal_term B5_ (equal_list equal_char)))
            rb ur))
        (fn x => Inl (snd x)))
  (fn _ =>
    let
      val is_urc = is_ur_closed_af_impl_tp_mv (B5_, B6_, B8_) i tp mu ur;
      val pia = af_inter (af rp) pi;
      val is_urc_pi = is_ur_closed_af_impl_tp_mv (B5_, B6_, B8_) i tp pia ur;
    in
      bindb (catch_errora
              (forallM
                (fn (l, ra) =>
                  check (is_urc (args l) ra andalso is_urc_pi (args l) ra)
                    (shows_prec_list show_char zero_nata
                       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w",
                         #"i", #"t", #"h", #" ", #"c", #"l", #"o", #"s", #"u",
                         #"r", #"e", #" ", #"p", #"r", #"o", #"p", #"e", #"r",
                         #"t", #"i", #"e", #"s", #" ", #"o", #"f", #" ", #"u",
                         #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"u", #"l",
                         #"e", #" "] o
                      (shows_rule (shows_prec B8_ zero_nata)
                         (shows_prec_list show_char zero_nata)
                         [#" ", #"-", #">", #" "] (l, ra) o
                        shows_prec_list show_char zero_nata
                          [#":", #" ", #"r", #"h", #"s", #" ", #"i", #"s", #" ",
                            #"n", #"o", #"t", #" ", #"c", #"l", #"o", #"s",
                            #"e", #"d", #" ", #"u", #"n", #"d", #"e", #"r",
                            #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ",
                            #"r", #"u", #"l", #"e", #"s"])))
                ur)
              (fn x => Inl (snd x)))
        (fn _ =>
          bindb (catch_errora
                  (catch_errora
                    (forallM
                      (fn f =>
                        check (subset
                                (card_UNIV_nat, cenum_nat, ceq_nat,
                                  ccompare_nat)
                                (mu f) (mono_af rp f))
                          (shows_string
                             [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n",
                               #" ", #"m", #"o", #"n", #"o", #"t", #"o", #"n",
                               #"i", #"c", #"i", #"t", #"y", #":", #" ", #"s",
                               #"t", #"r", #"i", #"c", #"t", #" ", #"o", #"r",
                               #"d", #"e", #"r", #" ", #"f", #"o", #"r", #" "] o
                            (shows_prec_prod B8_ show_nat zero_nata f o
                              (shows_string
                                 [#" ", #"e", #"n", #"s", #"u", #"r", #"e",
                                   #"s", #" ", #"m", #"o", #"n", #"o", #"t",
                                   #"o", #"n", #"i", #"c", #"i", #"t", #"y",
                                   #" ", #"i", #"n", #" ", #"p", #"o", #"s",
                                   #"i", #"t", #"i", #"o", #"n", #"s", #" "] o
                                (show_position_set f (mono_af rp f) o
                                  (shows_string
                                     [#"\n", #"b", #"u", #"t", #" ", #"u", #"s",
                                       #"a", #"b", #"l", #"e", #" ", #"r", #"e",
                                       #"p", #"l", #"a", #"c", #"e", #"m", #"e",
                                       #"n", #"t", #" ", #"m", #"a", #"p", #" ",
                                       #"i", #"s", #" "] o
                                    show_position_set f (mu f)))))))
                      fs)
                    (fn x => Inl (snd x)))
                  (fn x =>
                    Inl (x o (shows_string
                                [#"\n", #"t", #"h", #"e", #" ", #"c", #"o",
                                  #"m", #"p", #"u", #"t", #"e", #"d", #" ",
                                  #"u", #"s", #"a", #"b", #"l", #"e", #" ",
                                  #"r", #"e", #"p", #"l", #"a", #"c", #"e",
                                  #"m", #"e", #"n", #"t", #" ", #"m", #"a",
                                  #"p", #" ", #"("] o
                               (shows_string info o
                                 (shows_string [#")", #" ", #"i", #"s", #"\n"] o
                                   (shows_sep
                                      (fn f =>
shows_prec_list show_char zero_nata [#"m", #"u", #"("] o
  (shows_prec_prod B8_ show_nat zero_nata f o
    (shows_prec_list show_char zero_nata [#")", #" ", #"=", #" "] o
      show_position_set f (mu f))))
                                      shows_nl fs o
                                     shows_prec_list show_char zero_nata
                                       [#"\n", #"a", #"n", #"d", #" ", #"m",
 #"u", #"(", #"f", #")", #" ", #"=", #" ", #"{", #"}", #" ", #"f", #"o", #"r",
 #" ", #"a", #"l", #"l", #" ", #"o", #"t", #"h", #"e", #"r", #" ", #"s", #"y",
 #"m", #"b", #"o", #"l", #"s", #" ", #"f"])))))))
            (fn _ =>
              bindb (catch_errora
                      (catch_errora
                        (forallM (s rp)
                          (list_inter
                            (equal_prod (equal_term B5_ (equal_list equal_char))
                              (equal_term B5_ (equal_list equal_char)))
                            rdelete ur))
                        (fn x => Inl (snd x)))
                      (fn x =>
                        Inl (shows_string
                               [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ",
                                 #"w", #"h", #"e", #"n", #" ", #"o", #"r", #"i",
                                 #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"s",
                                 #"t", #"r", #"i", #"c", #"t", #" ", #"T", #"R",
                                 #"S", #"\n"] o
                              x)))
                (fn _ =>
                  bindb (catch_errora
                          (catch_errora
                            (forallM (ns rp)
                              (list_inter
                                (equal_prod
                                  (equal_term B5_ (equal_list equal_char))
                                  (equal_term B5_ (equal_list equal_char)))
                                rremain ur))
                            (fn x => Inl (snd x)))
                          (fn x =>
                            Inl (shows_string
                                   [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                     #" ", #"w", #"h", #"e", #"n", #" ", #"o",
                                     #"r", #"i", #"e", #"n", #"t", #"i", #"n",
                                     #"g", #" ", #"n", #"o", #"n", #"-", #"s",
                                     #"t", #"r", #"i", #"c", #"t", #" ", #"T",
                                     #"R", #"S", #"\n"] o
                                  x)))
                    (fn _ =>
                      catch_errora (cpx rp cm cc)
                        (fn x =>
                          Inl (shows_prec_list show_char zero_nata
                                 [#"p", #"r", #"o", #"b", #"l", #"e", #"m",
                                   #" ", #"w", #"h", #"e", #"n", #" ", #"e",
                                   #"n", #"s", #"u", #"r", #"i", #"n", #"g",
                                   #" ", #"c", #"o", #"m", #"p", #"l", #"e",
                                   #"x", #"i", #"t", #"y", #" ", #"o", #"f",
                                   #" ", #"o", #"r", #"d", #"e", #"r", #"\n"] o
                                x))))))
    end)))
                              end)
                        end))))
            (fn x =>
              Inl (shows_string
                     [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                       #" ", #"d", #"e", #"r", #"i", #"v", #"e", #" ", #"t",
                       #"h", #"e", #" ", #"i", #"n", #"t", #"e", #"n", #"d",
                       #"e", #"d", #" ", #"c", #"o", #"m", #"p", #"l", #"e",
                       #"x", #"i", #"t", #"y", #" "] o
                    (shows_prec_complexity_class zero_nata cc o
                      (shows_string
                         [#" ", #"f", #"r", #"o", #"m", #" ", #"t", #"h", #"e",
                           #" ", #"f", #"o", #"l", #"l", #"o", #"w", #"i", #"n",
                           #"g", #"\n"] o
                        (desc rp o
                          (shows_nl o
                            (x o (shows_string
                                    [#"\n", #"w", #"i", #"t", #"h", #" ", #"u",
                                      #"s", #"a", #"b", #"l", #"e", #" ", #"r",
                                      #"u", #"l", #"e", #"s", #"\n"] o
                                   shows_trs (shows_prec B8_ zero_nata)
                                     (shows_prec_list show_char zero_nata)
                                     [#"r", #"e", #"w", #"r", #"i", #"t", #"e",
                                       #" ", #"s", #"y", #"s", #"t", #"e", #"m",
                                       #":"]
                                     [#" ", #"-", #">", #" "] ur))))))))
      of Inl a => Inl a
      | Inr _ =>
        Inr (mkc i (nfsb i tp) (qb i tp) r2
              (list_union
                (equal_prod (equal_term B5_ (equal_list equal_char))
                  (equal_term B5_ (equal_list equal_char)))
                rw rdelete)))
  end;

fun inn_usable_rules_wf_tp (B1_, B2_) i d nfs =
  inn_usable_rules_wf (B1_, B2_) (is_QNFb i d) (icap_impl_tp B1_ i d)
    (rulesd i d) nfs;

fun x_1_to_x_n x = fresh_strings_list [#"x"] one_nata [] x;

fun get_innermost_strict_repl_map_rc (B1_, B2_, B3_, B4_, B5_, B6_, B7_) i d s
  (Derivational_Complexity f) =
  full_empty B4_
    (remdups (equal_prod B4_ equal_nat)
      (f @ default_fs (B5_, B7_) (rulesd i d)))
  | get_innermost_strict_repl_map_rc (B1_, B2_, B3_, B4_, B5_, B6_, B7_) i da s
    (Runtime_Complexity (c, d)) =
    let
      val r = rulesd i da;
    in
      (if nFQ_subset_NF_rulesb i da andalso
            less_eq_set
              (cenum_prod B1_ cenum_nat, ceq_prod B2_ ceq_nat,
                ccompare_prod B3_ ccompare_nat)
              (inf_seta (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat)
                (set (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat,
                       set_impl_prod B6_ set_impl_nat)
                  c)
                (set (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat,
                       set_impl_prod B6_ set_impl_nat)
                  (defined_list r)))
              (bot_set
                (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat,
                  set_impl_prod B6_ set_impl_nat))
        then let
               val isNF = is_QNFb i da;
               val u = inn_usable_rules_wf_tp (B4_, B5_) i da true;
               val a = icap_impl_tp B4_ i da;
             in
               mu_approx_impl (B4_, B5_) r
                 (maps (fn (f, n) =>
                         maps (fn xs =>
                                map (fn lr => (xs, (Fun (f, xs), lr))) s)
                           [map Var (x_1_to_x_n n)])
                   d)
                 (fn ss => fn t => u (ss, t)) isNF a
             end
        else full_empty B4_
               (remdups (equal_prod B4_ equal_nat)
                 (c @ d @ default_fs (B5_, B7_) r)))
    end;

fun get_innermost_strict_repl_map_rc_DP (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_)
  i d s t =
  let
    val (fs, (mu, info)) =
      get_innermost_strict_repl_map_rc
        (B2_, B3_, ccompare_cproper_interval B4_, B5_, B6_, B7_, B8_) i d s t;
  in
    (case check_DP_complexity (B1_, B2_, B3_, B4_, B5_, B7_, B8_)
            (show_list show_char) (rulesd i d) t
      of Inl _ => (fs, (mu, info))
      | Inr (rs, (_, (cp, (_, _)))) =>
        (if list_all
              (membera
                (equal_prod (equal_term B5_ (equal_list equal_char))
                  (equal_term B5_ (equal_list equal_char)))
                rs)
              s
          then (list_inter (equal_prod B5_ equal_nat) fs cp,
                 ((fn f =>
                    (if membera (equal_prod B5_ equal_nat) cp f then mu f
                      else set_empty (ceq_nat, ccompare_nat)
                             (of_phantom set_impl_nata))),
                   info @
                     [#" ", #"w", #"i", #"t", #"h", #" ", #"D", #"P", #"s"]))
          else (fs, (mu, info))))
  end;

fun rule_shift_complexity_urm_tt (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) i rp
  rdelete cm cc tp =
  let
    val rb = rulesd i tp;
    val r = rc i tp;
    val rw = rwc i tp;
    val r2 =
      ceta_list_diff
        (key_prod (key_term B6_ (key_list (equal_char, key_char)))
          (key_term B6_ (key_list (equal_char, key_char))))
        r rdelete;
    val _ = qb i tp;
  in
    (case catch_errora
            (bindb
              (catch_errora
                (check_subseteq
                  (equal_prod (equal_term B5_ (equal_list equal_char))
                    (equal_term B5_ (equal_list equal_char)))
                  rdelete rb)
                (fn x =>
                  Inl (shows_string [#"r", #"u", #"l", #"e", #" "] o
                        (shows_rule (shows_prec B8_ zero_nata)
                           (shows_prec_list show_char zero_nata)
                           [#" ", #"-", #">", #" "] x o
                          shows_prec_list show_char zero_nata
                            [#" ", #"s", #"h", #"o", #"u", #"l", #"d", #" ",
                              #"b", #"e", #" ", #"d", #"e", #"l", #"e", #"t",
                              #"e", #"d", #",", #" ", #"b", #"u", #"t", #" ",
                              #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t",
                              #" ", #"o", #"c", #"c", #"u", #"r", #" ", #"i",
                              #"n", #" ", #"p", #"r", #"o", #"b", #"l", #"e",
                              #"m"]))))
              (fn _ =>
                bindb (check_wf_trs B8_
                        (equal_list equal_char, show_list show_char) rb)
                  (fn _ =>
                    let
                      val (fs, (mu, info)) =
                        get_innermost_strict_repl_map_rc_DP
                          (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) i tp rdelete
                          cm;
                    in
                      bindb (valid rp)
                        (fn _ =>
                          bindb (catch_errora
                                  (catch_errora
                                    (forallM
                                      (fn f =>
check (subset (card_UNIV_nat, cenum_nat, ceq_nat, ccompare_nat) (mu f)
        (mono_af rp f))
  (shows_prec_list show_char zero_nata
     [#"e", #"r", #"r", #"o", #"r", #" ", #"i", #"n", #" ", #"m", #"o", #"n",
       #"o", #"t", #"o", #"n", #"i", #"c", #"i", #"t", #"y", #":", #" ", #"s",
       #"t", #"r", #"i", #"c", #"t", #" ", #"o", #"r", #"d", #"e", #"r", #" ",
       #"f", #"o", #"r", #" "] o
     shows_prec_prod B8_ show_nat zero_nata f o
     shows_prec_list show_char zero_nata
       [#" ", #"e", #"n", #"s", #"u", #"r", #"e", #"s", #" ", #"m", #"o", #"n",
         #"o", #"t", #"o", #"n", #"i", #"c", #"i", #"t", #"y", #" ", #"i", #"n",
         #" ", #"p", #"o", #"s", #"i", #"t", #"i", #"o", #"n", #"s", #" "] o
     show_position_set f (mono_af rp f) o
     shows_prec_list show_char zero_nata
       [#"\n", #"b", #"u", #"t", #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ",
         #"r", #"e", #"p", #"l", #"a", #"c", #"e", #"m", #"e", #"n", #"t", #" ",
         #"m", #"a", #"p", #" ", #"i", #"s", #" "] o
    show_position_set f (mu f)))
                                      fs)
                                    (fn x => Inl (snd x)))
                                  (fn x =>
                                    Inl (x o
   shows_prec_list show_char zero_nata
     [#"\n", #"t", #"h", #"e", #" ", #"c", #"o", #"m", #"p", #"u", #"t", #"e",
       #"d", #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"e", #"p",
       #"l", #"a", #"c", #"e", #"m", #"e", #"n", #"t", #" ", #"m", #"a", #"p",
       #" ", #"("] o
   shows_prec_list show_char zero_nata info o
   shows_prec_list show_char zero_nata [#")", #" ", #"i", #"s", #"\n"] o
   shows_sep
     (fn f =>
       shows_prec_list show_char zero_nata [#"m", #"u", #"("] o
         shows_prec_prod B8_ show_nat zero_nata f o
         shows_prec_list show_char zero_nata [#")", #" ", #"=", #" "] o
         show_position_set f (mu f))
     shows_nl fs o
  shows_prec_list show_char zero_nata
    [#"\n", #"a", #"n", #"d", #" ", #"m", #"u", #"(", #"f", #")", #" ", #"=",
      #" ", #"{", #"}", #" ", #"f", #"o", #"r", #" ", #"a", #"l", #"l", #" ",
      #"o", #"t", #"h", #"e", #"r", #" ", #"s", #"y", #"m", #"b", #"o", #"l",
      #"s", #" ", #"f"])))
                            (fn _ =>
                              bindb (catch_errora
                                      (catch_errora (forallM (s rp) rdelete)
(fn x => Inl (snd x)))
                                      (fn x =>
Inl (shows_prec_list show_char zero_nata
       [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e", #"n",
         #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g", #" ", #"s",
         #"t", #"r", #"i", #"c", #"t", #" ", #"T", #"R", #"S", #"\n"] o
      x)))
                                (fn _ =>
                                  bindb (catch_errora
  (catch_errora (forallM (ns rp) (rw @ r2)) (fn x => Inl (snd x)))
  (fn x =>
    Inl (shows_prec_list show_char zero_nata
           [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
             #"n", #" ", #"o", #"r", #"i", #"e", #"n", #"t", #"i", #"n", #"g",
             #" ", #"n", #"o", #"n", #"-", #"s", #"t", #"r", #"i", #"c", #"t",
             #" ", #"T", #"R", #"S", #"\n"] o
          x)))
                                    (fn _ =>
                                      catch_errora (cpx rp cm cc)
(fn x =>
  Inl (shows_prec_list show_char zero_nata
         [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"h", #"e",
           #"n", #" ", #"e", #"n", #"s", #"u", #"r", #"i", #"n", #"g", #" ",
           #"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y", #" ",
           #"o", #"f", #" ", #"o", #"r", #"d", #"e", #"r", #"\n"] o
        x))))))
                    end)))
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                       #" ", #"d", #"e", #"r", #"i", #"v", #"e", #" ", #"t",
                       #"h", #"e", #" ", #"i", #"n", #"t", #"e", #"n", #"d",
                       #"e", #"d", #" ", #"c", #"o", #"m", #"p", #"l", #"e",
                       #"x", #"i", #"t", #"y", #" "] o
                     shows_prec_complexity_class zero_nata cc o
                     shows_prec_list show_char zero_nata
                       [#" ", #"f", #"r", #"o", #"m", #" ", #"t", #"h", #"e",
                         #" ", #"f", #"o", #"l", #"l", #"o", #"w", #"i", #"n",
                         #"g", #"\n"] o
                     desc rp o
                     shows_nl o
                    x))
      of Inl a => Inl a
      | Inr _ =>
        Inr (mkc i (nfsb i tp) (qb i tp) r2
              (list_union
                (equal_prod (equal_term B5_ (equal_list equal_char))
                  (equal_term B5_ (equal_list equal_char)))
                rw rdelete)))
  end;

fun smart_rule_shift_complexity (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) i rp
  rdelete (SOME ur) cm cc tp =
  rule_shift_complexity_urm_ur_tt (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) i rp
    rdelete ur cm cc tp
  | smart_rule_shift_complexity (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) i rp
    rdelete NONE cm cc tp =
    rule_shift_complexity_urm_tt (B1_, B2_, B3_, B4_, B5_, B6_, B7_, B8_) i rp
      rdelete cm cc tp;

fun usable_rules_complexity_innermost (B1_, B2_, B3_, B4_, B5_, B6_, B7_) i nUr
  cm cc cp =
  catch_errora
    let
      val s = rc i cp;
      val w = rwc i cp;
      val r = s @ w;
    in
      bindb (check (nFQ_subset_NF_rulesb i cp)
              (shows_prec_list show_char zero_nata
                [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ",
                  #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"d"]))
        (fn _ =>
          bindb (check_wf_trs B7_ (equal_list equal_char, show_list show_char)
                  r)
            (fn _ =>
              bindb (extract_rt_C_D cm)
                (fn (cl, dl) =>
                  let
                    val c =
                      set (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat,
                            set_impl_prod B6_ set_impl_nat)
                        cl;
                    val d =
                      set (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat,
                            set_impl_prod B6_ set_impl_nat)
                        dl;
                    val isnf = is_QNFb i cp;
                  in
                    bindb (check
                            (null (list_inter (equal_prod B4_ equal_nat) cl
                                    (defined_list r)))
                            (shows_prec_list show_char zero_nata
                               [#"c", #"o", #"n", #"s", #"t", #"r", #"u", #"c",
                                 #"t", #"o", #"r", #"s", #" "] o
                              (shows_prec_list (show_prod B7_ show_nat)
                                 zero_nata cl o
                                shows_prec_list show_char zero_nata
                                  [#" ", #"m", #"u", #"s", #"t", #" ", #"n",
                                    #"o", #"t", #" ", #"b", #"e", #" ", #"d",
                                    #"e", #"f", #"i", #"n", #"e", #"d"])))
                      (fn _ =>
                        bindb (catch_errora
                                (check_subseteq
                                  (equal_prod
                                    (equal_term B4_ (equal_list equal_char))
                                    (equal_term B4_ (equal_list equal_char)))
                                  nUr r)
                                (fn _ =>
                                  Inl (shows_prec_list show_char zero_nata
 [#"r", #"u", #"l", #"e", #" "] o
(shows_rules (shows_prec B7_ zero_nata) (shows_prec_list show_char zero_nata)
   [#" ", #"-", #">", #" "] nUr o
  shows_prec_list show_char zero_nata
    [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"o", #"c",
      #"c", #"u", #"r", #" ", #"i", #"n", #" ", #"p", #"r", #"o", #"b", #"l",
      #"e", #"m"]))))
                          (fn _ =>
                            let
                              val ur =
                                list_diff
                                  (equal_prod
                                    (equal_term B4_ (equal_list equal_char))
                                    (equal_term B4_ (equal_list equal_char)))
                                  r nUr;
                            in
                              bindb (catch_errora
                                      (forallM
(fn (l, ra) =>
  check (not (member (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat)
                (the (root l)) d andalso
               less_eq_set
                 (cenum_prod B1_ cenum_nat, ceq_prod B2_ ceq_nat,
                   ccompare_prod B3_ ccompare_nat)
                 (foldr
                   (sup_seta
                      (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat) o
                     funas_term (B2_, B3_, B6_))
                   (args l)
                   (bot_set
                     (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat,
                       set_impl_prod B6_ set_impl_nat)))
                 c))
    (shows_rule (shows_prec B7_ zero_nata) (shows_prec_list show_char zero_nata)
       [#" ", #"-", #">", #" "] (l, ra) o
      shows_prec_list show_char zero_nata
        [#" ", #"s", #"h", #"o", #"u", #"l", #"d", #" ", #"b", #"e", #" ", #"u",
          #"s", #"a", #"b", #"l", #"e"]))
nUr)
                                      (fn x => Inl (snd x)))
                                (fn _ =>
                                  let
                                    val (_, (mu, _)) =
                                      get_fs_mu
(B1_, B2_, B3_, B4_, B5_, B6_, B7_) r (icap_impl B4_ isnf r) true cm;
                                    val is_urc =
                                      is_ur_closed_af_impl_tp_mv (B4_, B5_, B7_)
i cp mu ur;
                                  in
                                    bindb (catch_errora
    (forallM
      (fn (l, ra) =>
        check (is_urc (args l) ra)
          (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"w", #"i", #"t",
               #"h", #" ", #"c", #"l", #"o", #"s", #"u", #"r", #"e", #" ", #"p",
               #"r", #"o", #"p", #"e", #"r", #"t", #"i", #"e", #"s", #" ", #"o",
               #"f", #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ", #"r", #"u",
               #"l", #"e", #" "] o
            (shows_rule (shows_prec B7_ zero_nata)
               (shows_prec_list show_char zero_nata) [#" ", #"-", #">", #" "]
               (l, ra) o
              shows_prec_list show_char zero_nata
                [#":", #" ", #"r", #"h", #"s", #" ", #"i", #"s", #" ", #"n",
                  #"o", #"t", #" ", #"c", #"l", #"o", #"s", #"e", #"d", #" ",
                  #"u", #"n", #"d", #"e", #"r", #" ", #"u", #"s", #"a", #"b",
                  #"l", #"e", #" ", #"r", #"u", #"l", #"e", #"s"])))
      ur)
    (fn x => Inl (snd x)))
                                      (fn _ =>
Inr (mkc i (nfsb i cp) (qb i cp)
      (list_diff
        (equal_prod (equal_term B4_ (equal_list equal_char))
          (equal_term B4_ (equal_list equal_char)))
        s nUr)
      (list_diff
        (equal_prod (equal_term B4_ (equal_list equal_char))
          (equal_term B4_ (equal_list equal_char)))
        w nUr)))
                                  end)
                            end))
                  end)))
    end
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e", #"n", #" ",
               #"r", #"e", #"s", #"t", #"r", #"i", #"c", #"t", #"i", #"n", #"g",
               #" ", #"t", #"o", #" ", #"i", #"n", #"n", #"e", #"r", #"m", #"o",
               #"s", #"t", #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ", #"r",
               #"u", #"l", #"e", #"s"] o
            (shows_nl o x)));

fun get_signature_of_cm (Derivational_Complexity f) = f
  | get_signature_of_cm (Runtime_Complexity (c, d)) = c @ d;

fun usable_rules_complexity_usymbols (B1_, B2_, B3_, B4_, B5_, B6_, B7_)
  (C1_, C2_, C3_) i nUr cm cc cp =
  catch_errora
    let
      val s = rc i cp;
      val w = rwc i cp;
      val r = s @ w;
    in
      bindb (catch_errora
              (check_subseteq
                (equal_prod (equal_term B5_ C2_) (equal_term B5_ C2_)) nUr r)
              (fn _ =>
                Inl (shows_prec_list show_char zero_nata
                       [#"r", #"u", #"l", #"e", #" "] o
                      (shows_rules (shows_prec B7_ zero_nata)
                         (shows_prec C3_ zero_nata) [#" ", #"-", #">", #" "]
                         nUr o
                        shows_prec_list show_char zero_nata
                          [#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t",
                            #" ", #"o", #"c", #"c", #"u", #"r", #" ", #"i",
                            #"n", #" ", #"p", #"r", #"o", #"b", #"l", #"e",
                            #"m"]))))
        (fn _ =>
          let
            val ur =
              list_diff (equal_prod (equal_term B5_ C2_) (equal_term B5_ C2_)) r
                nUr;
            val us =
              set (ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat,
                    set_impl_prod B6_ set_impl_nat)
                (maps (funas_term_list o snd) ur @ get_signature_of_cm cm);
            val urs =
              set (ceq_prod (ceq_term B5_ C2_) (ceq_term B5_ C2_),
                    ccompare_prod (ccompare_term B4_ C1_)
                      (ccompare_term B4_ C1_),
                    set_impl_prod set_impl_term set_impl_term)
                ur;
          in
            bindb (check_varcond_subset B7_ (C2_, C3_) ur)
              (fn _ =>
                bindb (catch_errora
                        (forallM
                          (fn lr =>
                            check (if less_eq_set
(cenum_prod B1_ cenum_nat, ceq_prod B2_ ceq_nat, ccompare_prod B3_ ccompare_nat)
(funas_term (B2_, B3_, B6_) (fst lr)) us
                                    then member
   (ceq_prod (ceq_term B5_ C2_) (ceq_term B5_ C2_),
     ccompare_prod (ccompare_term B4_ C1_) (ccompare_term B4_ C1_))
   lr urs
                                    else true)
                              (shows_prec_list show_char zero_nata
                                 [#"r", #"u", #"l", #"e", #" "] o
                                (shows_rule (shows_prec B7_ zero_nata)
                                   (shows_prec C3_ zero_nata)
                                   [#" ", #"-", #">", #" "] lr o
                                  shows_prec_list show_char zero_nata
                                    [#" ", #"s", #"h", #"o", #"u", #"l", #"d",
                                      #" ", #"b", #"e", #" ", #"u", #"s", #"a",
                                      #"b", #"l", #"e"])))
                          r)
                        (fn x => Inl (snd x)))
                  (fn _ =>
                    Inr (mkc i (nfsb i cp) (qb i cp)
                          (list_diff
                            (equal_prod (equal_term B5_ C2_)
                              (equal_term B5_ C2_))
                            s nUr)
                          (list_diff
                            (equal_prod (equal_term B5_ C2_)
                              (equal_term B5_ C2_))
                            w nUr))))
          end)
    end
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e", #"n", #" ",
               #"r", #"e", #"s", #"t", #"r", #"i", #"c", #"t", #"i", #"n", #"g",
               #" ", #"t", #"o", #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ",
               #"r", #"u", #"l", #"e", #"s", #" ", #"w", #".", #"r", #".", #"t",
               #".", #" ", #"u", #"s", #"a", #"b", #"l", #"e", #" ", #"s", #"y",
               #"m", #"b", #"o", #"l", #"s"] o
            (shows_nl o x)));

fun usable_rules_complexity (B1_, B2_, B3_, B4_, B5_, B6_, B7_) i nUr cm cc cp =
  (case usable_rules_complexity_usymbols
          (B1_, B2_, B3_, (compare_compare_order o compare_order_key) B5_, B4_,
            B6_, B7_)
          (compare_list compare_char, equal_list equal_char,
            show_list show_char)
          i nUr cm cc cp
    of Inl e =>
      (case usable_rules_complexity_innermost
              (B1_, B2_, B3_, B4_, B5_, B6_, B7_) i nUr cm cc cp
        of Inl ea =>
          Inl (shows_prec_list show_char zero_nata
                 [#"n", #"e", #"i", #"t", #"h", #"e", #"r", #" ", #"o", #"f",
                   #" ", #"t", #"h", #"e", #" ", #"u", #"s", #"a", #"b", #"l",
                   #"e", #" ", #"r", #"u", #"l", #"e", #"s", #" ", #"p", #"r",
                   #"o", #"c", #"e", #"s", #"s", #"o", #"r", #"s", #" ", #"i",
                   #"s", #" ", #"a", #"p", #"p", #"l", #"i", #"c", #"a", #"b",
                   #"l", #"e", #":", #" "] o
                (shows_nl o
                  (shows_prec_list show_char zero_nata
                     [#"t", #"h", #"e", #" ", #"o", #"n", #"e", #" ", #"v",
                       #"i", #"a", #" ", #"u", #"s", #"a", #"b", #"l", #"e",
                       #" ", #"s", #"y", #"m", #"b", #"o", #"l", #"s", #" ",
                       #"c", #"o", #"m", #"p", #"l", #"a", #"i", #"n", #"s",
                       #" ", #"a", #"s", #" ", #"f", #"o", #"l", #"l", #"o",
                       #"w", #"s"] o
                    (shows_nl o
                      (e o (shows_nl o
                             (shows_nl o
                               (shows_prec_list show_char zero_nata
                                  [#"a", #"n", #"d", #" ", #"t", #"h", #"e",
                                    #" ", #"o", #"n", #"e", #" ", #"v", #"i",
                                    #"a", #" ", #"i", #"c", #"a", #"p", #" ",
                                    #"a", #"n", #"d", #" ", #"i", #"n", #"n",
                                    #"e", #"r", #"m", #"o", #"s", #"t", #" ",
                                    #"s", #"a", #"y", #"s", #" "] o
                                 (shows_nl o ea)))))))))
        | Inr a => Inr a)
    | Inr a => Inr a);

fun split_proc_complexity (B1_, B2_) (C1_, C2_) i s1 cp =
  catch_errora
    let
      val s = rc i cp;
      val w = rwc i cp;
      val nfs = nfsb i cp;
      val q = qb i cp;
    in
      bindb (catch_errora
              (check_subseteq
                (equal_prod (equal_term B1_ C1_) (equal_term B1_ C1_)) s1 s)
              (fn x =>
                Inl (shows_prec_list show_char zero_nata
                       [#"r", #"u", #"l", #"e", #" "] o
                      (shows_rule (shows_prec B2_ zero_nata)
                         (shows_prec C2_ zero_nata) [#" ", #"-", #">", #" "] x o
                        shows_prec_list show_char zero_nata
                          [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a",
                            #" ", #"s", #"t", #"r", #"i", #"c", #"t", #" ",
                            #"r", #"u", #"l", #"e"]))))
        (fn _ =>
          let
            val s2 =
              list_diff (equal_prod (equal_term B1_ C1_) (equal_term B1_ C1_)) s
                s1;
          in
            Inr (mkc i nfs q s1 (s2 @ w), mkc i nfs q s2 (s1 @ w))
          end)
    end
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e", #"n", #" ",
               #"s", #"p", #"l", #"i", #"t", #"t", #"i", #"n", #"g", #" ", #"c",
               #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y", #" ", #"p",
               #"r", #"o", #"b", #"l", #"e", #"m"] o
            (shows_nl o x)));

fun shows_complexity_measure (A1_, A2_) (Runtime_Complexity (c, d)) =
  shows_prec_list show_char zero_nata
    [#"b", #"a", #"s", #"i", #"c", #" ", #"t", #"e", #"r", #"m", #"s", #" ",
      #"f", #"(", #"c", #"1", #",", #".", #".", #",", #"c", #"n", #")", #" ",
      #"w", #"h", #"e", #"r", #"e", #" ", #"f", #" ", #"i", #"n", #" "] o
    (shows_nl o
      (shows_prec_list (show_prod A2_ show_nat) zero_nata
         (sort_key (linorder_prod A1_ linorder_nat) (fn x => x) d) o
        (shows_nl o
          (shows_prec_list show_char zero_nata
             [#" ", #"a", #"n", #"d", #" ", #"c", #"i", #" ", #"i", #"s", #" ",
               #"t", #"e", #"r", #"m", #" ", #"o", #"v", #"e", #"r", #" ", #"s",
               #"i", #"g", #"n", #"a", #"t", #"u", #"r", #"e", #" "] o
            (shows_nl o
              (shows_prec_list (show_prod A2_ show_nat) zero_nata
                 (sort_key (linorder_prod A1_ linorder_nat) (fn x => x) c) o
                shows_nl))))))
  | shows_complexity_measure (A1_, A2_) (Derivational_Complexity f) =
    shows_prec_list show_char zero_nata
      [#"a", #"l", #"l", #" ", #"t", #"e", #"r", #"m", #"s", #" ", #"o", #"v",
        #"e", #"r", #" ", #"s", #"i", #"g", #"n", #"a", #"t", #"u", #"r", #"e",
        #" "] o
      (shows_nl o
        (shows_prec_list (show_prod A2_ show_nat) zero_nata
           (sort_key (linorder_prod A1_ linorder_nat) (fn x => x) f) o
          shows_nl));

fun shows_complexityLL (A1_, A2_) (B1_, B2_) (C1_, C2_) (q, (s, (w, (cm, cc))))
  = shows_prec_list show_char zero_nata
      [#"s", #"t", #"r", #"i", #"c", #"t", #" ", #"r", #"u", #"l", #"e", #"s"] o
      (shows_nl o
        (shows_rules (shows_prec_lab A2_ B2_ zero_nata)
           (shows_prec C2_ zero_nata) [#" ", #"-", #">", #" "]
           (sort_key
             (linorder_prod
               (linorder_term
                 (compare_lab ((compare_compare_order o compare_order_key) A1_)
                   ((compare_compare_order o compare_order_key) B1_))
                 ((compare_compare_order o compare_order_key) C1_))
               (linorder_term
                 (compare_lab ((compare_compare_order o compare_order_key) A1_)
                   ((compare_compare_order o compare_order_key) B1_))
                 ((compare_compare_order o compare_order_key) C1_)))
             (fn x => x) s) o
          (shows_nl o
            (shows_nl o
              (shows_prec_list show_char zero_nata
                 [#"w", #"e", #"a", #"k", #" ", #"r", #"u", #"l", #"e", #"s"] o
                (shows_nl o
                  (shows_rules (shows_prec_lab A2_ B2_ zero_nata)
                     (shows_prec C2_ zero_nata) [#" ", #"-", #">", #" "]
                     (sort_key
                       (linorder_prod
                         (linorder_term
                           (compare_lab
                             ((compare_compare_order o compare_order_key) A1_)
                             ((compare_compare_order o compare_order_key) B1_))
                           ((compare_compare_order o compare_order_key) C1_))
                         (linorder_term
                           (compare_lab
                             ((compare_compare_order o compare_order_key) A1_)
                             ((compare_compare_order o compare_order_key) B1_))
                           ((compare_compare_order o compare_order_key) C1_)))
                       (fn x => x) w) o
                    (shows_nl o
                      (shows_nl o
                        (shows_prec_list show_char zero_nata
                           [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s",
                             #"t", #" ", #"l", #"h", #"s", #"s", #" ", #"(",
                             #"Q", #")"] o
                          (shows_nl o
                            (shows_lines (show_term (show_lab A2_ B2_) C2_)
                               (sort_key
                                 (linorder_term
                                   (compare_lab
                                     ((compare_compare_order o
compare_order_key)
                                       A1_)
                                     ((compare_compare_order o
compare_order_key)
                                       B1_))
                                   ((compare_compare_order o compare_order_key)
                                     C1_))
                                 (fn x => x) q) o
                              (shows_nl o
                                (shows_nl o
                                  (shows_prec_list show_char zero_nata
                                     [#"s", #"t", #"a", #"r", #"t", #"i", #"n",
                                       #"g", #" ", #"t", #"e", #"r", #"m", #"s",
                                       #":", #" "] o
                                    (shows_complexity_measure
                                       (linorder_lab
  ((compare_compare_order o compare_order_key) A1_)
  ((compare_compare_order o compare_order_key) B1_),
 show_lab A2_ B2_)
                                       cm o
                                      (shows_nl o
(shows_prec_list show_char zero_nata
   [#"i", #"n", #"t", #"e", #"n", #"d", #"e", #"d", #" ", #"c", #"o", #"m",
     #"p", #"l", #"e", #"x", #"i", #"t", #"y", #":", #" "] o
  (shows_prec_complexity_class zero_nata cc o shows_nl)))))))))))))))))));

fun check_terms_of_main (A1_, A2_) (Derivational_Complexity f)
  (Derivational_Complexity g) =
  catch_errora (check_subseteq (equal_prod A1_ equal_nat) f g)
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"c", #"o", #"n", #"s", #"i", #"d", #"e", #"r", #" ", #"o", #"f",
               #" ", #"s", #"y", #"m", #"b", #"o", #"l", #" "] o
            shows_prec_prod A2_ show_nat zero_nata x))
  | check_terms_of_main (A1_, A2_) (Runtime_Complexity (f, h))
    (Derivational_Complexity g) =
    catch_errora (check_subseteq (equal_prod A1_ equal_nat) (f @ h) g)
      (fn x =>
        Inl (shows_prec_list show_char zero_nata
               [#"c", #"o", #"n", #"s", #"i", #"d", #"e", #"r", #" ", #"o",
                 #"f", #" ", #"s", #"y", #"m", #"b", #"o", #"l", #" "] o
              shows_prec_prod A2_ show_nat zero_nata x))
  | check_terms_of_main (A1_, A2_) (Runtime_Complexity (f, h))
    (Runtime_Complexity (f1, h1)) =
    bindb (catch_errora (check_subseteq (equal_prod A1_ equal_nat) f f1)
            (fn x =>
              Inl (shows_prec_list show_char zero_nata
                     [#"c", #"o", #"n", #"s", #"i", #"d", #"e", #"r", #" ",
                       #"s", #"y", #"m", #"b", #"o", #"l", #" "] o
                    shows_prec_prod A2_ show_nat zero_nata x)))
      (fn _ =>
        catch_errora (check_subseteq (equal_prod A1_ equal_nat) h h1)
          (fn x =>
            Inl (shows_prec_list show_char zero_nata
                   [#"c", #"o", #"n", #"s", #"i", #"d", #"e", #"r", #" ", #"s",
                     #"y", #"m", #"b", #"o", #"l", #" "] o
                  shows_prec_prod A2_ show_nat zero_nata x)))
  | check_terms_of_main (A1_, A2_) (Derivational_Complexity g)
    (Runtime_Complexity (f1, h1)) =
    Inl (shows_prec_list show_char zero_nata
          [#"m", #"i", #"x", #"i", #"n", #"g", #" ", #"r", #"u", #"n", #"t",
            #"i", #"m", #"e", #" ", #"c", #"o", #"m", #"p", #"l", #"e", #"x",
            #"i", #"t", #"y", #" ", #"a", #"n", #"d", #" ", #"d", #"e", #"r",
            #"i", #"v", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #" ", #"c",
            #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y"]);

fun check_terms_of_nat (A1_, A2_) cm1 cm2 =
  catch_errora (check_terms_of_main (A1_, A2_) cm1 cm2)
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"e", #"r", #"r", #"o", #"r", #" ", #"c", #"o", #"m", #"p", #"a",
               #"r", #"i", #"n", #"g", #" ", #"s", #"t", #"a", #"r", #"t", #" ",
               #"t", #"e", #"r", #"m", #"s"] o
            (shows_nl o x)));

fun check_complexity_subsumes (A1_, A2_, A3_) (B1_, B2_, B3_)
  (C1_, C2_, C3_, C4_, C5_) (q1, (s1, (w1, (cm1, cc1))))
  (q2, (s2, (w2, (cm2, cc2)))) =
  catch_errora
    (bindb
      (catch_errora
        (check_subseteq
          (equal_prod (equal_term (equal_lab A1_ B1_) C2_)
            (equal_term (equal_lab A1_ B1_) C2_))
          s2 s1)
        (fn x =>
          Inl (shows_prec_list show_char zero_nata
                 [#"s", #"t", #"r", #"i", #"c", #"t", #" ", #"r", #"u", #"l",
                   #"e", #" "] o
                (shows_rule (shows_prec_lab A3_ B3_ zero_nata)
                   (shows_prec C5_ zero_nata) [#" ", #"-", #">", #" "] x o
                  shows_prec_list show_char zero_nata
                    [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s", #"i", #"n",
                      #"g"]))))
      (fn _ =>
        bindb (catch_errora
                (check_subseteq
                  (equal_prod (equal_term (equal_lab A1_ B1_) C2_)
                    (equal_term (equal_lab A1_ B1_) C2_))
                  w2 w1)
                (fn x =>
                  Inl (shows_prec_list show_char zero_nata
                         [#"w", #"e", #"a", #"k", #" ", #"r", #"u", #"l", #"e",
                           #" "] o
                        (shows_rule (shows_prec_lab A3_ B3_ zero_nata)
                           (shows_prec C5_ zero_nata) [#" ", #"-", #">", #" "]
                           x o
                          shows_prec_list show_char zero_nata
                            [#" ", #"i", #"s", #" ", #"m", #"i", #"s", #"s",
                              #"i", #"n", #"g"]))))
          (fn _ =>
            bindb (catch_errora
                    (check_NF_terms_subset
                      (is_NF_terms (equal_lab A1_ B1_, key_lab A2_ B2_)
                        (C1_, C2_, C4_) q2)
                      q1)
                    (fn x =>
                      Inl (shows_prec_list show_char zero_nata
                             [#"N", #"F", #"(", #"Q", #")", #" ", #"d", #"i",
                               #"f", #"f", #"e", #"r", #"s", #" ", #"d", #"u",
                               #"e", #" ", #"t", #"o", #" ", #"t", #"e", #"r",
                               #"m", #" "] o
                            shows_prec_term (show_lab A3_ B3_) C5_ zero_nata
                              x)))
              (fn _ =>
                bindb (check (less_eq_complexity_class cc1 cc2)
                        (shows_prec_list show_char zero_nata
                          [#"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t",
                            #"y", #" ", #"c", #"l", #"a", #"s", #"s", #"e",
                            #"s", #" ", #"d", #"o", #" ", #"n", #"o", #"t",
                            #" ", #"m", #"a", #"t", #"c", #"h"]))
                  (fn _ =>
                    check_terms_of_nat (equal_lab A1_ B1_, show_lab A3_ B3_) cm2
                      cm1)))))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ", #"e",
               #"n", #"s", #"u", #"r", #"e", #" ", #"t", #"h", #"a", #"t", #" ",
               #"a", #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #" ",
               #"m", #"a", #"t", #"c", #"h", #"e", #"s", #" ", #"c", #"u", #"r",
               #"r", #"e", #"n", #"t", #" ", #"c", #"o", #"m", #"p", #"l", #"e",
               #"x", #"i", #"t", #"y", #" ", #"p", #"r", #"o", #"b", #"l", #"e",
               #"m"] o
            (shows_nl o
              (x o (shows_nl o
                     (shows_nl o
                       (shows_prec_list show_char zero_nata
                          [#"a", #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o",
                            #"n", #" ", #"i", #"s", #" "] o
                         (shows_nl o
                           (shows_complexityLL (A2_, A3_) (B2_, B3_) (C3_, C5_)
                              (q1, (s1, (w1, (cm1, cc1)))) o
                             (shows_nl o
                               (shows_nl o
                                 (shows_prec_list show_char zero_nata
                                    [#"c", #"u", #"r", #"r", #"e", #"n", #"t",
                                      #" ", #"p", #"r", #"o", #"b", #"l", #"e",
                                      #"m", #" ", #"i", #"s", #" "] o
                                   (shows_nl o
                                     shows_complexityLL (A2_, A3_) (B2_, B3_)
                                       (C3_, C5_)
                                       (q2,
 (s2, (w2, (cm2, cc2)))))))))))))))));

fun check_tup (A1_, A2_) t (Var x) = false
  | check_tup (A1_, A2_) t (Fun (f, ts)) = member (A1_, A2_) f t;

fun dPos_impl (A1_, A2_) shp d (Var x) = []
  | dPos_impl (A1_, A2_) shp d (Fun (f, ts)) =
    let
      val n = size_list ts;
    in
      (if member (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat) (f, n) d
        then (fn a => (Empty, Fun (shp f, ts)) :: a) else id)
        (maps (fn (i, ti) =>
                map (fn (p, a) => (PCons (i, p), a))
                  (dPos_impl (A1_, A2_) shp d ti))
          (zip (upt zero_nata n) ts))
    end;

fun check_rule_dt (A1_, A2_, A3_, A4_) (B1_, B2_) shp d ds =
  (fn (a, b) =>
    let
      val (l, r) = a;
    in
      (fn (dl, dr) =>
        catch_errora
          let
            val sl = sharp_term shp l;
          in
            bindb (check (equal_terma A3_ B1_ sl dl)
                    (shows_string
                       [#"w", #"r", #"o", #"n", #"g", #" ", #"l", #"h", #"s",
                         #",", #" ", #"e", #"x", #"p", #"e", #"c", #"t", #"e",
                         #"d", #" "] o
                      (shows_prec_term A4_ B2_ zero_nata sl o
                        (shows_string
                           [#" ", #"b", #"u", #"t", #" ", #"g", #"o", #"t",
                             #" "] o
                          shows_prec_term A4_ B2_ zero_nata dl))))
              (fn _ =>
                let
                  val pts = dPos_impl (A1_, A2_) shp d r;
                  val spts = map snd pts;
                  val (_, dts) = split_term (check_tup (A1_, A2_) ds) dr;
                in
                  check (equal_multiseta (equal_term A3_ B1_)
                          (mset (equal_term A3_ B1_) dts)
                          (mset (equal_term A3_ B1_) spts))
                    (shows_prec_list show_char zero_nata
                      [#"m", #"u", #"l", #"t", #"i", #"s", #"e", #"t", #" ",
                        #"o", #"f", #" ", #"s", #"u", #"b", #"t", #"e", #"r",
                        #"m", #"s", #" ", #"w", #"i", #"t", #"h", #" ", #"d",
                        #"e", #"f", #"i", #"n", #"e", #"d", #" ", #"r", #"o",
                        #"o", #"t", #"s", #" ", #"d", #"i", #"f", #"f", #"e",
                        #"r", #"s"])
                end)
          end
          (fn x =>
            Inl (shows_string
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"e", #"n", #"s", #"u", #"r", #"e", #" ", #"t", #"h", #"a",
                     #"t", #" "] o
                  (shows_rule (shows_prec A4_ zero_nata)
                     (shows_prec B2_ zero_nata) [#" ", #"-", #">", #" "]
                     (dl, dr) o
                    (shows_string
                       [#" ", #"i", #"s", #" ", #"a", #" ", #"v", #"a", #"l",
                         #"i", #"d", #" ", #"d", #"e", #"p", #"e", #"n", #"d",
                         #"e", #"n", #"c", #"y", #" ", #"t", #"u", #"p", #"l",
                         #"e", #" ", #"f", #"o", #"r", #" "] o
                      (shows_rule (shows_prec A4_ zero_nata)
                         (shows_prec B2_ zero_nata) [#" ", #"-", #">", #" "]
                         (l, r) o
                        (shows_nl o x)))))))
    end
      b);

fun dt_transformation (A1_, A2_, A3_, A4_, A5_, A6_) (C1_, C2_, C3_, C4_) shp i
  info cm cc cp =
  catch_errora
    let
      val DT_Transformation_Info (s_DT_s, w_DT_w, q) = info;
    in
      (case cm
        of Derivational_Complexity _ =>
          Inl (shows_prec_list show_char zero_nata
                [#"o", #"n", #"l", #"y", #" ", #"r", #"u", #"n", #"t", #"i",
                  #"m", #"e", #" ", #"c", #"o", #"m", #"p", #"l", #"e", #"x",
                  #"i", #"t", #"y", #" ", #"s", #"u", #"p", #"p", #"o", #"r",
                  #"t", #"e", #"d", #" ", #"f", #"o", #"r", #" ", #"d", #"e",
                  #"p", #"e", #"n", #"d", #"e", #"n", #"c", #"y", #" ", #"t",
                  #"u", #"p", #"l", #"e", #"s"])
        | Runtime_Complexity (c, d) =>
          let
            val s = rc i cp;
            val w = rwc i cp;
            val sa = map fst s_DT_s;
            val wa = map fst w_DT_w;
            val r = sa @ wa;
            val dd = defined_list r;
            val dda =
              set (ceq_prod A2_ ceq_nat,
                    ccompare_prod (ccompare_cproper_interval A3_) ccompare_nat,
                    set_impl_prod A5_ set_impl_nat)
                d;
          in
            bindb (catch_errora
                    (forallM
                      (fn lr =>
                        check (list_ex (eq_rule_mod_vars A4_ (C1_, C2_, C3_) lr)
                                sa)
                          (shows_prec_list show_char zero_nata
                             [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
                               #"t", #" ", #"f", #"i", #"n", #"d", #" ", #"D",
                               #"T", #" ", #"f", #"o", #"r", #" ", #"s", #"t",
                               #"r", #"i", #"c", #"t", #" ", #"r", #"u", #"l",
                               #"e", #" "] o
                            shows_prec_prod (show_term A6_ C4_)
                              (show_term A6_ C4_) zero_nata lr))
                      s)
                    (fn x => Inl (snd x)))
              (fn _ =>
                bindb (catch_errora
                        (forallM
                          (fn lr =>
                            check (list_ex
                                    (eq_rule_mod_vars A4_ (C1_, C2_, C3_) lr)
                                    wa)
                              (shows_prec_list show_char zero_nata
                                 [#"c", #"o", #"u", #"l", #"d", #" ", #"n",
                                   #"o", #"t", #" ", #"f", #"i", #"n", #"d",
                                   #" ", #"D", #"T", #" ", #"f", #"o", #"r",
                                   #" ", #"w", #"e", #"a", #"k", #" ", #"r",
                                   #"u", #"l", #"e", #" "] o
                                shows_prec_prod (show_term A6_ C4_)
                                  (show_term A6_ C4_) zero_nata lr))
                          w)
                        (fn x => Inl (snd x)))
                  (fn _ =>
                    bindb (catch_errora
                            (forallM
                              (fn f =>
                                check (member
(ceq_prod A2_ ceq_nat,
  ccompare_prod (ccompare_cproper_interval A3_) ccompare_nat)
f dda)
                                  (shows_prec_list show_char zero_nata
                                     [#"d", #"e", #"f", #"i", #"n", #"e", #"d",
                                       #" ", #"s", #"y", #"m", #"b", #"o", #"l",
                                       #" "] o
                                    (shows_prec_prod A6_ show_nat zero_nata f o
                                      shows_prec_list show_char zero_nata
[#" ", #"d", #"o", #"e", #"s", #" ", #"n", #"o", #"t", #" ", #"o", #"c", #"c",
  #"u", #"r", #" ", #"i", #"n", #" ", #"d", #"e", #"f", #"i", #"n", #"e", #"d",
  #" ", #"s", #"y", #"m", #"b", #"o", #"l", #"s", #" ", #"f", #"r", #"o", #"m",
  #" ", #"R", #"C"])))
                              dd)
                            (fn x => Inl (snd x)))
                      (fn _ =>
                        let
                          val dTs = map snd s_DT_s;
                          val dTw = map snd w_DT_w;
                          val da =
                            set (ceq_prod A2_ ceq_nat,
                                  ccompare_prod (ccompare_cproper_interval A3_)
                                    ccompare_nat,
                                  set_impl_prod A5_ set_impl_nat)
                              dd;
                          val shpf = (fn (f, a) => (shp f, a));
                          val ds =
                            image (ceq_prod A2_ ceq_nat,
                                    ccompare_prod
                                      (ccompare_cproper_interval A3_)
                                      ccompare_nat)
                              (ceq_prod A2_ ceq_nat,
                                ccompare_prod (ccompare_cproper_interval A3_)
                                  ccompare_nat,
                                set_impl_prod A5_ set_impl_nat)
                              shpf da;
                          val ddd =
                            image (ceq_prod A2_ ceq_nat,
                                    ccompare_prod
                                      (ccompare_cproper_interval A3_)
                                      ccompare_nat)
                              (A2_, ccompare_cproper_interval A3_, A5_)
                              (shp o fst) da;
                          val f = funas_trs_list r @ c @ d;
                          val fs =
                            set (ceq_prod A2_ ceq_nat,
                                  ccompare_prod (ccompare_cproper_interval A3_)
                                    ccompare_nat,
                                  set_impl_prod A5_ set_impl_nat)
                              f;
                        in
                          bindb (catch_errora
                                  (forallM
                                    (fn qa =>
                                      check
(not (is_Var qa) andalso
  not (member
        (ceq_prod A2_ ceq_nat,
          ccompare_prod (ccompare_cproper_interval A3_) ccompare_nat)
        (the (root qa)) fs))
(shows_prec_list show_char zero_nata
   [#"n", #"e", #"w", #" ", #"Q", #"-", #"t", #"e", #"r", #"m", #" "] o
  (shows_prec_term A6_ C4_ zero_nata qa o
    shows_prec_list show_char zero_nata
      [#" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o", #"w", #"e",
        #"d"])))
                                    q)
                                  (fn x => Inl (snd x)))
                            (fn _ =>
                              bindb (check_wf_trs A6_ (C2_, C4_) r)
                                (fn _ =>
                                  bindb (catch_errora
  (check_NF_terms_subset (is_QNFb i cp) (map fst r))
  (fn _ =>
    Inl (shows_prec_list show_char zero_nata
          [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #" ", #"r",
            #"e", #"q", #"u", #"i", #"r", #"e", #"d"])))
                                    (fn _ =>
                                      bindb
(catch_errora
  (forallM
    (fn fa =>
      check (not (member
                   (ceq_prod A2_ ceq_nat,
                     ccompare_prod (ccompare_cproper_interval A3_) ccompare_nat)
                   fa ds))
        (shows_prec_prod A6_ show_nat zero_nata fa o
          shows_prec_list show_char zero_nata
            [#" ", #"a", #"s", #" ", #"s", #"h", #"a", #"r", #"p", #"e", #"d",
              #" ", #"s", #"y", #"m", #"b", #"o", #"l", #" ", #"i", #"s", #" ",
              #"n", #"o", #"t", #" ", #"f", #"r", #"e", #"s", #"h"]))
    f)
  (fn x => Inl (snd x)))
(fn _ =>
  bindb (check
          (is_empty
            (card_UNIV_prod A1_ card_UNIV_nat, ceq_prod A2_ ceq_nat,
              cproper_interval_prod A3_ cproper_interval_nat,
              set_impl_prod A5_ set_impl_nat)
            (inf_seta
              (ceq_prod A2_ ceq_nat,
                ccompare_prod (ccompare_cproper_interval A3_) ccompare_nat)
              (set (ceq_prod A2_ ceq_nat,
                     ccompare_prod (ccompare_cproper_interval A3_) ccompare_nat,
                     set_impl_prod A5_ set_impl_nat)
                c)
              da))
          (shows_prec_list show_char zero_nata
            [#"c", #"o", #"n", #"s", #"t", #"r", #"u", #"c", #"t", #"o", #"r",
              #"s", #" ", #"o", #"f", #" ", #"R", #"C", #" ", #"a", #"n", #"d",
              #" ", #"d", #"e", #"f", #"i", #"n", #"e", #"d", #" ", #"s", #"y",
              #"m", #"b", #"o", #"l", #"s", #" ", #"o", #"f", #" ", #"T", #"R",
              #"S", #"s", #" ", #"a", #"r", #"e", #" ", #"n", #"o", #"t", #" ",
              #"d", #"i", #"s", #"j", #"o", #"i", #"n", #"t"]))
    (fn _ =>
      bindb (catch_errora
              (forallM
                (check_rule_dt (A2_, ccompare_cproper_interval A3_, A4_, A6_)
                  (C2_, C4_) shp da ddd)
                s_DT_s)
              (fn x => Inl (snd x)))
        (fn _ =>
          bindb (catch_errora
                  (forallM
                    (check_rule_dt
                      (A2_, ccompare_cproper_interval A3_, A4_, A6_) (C2_, C4_)
                      shp da ddd)
                    w_DT_w)
                  (fn x => Inl (snd x)))
            (fn _ =>
              Inr (Runtime_Complexity (c, map shpf d),
                    mkc i false (qb i cp @ q) dTs (r @ dTw)))))))))
                        end)))
          end)
    end
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e", #"n", #" ",
               #"s", #"w", #"i", #"t", #"c", #"h", #"i", #"n", #"g", #" ", #"t",
               #"o", #" ", #"d", #"e", #"p", #"e", #"n", #"d", #"e", #"n", #"c",
               #"y", #" ", #"t", #"u", #"p", #"l", #"e", #"s"] o
            (shows_nl o x)));

fun shows_mctxt funa var MHole = shows_string [#"[", #"]"]
  | shows_mctxt funa var (MVar x) = var x
  | shows_mctxt funa var (MFun (f, cs)) =
    funa f o
      shows_list_gen id [] [#"("] [#",", #" "] [#")"]
        (map (shows_mctxt funa var) cs);

fun shows_prec_mctxt A_ B_ p c =
  shows_mctxt (shows_prec A_ zero_nata) (shows_prec B_ zero_nata) c;

fun ground_mctxt (MVar uu) = false
  | ground_mctxt MHole = true
  | ground_mctxt (MFun (f, cs)) = list_all ground_mctxt cs;

fun funas_mctxt (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_) (MFun (f, cs)) =
  sup_seta
    (ceq_prod A3_ ceq_nat,
      ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat)
    (inserta
      (ceq_prod A3_ ceq_nat,
        ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat)
      (f, size_list cs)
      (bot_set
        (ceq_prod A3_ ceq_nat,
          ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat,
          set_impl_prod A7_ set_impl_nat)))
    (sup_setb
      (finite_UNIV_prod A1_ finite_UNIV_nat, cenum_prod A2_ cenum_nat,
        ceq_prod A3_ ceq_nat, cproper_interval_prod A4_ cproper_interval_nat,
        set_impl_prod A7_ set_impl_nat)
      (image (ceq_mctxt A6_ B2_, ccompare_mctxt A5_ B1_)
        (ceq_set
           (cenum_prod A2_ cenum_nat, ceq_prod A3_ ceq_nat,
             ccompare_cproper_interval
               (cproper_interval_prod A4_ cproper_interval_nat)),
          ccompare_set
            (finite_UNIV_prod A1_ finite_UNIV_nat, ceq_prod A3_ ceq_nat,
              cproper_interval_prod A4_ cproper_interval_nat,
              set_impl_prod A7_ set_impl_nat),
          set_impl_set)
        (funas_mctxt (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_))
        (set (ceq_mctxt A6_ B2_, ccompare_mctxt A5_ B1_, set_impl_mctxt) cs)))
  | funas_mctxt (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_) (MVar v) =
    bot_set
      (ceq_prod A3_ ceq_nat,
        ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat,
        set_impl_prod A7_ set_impl_nat)
  | funas_mctxt (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_) MHole =
    bot_set
      (ceq_prod A3_ ceq_nat,
        ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat,
        set_impl_prod A7_ set_impl_nat);

fun is_compound_context (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_) cComp c =
  ground_mctxt c andalso
    less_eq_set
      (cenum_prod A2_ cenum_nat, ceq_prod A3_ ceq_nat,
        ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat)
      (funas_mctxt (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_) c) cComp;

fun if_Fun_in_set (A1_, A2_) f =
  (fn t =>
    is_Var t orelse
      member (ceq_prod A1_ ceq_nat, ccompare_prod A2_ ccompare_nat)
        (the (root t)) f);

fun uncap_till p (Var x) = (if p (Var x) then [Var x] else [])
  | uncap_till p (Fun (f, ts)) =
    (if p (Fun (f, ts)) then [Fun (f, ts)] else maps (uncap_till p) ts);

fun check_rule_wdp (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_) (B1_, B2_, B3_) shp
  cComp =
  (fn (a, b) =>
    let
      val (l, r) = a;
    in
      (fn (p, q) =>
        catch_errora
          let
            val la = sharp_term shp l;
          in
            bindb (check (equal_terma A6_ B2_ la p)
                    (shows_string
                       [#"w", #"r", #"o", #"n", #"g", #" ", #"l", #"h", #"s",
                         #",", #" ", #"e", #"x", #"p", #"e", #"c", #"t", #"e",
                         #"d", #" "] o
                      (shows_prec_term A8_ B3_ zero_nata la o
                        (shows_string
                           [#" ", #"b", #"u", #"t", #" ", #"g", #"o", #"t",
                             #" "] o
                          shows_prec_term A8_ B3_ zero_nata p))))
              (fn _ =>
                let
                  val us =
                    uncap_till
                      (if_Fun_in_set (A3_, ccompare_cproper_interval A4_)
                        (uminus_set cComp))
                      r;
                  val (c, usa) =
                    split_term
                      (if_Fun_in_set (A3_, ccompare_cproper_interval A4_)
                        (uminus_set cComp))
                      q;
                in
                  bindb (check
                          (equal_lista (equal_term A6_ B2_)
                            (map (sharp_term shp) us) usa)
                          (shows_prec_list show_char zero_nata
                            [#"l", #"i", #"s", #"t", #"s", #" ", #"o", #"f",
                              #" ", #"m", #"a", #"x", #"i", #"m", #"a", #"l",
                              #" ", #"s", #"u", #"b", #"t", #"e", #"r", #"m",
                              #"s", #" ", #"w", #"i", #"t", #"h", #" ", #"d",
                              #"e", #"f", #"i", #"n", #"e", #"d", #" ", #"r",
                              #"o", #"o", #"t", #" ", #"d", #"i", #"f", #"f",
                              #"e", #"r"]))
                    (fn _ =>
                      check (is_compound_context
                              (A1_, A2_, A3_, A4_, A5_, A6_, A7_) (B1_, B2_)
                              cComp c)
                        (shows_prec_mctxt A8_ B3_ zero_nata c o
                          (shows_string
                             [#" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                               #"a", #" ", #"p", #"r", #"o", #"p", #"e", #"r",
                               #" ", #"c", #"o", #"m", #"p", #"o", #"u", #"n",
                               #"d", #" ", #"c", #"o", #"n", #"t", #"e", #"x",
                               #"t", #" ", #"o", #"f", #" "] o
                            shows_prec_term A8_ B3_ zero_nata q)))
                end)
          end
          (fn x =>
            Inl (shows_string
                   [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t", #" ",
                     #"e", #"n", #"s", #"u", #"r", #"e", #" ", #"t", #"h", #"a",
                     #"t", #" "] o
                  (shows_rule (shows_prec A8_ zero_nata)
                     (shows_prec B3_ zero_nata) [#" ", #"-", #">", #" "]
                     (p, q) o
                    (shows_string
                       [#" ", #"i", #"s", #" ", #"a", #" ", #"v", #"a", #"l",
                         #"i", #"d", #" ", #"w", #"e", #"a", #"k", #" ", #"d",
                         #"e", #"p", #"e", #"n", #"d", #"e", #"n", #"c", #"y",
                         #" ", #"p", #"a", #"i", #"r", #" ", #"f", #"o", #"r",
                         #" "] o
                      (shows_rule (shows_prec A8_ zero_nata)
                         (shows_prec B3_ zero_nata) [#" ", #"-", #">", #" "]
                         (l, r) o
                        (shows_nl o x)))))))
    end
      b);

fun check_wdp_trans (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_)
  (C1_, C2_, C3_, C4_, C5_) shp i info cm cc cp =
  catch_errora
    let
      val WDP_Trans_Info (compa, s_wdps, w_wdps, q) = info;
    in
      (case cm
        of Derivational_Complexity _ =>
          Inl (shows_prec_list show_char zero_nata
                [#"o", #"n", #"l", #"y", #" ", #"r", #"u", #"n", #"t", #"i",
                  #"m", #"e", #" ", #"c", #"o", #"m", #"p", #"l", #"e", #"x",
                  #"i", #"t", #"y", #" ", #"s", #"u", #"p", #"p", #"o", #"r",
                  #"t", #"e", #"d", #" ", #"f", #"o", #"r", #" ", #"w", #"e",
                  #"a", #"k", #" ", #"d", #"e", #"p", #"e", #"n", #"d", #"e",
                  #"n", #"c", #"y", #" ", #"p", #"a", #"i", #"r", #"s"])
        | Runtime_Complexity (c, d) =>
          let
            val s = rc i cp;
            val w = rwc i cp;
            val sa = map fst s_wdps;
            val wa = map fst w_wdps;
            val r = sa @ wa;
            val fs = funas_trs_list r;
            val ds = defined_list r;
          in
            bindb (catch_errora
                    (forallM
                      (fn ra =>
                        check (list_ex (eq_rule_mod_vars A6_ (C1_, C3_, C4_) ra)
                                sa)
                          (shows_prec_list show_char zero_nata
                             [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o",
                               #"t", #" ", #"f", #"i", #"n", #"d", #" ", #"w",
                               #"e", #"a", #"k", #" ", #"d", #"e", #"p", #"e",
                               #"n", #"d", #"e", #"n", #"c", #"y", #" ", #"p",
                               #"a", #"i", #"r", #" ", #"f", #"o", #"r", #" ",
                               #"s", #"t", #"r", #"i", #"c", #"t", #" ", #"r",
                               #"u", #"l", #"e", #" "] o
                            shows_prec_prod (show_term A8_ C5_)
                              (show_term A8_ C5_) zero_nata ra))
                      s)
                    (fn x => Inl (snd x)))
              (fn _ =>
                bindb (catch_errora
                        (forallM
                          (fn ra =>
                            check (list_ex
                                    (eq_rule_mod_vars A6_ (C1_, C3_, C4_) ra)
                                    wa)
                              (shows_prec_list show_char zero_nata
                                 [#"c", #"o", #"u", #"l", #"d", #" ", #"n",
                                   #"o", #"t", #" ", #"f", #"i", #"n", #"d",
                                   #" ", #"w", #"e", #"a", #"k", #" ", #"d",
                                   #"e", #"p", #"e", #"n", #"d", #"e", #"n",
                                   #"c", #"y", #" ", #"p", #"a", #"i", #"r",
                                   #" ", #"f", #"o", #"r", #" ", #"w", #"e",
                                   #"a", #"k", #" ", #"r", #"u", #"l", #"e",
                                   #" "] o
                                shows_prec_prod (show_term A8_ C5_)
                                  (show_term A8_ C5_) zero_nata ra))
                          w)
                        (fn x => Inl (snd x)))
                  (fn _ =>
                    let
                      val wDP_S = map snd s_wdps;
                      val wDP_W = map snd w_wdps;
                      val shpf = (fn (f, a) => (shp f, a));
                      val f = fs @ c @ d;
                      val f_sharps = map shpf f;
                      val _ =
                        image (ceq_prod A3_ ceq_nat,
                                ccompare_prod (ccompare_cproper_interval A4_)
                                  ccompare_nat)
                          (ceq_prod A3_ ceq_nat,
                            ccompare_prod (ccompare_cproper_interval A4_)
                              ccompare_nat,
                            set_impl_prod A7_ set_impl_nat)
                          (fn (fa, a) => (shp fa, a))
                          (set (ceq_prod A3_ ceq_nat,
                                 ccompare_prod (ccompare_cproper_interval A4_)
                                   ccompare_nat,
                                 set_impl_prod A7_ set_impl_nat)
                            f);
                      val cComp =
                        sup_seta
                          (ceq_prod A3_ ceq_nat,
                            ccompare_prod (ccompare_cproper_interval A4_)
                              ccompare_nat)
                          (minus_set
                            (ceq_prod A3_ ceq_nat,
                              ccompare_prod (ccompare_cproper_interval A4_)
                                ccompare_nat)
                            (minus_set
                              (ceq_prod A3_ ceq_nat,
                                ccompare_prod (ccompare_cproper_interval A4_)
                                  ccompare_nat)
                              (set (ceq_prod A3_ ceq_nat,
                                     ccompare_prod
                                       (ccompare_cproper_interval A4_)
                                       ccompare_nat,
                                     set_impl_prod A7_ set_impl_nat)
                                fs)
                              (set (ceq_prod A3_ ceq_nat,
                                     ccompare_prod
                                       (ccompare_cproper_interval A4_)
                                       ccompare_nat,
                                     set_impl_prod A7_ set_impl_nat)
                                (defined_list r)))
                            (set (ceq_prod A3_ ceq_nat,
                                   ccompare_prod (ccompare_cproper_interval A4_)
                                     ccompare_nat,
                                   set_impl_prod A7_ set_impl_nat)
                              d))
                          compa;
                    in
                      bindb (catch_errora
                              (forallM
                                (fn qa =>
                                  check (not (is_Var qa) andalso
  not (membera (equal_prod A6_ equal_nat) f (the (root qa))))
                                    (shows_prec_list show_char zero_nata
                                       [#"n", #"e", #"w", #" ", #"Q", #"-",
 #"t", #"e", #"r", #"m", #" "] o
                                      (shows_prec_term A8_ C5_ zero_nata qa o
shows_prec_list show_char zero_nata
  [#" ", #"n", #"o", #"t", #" ", #"a", #"l", #"l", #"o", #"w", #"e", #"d"])))
                                q)
                              (fn x => Inl (snd x)))
                        (fn _ =>
                          bindb (check_wf_trs A8_ (C3_, C5_) r)
                            (fn _ =>
                              bindb (catch_errora
                                      (forallM
(fn fa =>
  check (not (member
               (ceq_prod A3_ ceq_nat,
                 ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat)
               fa cComp))
    (shows_prec_prod A8_ show_nat zero_nata fa o
      shows_prec_list show_char zero_nata
        [#" ", #"c", #"l", #"a", #"s", #"h", #"e", #"s", #" ", #"w", #"i", #"t",
          #"h", #" ", #"s", #"h", #"a", #"r", #"p", #" ", #"s", #"y", #"m",
          #"b", #"o", #"l", #"s"]))
f_sharps)
                                      (fn x => Inl (snd x)))
                                (fn _ =>
                                  bindb (catch_errora
  (forallM
    (fn fa =>
      check (not (member
                   (ceq_prod A3_ ceq_nat,
                     ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat)
                   fa cComp))
        (shows_prec_prod A8_ show_nat zero_nata fa o
          shows_prec_list show_char zero_nata
            [#" ", #"c", #"l", #"a", #"s", #"h", #"e", #"s", #" ", #"w", #"i",
              #"t", #"h", #" ", #"d", #"e", #"f", #"i", #"n", #"e", #"d", #" ",
              #"s", #"y", #"m", #"b", #"o", #"l", #"s", #" ", #"o", #"f", #" ",
              #"R", #"C"]))
    d)
  (fn x => Inl (snd x)))
                                    (fn _ =>
                                      bindb
(catch_errora
  (forallM
    (fn fa =>
      check (not (member
                   (ceq_prod A3_ ceq_nat,
                     ccompare_prod (ccompare_cproper_interval A4_) ccompare_nat)
                   fa cComp))
        (shows_prec_prod A8_ show_nat zero_nata fa o
          shows_prec_list show_char zero_nata
            [#" ", #"c", #"l", #"a", #"s", #"h", #"e", #"s", #" ", #"w", #"i",
              #"t", #"h", #" ", #"d", #"e", #"f", #"i", #"n", #"e", #"d", #" ",
              #"s", #"y", #"m", #"b", #"o", #"l", #"s"]))
    ds)
  (fn x => Inl (snd x)))
(fn _ =>
  bindb (catch_errora
          (forallM
            (check_rule_wdp (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_)
              (C2_, C3_, C5_) shp cComp)
            s_wdps)
          (fn x => Inl (snd x)))
    (fn _ =>
      bindb (catch_errora
              (forallM
                (check_rule_wdp (A1_, A2_, A3_, A4_, A5_, A6_, A7_, A8_)
                  (C2_, C3_, C5_) shp cComp)
                w_wdps)
              (fn x => Inl (snd x)))
        (fn _ =>
          Inr (Runtime_Complexity (c, map shpf d),
                mkc i (nfsb i cp) (qb i cp @ q) (wDP_S @ sa)
                  (wDP_W @ wa)))))))))
                    end))
          end)
    end
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"e", #"r", #"r", #"o", #"r", #" ", #"w", #"h", #"e", #"n", #" ",
               #"s", #"w", #"i", #"t", #"c", #"h", #"i", #"n", #"g", #" ", #"t",
               #"o", #" ", #"w", #"e", #"a", #"k", #" ", #"d", #"e", #"p", #"e",
               #"n", #"d", #"e", #"n", #"c", #"y", #" ", #"p", #"a", #"i", #"r",
               #"s"] o
            (shows_nl o x)));

fun equal_boundstype Roof Match = false
  | equal_boundstype Match Roof = false
  | equal_boundstype Match Match = true
  | equal_boundstype Roof Roof = true;

fun boundstype (Bounds_Info (x1, x2, x3, x4, x5)) = x1;

fun stackable_of_cm (Derivational_Complexity f) = f
  | stackable_of_cm (Runtime_Complexity (c, d)) = c;

fun bounds_complexity_rel (B1_, B2_, B3_)
  (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_)
  (D1_, D2_, D3_, D4_, D5_, D6_, D7_, D8_) i info rdelete cm cc tp =
  catch_errora
    let
      val r = rc i tp;
      val rw = rwc i tp;
      val r2 =
        ceta_list_diff (key_prod (key_term B2_ C6_) (key_term B2_ C6_)) r
          rdelete;
    in
      bindb (catch_errora
              (check_subseteq
                (equal_prod (equal_term B1_ C5_) (equal_term B1_ C5_)) rdelete
                (rulesd i tp))
              (fn x =>
                Inl (shows_prec_list show_char zero_nata
                       [#"c", #"o", #"u", #"l", #"d", #" ", #"n", #"o", #"t",
                         #" ", #"f", #"i", #"n", #"d", #" ", #"r", #"u", #"l",
                         #"e", #" "] o
                      (shows_rule (shows_prec B3_ zero_nata)
                         (shows_prec C8_ zero_nata) [#" ", #"-", #">", #" "] x o
                        shows_prec_list show_char zero_nata
                          [#" ", #"i", #"n", #" ", #"c", #"u", #"r", #"r", #"e",
                            #"n", #"t", #" ", #"c", #"o", #"m", #"p", #"l",
                            #"e", #"x", #"i", #"t", #"y", #" ", #"p", #"r",
                            #"o", #"b", #"l", #"e", #"m"]))))
        (fn _ =>
          bindb (check (less_eq_complexity_class (Comp_Poly one_nata) cc)
                  (shows_prec_list show_char zero_nata
                    [#"c", #"a", #"n", #" ", #"o", #"n", #"l", #"y", #" ", #"e",
                      #"n", #"s", #"u", #"r", #"e", #" ", #"l", #"i", #"n",
                      #"e", #"a", #"r", #" ", #"c", #"o", #"m", #"p", #"l",
                      #"e", #"x", #"i", #"t", #"y"]))
            (fn _ =>
              bindb (check (equal_boundstype (boundstype info) Match)
                      (shows_prec_list show_char zero_nata
                        [#"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t",
                          #"y", #" ", #"a", #"n", #"a", #"l", #"y", #"s", #"i",
                          #"s", #" ", #"r", #"e", #"q", #"u", #"i", #"r", #"e",
                          #"s", #" ", #"b", #"o", #"u", #"n", #"d", #"s", #"t",
                          #"y", #"p", #"e", #" ", #"m", #"a", #"t", #"c",
                          #"h"]))
                (fn _ =>
                  let
                    val _ = rulesd i tp;
                  in
                    bindb (check_bounds_generic
                            (compare_order_key B2_, B1_, B3_)
                            (D1_, D2_, D3_, D4_, D5_, D6_, D7_, D8_)
                            (C1_, C2_, C3_, C4_, compare_order_key C6_, C5_,
                              C7_, C8_)
                            info rdelete (rw @ r2) (stackable_of_cm cm)
                            (roots_of_cm cm))
                      (fn _ =>
                        Inr (mkc i (nfsb i tp) (qb i tp) r2
                              (list_union
                                (equal_prod (equal_term B1_ C5_)
                                  (equal_term B1_ C5_))
                                rw rdelete)))
                  end)))
    end
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"e", #"n", #"s", #"u", #"r", #"i", #"n", #"g", #" ", #"m", #"a",
               #"t", #"c", #"h", #"-", #"R", #"T", #" ", #"b", #"o", #"u", #"n",
               #"d", #"e", #"d", #"n", #"e", #"s", #"s", #" ", #"o", #"f",
               #" "] o
            (shows_nl o
              (shows_tp (shows_prec B3_ zero_nata) (shows_prec C8_ zero_nata) i
                 tp o
                (shows_nl o
                  (shows_prec_list show_char zero_nata
                     [#"w", #"i", #"t", #"h", #" ", #"d", #"e", #"l", #"e",
                       #"t", #"i", #"o", #"n", #" ", #"o", #"f", #" ", #"r",
                       #"u", #"l", #"e", #"s"] o
                    (shows_nl o
                      (shows_trs (shows_prec B3_ zero_nata)
                         (shows_prec C8_ zero_nata)
                         [#"r", #"e", #"w", #"r", #"i", #"t", #"e", #" ", #"s",
                           #"y", #"s", #"t", #"e", #"m", #":"]
                         [#" ", #"-", #">", #" "] rdelete o
                        x))))))));

fun bounds_complexity (B1_, B2_, B3_) (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_)
  (D1_, D2_, D3_, D4_, D5_, D6_, D7_, D8_) i info cm cc tp =
  catch_errora
    (bindb
      (check (less_eq_complexity_class (Comp_Poly one_nata) cc)
        (shows_prec_list show_char zero_nata
          [#"c", #"a", #"n", #" ", #"o", #"n", #"l", #"y", #" ", #"e", #"n",
            #"s", #"u", #"r", #"e", #" ", #"l", #"i", #"n", #"e", #"a", #"r",
            #" ", #"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y"]))
      (fn _ =>
        bindb (check (equal_boundstype (boundstype info) Match)
                (shows_prec_list show_char zero_nata
                  [#"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y",
                    #" ", #"a", #"n", #"a", #"l", #"y", #"s", #"i", #"s", #" ",
                    #"r", #"e", #"q", #"u", #"i", #"r", #"e", #"s", #" ", #"b",
                    #"o", #"u", #"n", #"d", #"s", #"t", #"y", #"p", #"e", #" ",
                    #"m", #"a", #"t", #"c", #"h"]))
          (fn _ =>
            check_bounds_generic (B1_, B2_, B3_)
              (D1_, D2_, D3_, D4_, D5_, D6_, D7_, D8_)
              (C1_, C2_, C3_, C4_, C5_, C6_, C7_, C8_) info (rulesd i tp) []
              (stackable_of_cm cm) (roots_of_cm cm))))
    (fn x =>
      Inl (shows_prec_list show_char zero_nata
             [#"p", #"r", #"o", #"b", #"l", #"e", #"m", #" ", #"i", #"n", #" ",
               #"e", #"n", #"s", #"u", #"r", #"i", #"n", #"g", #" ", #"m", #"a",
               #"t", #"c", #"h", #" ", #"b", #"o", #"u", #"n", #"d", #"e", #"d",
               #"n", #"e", #"s", #"s", #" ", #"o", #"f", #" "] o
            (shows_nl o
              (shows_tp (shows_prec B3_ zero_nata) (shows_prec C8_ zero_nata) i
                 tp o
                (shows_nl o x)))));

fun check_assm (B1_, B2_) (C1_, C2_) i cpx_check
  (Complexity_assm_proof (cp, prf)) =
  cpx_check (mk_cpx (B1_, B2_) (C1_, C2_) i cp) prf
  | check_assm (B1_, B2_) (C1_, C2_) i uu (SN_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
            #"t", #"i", #"o", #"n", #" ", #"o", #"r", #" ", #"n", #"o", #"n",
            #"-", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o",
            #"n", #" ", #"a", #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o",
            #"n", #"s", #" ", #"i", #"n", #" ", #"c", #"o", #"m", #"p", #"l",
            #"e", #"x", #"i", #"t", #"y", #" ", #"p", #"r", #"o", #"o", #"f"])
  | check_assm (B1_, B2_) (C1_, C2_) i uu (Finite_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
            #"t", #"i", #"o", #"n", #" ", #"o", #"r", #" ", #"n", #"o", #"n",
            #"-", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o",
            #"n", #" ", #"a", #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o",
            #"n", #"s", #" ", #"i", #"n", #" ", #"c", #"o", #"m", #"p", #"l",
            #"e", #"x", #"i", #"t", #"y", #" ", #"p", #"r", #"o", #"o", #"f"])
  | check_assm (B1_, B2_) (C1_, C2_) i uu (SN_FP_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
            #"t", #"i", #"o", #"n", #" ", #"o", #"r", #" ", #"n", #"o", #"n",
            #"-", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o",
            #"n", #" ", #"a", #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o",
            #"n", #"s", #" ", #"i", #"n", #" ", #"c", #"o", #"m", #"p", #"l",
            #"e", #"x", #"i", #"t", #"y", #" ", #"p", #"r", #"o", #"o", #"f"])
  | check_assm (B1_, B2_) (C1_, C2_) i uu (Not_SN_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
            #"t", #"i", #"o", #"n", #" ", #"o", #"r", #" ", #"n", #"o", #"n",
            #"-", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o",
            #"n", #" ", #"a", #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o",
            #"n", #"s", #" ", #"i", #"n", #" ", #"c", #"o", #"m", #"p", #"l",
            #"e", #"x", #"i", #"t", #"y", #" ", #"p", #"r", #"o", #"o", #"f"])
  | check_assm (B1_, B2_) (C1_, C2_) i uu (Infinite_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
            #"t", #"i", #"o", #"n", #" ", #"o", #"r", #" ", #"n", #"o", #"n",
            #"-", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o",
            #"n", #" ", #"a", #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o",
            #"n", #"s", #" ", #"i", #"n", #" ", #"c", #"o", #"m", #"p", #"l",
            #"e", #"x", #"i", #"t", #"y", #" ", #"p", #"r", #"o", #"o", #"f"])
  | check_assm (B1_, B2_) (C1_, C2_) i uu (Not_RelSN_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
            #"t", #"i", #"o", #"n", #" ", #"o", #"r", #" ", #"n", #"o", #"n",
            #"-", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o",
            #"n", #" ", #"a", #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o",
            #"n", #"s", #" ", #"i", #"n", #" ", #"c", #"o", #"m", #"p", #"l",
            #"e", #"x", #"i", #"t", #"y", #" ", #"p", #"r", #"o", #"o", #"f"])
  | check_assm (B1_, B2_) (C1_, C2_) i uu (Not_SN_FP_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
            #"t", #"i", #"o", #"n", #" ", #"o", #"r", #" ", #"n", #"o", #"n",
            #"-", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o",
            #"n", #" ", #"a", #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o",
            #"n", #"s", #" ", #"i", #"n", #" ", #"c", #"o", #"m", #"p", #"l",
            #"e", #"x", #"i", #"t", #"y", #" ", #"p", #"r", #"o", #"o", #"f"])
  | check_assm (B1_, B2_) (C1_, C2_) i uu (Unknown_assm_proof (v, va)) =
    Inl (shows_prec_list show_char zero_nata
          [#"n", #"o", #" ", #"s", #"u", #"p", #"p", #"o", #"r", #"t", #" ",
            #"f", #"o", #"r", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
            #"t", #"i", #"o", #"n", #" ", #"o", #"r", #" ", #"n", #"o", #"n",
            #"-", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o",
            #"n", #" ", #"a", #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o",
            #"n", #"s", #" ", #"i", #"n", #" ", #"c", #"o", #"m", #"p", #"l",
            #"e", #"x", #"i", #"t", #"y", #" ", #"p", #"r", #"o", #"o", #"f"]);

fun check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms i
  (tp, (cm, cc)) (Rule_Shift_Complexity (redp, rdelete, ur_opt, prf)) =
  debug (i [])
    [#"R", #"u", #"l", #"e", #" ", #"R", #"e", #"m", #"o", #"v", #"a", #"l",
      #" ", #"C", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y"]
    (bindb
      (catch_errora
        (smart_rule_shift_complexity
          (card_UNIV_lab, cenum_lab, ceq_lab B1_ C1_,
            cproper_interval_lab
              ((compare_compare_order o compare_order_key) B2_)
              ((compare_compare_order o compare_order_key) C2_),
            equal_lab B1_ C1_, key_lab B2_ C2_, set_impl_lab, show_lab B3_ C3_)
          ia (get_redtriple
               (ceq_lab B1_ C1_,
                 ccompare_lab ((compare_compare_order o compare_order_key) B2_)
                   ((compare_compare_order o compare_order_key) C2_),
                 equal_lab B1_ C1_, key_lab B2_ C2_, set_impl_lab,
                 show_lab B3_ C3_)
               redp)
          rdelete ur_opt cm cc tp)
        (fn x =>
          Inl (i o (shows_string
                      [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                        #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                        #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"r",
                        #"u", #"l", #"e", #" ", #"s", #"h", #"i", #"f", #"t",
                        #"i", #"n", #"g", #" ", #"t", #"e", #"c", #"h", #"n",
                        #"i", #"q", #"u", #"e", #" ", #"o", #"n", #" "] o
                     (shows_nl o
                       (shows_tp (shows_prec_lab B3_ C3_ zero_nata)
                          (shows_prec_list show_char zero_nata) ia tp o
                         (shows_nl o x)))))))
      (fn tpa =>
        catch_errora
          (check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms
            (i o shows_string [#".", #"1"]) (tpa, (cm, cc)) prf)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                          #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e", #" ",
                          #"r", #"u", #"l", #"e", #" ", #"s", #"h", #"i", #"f",
                          #"t", #"i", #"n", #"g", #" ", #"p", #"r", #"o", #"c",
                          #"e", #"s", #"s", #"o", #"r"] o
                       (shows_nl o indent x))))))
  | check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms i
    (tp, (cm, cc)) RisEmpty_Complexity =
    debug (i [])
      [#"R", #" ", #"i", #"s", #" ", #"e", #"m", #"p", #"t", #"y", #" ", #"f",
        #"o", #"r", #" ", #"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t",
        #"y"]
      (check (null (rc ia tp))
        (i o (shows_string
                [#":", #" ", #"R", #" ", #"i", #"s", #" ", #"n", #"o", #"t",
                  #" ", #"e", #"m", #"p", #"t", #"y", #" ", #"i", #"n", #" "] o
               (shows_nl o
                 shows_tp (shows_prec_lab B3_ C3_ zero_nata)
                   (shows_prec_list show_char zero_nata) ia tp))))
  | check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms i
    (tp, (cm, cc)) (Remove_Nonapplicable_Rules_Complexity (r, prf)) =
    debug (i [])
      [#"R", #"e", #"m", #"o", #"v", #"i", #"n", #"g", #" ", #"n", #"o", #"n",
        #"-", #"a", #"p", #"p", #"l", #"i", #"c", #"a", #"b", #"l", #"e", #" ",
        #"r", #"u", #"l", #"e", #"s"]
      let
        val _ = rc ia tp;
      in
        bindb (catch_errora (check_non_applicable_rules (is_QNFb ia tp) r)
                (fn x =>
                  Inl (i o (shows_string
                              [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                #"w", #"h", #"e", #"n", #" ", #"r", #"e", #"m",
                                #"o", #"v", #"i", #"n", #"g", #" ", #"n", #"o",
                                #"n", #"-", #"a", #"p", #"p", #"l", #"i", #"c",
                                #"a", #"b", #"l", #"e", #" ", #"r", #"u", #"l",
                                #"e", #"s"] o
                             (shows_nl o
                               indent
                                 (shows_rule (shows_prec_lab B3_ C3_ zero_nata)
                                    (shows_prec_list show_char zero_nata)
                                    [#" ", #"-", #">", #" "] x o
                                   shows_prec_list show_char zero_nata
                                     [#" ", #"i", #"s", #" ", #"a", #"p", #"p",
                                       #"l", #"i", #"c", #"a", #"b", #"l",
                                       #"e"]))))))
          (fn _ =>
            let
              val tpa = delete_R_Rwb ia tp r r;
            in
              catch_errora
                (check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms
                  (i o shows_string [#".", #"1"]) (tpa, (cm, cc)) prf)
                (fn x =>
                  Inl (i o (shows_string
                              [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                #"b", #"e", #"l", #"o", #"w", #" ", #"t", #"h",
                                #"e", #" ", #"n", #"o", #"n", #"-", #"a", #"p",
                                #"p", #"l", #"i", #"c", #"a", #"b", #"l", #"e",
                                #" ", #"r", #"u", #"l", #"e", #"s", #" ", #"r",
                                #"e", #"m", #"o", #"v", #"a", #"l"] o
                             (shows_nl o indent x))))
            end)
      end
  | check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms i
    (tp, (cm, cc)) (Matchbounds_Complexity info) =
    debug (i [])
      [#"M", #"a", #"t", #"c", #"h", #"b", #"o", #"u", #"n", #"d", #"s"]
      (catch_errora
        (bounds_complexity
          (compare_order_lab ((compare_compare_order o compare_order_key) B2_)
             ((compare_compare_order o compare_order_key) C2_),
            equal_lab B1_ C1_, show_lab B3_ C3_)
          (finite_UNIV_list, cenum_list, ceq_list ceq_char,
            cproper_interval_list ccompare_char,
            compare_order_list (compare_order_char, equal_char),
            equal_list equal_char, set_impl_list, show_list show_char)
          (card_UNIV_list, cenum_list, ceq_list ceq_char,
            ccompare_list ccompare_char,
            compare_order_list (compare_order_char, equal_char),
            equal_list equal_char, set_impl_list, show_list show_char)
          ia info cm cc tp)
        (fn x =>
          Inl (i o (shows_string
                      [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                        #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                        #"i", #"n", #"g", #" ", #"m", #"a", #"t", #"c", #"h",
                        #"b", #"o", #"u", #"n", #"d", #"s"] o
                     (shows_nl o indent x)))))
  | check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms i
    (tp, (cm, cc)) (Matchbounds_Rel_Complexity (info, rdel, prf)) =
    debug (i [])
      [#"M", #"a", #"t", #"c", #"h", #"b", #"o", #"u", #"n", #"d", #"s", #"-",
        #"R", #"e", #"l"]
      (bindb
        (catch_errora
          (bounds_complexity_rel
            (equal_lab B1_ C1_, key_lab B2_ C2_, show_lab B3_ C3_)
            (finite_UNIV_list, cenum_list, ceq_list ceq_char,
              cproper_interval_list ccompare_char, equal_list equal_char,
              key_list (equal_char, key_char), set_impl_list,
              show_list show_char)
            (card_UNIV_list, cenum_list, ceq_list ceq_char,
              ccompare_list ccompare_char,
              compare_order_list (compare_order_char, equal_char),
              equal_list equal_char, set_impl_list, show_list show_char)
            ia info rdel cm cc tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"r", #"e", #"l", #"a", #"t",
                          #"i", #"v", #"e", #" ", #"m", #"a", #"t", #"c", #"h",
                          #"b", #"o", #"u", #"n", #"d", #"s"] o
                       (shows_nl o indent x)))))
        (fn tpa =>
          catch_errora
            (check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms
              (i o shows_string [#".", #"1"]) (tpa, (cm, cc)) prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"a", #"p", #"p",
                            #"l", #"y", #"i", #"n", #"g", #" ", #"r", #"e",
                            #"l", #"a", #"t", #"i", #"v", #"e", #" ", #"m",
                            #"a", #"t", #"c", #"h", #"b", #"o", #"u", #"n",
                            #"d", #"s"] o
                         (shows_nl o indent x))))))
  | check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms i
    (tp, (cm, cc)) (DT_Transformation (info, prf)) =
    debug (i [])
      [#"D", #"T", #" ", #"T", #"r", #"a", #"n", #"s", #"f", #"o", #"r", #"m",
        #"a", #"t", #"i", #"o", #"n"]
      (bindb
        (catch_errora
          (dt_transformation
            (card_UNIV_lab, ceq_lab B1_ C1_,
              cproper_interval_lab
                ((compare_compare_order o compare_order_key) B2_)
                ((compare_compare_order o compare_order_key) C2_),
              equal_lab B1_ C1_, set_impl_lab, show_lab B3_ C3_)
            (ccompare_list ccompare_char, equal_list equal_char,
              mapping_impl_list, show_list show_char)
            Sharp ia info cm cc tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"D",
                          #"T", #" ", #"t", #"r", #"a", #"n", #"s", #"f", #"o",
                          #"r", #"m", #"a", #"t", #"i", #"o", #"n", #" ", #"o",
                          #"n", #" "] o
                       (shows_nl o
                         (shows_tp (shows_prec_lab B3_ C3_ zero_nata)
                            (shows_prec_list show_char zero_nata) ia tp o
                           (shows_nl o x)))))))
        (fn (cma, tpa) =>
          catch_errora
            (check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms
              (i o shows_string [#".", #"1"]) (tpa, (cma, cc)) prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"D", #"T", #" ", #"t", #"r", #"a", #"n",
                            #"s", #"f", #"o", #"r", #"m", #"a", #"t", #"i",
                            #"o", #"n"] o
                         (shows_nl o indent x))))))
  | check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms i
    (tp, (cm, cc)) (WDP_Transformation (info, prf)) =
    debug (i [])
      [#"W", #"D", #"P", #" ", #"T", #"r", #"a", #"n", #"s", #"f", #"o", #"r",
        #"m", #"a", #"t", #"i", #"o", #"n"]
      (bindb
        (catch_errora
          (check_wdp_trans
            (finite_UNIV_lab, cenum_lab, ceq_lab B1_ C1_,
              cproper_interval_lab
                ((compare_compare_order o compare_order_key) B2_)
                ((compare_compare_order o compare_order_key) C2_),
              compare_lab ((compare_compare_order o compare_order_key) B2_)
                ((compare_compare_order o compare_order_key) C2_),
              equal_lab B1_ C1_, set_impl_lab, show_lab B3_ C3_)
            (ccompare_list ccompare_char, compare_list compare_char,
              equal_list equal_char, mapping_impl_list, show_list show_char)
            Sharp ia info cm cc tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"t", #"h", #"e", #" ", #"W",
                          #"D", #"P", #" ", #"t", #"r", #"a", #"n", #"s", #"f",
                          #"o", #"r", #"m", #"a", #"t", #"i", #"o", #"n", #" ",
                          #"o", #"n", #" "] o
                       (shows_nl o
                         (shows_tp (shows_prec_lab B3_ C3_ zero_nata)
                            (shows_prec_list show_char zero_nata) ia tp o
                           (shows_nl o x)))))))
        (fn (cma, tpa) =>
          catch_errora
            (check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms
              (i o shows_string [#".", #"1"]) (tpa, (cma, cc)) prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"t", #"h", #"e",
                            #" ", #"W", #"D", #"P", #" ", #"t", #"r", #"a",
                            #"n", #"s", #"f", #"o", #"r", #"m", #"a", #"t",
                            #"i", #"o", #"n"] o
                         (shows_nl o indent x))))))
  | check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms i
    (tp, (cm, cc)) (Usable_Rules_Complexity (ur, prf)) =
    debug (i [])
      [#"U", #"s", #"a", #"b", #"l", #"e", #" ", #"R", #"u", #"l", #"e", #"s"]
      (bindb
        (catch_errora
          (usable_rules_complexity
            (cenum_lab, ceq_lab B1_ C1_,
              ccompare_lab ((compare_compare_order o compare_order_key) B2_)
                ((compare_compare_order o compare_order_key) C2_),
              equal_lab B1_ C1_, key_lab B2_ C2_, set_impl_lab,
              show_lab B3_ C3_)
            ia ur cm cc tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"u", #"s", #"a", #"b", #"l",
                          #"e", #" ", #"r", #"u", #"l", #"e", #"s"] o
                       (shows_nl o indent x)))))
        (fn tpa =>
          catch_errora
            (check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms
              (i o shows_string [#".", #"1"]) (tpa, (cm, cc)) prf)
            (fn x =>
              Inl (i o (shows_string
                          [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"b",
                            #"e", #"l", #"o", #"w", #" ", #"a", #"p", #"p",
                            #"l", #"y", #"i", #"n", #"g", #" ", #"u", #"s",
                            #"a", #"b", #"l", #"e", #" ", #"r", #"u", #"l",
                            #"e", #"s"] o
                         (shows_nl o indent x))))))
  | check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms i
    (tp, (cm, cc)) (Complexity_Assumption (a, ass)) =
    debug (i [])
      [#"C", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y", #" ", #"A",
        #"s", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n"]
      (if assms
        then bindb (catch_errora
                     (check_complexity_subsumes (B1_, B2_, B3_) (C1_, C2_, C3_)
                       (ccompare_list ccompare_char, equal_list equal_char,
                         key_list (equal_char, key_char), mapping_impl_list,
                         show_list show_char)
                       a (qb ia tp, (rc ia tp, (rwc ia tp, (cm, cc)))))
                     (fn x =>
                       Inl (i o (shows_prec_list show_char zero_nata
                                   [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                     #" ", #"i", #"n", #" ", #"c", #"o", #"m",
                                     #"p", #"l", #"e", #"x", #"i", #"t", #"y",
                                     #" ", #"a", #"s", #"s", #"u", #"m", #"p",
                                     #"t", #"i", #"o", #"n", #" ", #"o", #"r",
                                     #" ", #"u", #"n", #"k", #"n", #"o", #"w",
                                     #"n", #" ", #"p", #"r", #"o", #"o", #"f"] o
                                  (shows_nl o x)))))
               (fn _ =>
                 catch_errora
                   (catch_errora
                     (forallM_index
                       (fn asa => fn j =>
                         check_assm (B2_, B3_) (C2_, C3_) ia
                           (check_complexity_proof (B1_, B2_, B3_)
                             (C1_, C2_, C3_) ia assms
                             (i o (shows_string [#"."] o
                                    shows_prec_nat zero_nata (suc j))))
                           asa)
                       ass)
                     (fn x => Inl (snd x)))
                   (fn x =>
                     Inl (i o (shows_string
                                 [#":", #" ", #"e", #"r", #"r", #"o", #"r",
                                   #" ", #"b", #"e", #"l", #"o", #"w", #" ",
                                   #"u", #"n", #"k", #"n", #"o", #"w", #"n",
                                   #" ", #"p", #"r", #"o", #"o", #"f"] o
                                (shows_nl o indent x)))))
        else Inl (shows_prec_list show_char zero_nata
                   [#"t", #"h", #"e", #" ", #"p", #"r", #"o", #"o", #"f", #" ",
                     #"c", #"o", #"n", #"t", #"a", #"i", #"n", #"s", #" ", #"a",
                     #"n", #" ", #"a", #"s", #"s", #"u", #"m", #"p", #"t", #"i",
                     #"o", #"n", #" ", #"o", #"r", #" ", #"u", #"n", #"k", #"n",
                     #"o", #"w", #"n", #" ", #"p", #"r", #"o", #"o", #"f", #" ",
                     #"w", #"h", #"i", #"c", #"h", #" ", #"h", #"a", #"v", #"e",
                     #" ", #"t", #"o", #" ", #"b", #"e", #" ", #"m", #"a", #"n",
                     #"u", #"a", #"l", #"l", #"y", #" ", #"a", #"l", #"l", #"o",
                     #"w", #"e", #"d"]))
  | check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms i
    (tp, (cm, cc)) (Split_Complexity (info, prf1, prf2)) =
    debug (i []) [#"S", #"p", #"l", #"i", #"t"]
      (bindb
        (catch_errora
          (split_proc_complexity (equal_lab B1_ C1_, show_lab B3_ C3_)
            (equal_list equal_char, show_list show_char) ia info tp)
          (fn x =>
            Inl (i o (shows_string
                        [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ", #"w",
                          #"h", #"e", #"n", #" ", #"a", #"p", #"p", #"l", #"y",
                          #"i", #"n", #"g", #" ", #"s", #"p", #"l", #"i", #"t",
                          #" ", #"p", #"r", #"o", #"c", #"e", #"s", #"s", #"o",
                          #"r"] o
                       (shows_nl o indent x)))))
        (fn (tp1, tp2) =>
          bindb (catch_errora
                  (check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia
                    assms (i o shows_string [#".", #"1"]) (tp1, (cm, cc)) prf1)
                  (fn x =>
                    Inl (i o (shows_string
                                [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                  #"b", #"e", #"l", #"o", #"w", #" ", #"a",
                                  #"p", #"p", #"l", #"y", #"i", #"n", #"g",
                                  #" ", #"s", #"p", #"l", #"i", #"t", #" ",
                                  #"p", #"r", #"o", #"c", #"e", #"s", #"s",
                                  #"o", #"r"] o
                               (shows_nl o indent x)))))
            (fn _ =>
              catch_errora
                (check_complexity_proof (B1_, B2_, B3_) (C1_, C2_, C3_) ia assms
                  (i o shows_string [#".", #"2"]) (tp2, (cm, cc)) prf2)
                (fn x =>
                  Inl (i o (shows_string
                              [#":", #" ", #"e", #"r", #"r", #"o", #"r", #" ",
                                #"b", #"e", #"l", #"o", #"w", #" ", #"a", #"p",
                                #"p", #"l", #"y", #"i", #"n", #"g", #" ", #"s",
                                #"p", #"l", #"i", #"t", #" ", #"p", #"r", #"o",
                                #"c", #"e", #"s", #"s", #"o", #"r"] o
                             (shows_nl o indent x)))))));

fun translate_complexity_claim A_ r s start =
  let
    val f = funas_trs_list (r @ s);
    val d = defined_list (r @ s);
    val c = filtera (fn fa => not (membera (equal_prod A_ equal_nat) d fa)) f;
  in
    (case start of Full => Derivational_Complexity f
      | Constructor_Based => Runtime_Complexity (c, d))
  end;

fun check_unknown_proof (B1_, B2_, B3_, B4_) ia j a i u prf =
  check_unknown_proof_main (B1_, B2_, B3_, B4_) ia j a i u
    (unlab_to_split_unknown (B2_, B3_)
      (equal_list equal_nat, key_list (equal_nat, key_nat))
      (equal_list equal_char, key_list (equal_char, key_char)) prf);

fun fp_strategy_to_fp_impl A_ strat r =
  (case strat of Outermost => o_to_fp_impl (map fst r)
    | Context_Sensitive a => mu_to_fp_impl A_ a | Forbidden_Patterns fp => fp);

fun proof_to_string proof =
  (case proof
    of TRS_Termination_Proof _ =>
      [#"T", #"R", #"S", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t",
        #"i", #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"]
    | Complexity_Proof _ =>
      [#"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y", #" ", #"p",
        #"r", #"o", #"o", #"f"]
    | DP_Termination_Proof _ =>
      [#"D", #"P", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
        #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"]
    | DP_Nontermination_Proof _ =>
      [#"D", #"P", #" ", #"n", #"o", #"n", #"t", #"e", #"r", #"m", #"i", #"n",
        #"a", #"t", #"i", #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"]
    | TRS_Nontermination_Proof _ =>
      [#"T", #"R", #"S", #" ", #"n", #"o", #"n", #"t", #"e", #"r", #"m", #"i",
        #"n", #"a", #"t", #"i", #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"]
    | FP_Termination_Proof _ =>
      [#"F", #"P", #" ", #"T", #"R", #"S", #" ", #"t", #"e", #"r", #"m", #"i",
        #"n", #"a", #"t", #"i", #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"]
    | Relative_TRS_Nontermination_Proof _ =>
      [#"r", #"e", #"l", #"a", #"t", #"i", #"v", #"e", #" ", #"T", #"R", #"S",
        #" ", #"n", #"o", #"n", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t",
        #"i", #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"]
    | TRS_Confluence_Proof _ =>
      [#"T", #"R", #"S", #" ", #"c", #"o", #"n", #"f", #"l", #"u", #"e", #"n",
        #"c", #"e", #" ", #"p", #"r", #"o", #"o", #"f"]
    | TRS_Non_Confluence_Proof _ =>
      [#"T", #"R", #"S", #" ", #"n", #"o", #"n", #"c", #"o", #"n", #"f", #"l",
        #"u", #"e", #"n", #"c", #"e", #" ", #"p", #"r", #"o", #"o", #"f"]
    | Completion_Proof _ =>
      [#"c", #"o", #"m", #"p", #"l", #"e", #"t", #"i", #"o", #"n", #" ", #"p",
        #"r", #"o", #"o", #"f"]
    | Ordered_Completion_Proof _ =>
      [#"o", #"r", #"d", #"e", #"r", #"e", #"d", #" ", #"c", #"o", #"m", #"p",
        #"l", #"e", #"t", #"i", #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"]
    | Equational_Proof _ =>
      [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #" ", #"p",
        #"r", #"o", #"o", #"f"]
    | Equational_Disproof _ =>
      [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #" ", #"d",
        #"i", #"s", #"p", #"r", #"o", #"o", #"f"]
    | Quasi_Reductive_Proof _ =>
      [#"q", #"u", #"a", #"s", #"i", #"-", #"r", #"e", #"d", #"u", #"c", #"t",
        #"i", #"v", #"e", #" ", #"p", #"r", #"o", #"o", #"f"]
    | Conditional_CR_Proof _ =>
      [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a", #"l", #" ",
        #"c", #"o", #"n", #"f", #"l", #"u", #"e", #"n", #"c", #"e", #" ", #"p",
        #"r", #"o", #"o", #"f"]
    | Conditional_Non_CR_Proof _ =>
      [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a", #"l", #" ",
        #"n", #"o", #"n", #"c", #"o", #"n", #"f", #"l", #"u", #"e", #"n", #"c",
        #"e", #" ", #"p", #"r", #"o", #"o", #"f"]
    | Tree_Automata_Closed_Proof _ =>
      [#"t", #"r", #"e", #"e", #" ", #"a", #"u", #"t", #"o", #"m", #"a", #"t",
        #"a", #" ", #"c", #"l", #"o", #"s", #"e", #"d", #" ", #"p", #"r", #"o",
        #"o", #"f"]
    | AC_Termination_Proof _ =>
      [#"A", #"C", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
        #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"]
    | LTS_Termination_Proof _ =>
      [#"L", #"T", #"S", #" ", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t",
        #"i", #"o", #"n", #" ", #"p", #"r", #"o", #"o", #"f"]
    | LTS_Safety_Proof _ =>
      [#"L", #"T", #"S", #" ", #"s", #"a", #"f", #"e", #"t", #"y", #" ", #"p",
        #"r", #"o", #"o", #"f"]
    | Unknown_Proof _ =>
      [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"p", #"r", #"o", #"o",
        #"f"]
    | Unknown_Disproof _ =>
      [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"d", #"i", #"s", #"p",
        #"r", #"o", #"o", #"f"]);

fun input_to_string input =
  (case input
    of DP_input (_, _, _, _) => [#"D", #"P", #" ", #"i", #"n", #"p", #"u", #"t"]
    | Inn_TRS_input (_, _, _, _) =>
      [#"T", #"R", #"S", #" ", #"i", #"n", #"p", #"u", #"t"]
    | CPX_input (_, _, _, _, _) =>
      [#"C", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y", #" ", #"i",
        #"n", #"p", #"u", #"t"]
    | COMP_input (_, _) =>
      [#"C", #"o", #"m", #"p", #"l", #"e", #"t", #"i", #"o", #"n", #" ", #"i",
        #"n", #"p", #"u", #"t"]
    | OCOMP_input (_, _, _, _) =>
      [#"O", #"r", #"d", #"e", #"r", #"e", #"d", #" ", #"C", #"o", #"m", #"p",
        #"l", #"e", #"t", #"i", #"o", #"n", #" ", #"i", #"n", #"p", #"u", #"t"]
    | EQ_input (_, _) =>
      [#"E", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #" ", #"i",
        #"n", #"p", #"u", #"t"]
    | FP_TRS_input (_, _) =>
      [#"F", #"P", #"-", #"T", #"R", #"S", #" ", #"i", #"n", #"p", #"u", #"t"]
    | CTRS_input _ =>
      [#"C", #"T", #"R", #"S", #" ", #"i", #"n", #"p", #"u", #"t"]
    | TA_input (_, _) => [#"T", #"A", #" ", #"i", #"n", #"p", #"u", #"t"]
    | AC_input (_, _, _) =>
      [#"A", #"C", #"-", #"T", #"R", #"S", #" ", #"i", #"n", #"p", #"u", #"t"]
    | LTS_input _ => [#"L", #"T", #"S", #" ", #"i", #"n", #"p", #"u", #"t"]
    | LTS_safety_input (_, _) =>
      [#"L", #"T", #"S", #" ", #"s", #"a", #"f", #"e", #"t", #"y", #" ", #"i",
        #"n", #"p", #"u", #"t"]
    | Unknown_input _ =>
      [#"U", #"n", #"k", #"n", #"o", #"w", #"n", #" ", #"i", #"n", #"p", #"u",
        #"t"]);

fun claim_to_string claim =
  (case claim of Yes => [#"y", #"e", #"s"] | No => [#"n", #"o"]
    | Terminating =>
      [#"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n"]
    | Upperbound _ =>
      [#"u", #"p", #"p", #"e", #"r", #"b", #"o", #"u", #"n", #"d", #" ", #"c",
        #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y"]
    | Nonterminating =>
      [#"n", #"o", #"n", #"t", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i",
        #"o", #"n"]
    | Confluent => [#"c", #"o", #"n", #"f", #"l", #"u", #"e", #"n", #"c", #"e"]
    | Nonconfluent =>
      [#"n", #"o", #"n", #"c", #"o", #"n", #"f", #"l", #"u", #"e", #"n", #"c",
        #"e"]
    | Completed => [#"c", #"o", #"m", #"p", #"l", #"e", #"t", #"i", #"o", #"n"]
    | Ordered_Completed =>
      [#"o", #"r", #"d", #"e", #"r", #"e", #"d", #" ", #"c", #"o", #"m", #"p",
        #"l", #"e", #"t", #"i", #"o", #"n"]
    | Anything => [#"a", #"n", #"y", #"t", #"h", #"i", #"n", #"g"]);

fun check_cert (B1_, B2_, B3_, B4_, B5_) i j k l a input claim proof =
  let
    val mismatch =
      shows_prec_list show_char zero_nata
        ([#"C", #"l", #"a", #"i", #"m", #"i", #"n", #"g", #" "] @
          claim_to_string claim @
            [#" ", #"o", #"f", #" "] @
              input_to_string input @
                [#" ", #"b", #"y", #" "] @ proof_to_string proof);
  in
    (case input
      of DP_input (m, p, q, r) =>
        (case proof of TRS_Termination_Proof _ => Inl mismatch
          | Complexity_Proof _ => Inl mismatch
          | DP_Termination_Proof prf =>
            (if equal_claim claim Terminating orelse equal_claim claim Anything
              then check_dp_termination_proof (B1_, B3_, B4_, B5_) i j a
                     (shows_string [#"1"])
                     (mkd j default_nfs_dp m p []
                       (strategy_to_Q (equal_lab B3_ (equal_list equal_nat))
                         (equal_list equal_char) q r)
                       [] r)
                     prf
              else Inl mismatch)
          | DP_Nontermination_Proof prf =>
            (if equal_claim claim Nonterminating orelse
                  equal_claim claim Anything
              then check_dp_nontermination_proof (B2_, B3_, B4_, B5_)
                     (equal_list equal_nat, key_list (equal_nat, key_nat),
                       show_list show_nat)
                     i j a (shows_string [#"1"])
                     (mkd j default_nfs_nt_dp m p []
                       (strategy_to_Q (equal_lab B3_ (equal_list equal_nat))
                         (equal_list equal_char) q r)
                       [] r)
                     prf
              else Inl mismatch)
          | TRS_Nontermination_Proof _ => Inl mismatch
          | FP_Termination_Proof _ => Inl mismatch
          | Relative_TRS_Nontermination_Proof _ => Inl mismatch
          | TRS_Confluence_Proof _ => Inl mismatch
          | TRS_Non_Confluence_Proof _ => Inl mismatch
          | Completion_Proof _ => Inl mismatch
          | Ordered_Completion_Proof _ => Inl mismatch
          | Equational_Proof _ => Inl mismatch
          | Equational_Disproof _ => Inl mismatch
          | Quasi_Reductive_Proof _ => Inl mismatch
          | Conditional_CR_Proof _ => Inl mismatch
          | Conditional_Non_CR_Proof _ => Inl mismatch
          | Tree_Automata_Closed_Proof _ => Inl mismatch
          | AC_Termination_Proof _ => Inl mismatch
          | LTS_Termination_Proof _ => Inl mismatch
          | LTS_Safety_Proof _ => Inl mismatch | Unknown_Proof _ => Inl mismatch
          | Unknown_Disproof _ => Inl mismatch)
      | Inn_TRS_input (q, r, s, start) =>
        (case proof
          of TRS_Termination_Proof prf =>
            (if equal_claim claim Terminating orelse equal_claim claim Anything
              then check_trs_termination_proof (B1_, B3_, B4_, B5_) i j a
                     (shows_string [#"1"])
                     (mkc i default_nfs_trs
                       (strategy_to_Q (equal_lab B3_ (equal_list equal_nat))
                         (equal_list equal_char) q r)
                       r s)
                     prf
              else Inl mismatch)
          | Complexity_Proof prf =>
            (case claim of Yes => Inl mismatch | No => Inl mismatch
              | Terminating => Inl mismatch
              | Upperbound ub =>
                let
                  val cm =
                    translate_complexity_claim
                      (equal_lab B3_ (equal_list equal_nat)) r s start;
                  val cc = Comp_Poly ub;
                in
                  check_complexity_proof (B3_, B4_, B5_)
                    (equal_list equal_nat, key_list (equal_nat, key_nat),
                      show_list show_nat)
                    i a (shows_string [#"1"])
                    (mkc i true
                       (strategy_to_Q (equal_lab B3_ (equal_list equal_nat))
                         (equal_list equal_char) q (r @ s))
                       r s,
                      (cm, cc))
                    prf
                end
              | Nonterminating => Inl mismatch | Confluent => Inl mismatch
              | Nonconfluent => Inl mismatch | Completed => Inl mismatch
              | Ordered_Completed => Inl mismatch | Anything => Inl mismatch)
          | DP_Termination_Proof _ => Inl mismatch
          | DP_Nontermination_Proof _ => Inl mismatch
          | TRS_Nontermination_Proof prf =>
            (if equal_claim claim Nonterminating orelse
                  equal_claim claim Anything
              then bindb (check (equal_start_term start Full) mismatch)
                     (fn _ =>
                       bindb (check (null s) mismatch)
                         (fn _ =>
                           check_trs_nontermination_proof (B2_, B3_, B4_, B5_)
                             (equal_list equal_nat,
                               key_list (equal_nat, key_nat),
                               show_list show_nat)
                             i j a (shows_string [#"1"])
                             (mkc i default_nfs_nt_trs
                               (strategy_to_Q
                                 (equal_lab B3_ (equal_list equal_nat))
                                 (equal_list equal_char) q r)
                               r [])
                             prf))
              else Inl mismatch)
          | FP_Termination_Proof _ => Inl mismatch
          | Relative_TRS_Nontermination_Proof prf =>
            (if equal_claim claim Nonterminating orelse
                  equal_claim claim Anything
              then bindb (check (equal_start_term start Full) mismatch)
                     (fn _ =>
                       check_reltrs_nontermination_proof (B2_, B3_, B4_, B5_)
                         (equal_list equal_nat, key_list (equal_nat, key_nat),
                           show_list show_nat)
                         i j a (shows_string [#"1"])
                         (mkc i default_nfs_nt_trs
                           (strategy_to_Q (equal_lab B3_ (equal_list equal_nat))
                             (equal_list equal_char) q r)
                           r s)
                         prf)
              else Inl mismatch)
          | TRS_Confluence_Proof prf =>
            (if equal_claim claim Confluent orelse equal_claim claim Anything
              then bindb (check (equal_start_term start Full)
                           (shows_prec_list show_char zero_nata
                             [#"C", #"o", #"n", #"f", #"l", #"u", #"e", #"n",
                               #"c", #"e", #" ", #"w", #"i", #"t", #"h", #" ",
                               #"s", #"t", #"a", #"r", #"t", #" ", #"t", #"e",
                               #"r", #"m", #" ", #"n", #"o", #"t", #" ", #"s",
                               #"u", #"p", #"p", #"o", #"r", #"t", #"e", #"d"]))
                     (fn _ =>
                       bindb (check
                               (equal_strategy
                                 (equal_lab B3_ (equal_list equal_nat))
                                 (equal_list equal_char) q No_Strategy)
                               (shows_prec_list show_char zero_nata
                                 [#"C", #"o", #"n", #"f", #"l", #"u", #"e",
                                   #"n", #"c", #"e", #" ", #"u", #"n", #"d",
                                   #"e", #"r", #" ", #"s", #"t", #"r", #"a",
                                   #"t", #"e", #"g", #"y", #" ", #"n", #"o",
                                   #"t", #" ", #"s", #"u", #"p", #"p", #"o",
                                   #"r", #"t", #"e", #"d"]))
                         (fn _ =>
                           bindb (check (null s)
                                   (shows_prec_list show_char zero_nata
                                     [#"R", #"e", #"l", #"a", #"t", #"i", #"v",
                                       #"e", #" ", #"c", #"o", #"n", #"f", #"l",
                                       #"u", #"e", #"n", #"c", #"e", #" ", #"n",
                                       #"o", #"t", #" ", #"s", #"u", #"p", #"p",
                                       #"o", #"r", #"t", #"e", #"d"]))
                             (fn _ =>
                               check_cr_proof (B1_, B3_, B4_, B5_) a
                                 (shows_string [#"1"]) i j r prf)))
              else Inl mismatch)
          | TRS_Non_Confluence_Proof prf =>
            (if equal_claim claim Nonconfluent orelse equal_claim claim Anything
              then bindb (check (equal_start_term start Full)
                           (shows_prec_list show_char zero_nata
                             [#"N", #"o", #"n", #"c", #"o", #"n", #"f", #"l",
                               #"u", #"e", #"n", #"c", #"e", #" ", #"w", #"i",
                               #"t", #"h", #" ", #"s", #"t", #"a", #"r", #"t",
                               #" ", #"t", #"e", #"r", #"m", #" ", #"n", #"o",
                               #"t", #" ", #"s", #"u", #"p", #"p", #"o", #"r",
                               #"t", #"e", #"d"]))
                     (fn _ =>
                       bindb (check
                               (equal_strategy
                                 (equal_lab B3_ (equal_list equal_nat))
                                 (equal_list equal_char) q No_Strategy)
                               (shows_prec_list show_char zero_nata
                                 [#"C", #"o", #"n", #"f", #"l", #"u", #"e",
                                   #"n", #"c", #"e", #" ", #"u", #"n", #"d",
                                   #"e", #"r", #" ", #"s", #"t", #"r", #"a",
                                   #"t", #"e", #"g", #"y", #" ", #"n", #"o",
                                   #"t", #" ", #"s", #"u", #"p", #"p", #"o",
                                   #"r", #"t", #"e", #"d"]))
                         (fn _ =>
                           bindb (check (null s)
                                   (shows_prec_list show_char zero_nata
                                     [#"R", #"e", #"l", #"a", #"t", #"i", #"v",
                                       #"e", #" ", #"n", #"o", #"n", #"c", #"o",
                                       #"n", #"f", #"l", #"u", #"e", #"n", #"c",
                                       #"e", #" ", #"n", #"o", #"t", #" ", #"s",
                                       #"u", #"p", #"p", #"o", #"r", #"t", #"e",
                                       #"d"]))
                             (fn _ =>
                               check_ncr_proof (B1_, B2_, B3_, B4_, B5_) a
                                 (shows_string [#"1"]) i j r prf)))
              else Inl mismatch)
          | Completion_Proof _ => Inl mismatch
          | Ordered_Completion_Proof _ => Inl mismatch
          | Equational_Proof _ => Inl mismatch
          | Equational_Disproof _ => Inl mismatch
          | Quasi_Reductive_Proof _ => Inl mismatch
          | Conditional_CR_Proof _ => Inl mismatch
          | Conditional_Non_CR_Proof _ => Inl mismatch
          | Tree_Automata_Closed_Proof _ => Inl mismatch
          | AC_Termination_Proof _ => Inl mismatch
          | LTS_Termination_Proof _ => Inl mismatch
          | LTS_Safety_Proof _ => Inl mismatch | Unknown_Proof _ => Inl mismatch
          | Unknown_Disproof _ => Inl mismatch)
      | CPX_input (q, r, s, cm, cc) =>
        (case proof of TRS_Termination_Proof _ => Inl mismatch
          | Complexity_Proof prf =>
            bindb (case claim of Yes => Inl mismatch | No => Inl mismatch
                    | Terminating => Inl mismatch
                    | Upperbound ub =>
                      check (equal_complexity_class cc (Comp_Poly ub))
                        (shows_prec_list show_char zero_nata
                          [#"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t",
                            #"y", #" ", #"c", #"l", #"a", #"s", #"s", #" ",
                            #"m", #"i", #"s", #"m", #"a", #"t", #"c", #"h"])
                    | Nonterminating => Inl mismatch | Confluent => Inl mismatch
                    | Nonconfluent => Inl mismatch | Completed => Inl mismatch
                    | Ordered_Completed => Inl mismatch | Anything => Inr ())
              (fn _ =>
                check_complexity_proof (B3_, B4_, B5_)
                  (equal_list equal_nat, key_list (equal_nat, key_nat),
                    show_list show_nat)
                  i a (shows_string [#"1"])
                  (mkc i true
                     (strategy_to_Q (equal_lab B3_ (equal_list equal_nat))
                       (equal_list equal_char) q (r @ s))
                     r s,
                    (cm, cc))
                  prf)
          | DP_Termination_Proof _ => Inl mismatch
          | DP_Nontermination_Proof _ => Inl mismatch
          | TRS_Nontermination_Proof _ => Inl mismatch
          | FP_Termination_Proof _ => Inl mismatch
          | Relative_TRS_Nontermination_Proof _ => Inl mismatch
          | TRS_Confluence_Proof _ => Inl mismatch
          | TRS_Non_Confluence_Proof _ => Inl mismatch
          | Completion_Proof _ => Inl mismatch
          | Ordered_Completion_Proof _ => Inl mismatch
          | Equational_Proof _ => Inl mismatch
          | Equational_Disproof _ => Inl mismatch
          | Quasi_Reductive_Proof _ => Inl mismatch
          | Conditional_CR_Proof _ => Inl mismatch
          | Conditional_Non_CR_Proof _ => Inl mismatch
          | Tree_Automata_Closed_Proof _ => Inl mismatch
          | AC_Termination_Proof _ => Inl mismatch
          | LTS_Termination_Proof _ => Inl mismatch
          | LTS_Safety_Proof _ => Inl mismatch | Unknown_Proof _ => Inl mismatch
          | Unknown_Disproof _ => Inl mismatch)
      | COMP_input (e, r) =>
        (case proof of TRS_Termination_Proof _ => Inl mismatch
          | Complexity_Proof _ => Inl mismatch
          | DP_Termination_Proof _ => Inl mismatch
          | DP_Nontermination_Proof _ => Inl mismatch
          | TRS_Nontermination_Proof _ => Inl mismatch
          | FP_Termination_Proof _ => Inl mismatch
          | Relative_TRS_Nontermination_Proof _ => Inl mismatch
          | TRS_Confluence_Proof _ => Inl mismatch
          | TRS_Non_Confluence_Proof _ => Inl mismatch
          | Completion_Proof prf =>
            (if equal_claim claim Completed orelse equal_claim claim Anything
              then check_completion_proof (B1_, B3_, B4_, B5_) a
                     (shows_string [#"1"]) i j e r prf
              else Inl mismatch)
          | Ordered_Completion_Proof _ => Inl mismatch
          | Equational_Proof _ => Inl mismatch
          | Equational_Disproof _ => Inl mismatch
          | Quasi_Reductive_Proof _ => Inl mismatch
          | Conditional_CR_Proof _ => Inl mismatch
          | Conditional_Non_CR_Proof _ => Inl mismatch
          | Tree_Automata_Closed_Proof _ => Inl mismatch
          | AC_Termination_Proof _ => Inl mismatch
          | LTS_Termination_Proof _ => Inl mismatch
          | LTS_Safety_Proof _ => Inl mismatch | Unknown_Proof _ => Inl mismatch
          | Unknown_Disproof _ => Inl mismatch)
      | OCOMP_input (e_0, e, r, ord) =>
        (case proof of TRS_Termination_Proof _ => Inl mismatch
          | Complexity_Proof _ => Inl mismatch
          | DP_Termination_Proof _ => Inl mismatch
          | DP_Nontermination_Proof _ => Inl mismatch
          | TRS_Nontermination_Proof _ => Inl mismatch
          | FP_Termination_Proof _ => Inl mismatch
          | Relative_TRS_Nontermination_Proof _ => Inl mismatch
          | TRS_Confluence_Proof _ => Inl mismatch
          | TRS_Non_Confluence_Proof _ => Inl mismatch
          | Completion_Proof _ => Inl mismatch
          | Ordered_Completion_Proof prf =>
            (if equal_claim claim Ordered_Completed orelse
                  equal_claim claim Anything
              then check_ordered_completion_proof (B3_, B4_, B5_) a
                     (shows_string [#"1"]) i j e_0 e r ord prf
              else Inl mismatch)
          | Equational_Proof _ => Inl mismatch
          | Equational_Disproof _ => Inl mismatch
          | Quasi_Reductive_Proof _ => Inl mismatch
          | Conditional_CR_Proof _ => Inl mismatch
          | Conditional_Non_CR_Proof _ => Inl mismatch
          | Tree_Automata_Closed_Proof _ => Inl mismatch
          | AC_Termination_Proof _ => Inl mismatch
          | LTS_Termination_Proof _ => Inl mismatch
          | LTS_Safety_Proof _ => Inl mismatch | Unknown_Proof _ => Inl mismatch
          | Unknown_Disproof _ => Inl mismatch)
      | EQ_input (e, eq) =>
        (case proof of TRS_Termination_Proof _ => Inl mismatch
          | Complexity_Proof _ => Inl mismatch
          | DP_Termination_Proof _ => Inl mismatch
          | DP_Nontermination_Proof _ => Inl mismatch
          | TRS_Nontermination_Proof _ => Inl mismatch
          | FP_Termination_Proof _ => Inl mismatch
          | Relative_TRS_Nontermination_Proof _ => Inl mismatch
          | TRS_Confluence_Proof _ => Inl mismatch
          | TRS_Non_Confluence_Proof _ => Inl mismatch
          | Completion_Proof _ => Inl mismatch
          | Ordered_Completion_Proof _ => Inl mismatch
          | Equational_Proof prf =>
            (if equal_claim claim Yes orelse equal_claim claim Anything
              then check_equational_proof (B1_, B3_, B4_, B5_) a
                     (shows_string [#"1"]) i j e eq prf
              else Inl mismatch)
          | Equational_Disproof prf =>
            (if equal_claim claim No orelse equal_claim claim Anything
              then check_equational_disproof (B1_, B3_, B4_, B5_) a
                     (shows_string [#"1"]) i j e eq prf
              else Inl mismatch)
          | Quasi_Reductive_Proof _ => Inl mismatch
          | Conditional_CR_Proof _ => Inl mismatch
          | Conditional_Non_CR_Proof _ => Inl mismatch
          | Tree_Automata_Closed_Proof _ => Inl mismatch
          | AC_Termination_Proof _ => Inl mismatch
          | LTS_Termination_Proof _ => Inl mismatch
          | LTS_Safety_Proof _ => Inl mismatch | Unknown_Proof _ => Inl mismatch
          | Unknown_Disproof _ => Inl mismatch)
      | FP_TRS_input (strat, r) =>
        (case proof of TRS_Termination_Proof _ => Inl mismatch
          | Complexity_Proof _ => Inl mismatch
          | DP_Termination_Proof _ => Inl mismatch
          | DP_Nontermination_Proof _ => Inl mismatch
          | TRS_Nontermination_Proof prf =>
            (if equal_claim claim Nonterminating orelse
                  equal_claim claim Anything
              then check_fp_nontermination_proof (B2_, B3_, B4_, B5_)
                     (equal_list equal_nat, key_list (equal_nat, key_nat),
                       show_list show_nat)
                     i j a (shows_string [#"1"])
                     (fp_strategy_to_fp_impl
                        (equal_lab B3_ (equal_list equal_nat)) strat r,
                       r)
                     prf
              else Inl mismatch)
          | FP_Termination_Proof prf =>
            (if equal_claim claim Terminating orelse equal_claim claim Anything
              then check_fptrs_termination_proof (B1_, B3_, B4_, B5_) i j a
                     (shows_string [#"1"])
                     (fp_strategy_to_fp_impl
                        (equal_lab B3_ (equal_list equal_nat)) strat r,
                       r)
                     prf
              else Inl mismatch)
          | Relative_TRS_Nontermination_Proof _ => Inl mismatch
          | TRS_Confluence_Proof _ => Inl mismatch
          | TRS_Non_Confluence_Proof _ => Inl mismatch
          | Completion_Proof _ => Inl mismatch
          | Ordered_Completion_Proof _ => Inl mismatch
          | Equational_Proof _ => Inl mismatch
          | Equational_Disproof _ => Inl mismatch
          | Quasi_Reductive_Proof _ => Inl mismatch
          | Conditional_CR_Proof _ => Inl mismatch
          | Conditional_Non_CR_Proof _ => Inl mismatch
          | Tree_Automata_Closed_Proof _ => Inl mismatch
          | AC_Termination_Proof _ => Inl mismatch
          | LTS_Termination_Proof _ => Inl mismatch
          | LTS_Safety_Proof _ => Inl mismatch | Unknown_Proof _ => Inl mismatch
          | Unknown_Disproof _ => Inl mismatch)
      | CTRS_input ctrs =>
        (case proof of TRS_Termination_Proof _ => Inl mismatch
          | Complexity_Proof _ => Inl mismatch
          | DP_Termination_Proof _ => Inl mismatch
          | DP_Nontermination_Proof _ => Inl mismatch
          | TRS_Nontermination_Proof _ => Inl mismatch
          | FP_Termination_Proof _ => Inl mismatch
          | Relative_TRS_Nontermination_Proof _ => Inl mismatch
          | TRS_Confluence_Proof _ => Inl mismatch
          | TRS_Non_Confluence_Proof _ => Inl mismatch
          | Completion_Proof _ => Inl mismatch
          | Ordered_Completion_Proof _ => Inl mismatch
          | Equational_Proof _ => Inl mismatch
          | Equational_Disproof _ => Inl mismatch
          | Quasi_Reductive_Proof prf =>
            (if equal_claim claim Terminating orelse equal_claim claim Anything
              then check_quasi_reductive_proof (B1_, B3_, B4_, B5_) a
                     (shows_string [#"1"]) i j ctrs prf
              else Inl mismatch)
          | Conditional_CR_Proof prf =>
            (if equal_claim claim Confluent orelse equal_claim claim Anything
              then check_conditional_cr_proof (B1_, B2_, B3_, B4_, B5_) a
                     (shows_string [#"1"]) i j ctrs prf
              else Inl mismatch)
          | Conditional_Non_CR_Proof prf =>
            (if equal_claim claim Nonconfluent orelse equal_claim claim Anything
              then check_conditional_ncr_proof (B1_, B2_, B3_, B4_, B5_) a
                     (shows_string [#"1"]) i j ctrs prf
              else Inl mismatch)
          | Tree_Automata_Closed_Proof _ => Inl mismatch
          | AC_Termination_Proof _ => Inl mismatch
          | LTS_Termination_Proof _ => Inl mismatch
          | LTS_Safety_Proof _ => Inl mismatch | Unknown_Proof _ => Inl mismatch
          | Unknown_Disproof _ => Inl mismatch)
      | TA_input (ta, r) =>
        (case proof of TRS_Termination_Proof _ => Inl mismatch
          | Complexity_Proof _ => Inl mismatch
          | DP_Termination_Proof _ => Inl mismatch
          | DP_Nontermination_Proof _ => Inl mismatch
          | TRS_Nontermination_Proof _ => Inl mismatch
          | FP_Termination_Proof _ => Inl mismatch
          | Relative_TRS_Nontermination_Proof _ => Inl mismatch
          | TRS_Confluence_Proof _ => Inl mismatch
          | TRS_Non_Confluence_Proof _ => Inl mismatch
          | Completion_Proof _ => Inl mismatch
          | Ordered_Completion_Proof _ => Inl mismatch
          | Equational_Proof _ => Inl mismatch
          | Equational_Disproof _ => Inl mismatch
          | Quasi_Reductive_Proof _ => Inl mismatch
          | Conditional_CR_Proof _ => Inl mismatch
          | Conditional_Non_CR_Proof _ => Inl mismatch
          | Tree_Automata_Closed_Proof prf =>
            (if equal_claim claim Yes orelse equal_claim claim Anything
              then tree_aut_trs_closed
                     (card_UNIV_list, cenum_list, ceq_list ceq_char,
                       cproper_interval_list ccompare_char,
                       compare_order_list (compare_order_char, equal_char),
                       equal_list equal_char, set_impl_list,
                       show_list show_char)
                     (ceq_lab B3_ (equal_list equal_nat),
                       ccompare_lab
                         ((compare_compare_order o compare_order_key) B4_)
                         (compare_list compare_nat),
                       compare_order_lab
                         ((compare_compare_order o compare_order_key) B4_)
                         (compare_list compare_nat),
                       default_lab B2_, equal_lab B3_ (equal_list equal_nat),
                       set_impl_lab, show_lab B5_ (show_list show_nat))
                     (finite_UNIV_list, cenum_list, ceq_list ceq_char,
                       cproper_interval_list ccompare_char,
                       compare_order_list (compare_order_char, equal_char),
                       equal_list equal_char, set_impl_list,
                       show_list show_char)
                     ta prf r
              else Inl mismatch)
          | AC_Termination_Proof _ => Inl mismatch
          | LTS_Termination_Proof _ => Inl mismatch
          | LTS_Safety_Proof _ => Inl mismatch | Unknown_Proof _ => Inl mismatch
          | Unknown_Disproof _ => Inl mismatch)
      | AC_input (r, aa, c) =>
        (case proof of TRS_Termination_Proof _ => Inl mismatch
          | Complexity_Proof _ => Inl mismatch
          | DP_Termination_Proof _ => Inl mismatch
          | DP_Nontermination_Proof _ => Inl mismatch
          | TRS_Nontermination_Proof _ => Inl mismatch
          | FP_Termination_Proof _ => Inl mismatch
          | Relative_TRS_Nontermination_Proof _ => Inl mismatch
          | TRS_Confluence_Proof _ => Inl mismatch
          | TRS_Non_Confluence_Proof _ => Inl mismatch
          | Completion_Proof _ => Inl mismatch
          | Ordered_Completion_Proof _ => Inl mismatch
          | Equational_Proof _ => Inl mismatch
          | Equational_Disproof _ => Inl mismatch
          | Quasi_Reductive_Proof _ => Inl mismatch
          | Conditional_CR_Proof _ => Inl mismatch
          | Conditional_Non_CR_Proof _ => Inl mismatch
          | Tree_Automata_Closed_Proof _ => Inl mismatch
          | AC_Termination_Proof prf =>
            (if equal_claim claim Terminating orelse equal_claim claim Anything
              then check_ac_termination_proof (B3_, B4_, B5_)
                     (equal_list equal_nat, key_list (equal_nat, key_nat),
                       show_list show_nat)
                     l k (shows_string [#"1"]) (mke k r aa c) prf
              else Inl mismatch)
          | LTS_Termination_Proof _ => Inl mismatch
          | LTS_Safety_Proof _ => Inl mismatch | Unknown_Proof _ => Inl mismatch
          | Unknown_Disproof _ => Inl mismatch)
      | LTS_input r =>
        (case proof of TRS_Termination_Proof _ => Inl mismatch
          | Complexity_Proof _ => Inl mismatch
          | DP_Termination_Proof _ => Inl mismatch
          | DP_Nontermination_Proof _ => Inl mismatch
          | TRS_Nontermination_Proof _ => Inl mismatch
          | FP_Termination_Proof _ => Inl mismatch
          | Relative_TRS_Nontermination_Proof _ => Inl mismatch
          | TRS_Confluence_Proof _ => Inl mismatch
          | TRS_Non_Confluence_Proof _ => Inl mismatch
          | Completion_Proof _ => Inl mismatch
          | Ordered_Completion_Proof _ => Inl mismatch
          | Equational_Proof _ => Inl mismatch
          | Equational_Disproof _ => Inl mismatch
          | Quasi_Reductive_Proof _ => Inl mismatch
          | Conditional_CR_Proof _ => Inl mismatch
          | Conditional_Non_CR_Proof _ => Inl mismatch
          | Tree_Automata_Closed_Proof _ => Inl mismatch
          | AC_Termination_Proof _ => Inl mismatch
          | LTS_Termination_Proof prf =>
            (if equal_claim claim Terminating orelse equal_claim claim Anything
              then check_termination
                     (ccompare_list ccompare_char, compare_list compare_char,
                       equal_list equal_char, mapping_impl_list,
                       linorder_list (equal_char, linorder_char),
                       show_list show_char)
                     (cenum_list, ceq_list ceq_char,
                       ccompare_list ccompare_char, equal_list equal_char,
                       key_list (equal_char, key_char), mapping_impl_list,
                       set_impl_list, show_list show_char)
                     (ceq_list ceq_char, ccompare_list ccompare_char,
                       equal_list equal_char, mapping_impl_list, set_impl_list,
                       show_list show_char)
                     r prf
              else Inl mismatch)
          | LTS_Safety_Proof _ => Inl mismatch | Unknown_Proof _ => Inl mismatch
          | Unknown_Disproof _ => Inl mismatch)
      | LTS_safety_input (r, e) =>
        (case proof of TRS_Termination_Proof _ => Inl mismatch
          | Complexity_Proof _ => Inl mismatch
          | DP_Termination_Proof _ => Inl mismatch
          | DP_Nontermination_Proof _ => Inl mismatch
          | TRS_Nontermination_Proof _ => Inl mismatch
          | FP_Termination_Proof _ => Inl mismatch
          | Relative_TRS_Nontermination_Proof _ => Inl mismatch
          | TRS_Confluence_Proof _ => Inl mismatch
          | TRS_Non_Confluence_Proof _ => Inl mismatch
          | Completion_Proof _ => Inl mismatch
          | Ordered_Completion_Proof _ => Inl mismatch
          | Equational_Proof _ => Inl mismatch
          | Equational_Disproof _ => Inl mismatch
          | Quasi_Reductive_Proof _ => Inl mismatch
          | Conditional_CR_Proof _ => Inl mismatch
          | Conditional_Non_CR_Proof _ => Inl mismatch
          | Tree_Automata_Closed_Proof _ => Inl mismatch
          | AC_Termination_Proof _ => Inl mismatch
          | LTS_Termination_Proof _ => Inl mismatch
          | LTS_Safety_Proof prf =>
            (if equal_claim claim Yes orelse equal_claim claim Anything
              then check_safety (ccompare_sig, equal_sig, show_sig)
                     (ceq_ty, ccompare_ty, equal_ty, show_ty)
                     (default_hints, show_hints)
                     (ccompare_list ccompare_char, equal_list equal_char,
                       show_list show_char)
                     (cenum_list, ceq_list ceq_char,
                       ccompare_list ccompare_char, equal_list equal_char,
                       mapping_impl_list, set_impl_list, show_list show_char)
                     (ceq_list ceq_char, ccompare_list ccompare_char,
                       equal_list equal_char, mapping_impl_list, set_impl_list,
                       show_list show_char)
                     (ccompare_list ccompare_char, equal_list equal_char,
                       mapping_impl_list, show_list show_char)
                     type_of_fun
                     (inserta (ceq_ty, ccompare_ty) BoolT
                       (set_empty (ceq_ty, ccompare_ty)
                         (of_phantom set_impl_ty)))
                     (check_clause
                       (ccompare_list ccompare_char, equal_list equal_char,
                         mapping_impl_list,
                         linorder_list (equal_char, linorder_char),
                         show_list show_char))
                     (check_clause
                       (ccompare_trans_var (ccompare_list ccompare_char),
                         equal_trans_var (equal_list equal_char),
                         mapping_impl_trans_var,
                         linorder_trans_var (compare_list compare_char),
                         show_trans_var (show_list show_char)))
                     (show_IA_exp
                       (equal_list equal_char,
                         linorder_list (equal_char, linorder_char),
                         show_list show_char))
                     (show_IA_exp
                       (equal_trans_var (equal_list equal_char),
                         linorder_trans_var (compare_list compare_char),
                         show_trans_var (show_list show_char)))
                     (negate (show_list show_char))
                     (negate (show_trans_var (show_list show_char))) r e prf
              else Inl mismatch)
          | Unknown_Proof _ => Inl mismatch
          | Unknown_Disproof _ => Inl mismatch)
      | Unknown_input ur =>
        (case proof of TRS_Termination_Proof _ => Inl mismatch
          | Complexity_Proof _ => Inl mismatch
          | DP_Termination_Proof _ => Inl mismatch
          | DP_Nontermination_Proof _ => Inl mismatch
          | TRS_Nontermination_Proof _ => Inl mismatch
          | FP_Termination_Proof _ => Inl mismatch
          | Relative_TRS_Nontermination_Proof _ => Inl mismatch
          | TRS_Confluence_Proof _ => Inl mismatch
          | TRS_Non_Confluence_Proof _ => Inl mismatch
          | Completion_Proof _ => Inl mismatch
          | Ordered_Completion_Proof _ => Inl mismatch
          | Equational_Proof _ => Inl mismatch
          | Equational_Disproof _ => Inl mismatch
          | Quasi_Reductive_Proof _ => Inl mismatch
          | Conditional_CR_Proof _ => Inl mismatch
          | Conditional_Non_CR_Proof _ => Inl mismatch
          | Tree_Automata_Closed_Proof _ => Inl mismatch
          | AC_Termination_Proof _ => Inl mismatch
          | LTS_Termination_Proof _ => Inl mismatch
          | LTS_Safety_Proof _ => Inl mismatch
          | Unknown_Proof b =>
            check_unknown_proof (B1_, B3_, B4_, B5_) i j a (shows_string [#"1"])
              ur b
          | Unknown_Disproof b =>
            check_unknown_disproof (B2_, B3_, B4_, B5_)
              (equal_list equal_nat, key_list (equal_nat, key_nat),
                show_list show_nat)
              i j a (shows_string [#"1"]) ur b))
  end;

fun intersect_values A_ B_ key vs m =
  foldr (aux A_ B_ key m) vs (empty (linorder_compare_order B_));

fun intersect_rules (A1_, A2_) B_ rs =
  intersect_values
    (equal_prod equal_bool (equal_prod (equal_term A2_ B_) (equal_term A2_ B_)))
    (compare_order_prod A1_ compare_order_nat) key
    (map (fn a => (true, a)) rs @ map (fn a => (false, a)) rs);

fun sharp_trans_id trans_id_parser =
  xml_or
    (xml_change
      (trans_id_parser
        [#"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n", #"D", #"u",
          #"p", #"l", #"i", #"c", #"a", #"t", #"e"])
      (xml_return o Sharpa))
    (xml_change
      (trans_id_parser
        [#"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n", #"I",
          #"d"])
      (xml_return o Flat));

fun unraveling_info (A1_, A2_) (B1_, B2_) xml2name =
  xml_do
    [#"u", #"n", #"r", #"a", #"v", #"e", #"l", #"i", #"n", #"g", #"I", #"n",
      #"f", #"o", #"r", #"m", #"a", #"t", #"i", #"o", #"n"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"u", #"n", #"r", #"a", #"v", #"e", #"l", #"i", #"n", #"g", #"E", #"n",
          #"t", #"r", #"y"]
        (xml_take
          (crule (show_lab A2_ B2_) xml2name
            [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a", #"l",
              #"R", #"u", #"l", #"e"])
          (fn a =>
            xml_take_many_sub [] zero_nata Infinity_enat
              (rule (show_lab A2_ B2_) xml2name) (fn b => xml_return (a, b)))))
      (fn a => xml_return (id a)));

fun impl_ofc B_ A_ (TP x) = x;

fun q_impl (uu, (q, uv)) = q;

fun q A_ B_ tp = q_impl (impl_ofc A_ B_ tp);

fun r_impl A_ (uu, (uv, (uw, (vR, (ux, (m, uy)))))) =
  vR @ rules_with ((linorder_compare_order o compare_order_key) A_) id m;

fun r A_ B_ tp = r_impl A_ (impl_ofc A_ B_ tp);

fun invariant_proof_parser F_ location_parser trans_parser atom_parser
  hint_parser i =
  xml_change
    (art_parser F_ xml_text location_parser trans_parser atom_parser
      hint_parser)
    (fn prf => xml_return (Impact (i, prf)));

fun sharp_location_parser location_id_parser =
  xml_or
    (xml_change
      (location_id_parser
        [#"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n", #"D", #"u", #"p", #"l",
          #"i", #"c", #"a", #"t", #"e"])
      (xml_return o Sharpa))
    (xml_change
      (location_id_parser
        [#"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n", #"I", #"d"])
      (xml_return o Flat));

fun invariant_parser location_parser atom_parser =
  xml_do [#"i", #"n", #"v", #"a", #"r", #"i", #"a", #"n", #"t"]
    (xml_take
      (xml_do [#"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n"]
        (xml_take location_parser xml_return))
      (fn l =>
        xml_take
          (xml_do [#"f", #"o", #"r", #"m", #"u", #"l", #"a"]
            (xml_take (formula_parser atom_parser) xml_return))
          (fn phi => xml_return (l, phi))));

fun invariants_parser location_parser atom_parser =
  xml_do [#"i", #"n", #"v", #"a", #"r", #"i", #"a", #"n", #"t", #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (invariant_parser location_parser atom_parser) xml_return);

fun cooperation_proof_parser (A1_, A2_) E_ (F1_, F2_, F3_) location_id_parser
  exp_parser atom_parser tatom_parser variable_parser hint_parser type_parser
  dom_type trans_parser xs =
  xml_or
    (xml_do [#"t", #"r", #"i", #"v", #"i", #"a", #"l"] (xml_return Triviala))
    (xml_or
      (xml_do
        [#"n", #"e", #"w", #"I", #"n", #"v", #"a", #"r", #"i", #"a", #"n", #"t",
          #"s"]
        (xml_take
          (invariants_parser (sharp_location_parser location_id_parser)
            atom_parser)
          (fn i =>
            xml_take
              (invariant_proof_parser E_
                (sharp_location_parser location_id_parser) trans_parser
                atom_parser hint_parser i)
              (fn p =>
                xml_take
                  (cooperation_proof_parser (A1_, A2_) E_ (F1_, F2_, F3_)
                    location_id_parser exp_parser atom_parser tatom_parser
                    variable_parser hint_parser type_parser dom_type
                    trans_parser)
                  (fn cp => xml_return (Invariants_Update (p, cp)))))))
      (xml_or
        (xml_do
          [#"t", #"r", #"a", #"n", #"s", #"i", #"t", #"i", #"o", #"n", #"R",
            #"e", #"m", #"o", #"v", #"a", #"l"]
          (xml_take
            (xml_do
              [#"r", #"a", #"n", #"k", #"i", #"n", #"g", #"F", #"u", #"n", #"c",
                #"t", #"i", #"o", #"n", #"s"]
              (xml_take_many_sub [] zero_nata Infinity_enat
                (xml_do
                  [#"r", #"a", #"n", #"k", #"i", #"n", #"g", #"F", #"u", #"n",
                    #"c", #"t", #"i", #"o", #"n"]
                  (xml_take
                    (xml_do [#"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n"]
                      (xml_take (sharp_location_parser location_id_parser)
                        xml_return))
                    (fn l =>
                      xml_take
                        (xml_do
                          [#"e", #"x", #"p", #"r", #"e", #"s", #"s", #"i", #"o",
                            #"n"]
                          (xml_take_many_sub [] one_nata Infinity_enat
                            exp_parser xml_return))
                        (fn es => xml_return (l, es)))))
                xml_return))
            (fn rs =>
              xml_take
                (xml_do [#"b", #"o", #"u", #"n", #"d"]
                  (xml_take_many_sub [] zero_nata Infinity_enat exp_parser
                    xml_return))
                (fn bounds =>
                  xml_take
                    (xml_do [#"r", #"e", #"m", #"o", #"v", #"e"]
                      (xml_take_many_sub [] zero_nata Infinity_enat trans_parser
                        xml_return))
                    (fn removed =>
                      xml_take_default (fn _ => default_hinta E_)
                        (xml_do [#"h", #"i", #"n", #"t", #"s"]
                          (xml_take_many_sub [] zero_nata Infinity_enat
                            (xml_do [#"h", #"i", #"n", #"t"]
                              (xml_take trans_parser
                                (fn tr =>
                                  xml_take_default (default_hinta E_)
                                    (hints_parser E_ hint_parser)
                                    (fn hint => xml_return (tr, hint)))))
                            (fn pairs =>
                              xml_return
                                (map_of_default (F1_, F2_, F3_)
                                  (default_hinta E_) pairs))))
                        (fn hinter =>
                          xml_take
                            (cooperation_proof_parser (A1_, A2_) E_
                              (F1_, F2_, F3_) location_id_parser exp_parser
                              atom_parser tatom_parser variable_parser
                              hint_parser type_parser dom_type trans_parser)
                            (fn inner =>
                              let
                                val rf =
                                  map_of_default
                                    (ccompare_sharp A1_, equal_sharp A2_,
                                      mapping_impl_sharp)
                                    [] rs;
                              in
                                xml_return
                                  (Transition_Removal
                                    (Transition_removal_info
                                       (rf, removed, dom_type, bounds, hinter),
                                      inner))
                              end)))))))
        (xml_or
          (xml_do
            [#"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n", #"A", #"d", #"d",
              #"i", #"t", #"i", #"o", #"n"]
            (xml_take
              (transition_parser (sharp_location_parser location_id_parser)
                trans_parser tatom_parser)
              (fn tr =>
                xml_take
                  (cooperation_proof_parser (A1_, A2_) E_ (F1_, F2_, F3_)
                    location_id_parser exp_parser atom_parser tatom_parser
                    variable_parser hint_parser type_parser dom_type
                    trans_parser)
                  (fn prof =>
                    let
                      val (tr_id, tau) = tr;
                    in
                      xml_return
                        (Location_Addition
                          (Location_Addition_Info
                             (source tau, target tau, tr_id, tau),
                            prof))
                    end))))
          (xml_or
            (xml_do
              [#"f", #"r", #"e", #"s", #"h", #"V", #"a", #"r", #"i", #"a", #"b",
                #"l", #"e", #"A", #"d", #"d", #"i", #"t", #"i", #"o", #"n"]
              (xml_take variable_parser
                (fn x1 =>
                  xml_take type_parser
                    (fn x2 =>
                      xml_take
                        (xml_do
                          [#"a", #"d", #"d", #"i", #"t", #"i", #"o", #"n", #"a",
                            #"l", #"F", #"o", #"r", #"m", #"u", #"l", #"a",
                            #"s"]
                          (xml_take_many_sub [] zero_nata Infinity_enat
                            (xml_do
                              [#"a", #"d", #"d", #"i", #"t", #"i", #"o", #"n",
                                #"a", #"l", #"F", #"o", #"r", #"m", #"u", #"l",
                                #"a"]
                              (xml_take trans_parser
                                (fn tr =>
                                  xml_take (formula_parser tatom_parser)
                                    (fn phi => xml_return (tr, phi)))))
                            xml_return))
                        (fn x3 =>
                          xml_take
                            (cooperation_proof_parser (A1_, A2_) E_
                              (F1_, F2_, F3_) location_id_parser exp_parser
                              atom_parser tatom_parser variable_parser
                              hint_parser type_parser dom_type trans_parser)
                            (fn prof =>
                              xml_return
                                (Fresh_Variable_Addition
                                  (Fresh_Variable_Addition_Info (x1, x2, x3),
                                    prof))))))))
            (xml_or
              (xml_do
                [#"c", #"u", #"t", #"T", #"r", #"a", #"n", #"s", #"i", #"t",
                  #"i", #"o", #"n", #"S", #"p", #"l", #"i", #"t"]
                (xml_take_many_sub [] zero_nata Infinity_enat
                  (xml_do
                    [#"c", #"u", #"t", #"T", #"r", #"a", #"n", #"s", #"i", #"t",
                      #"i", #"o", #"n", #"s", #"W", #"i", #"t", #"h", #"P",
                      #"r", #"o", #"o", #"f"]
                    (xml_take
                      (xml_do
                        [#"c", #"u", #"t", #"T", #"r", #"a", #"n", #"s", #"i",
                          #"t", #"i", #"o", #"n", #"s"]
                        (xml_take_many_sub [] zero_nata Infinity_enat
                          trans_parser xml_return))
                      (fn cuts =>
                        xml_take
                          (cooperation_proof_parser (A1_, A2_) E_
                            (F1_, F2_, F3_) location_id_parser exp_parser
                            atom_parser tatom_parser variable_parser hint_parser
                            type_parser dom_type trans_parser)
                          (fn prof => xml_return (cuts, prof)))))
                  (fn ps => xml_return (Cut_Transition_Split ps))))
              (xml_do
                [#"s", #"c", #"c", #"D", #"e", #"c", #"o", #"m", #"p", #"o",
                  #"s", #"i", #"t", #"i", #"o", #"n"]
                (xml_take_many_sub [] zero_nata Infinity_enat
                  (xml_do
                    [#"s", #"c", #"c", #"W", #"i", #"t", #"h", #"P", #"r", #"o",
                      #"o", #"f"]
                    (xml_take
                      (xml_do [#"s", #"c", #"c"]
                        (xml_take_many_sub [] one_nata Infinity_enat
                          (sharp_location_parser location_id_parser)
                          xml_return))
                      (fn scc =>
                        xml_take
                          (cooperation_proof_parser (A1_, A2_) E_
                            (F1_, F2_, F3_) location_id_parser exp_parser
                            atom_parser tatom_parser variable_parser hint_parser
                            type_parser dom_type trans_parser)
                          (fn prof => xml_return (scc, prof)))))
                  (fn sccs => xml_return (Scc_Decomp sccs)))))))))
    xs;

fun cut_points_to_transitions ts [] = ts
  | cut_points_to_transitions ts ((l, (tr, phi)) :: cps) =
    cut_points_to_transitions
      ((Flat tr, Transition (Flat l, Sharpa l, phi)) :: ts) cps;

fun cutPoints_parser location_id_parser trans_id_parser tatom_parser =
  xml_do [#"c", #"u", #"t", #"P", #"o", #"i", #"n", #"t", #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do [#"c", #"u", #"t", #"P", #"o", #"i", #"n", #"t"]
        (xml_take
          (location_id_parser
            [#"l", #"o", #"c", #"a", #"t", #"i", #"o", #"n", #"I", #"d"])
          (fn l =>
            xml_take (trans_id_parser [#"s", #"k", #"i", #"p", #"I", #"d"])
              (fn tr =>
                xml_take
                  (xml_do
                    [#"s", #"k", #"i", #"p", #"F", #"o", #"r", #"m", #"u", #"l",
                      #"a"]
                    (xml_take (formula_parser tatom_parser) xml_return))
                  (fn phi => xml_return (l, (tr, phi)))))))
      (fn tuples => xml_return (cut_points_to_transitions [] tuples)));

fun termination_proof_parser (A1_, A2_) (B1_, B2_) F_ location_id_parser
  trans_id_parser exp_parser atom_parser tatom_parser variable_parser
  hint_parser type_parser dom_type xml =
  xml_or
    (xml_do [#"t", #"r", #"i", #"v", #"i", #"a", #"l"] (xml_return Trivialb))
    (xml_or
      (xml_do
        [#"n", #"e", #"w", #"I", #"n", #"v", #"a", #"r", #"i", #"a", #"n", #"t",
          #"s"]
        (xml_take
          (invariants_parser (location_parser location_id_parser) atom_parser)
          (fn i =>
            xml_take
              (invariant_proof_parser F_ (location_parser location_id_parser)
                (trans_id trans_id_parser) atom_parser hint_parser i)
              (fn p =>
                xml_take
                  (termination_proof_parser (A1_, A2_) (B1_, B2_) F_
                    location_id_parser trans_id_parser exp_parser atom_parser
                    tatom_parser variable_parser hint_parser type_parser
                    dom_type)
                  (fn cp => xml_return (Invariants_Update_LTS (p, cp)))))))
      (xml_do
        [#"s", #"w", #"i", #"t", #"c", #"h", #"T", #"o", #"C", #"o", #"o", #"p",
          #"e", #"r", #"a", #"t", #"i", #"o", #"n", #"T", #"e", #"r", #"m",
          #"i", #"n", #"a", #"t", #"i", #"o", #"n"]
        (xml_take
          (cutPoints_parser location_id_parser trans_id_parser tatom_parser)
          (fn cp =>
            xml_take
              (cooperation_proof_parser (A1_, A2_) F_
                (ccompare_sharp B1_, equal_sharp B2_, mapping_impl_sharp)
                location_id_parser exp_parser atom_parser tatom_parser
                variable_parser hint_parser type_parser dom_type
                (sharp_trans_id trans_id_parser))
              (fn p => xml_return (Via_Cooperation [(cp, p)]))))))
    xml;

fun tatom_parser x =
  xml_change
    (bexp_parser (show_trans_var (show_list show_char)) trans_var_parser)
    (xml_return o Atom) x;

fun type_parser x =
  xml_or (xml_do [#"i", #"n", #"t"] (xml_return IntT))
    (xml_do [#"b", #"o", #"o", #"l"] (xml_return BoolT)) x;

fun hint_parser x =
  xml_do
    [#"l", #"i", #"n", #"e", #"a", #"r", #"C", #"o", #"m", #"b", #"i", #"n",
      #"a", #"t", #"i", #"o", #"n"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_int [#"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t"])
      (fn xs => xml_return (Hints xs)))
    x;

fun atom_parser x =
  xml_change (bexp_parser (show_list show_char) variable_parser)
    (xml_return o Atom) x;

fun exp_parser x = exp_parsera variable_parser x;

fun lts_termination_proof_parser x =
  termination_proof_parser (ccompare_list ccompare_char, equal_list equal_char)
    (ccompare_list ccompare_char, equal_list equal_char) default_hints xml_text
    xml_text exp_parser atom_parser tatom_parser variable_parser hint_parser
    type_parser IntT x;

fun safety_proof_parser F_ location_parser trans_parser atom_parser hint_parser
  = xml_do
      [#"s", #"a", #"f", #"e", #"t", #"y", #"V", #"i", #"a", #"I", #"n", #"v",
        #"a", #"r", #"i", #"a", #"n", #"t", #"s"]
      (xml_take (invariants_parser location_parser atom_parser)
        (fn i =>
          xml_take
            (invariant_proof_parser F_ location_parser trans_parser atom_parser
              hint_parser i)
            (fn p => xml_return (Invariant_Assertion (p, Trivial)))));

fun lts_safety_proof_parser x =
  safety_proof_parser default_hints (location_parser xml_text)
    (trans_id xml_text) atom_parser hint_parser x;

fun xml2dp_nontermination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name x =
  xml_do
    [#"d", #"p", #"N", #"o", #"n", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
      #"t", #"i", #"o", #"n", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_do
          [#"d", #"p", #"R", #"u", #"l", #"e", #"R", #"e", #"m", #"o", #"v",
            #"a", #"l"]
          (xml_take_optional
            (xml_do [#"d", #"p", #"s"]
              (xml_take (rules (show_lab A3_ B3_) xml2name)
                (fn xa => xml_return (id xa))))
            (fn p =>
              xml_take_optional
                (xml_do [#"t", #"r", #"s"]
                  (xml_take (rules (show_lab A3_ B3_) xml2name)
                    (fn xa => xml_return (id xa))))
                (fn r =>
                  xml_take
                    (xml2dp_nontermination_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                      xml2name)
                    (fn prf =>
                      xml_return
                        (DP_Rule_Removal
                          (Rule_removal_nonterm_dp_prf (p, r), prf)))))))
        (xml_or
          (xml_change (loop (show_lab A3_ B3_) xml2name)
            (fn (s, (rseq, (sigma, c))) =>
              xml_return (DP_Loop (DP_loop_prf (s, rseq, sigma, c)))))
          (xml_or
            (xml_change (nonloop (A2_, A3_) (B2_, B3_) xml2name)
              (xml_return o DP_Nonloop))
            (xml_or
              (xml_do
                [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #"L",
                  #"h", #"s", #"s", #"R", #"e", #"m", #"o", #"v", #"a", #"l",
                  #"P", #"r", #"o", #"c"]
                (xml_take (innermostLhss (show_lab A3_ B3_) xml2name)
                  (fn a =>
                    xml_take
                      (xml2dp_nontermination_proof (A1_, A2_, A3_)
                        (B1_, B2_, B3_) xml2name)
                      (fn b =>
                        xml_return
                          (DP_Q_Reduction (DP_q_reduction_nonterm_prf a, b))))))
              (xml_or
                (xml_do
                  [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t", #"L",
                    #"h", #"s", #"s", #"I", #"n", #"c", #"r", #"e", #"a", #"s",
                    #"e", #"P", #"r", #"o", #"c"]
                  (xml_take (innermostLhss (show_lab A3_ B3_) xml2name)
                    (fn a =>
                      xml_take
                        (xml2dp_nontermination_proof (A1_, A2_, A3_)
                          (B1_, B2_, B3_) xml2name)
                        (fn b =>
                          xml_return
                            (DP_Q_Increase (Q_increase_nonterm_dp_prf a, b))))))
                (xml_or
                  (xml_do
                    [#"i", #"n", #"s", #"t", #"a", #"n", #"t", #"i", #"a", #"t",
                      #"i", #"o", #"n", #"P", #"r", #"o", #"c"]
                    (xml_take
                      (xml_do [#"d", #"p", #"s"]
                        (xml_take (rules (show_lab A3_ B3_) xml2name)
                          (fn xa => xml_return (id xa))))
                      (fn a =>
                        xml_take
                          (xml2dp_nontermination_proof (A1_, A2_, A3_)
                            (B1_, B2_, B3_) xml2name)
                          (fn b =>
                            xml_return
                              (DP_Instantiation
                                (Instantiation_complete_proc_prf a, b))))))
                  (xml_or
                    (xml_do
                      [#"n", #"a", #"r", #"r", #"o", #"w", #"i", #"n", #"g",
                        #"P", #"r", #"o", #"c"]
                      (xml_take (rule (show_lab A3_ B3_) xml2name)
                        (fn a =>
                          xml_take pos
                            (fn b =>
                              xml_take
                                (xml_do
                                  [#"n", #"a", #"r", #"r", #"o", #"w", #"i",
                                    #"n", #"g", #"s"]
                                  (xml_take (rules (show_lab A3_ B3_) xml2name)
                                    (fn xa => xml_return (id xa))))
                                (fn c =>
                                  xml_take
                                    (xml2dp_nontermination_proof (A1_, A2_, A3_)
                                      (B1_, B2_, B3_) xml2name)
                                    (fn d =>
                                      xml_return
(DP_Narrowing (Narrowing_complete_proc_prf (a, b, c), d))))))))
                    (xml_or
                      (xml_do
                        [#"r", #"e", #"w", #"r", #"i", #"t", #"i", #"n", #"g",
                          #"P", #"r", #"o", #"c"]
                        (xml_take (rule (show_lab A3_ B3_) xml2name)
                          (fn (s, t) =>
                            xml_take (rstep (show_lab A3_ B3_) xml2name)
                              (fn (p, (lr, ta)) =>
                                xml_take_optional
                                  (rule (show_lab A3_ B3_) xml2name)
                                  (fn c =>
                                    xml_take_optional
                                      (xml_do
[#"u", #"s", #"a", #"b", #"l", #"e", #"R", #"u", #"l", #"e", #"s"]
(xml_take (rules (show_lab A3_ B3_) xml2name) (fn xa => xml_return (id xa))))
                                      (fn uopt =>
xml_take (xml2dp_nontermination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
  (fn prf =>
    let
      val st = (case c of NONE => (s, ta) | SOME v => v);
    in
      xml_return
        (DP_Rewriting
          (Rewriting_complete_proc_prf (uopt, (s, t), (s, ta), st, lr, p), prf))
    end)))))))
                      (xml_or
                        (xml_do
                          [#"s", #"w", #"i", #"t", #"c", #"h", #"F", #"u", #"l",
                            #"l", #"S", #"t", #"r", #"a", #"t", #"e", #"g",
                            #"y", #"P", #"r", #"o", #"c"]
                          (xml_take (wcr_proof (show_lab A3_ B3_) xml2name)
                            (fn a =>
                              xml_take
                                (xml2dp_nontermination_proof (A1_, A2_, A3_)
                                  (B1_, B2_, B3_) xml2name)
                                (fn b =>
                                  xml_return (DP_Termination_Switch (a, b))))))
                        (xml_or
                          (xml_do
                            [#"i", #"n", #"f", #"i", #"n", #"i", #"t", #"e",
                              #"n", #"e", #"s", #"s", #"A", #"s", #"s", #"u",
                              #"m", #"p", #"t", #"i", #"o", #"n"]
                            (xml_take
                              (xml2dp_inputa
                                (equal_lab A1_ B1_, show_lab A3_ B3_) xml2name
                                false)
                              (fn xa =>
                                xml_return (DP_Assume_Infinite (xa, [])))))
                          (xml_do
                            [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #"P",
                              #"r", #"o", #"o", #"f"]
                            (xml_take
                              (xml_text
                                [#"d", #"e", #"s", #"c", #"r", #"i", #"p", #"t",
                                  #"i", #"o", #"n"])
                              (fn _ =>
                                xml_take
                                  (xml2dp_inputa
                                    (equal_lab A1_ B1_, show_lab A3_ B3_)
                                    xml2name false)
                                  (fn b =>
                                    xml_take_many_sub [] zero_nata Infinity_enat
                                      (fn xa => Inr (fst xa))
                                      (fn _ =>
xml_return (DP_Assume_Infinite (b, [])))))))))))))))))
      (fn xa => xml_return (id xa)))
    x;

fun xml2inn_nt_trs_assm (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name =
  xml_change (xml2_trs_input (show_lab A3_ B3_) xml2name)
    (fn Inn_TRS_input (inn, r, s, start) =>
      (if not (null s)
        then xml_error (show_list (show_list show_char))
               [#"(", #"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t",
                 #")", #" ", #"T", #"R", #"S", #" ", #"w", #"i", #"t", #"h",
                 #"o", #"u", #"t", #" ", #"r", #"e", #"l", #"a", #"t", #"i",
                 #"v", #"e", #" ", #"r", #"u", #"l", #"e", #"s", #" ", #"e",
                 #"x", #"p", #"e", #"c", #"t", #"e", #"d"]
        else (if not (equal_start_term start Full)
               then xml_error (show_list (show_list show_char))
                      [#"s", #"t", #"a", #"r", #"t", #" ", #"t", #"e", #"r",
                        #"m", #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ",
                        #"a", #"l", #"l", #"o", #"w", #"e", #"d", #" ", #"h",
                        #"e", #"r", #"e"]
               else xml_return
                      (default_nfs_nt_trs,
                        (strategy_to_Q (equal_lab A1_ B1_)
                           (equal_list equal_char) inn r,
                          r)))));

fun xml2trs_nontermination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name x =
  xml_do
    [#"t", #"r", #"s", #"N", #"o", #"n", #"t", #"e", #"r", #"m", #"i", #"n",
      #"a", #"t", #"i", #"o", #"n", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_leaf
          [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #"C", #"o", #"n",
            #"d", #"i", #"t", #"i", #"o", #"n", #"V", #"i", #"o", #"l", #"a",
            #"t", #"e", #"d"]
          TRS_Not_Well_Formed)
        (xml_or
          (xml_change (loop (show_lab A3_ B3_) xml2name)
            (fn (s, (rseq, (sigma, c))) =>
              xml_return
                (TRS_Loop
                  (TRS_loop_prf
                    (s, map (fn (xa, (y, (_, z))) => (xa, (y, z))) rseq, sigma,
                      c)))))
          (xml_or
            (xml_change (nonloop (A2_, A3_) (B2_, B3_) xml2name)
              (xml_return o TRS_Nonloop))
            (xml_or
              (xml_change (nonloop_srs (A2_, A3_) (B2_, B3_) xml2name)
                (xml_return o TRS_Nonloop_SRS))
              (xml_or
                (xml_do
                  [#"r", #"u", #"l", #"e", #"R", #"e", #"m", #"o", #"v", #"a",
                    #"l"]
                  (xml_take
                    (xml_do [#"t", #"r", #"s"]
                      (xml_take (rules (show_lab A3_ B3_) xml2name)
                        (fn xa => xml_return (id xa))))
                    (fn a =>
                      xml_take
                        (xml2trs_nontermination_proof (A1_, A2_, A3_)
                          (B1_, B2_, B3_) xml2name)
                        (fn b =>
                          xml_return
                            (TRS_Rule_Removal
                              (Rule_removal_nonterm_trs_prf a, b))))))
                (xml_or
                  (xml_do [#"d", #"p", #"T", #"r", #"a", #"n", #"s"]
                    (xml_take
                      (xml_do [#"d", #"p", #"s"]
                        (xml_take (rules (show_lab A3_ B3_) xml2name)
                          (fn xa => xml_return (id xa))))
                      (fn a =>
                        xml_take
                          (xml_bool
                            [#"m", #"a", #"r", #"k", #"e", #"d", #"S", #"y",
                              #"m", #"b", #"o", #"l", #"s"])
                          (fn _ =>
                            xml_take
                              (xml2dp_nontermination_proof (A1_, A2_, A3_)
                                (B1_, B2_, B3_) xml2name)
                              (fn c =>
                                xml_return
                                  (TRS_DP_Trans
                                    (DP_trans_nontermination_tt_prf a, c)))))))
                  (xml_or
                    (xml_do
                      [#"s", #"t", #"r", #"i", #"n", #"g", #"R", #"e", #"v",
                        #"e", #"r", #"s", #"a", #"l"]
                      (xml_take
                        (xml_do [#"t", #"r", #"s"]
                          (xml_take (rules (show_lab A3_ B3_) xml2name)
                            (fn xa => xml_return (id xa))))
                        (fn _ =>
                          xml_take
                            (xml2trs_nontermination_proof (A1_, A2_, A3_)
                              (B1_, B2_, B3_) xml2name)
                            (fn b => xml_return (TRS_String_Reversal b)))))
                    (xml_or
                      (xml_do
                        [#"c", #"o", #"n", #"s", #"t", #"a", #"n", #"t", #"T",
                          #"o", #"U", #"n", #"a", #"r", #"y"]
                        (xml_take plain_var
                          (fn a =>
                            xml_take (renaming (show_lab A3_ B3_) xml2name)
                              (fn b =>
                                xml_take
                                  (xml_do [#"t", #"r", #"s"]
                                    (xml_take
                                      (rules (show_lab A3_ B3_) xml2name)
                                      (fn xa => xml_return (id xa))))
                                  (fn c =>
                                    xml_take
                                      (xml2trs_nontermination_proof
(A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
                                      (fn d =>
xml_return
  (TRS_Constant_String (Const_string_complete_proof (a, b, c), d))))))))
                      (xml_or
                        (xml_do
                          [#"i", #"n", #"n", #"e", #"r", #"m", #"o", #"s", #"t",
                            #"L", #"h", #"s", #"s", #"I", #"n", #"c", #"r",
                            #"e", #"a", #"s", #"e"]
                          (xml_take (innermostLhss (show_lab A3_ B3_) xml2name)
                            (fn a =>
                              xml_take
                                (xml2trs_nontermination_proof (A1_, A2_, A3_)
                                  (B1_, B2_, B3_) xml2name)
                                (fn b =>
                                  xml_return
                                    (TRS_Q_Increase
                                      (Q_increase_nonterm_trs_prf a, b))))))
                        (xml_or
                          (xml_do
                            [#"s", #"w", #"i", #"t", #"c", #"h", #"F", #"u",
                              #"l", #"l", #"S", #"t", #"r", #"a", #"t", #"e",
                              #"g", #"y"]
                            (xml_take (wcr_proof (show_lab A3_ B3_) xml2name)
                              (fn a =>
                                xml_take
                                  (xml2trs_nontermination_proof (A1_, A2_, A3_)
                                    (B1_, B2_, B3_) xml2name)
                                  (fn b =>
                                    xml_return
                                      (TRS_Termination_Switch (a, b))))))
                          (xml_or
                            (xml_do [#"u", #"n", #"c", #"u", #"r", #"r", #"y"]
                              (xml_take
                                (uncurry_info (show_lab A3_ B3_) xml2name)
                                (fn a =>
                                  xml_take
                                    (xml_do [#"t", #"r", #"s"]
                                      (xml_take
(rules (show_lab A3_ B3_) xml2name) (fn xa => xml_return (id xa))))
                                    (fn b =>
                                      xml_take
(xml2trs_nontermination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
(fn c => xml_return (TRS_Uncurry (Uncurry_nt_proof (a, b), c)))))))
                            (xml_or
                              (xml_change
                                (not_wn_ta (A2_, A3_) (B2_, B3_) xml2name)
                                (xml_return o TRS_Not_WN_Tree_Automaton))
                              (xml_or
                                (xml_do
                                  [#"n", #"o", #"n", #"t", #"e", #"r", #"m",
                                    #"i", #"n", #"a", #"t", #"i", #"o", #"n",
                                    #"A", #"s", #"s", #"u", #"m", #"p", #"t",
                                    #"i", #"o", #"n"]
                                  (xml_take
                                    (xml2inn_nt_trs_assm (A1_, A2_, A3_)
                                      (B1_, B2_, B3_) xml2name)
                                    (fn xa =>
                                      xml_return (TRS_Assume_Not_SN (xa, [])))))
                                (xml_do
                                  [#"u", #"n", #"k", #"n", #"o", #"w", #"n",
                                    #"P", #"r", #"o", #"o", #"f"]
                                  (xml_take
                                    (xml_text
                                      [#"d", #"e", #"s", #"c", #"r", #"i", #"p",
#"t", #"i", #"o", #"n"])
                                    (fn _ =>
                                      xml_take
(xml2inn_nt_trs_assm (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
(fn b =>
  xml_take_many_sub [] zero_nata Infinity_enat (fn xa => Inr (fst xa))
    (fn _ => xml_return (TRS_Assume_Not_SN (b, []))))))))))))))))))))
      (fn xa => xml_return (id xa)))
    x;

fun xml2inn_rel_nt_trs_assm (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name =
  xml_change (xml2_trs_input (show_lab A3_ B3_) xml2name)
    (fn Inn_TRS_input (inn, r, s, start) =>
      (if not (equal_start_term start Full)
        then xml_error (show_list (show_list show_char))
               [#"s", #"t", #"a", #"r", #"t", #" ", #"t", #"e", #"r", #"m",
                 #" ", #"i", #"s", #" ", #"n", #"o", #"t", #" ", #"a", #"l",
                 #"l", #"o", #"w", #"e", #"d", #" ", #"h", #"e", #"r", #"e"]
        else xml_return
               (default_nfs_nt_trs,
                 (strategy_to_Q (equal_lab A1_ B1_) (equal_list equal_char) inn
                    r,
                   (r, s)))));

fun xml2reltrs_nontermination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name x =
  xml_do
    [#"r", #"e", #"l", #"a", #"t", #"i", #"v", #"e", #"N", #"o", #"n", #"t",
      #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o", #"n", #"P", #"r",
      #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_leaf
          [#"v", #"a", #"r", #"i", #"a", #"b", #"l", #"e", #"C", #"o", #"n",
            #"d", #"i", #"t", #"i", #"o", #"n", #"V", #"i", #"o", #"l", #"a",
            #"t", #"e", #"d"]
          Rel_Not_Well_Formed)
        (xml_or
          (xml_change (loop (show_lab A3_ B3_) xml2name)
            (fn (s, (rseq, (sigma, c))) =>
              xml_return (Rel_Loop (Rel_trs_loop_prf (s, rseq, sigma, c)))))
          (xml_or
            (xml_change
              (xml2trs_nontermination_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                xml2name)
              (xml_return o Rel_R_Not_SN))
            (xml_or
              (xml_do
                [#"r", #"u", #"l", #"e", #"R", #"e", #"m", #"o", #"v", #"a",
                  #"l"]
                (xml_take
                  (xml_do [#"t", #"r", #"s"]
                    (xml_take (rules (show_lab A3_ B3_) xml2name)
                      (fn xa => xml_return (SOME xa))))
                  (fn a =>
                    xml_take
                      (xml_do [#"t", #"r", #"s"]
                        (xml_take (rules (show_lab A3_ B3_) xml2name)
                          (fn xa => xml_return (SOME xa))))
                      (fn b =>
                        xml_take
                          (xml2reltrs_nontermination_proof (A1_, A2_, A3_)
                            (B1_, B2_, B3_) xml2name)
                          (fn c =>
                            xml_return
                              (Rel_Rule_Removal
                                (Rule_removal_nonterm_reltrs_prf (a, b),
                                  c)))))))
              (xml_or
                (xml_do
                  [#"s", #"t", #"r", #"i", #"n", #"g", #"R", #"e", #"v", #"e",
                    #"r", #"s", #"a", #"l"]
                  (xml_take
                    (xml_do [#"t", #"r", #"s"]
                      (xml_take (rules (show_lab A3_ B3_) xml2name)
                        (fn xa => xml_return (SOME xa))))
                    (fn _ =>
                      xml_take
                        (xml_do [#"t", #"r", #"s"]
                          (xml_take (rules (show_lab A3_ B3_) xml2name)
                            (fn xa => xml_return (SOME xa))))
                        (fn _ =>
                          xml_take
                            (xml2reltrs_nontermination_proof (A1_, A2_, A3_)
                              (B1_, B2_, B3_) xml2name)
                            (fn c => xml_return (Rel_TRS_String_Reversal c))))))
                (xml_or
                  (xml_do
                    [#"n", #"o", #"n", #"t", #"e", #"r", #"m", #"i", #"n", #"a",
                      #"t", #"i", #"o", #"n", #"A", #"s", #"s", #"u", #"m",
                      #"p", #"t", #"i", #"o", #"n"]
                    (xml_take
                      (xml2inn_rel_nt_trs_assm (A1_, A2_, A3_) (B1_, B2_, B3_)
                        xml2name)
                      (fn xa => xml_return (Rel_TRS_Assume_Not_SN (xa, [])))))
                  (xml_do
                    [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #"P", #"r", #"o",
                      #"o", #"f"]
                    (xml_take
                      (xml_text
                        [#"d", #"e", #"s", #"c", #"r", #"i", #"p", #"t", #"i",
                          #"o", #"n"])
                      (fn _ =>
                        xml_take
                          (xml2inn_rel_nt_trs_assm (A1_, A2_, A3_)
                            (B1_, B2_, B3_) xml2name)
                          (fn b =>
                            xml_take_many_sub [] zero_nata Infinity_enat
                              (fn xa => Inr (fst xa))
                              (fn _ =>
                                xml_return
                                  (Rel_TRS_Assume_Not_SN (b, [])))))))))))))
      (fn xa => xml_return (id xa)))
    x;

fun xml2ordered_completion_step (A1_, A2_) (B1_, B2_) xml2name =
  xml_or
    (xml_do [#"d", #"e", #"d", #"u", #"c", #"e"]
      (xml_take (term (show_lab A2_ B2_) xml2name)
        (fn a =>
          xml_take (term (show_lab A2_ B2_) xml2name)
            (fn b =>
              xml_take (term (show_lab A2_ B2_) xml2name)
                (fn c => xml_return (OC_Deduce (a, b, c)))))))
    (xml_or
      (xml_do [#"o", #"r", #"i", #"e", #"n", #"t", #"l"]
        (xml_take (term (show_lab A2_ B2_) xml2name)
          (fn a =>
            xml_take (term (show_lab A2_ B2_) xml2name)
              (fn b => xml_return (OC_Orientl (a, b))))))
      (xml_or
        (xml_do [#"o", #"r", #"i", #"e", #"n", #"t", #"r"]
          (xml_take (term (show_lab A2_ B2_) xml2name)
            (fn a =>
              xml_take (term (show_lab A2_ B2_) xml2name)
                (fn b => xml_return (OC_Orientr (a, b))))))
        (xml_or
          (xml_do [#"d", #"e", #"l", #"e", #"t", #"e"]
            (xml_take (term (show_lab A2_ B2_) xml2name)
              (fn x => xml_return (OC_Delete x))))
          (xml_or
            (xml_do [#"c", #"o", #"m", #"p", #"o", #"s", #"e"]
              (xml_take (term (show_lab A2_ B2_) xml2name)
                (fn a =>
                  xml_take (term (show_lab A2_ B2_) xml2name)
                    (fn b =>
                      xml_take (term (show_lab A2_ B2_) xml2name)
                        (fn c => xml_return (OC_Compose (a, b, c)))))))
            (xml_or
              (xml_do [#"s", #"i", #"m", #"p", #"l", #"i", #"f", #"y", #"l"]
                (xml_take (term (show_lab A2_ B2_) xml2name)
                  (fn a =>
                    xml_take (term (show_lab A2_ B2_) xml2name)
                      (fn b =>
                        xml_take (term (show_lab A2_ B2_) xml2name)
                          (fn c => xml_return (OC_Simplifyl (a, b, c)))))))
              (xml_or
                (xml_do [#"s", #"i", #"m", #"p", #"l", #"i", #"f", #"y", #"r"]
                  (xml_take (term (show_lab A2_ B2_) xml2name)
                    (fn a =>
                      xml_take (term (show_lab A2_ B2_) xml2name)
                        (fn b =>
                          xml_take (term (show_lab A2_ B2_) xml2name)
                            (fn c => xml_return (OC_Simplifyr (a, b, c)))))))
                (xml_do [#"c", #"o", #"l", #"l", #"a", #"p", #"s", #"e"]
                  (xml_take (term (show_lab A2_ B2_) xml2name)
                    (fn a =>
                      xml_take (term (show_lab A2_ B2_) xml2name)
                        (fn b =>
                          xml_take (term (show_lab A2_ B2_) xml2name)
                            (fn c =>
                              xml_return (OC_Collapse (a, b, c)))))))))))));

fun xml2ordered_completion_proof (A1_, A2_) (B1_, B2_) xml2name =
  xml_do
    [#"o", #"r", #"d", #"e", #"r", #"e", #"d", #"C", #"o", #"m", #"p", #"l",
      #"e", #"t", #"i", #"o", #"n", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_do [#"r", #"u", #"n"]
        (xml_take_many_sub [] zero_nata Infinity_enat
          (xml_do
            [#"o", #"r", #"d", #"e", #"r", #"e", #"d", #"C", #"o", #"m", #"p",
              #"l", #"e", #"t", #"i", #"o", #"n", #"S", #"t", #"e", #"p"]
            (xml_take
              (xml2ordered_completion_step (A1_, A2_) (B1_, B2_) xml2name)
              (fn x => xml_return (id x))))
          (fn a => xml_return (id a))))
      (fn x => xml_return (OKB x)));

fun xml2quasi_reductive_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name =
  xml_do
    [#"q", #"u", #"a", #"s", #"i", #"R", #"e", #"d", #"u", #"c", #"t", #"i",
      #"v", #"e", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_do [#"u", #"n", #"r", #"a", #"v", #"e", #"l", #"i", #"n", #"g"]
        (xml_take (unraveling_info (A2_, A3_) (B2_, B3_) xml2name)
          (fn a =>
            xml_take
              (xml2trs_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                xml2name)
              (fn b => xml_return (Unravel (a, b))))))
      (fn x => xml_return (id x)));

fun map_r_states f r = TA_rule (r_root r, map f (r_lhs_states r), f (r_rhs r));

fun map_states_impl f (Tree_Automaton (qs, ts, eps)) =
  Tree_Automaton
    (map f qs, map (map_r_states f) ts, map (fn (p, q) => (f p, f q)) eps);

fun xml2nonreachable_etac_info (A1_, A2_) (B1_, B2_) xml2name =
  xml_do
    [#"n", #"o", #"n", #"r", #"e", #"a", #"c", #"h", #"a", #"b", #"l", #"e",
      #"E", #"t", #"a", #"c"]
    (xml_take (cPFsignature (show_lab A2_ B2_) xml2name)
      (fn a =>
        xml_take xml2name
          (fn b =>
            xml_take xml2name
              (fn c =>
                xml_take (tree_automaton (ta_normal_lhs xml2name))
                  (fn d =>
                    xml_take (xml2state_map (A1_, A2_) (B1_, B2_) xml2name)
                      (fn e =>
                        xml_return
                          (Nonreachable_ETAC
                            (a, b, c, map_states_impl e d))))))));

fun xml2nonreachability_proof (A1_, A2_) (B1_, B2_) xml2name x =
  xml_do
    [#"n", #"o", #"n", #"r", #"e", #"a", #"c", #"h", #"a", #"b", #"i", #"l",
      #"i", #"t", #"y", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_leaf
          [#"n", #"o", #"n", #"r", #"e", #"a", #"c", #"h", #"a", #"b", #"l",
            #"e", #"T", #"c", #"a", #"p"]
          Nonreachable_Gtcap)
        (xml_or (xml2nonreachable_etac_info (A1_, A2_) (B1_, B2_) xml2name)
          (xml_or
            (xml_do
              [#"n", #"o", #"n", #"r", #"e", #"a", #"c", #"h", #"a", #"b", #"l",
                #"e", #"S", #"u", #"b", #"s", #"t", #"A", #"p", #"p", #"r",
                #"o", #"x"]
              (xml_take (rules (show_lab A2_ B2_) xml2name)
                (fn a =>
                  xml_take
                    (xml2nonreachability_proof (A1_, A2_) (B1_, B2_) xml2name)
                    (fn b => xml_return (Nonreachable_Subst_Approx (a, b))))))
            (xml_do
              [#"n", #"o", #"n", #"r", #"e", #"a", #"c", #"h", #"a", #"b", #"l",
                #"e", #"R", #"e", #"v", #"e", #"r", #"s", #"e"]
              (xml_take
                (xml2nonreachability_proof (A1_, A2_) (B1_, B2_) xml2name)
                (fn xa => xml_return (Nonreachable_Reverse xa)))))))
      (fn xa => xml_return (id xa)))
    x;

fun xml2nonjoinability_proof (A1_, A2_) (B1_, B2_) xml2name =
  xml_do
    [#"n", #"o", #"n", #"j", #"o", #"i", #"n", #"a", #"b", #"i", #"l", #"i",
      #"t", #"y", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_leaf
          [#"n", #"o", #"n", #"j", #"o", #"i", #"n", #"a", #"b", #"l", #"e",
            #"T", #"c", #"a", #"p"]
          Nonjoinable_Tcap)
        (xml_change (xml2nonreachability_proof (A1_, A2_) (B1_, B2_) xml2name)
          (xml_return o Nonjoinable_Ground_NF)))
      (fn x => xml_return (id x)));

fun xml2infeasibility_proof (A1_, A2_) (B1_, B2_) xml2name x =
  xml_do
    [#"i", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"i", #"l", #"i", #"t",
      #"y", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_do
          [#"i", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e", #"C",
            #"o", #"m", #"p", #"o", #"u", #"n", #"d", #"C", #"o", #"n", #"d",
            #"i", #"t", #"i", #"o", #"n", #"s"]
          (xml_take xml2name
            (fn a =>
              xml_take
                (xml2nonreachability_proof (A1_, A2_) (B1_, B2_) xml2name)
                (fn b => xml_return (Infeasible_Compound_Conditions (a, b))))))
        (xml_or
          (xml_do
            [#"i", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e", #"E",
              #"q", #"u", #"a", #"t", #"i", #"o", #"n"]
            (xml_take (rule (show_lab A2_ B2_) xml2name)
              (fn a =>
                xml_take
                  (xml2nonreachability_proof (A1_, A2_) (B1_, B2_) xml2name)
                  (fn b =>
                    xml_return
                      (let
                         val (aa, ba) = a;
                       in
                         (fn c => Infeasible_Equation (aa, ba, c))
                       end
                        b)))))
          (xml_or
            (xml_do
              [#"i", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e", #"S",
                #"u", #"b", #"s", #"e", #"t"]
              (xml_take (rules (show_lab A2_ B2_) xml2name)
                (fn a =>
                  xml_take
                    (xml2infeasibility_proof (A1_, A2_) (B1_, B2_) xml2name)
                    (fn b => xml_return (Infeasible_Subset (a, b))))))
            (xml_do
              [#"i", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e", #"R",
                #"h", #"s", #"s", #"E", #"q", #"u", #"a", #"l"]
              (xml_take (term (show_lab A2_ B2_) xml2name)
                (fn a =>
                  xml_take (term (show_lab A2_ B2_) xml2name)
                    (fn b =>
                      xml_take (term (show_lab A2_ B2_) xml2name)
                        (fn c =>
                          xml_take
                            (xml2nonjoinability_proof (A1_, A2_) (B1_, B2_)
                              xml2name)
                            (fn d =>
                              xml_return
                                (Infeasible_Rhss_Equal (a, b, c, d)))))))))))
      (fn xa => xml_return (id xa)))
    x;

fun xml2infeasible_rules_info (A1_, A2_) (B1_, B2_) xml2name =
  xml_do
    [#"i", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e", #"R", #"u",
      #"l", #"e", #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"i", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e", #"R", #"u",
          #"l", #"e"]
        (xml_take (crule (show_lab A2_ B2_) xml2name [#"r", #"u", #"l", #"e"])
          (fn a =>
            xml_take (xml2infeasibility_proof (A1_, A2_) (B1_, B2_) xml2name)
              (fn b => xml_return (a, b)))))
      (fn a => xml_return (id a)));

fun xml2inline_cond_info (A1_, A2_) (B1_, B2_) xml2name =
  xml_do
    [#"i", #"n", #"l", #"i", #"n", #"e", #"d", #"R", #"u", #"l", #"e", #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do [#"i", #"n", #"l", #"i", #"n", #"e", #"d", #"R", #"u", #"l", #"e"]
        (xml_take (crule (show_lab A2_ B2_) xml2name [#"r", #"u", #"l", #"e"])
          (fn rule =>
            xml_take
              (conditions (show_lab A2_ B2_) xml2name
                [#"i", #"n", #"l", #"i", #"n", #"e", #"d", #"C", #"o", #"n",
                  #"d", #"i", #"t", #"i", #"o", #"n", #"s"])
              (fn conds => xml_return (rule, conds)))))
      xml_return);

fun xml2conditional_ncr_proof xml2name x =
  xml_do
    [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a", #"l", #"C",
      #"r", #"D", #"i", #"s", #"p", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_do
          [#"u", #"n", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
            #"a", #"l"]
          (xml_take (xml2ncr_proof xml2name)
            (fn xa => xml_return (Unconditional_CNCR xa))))
        (xml_or
          (xml_do
            [#"i", #"n", #"l", #"i", #"n", #"e", #"C", #"o", #"n", #"d", #"i",
              #"t", #"i", #"o", #"n", #"s"]
            (xml_take
              (xml_do [#"r", #"u", #"l", #"e", #"s"]
                (xml_take_many_sub [] zero_nata Infinity_enat
                  (crule (show_lab (show_list show_char) (show_list show_nat))
                    xml2name [#"r", #"u", #"l", #"e"])
                  xml_return))
              (fn a =>
                xml_take
                  (xml2inline_cond_info
                    (key_list (equal_char, key_char), show_list show_char)
                    (key_list (equal_nat, key_nat), show_list show_nat)
                    xml2name)
                  (fn b =>
                    xml_take (xml2conditional_ncr_proof xml2name)
                      (fn c =>
                        xml_return
                          (((fn aa => fn ba => Transformation_CNCR (aa, ba)) o
                             (fn ba => Inline_Conditions_CCRT (a, ba)))
                            b c))))))
          (xml_or
            (xml_do
              [#"i", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e", #"R",
                #"u", #"l", #"e", #"R", #"e", #"m", #"o", #"v", #"a", #"l"]
              (xml_take
                (xml2infeasible_rules_info
                  (key_list (equal_char, key_char), show_list show_char)
                  (key_list (equal_nat, key_nat), show_list show_nat) xml2name)
                (fn a =>
                  xml_take (xml2conditional_ncr_proof xml2name)
                    (fn b =>
                      xml_return
                        (((fn aa => fn ba => Transformation_CNCR (aa, ba)) o
                           Infeasible_Rule_Removal_CCRT)
                          a b)))))
            (xml_do
              [#"n", #"o", #"n", #"J", #"o", #"i", #"n", #"a", #"b", #"l", #"e",
                #"F", #"o", #"r", #"k"]
              (xml_take
                (xml_do [#"t", #"e", #"r", #"m", #"s"]
                  (xml_take
                    (term (show_lab (show_list show_char) (show_list show_nat))
                      xml2name)
                    (fn a =>
                      xml_take
                        (term (show_lab (show_list show_char)
                                (show_list show_nat))
                          xml2name)
                        (fn b =>
                          xml_take
                            (term (show_lab (show_list show_char)
                                    (show_list show_nat))
                              xml2name)
                            (fn c => xml_return (a, (b, c)))))))
                (fn a =>
                  xml_take
                    (csteps
                      (key_list (equal_char, key_char), show_list show_char)
                      (key_list (equal_nat, key_nat), show_list show_nat)
                      xml2name)
                    (fn b =>
                      xml_take
                        (csteps
                          (key_list (equal_char, key_char), show_list show_char)
                          (key_list (equal_nat, key_nat), show_list show_nat)
                          xml2name)
                        (fn c =>
                          xml_take (xml2non_join_info xml2name)
                            (fn d =>
                              xml_return
                                (let
                                   val (s, aa) = a;
                                   val (ab, ba) = aa;
                                 in
                                   (fn ca => fn da => fn e =>
                                     Non_Join_CNCR (s, ab, ba, ca, da, e))
                                 end
                                   b
                                   c
                                  d))))))))))
      (fn xa => xml_return (id xa)))
    x;

fun xml2context_joinable_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name =
  xml_do
    [#"c", #"o", #"n", #"t", #"e", #"x", #"t", #"J", #"o", #"i", #"n", #"a",
      #"b", #"i", #"l", #"i", #"t", #"y", #"P", #"r", #"o", #"o", #"f"]
    (xml_take (term (show_lab A3_ B3_) xml2name)
      (fn a =>
        xml_take (csteps (A2_, A3_) (B2_, B3_) xml2name)
          (fn b =>
            xml_take (csteps (A2_, A3_) (B2_, B3_) xml2name)
              (fn c =>
                xml_take
                  (xml2const_map (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
                  (fn d =>
                    xml_return
                      (Contextual_Join
                        (orig_term d a, map (orig_cstep d) b,
                          map (orig_cstep d) c)))))));

fun xml2context_joinable_ccps (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name =
  xml_do
    [#"c", #"o", #"n", #"t", #"e", #"x", #"t", #"J", #"o", #"i", #"n", #"a",
      #"b", #"l", #"e", #"C", #"C", #"P", #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"c", #"o", #"n", #"t", #"e", #"x", #"t", #"J", #"o", #"i", #"n", #"a",
          #"b", #"l", #"e", #"C", #"C", #"P"]
        (xml_take (term (show_lab A3_ B3_) xml2name)
          (fn s =>
            xml_take (term (show_lab A3_ B3_) xml2name)
              (fn t =>
                xml_take
                  (conditions (show_lab A3_ B3_) xml2name
                    [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
                      #"s"])
                  (fn cs =>
                    xml_take
                      (xml2context_joinable_proof (A1_, A2_, A3_)
                        (B1_, B2_, B3_) xml2name)
                      (fn p => xml_return (s, (t, (cs, p)))))))))
      xml_return);

fun xml2ao_infeasibility_proof (A1_, A2_) (B1_, B2_) xml2name =
  xml_do
    [#"a", #"o", #"I", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"i", #"l",
      #"i", #"t", #"y", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_change (xml2infeasibility_proof (A1_, A2_) (B1_, B2_) xml2name)
          (xml_return o AO_Infeasibility_Proof))
        (xml_do
          [#"a", #"o", #"L", #"h", #"s", #"s", #"E", #"q", #"u", #"a", #"l"]
          (xml_take (term (show_lab A2_ B2_) xml2name)
            (fn a =>
              xml_take (term (show_lab A2_ B2_) xml2name)
                (fn b =>
                  xml_take (term (show_lab A2_ B2_) xml2name)
                    (fn c =>
                      xml_take
                        (xml2nonjoinability_proof (A1_, A2_) (B1_, B2_)
                          xml2name)
                        (fn d => xml_return (AO_Lhss_Equal (a, b, c, d)))))))))
      (fn x => xml_return (id x)));

fun xml2ao_infeasible_conds (A1_, A2_) (B1_, B2_) xml2name =
  xml_do
    [#"a", #"o", #"I", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e",
      #"C", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"a", #"o", #"I", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e",
          #"C", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n"]
        (xml_take
          (conditions (show_lab A2_ B2_) xml2name
            [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s"])
          (fn a =>
            xml_take
              (conditions (show_lab A2_ B2_) xml2name
                [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s"])
              (fn b =>
                xml_take
                  (xml2ao_infeasibility_proof (A1_, A2_) (B1_, B2_) xml2name)
                  (fn c => xml_return (a, (b, c)))))))
      (fn a => xml_return (id a)));

fun xml2infeasible_conds (A1_, A2_) (B1_, B2_) xml2name =
  xml_do
    [#"i", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e", #"C", #"o",
      #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"i", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e", #"C", #"o",
          #"n", #"d", #"i", #"t", #"i", #"o", #"n"]
        (xml_take
          (conditions (show_lab A2_ B2_) xml2name
            [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"s"])
          (fn a =>
            xml_take (xml2infeasibility_proof (A1_, A2_) (B1_, B2_) xml2name)
              (fn b => xml_return (a, b)))))
      (fn a => xml_return (id a)));

fun xml2unfeasible_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name =
  xml_do
    [#"u", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"i", #"l", #"i", #"t",
      #"y", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_do [#"t", #"e", #"r", #"m", #"s"]
        (xml_take (term (show_lab A3_ B3_) xml2name)
          (fn a =>
            xml_take (term (show_lab A3_ B3_) xml2name)
              (fn b =>
                xml_take (term (show_lab A3_ B3_) xml2name)
                  (fn c => xml_return (a, (b, c)))))))
      (fn a =>
        xml_take (csteps (A2_, A3_) (B2_, B3_) xml2name)
          (fn b =>
            xml_take (csteps (A2_, A3_) (B2_, B3_) xml2name)
              (fn c =>
                xml_take
                  (xml_do [#"r", #"u", #"l", #"e", #"s"]
                    (xml_take
                      (crule (show_lab A3_ B3_) xml2name
                        [#"r", #"u", #"l", #"e"])
                      (fn aa =>
                        xml_take
                          (crule (show_lab A3_ B3_) xml2name
                            [#"r", #"u", #"l", #"e"])
                          (fn ba => xml_return (aa, ba)))))
                  (fn d =>
                    xml_take
                      (xml2const_map (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
                      (fn e =>
                        xml_return
                          (let
                             val (t, (u, v)) = a;
                           in
                             (fn ps => fn qs => fn (r, ra) => fn m =>
                               UnfeasibleOverlap
                                 (orig_term m t, orig_term m u, orig_term m v,
                                   map (orig_cstep m) ps, map (orig_cstep m) qs,
                                   r, ra))
                           end
                             b
                             c
                             d
                            e)))))));

fun xml2unfeasible_ccps (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name =
  xml_do
    [#"u", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e", #"C", #"C",
      #"P", #"s"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"u", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e", #"C", #"C",
          #"P"]
        (xml_take (substa (show_lab A3_ B3_) xml2name)
          (fn a =>
            xml_take
              (xml2unfeasible_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
              (fn b => xml_return (subst_of (equal_list equal_char) a, b)))))
      (fn a => xml_return (id a)));

fun xml2conditional_cr_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name x =
  xml_do
    [#"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n", #"a", #"l", #"C",
      #"r", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_do
          [#"u", #"n", #"c", #"o", #"n", #"d", #"i", #"t", #"i", #"o", #"n",
            #"a", #"l"]
          (xml_take (xml2cr_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
            (fn xa => xml_return (Unconditional_CR xa))))
        (xml_or
          (xml_do [#"u", #"n", #"r", #"a", #"v", #"e", #"l", #"i", #"n", #"g"]
            (xml_take (unraveling_info (A2_, A3_) (B2_, B3_) xml2name)
              (fn a =>
                xml_take (xml2cr_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
                  (fn b => xml_return (Unravel_CR (a, b))))))
          (xml_or
            (xml_do
              [#"i", #"n", #"l", #"i", #"n", #"e", #"C", #"o", #"n", #"d", #"i",
                #"t", #"i", #"o", #"n", #"s"]
              (xml_take
                (xml_do [#"r", #"u", #"l", #"e", #"s"]
                  (xml_take_many_sub [] zero_nata Infinity_enat
                    (crule (show_lab A3_ B3_) xml2name [#"r", #"u", #"l", #"e"])
                    xml_return))
                (fn a =>
                  xml_take (xml2inline_cond_info (A2_, A3_) (B2_, B3_) xml2name)
                    (fn b =>
                      xml_take
                        (xml2conditional_cr_proof (A1_, A2_, A3_)
                          (B1_, B2_, B3_) xml2name)
                        (fn c =>
                          xml_return
                            (((fn aa => fn ba => Transformation_CR (aa, ba)) o
                               (fn ba => Inline_Conditions_CCRT (a, ba)))
                              b c))))))
            (xml_or
              (xml_do
                [#"i", #"n", #"f", #"e", #"a", #"s", #"i", #"b", #"l", #"e",
                  #"R", #"u", #"l", #"e", #"R", #"e", #"m", #"o", #"v", #"a",
                  #"l"]
                (xml_take
                  (xml2infeasible_rules_info (A2_, A3_) (B2_, B3_) xml2name)
                  (fn a =>
                    xml_take
                      (xml2conditional_cr_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                        xml2name)
                      (fn b =>
                        xml_return
                          (((fn aa => fn ba => Transformation_CR (aa, ba)) o
                             Infeasible_Rule_Removal_CCRT)
                            a b)))))
              (xml_or
                (xml_leaf
                  [#"a", #"l", #"m", #"o", #"s", #"t", #"O", #"r", #"t", #"h",
                    #"o", #"g", #"o", #"n", #"a", #"l"]
                  Almost_Orthogonal_CR)
                (xml_or
                  (xml_do
                    [#"a", #"l", #"m", #"o", #"s", #"t", #"O", #"r", #"t", #"h",
                      #"o", #"g", #"o", #"n", #"a", #"l", #"M", #"o", #"d",
                      #"u", #"l", #"o", #"I", #"n", #"f", #"e", #"a", #"s",
                      #"i", #"b", #"i", #"l", #"i", #"t", #"y"]
                    (xml_take
                      (xml2ao_infeasible_conds (A2_, A3_) (B2_, B3_) xml2name)
                      (fn xa =>
                        xml_return
                          (Almost_Orthogonal_Modulo_Infeasibility_CRa xa))))
                  (xml_do [#"a", #"l", #"9", #"4"]
                    (xml_take
                      (xml2quasi_reductive_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                        xml2name)
                      (fn a =>
                        xml_take
                          (xml2context_joinable_ccps (A1_, A2_, A3_)
                            (B1_, B2_, B3_) xml2name)
                          (fn b =>
                            xml_take
                              (xml2infeasible_conds (A2_, A3_) (B2_, B3_)
                                xml2name)
                              (fn c =>
                                xml_take
                                  (xml2unfeasible_ccps (A1_, A2_, A3_)
                                    (B1_, B2_, B3_) xml2name)
                                  (fn d =>
                                    xml_return
                                      (AL94_CR (a, b, c, d))))))))))))))
      (fn xa => xml_return (id xa)))
    x;

fun xml2ac_dp_termination_proof (A1_, A2_) (B1_, B2_) xml2name x =
  xml_do
    [#"a", #"c", #"D", #"P", #"T", #"e", #"r", #"m", #"i", #"n", #"a", #"t",
      #"i", #"o", #"n", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_do
          [#"a", #"c", #"R", #"e", #"d", #"P", #"a", #"i", #"r", #"P", #"r",
            #"o", #"c"]
          (xml_take
            (ordering_constraint_proof (show_lab A2_ B2_) xml2name false)
            (fn a =>
              xml_take
                (xml_do [#"d", #"p", #"s"]
                  (xml_take (rules (show_lab A2_ B2_) xml2name)
                    (fn xa => xml_return (id xa))))
                (fn b =>
                  xml_take
                    (xml_do
                      [#"u", #"s", #"a", #"b", #"l", #"e", #"R", #"u", #"l",
                        #"e", #"s"]
                      (xml_take (rules (show_lab A2_ B2_) xml2name)
                        (fn xa => xml_return (id xa))))
                    (fn c =>
                      xml_take
                        (xml2ac_dp_termination_proof (A1_, A2_) (B1_, B2_)
                          xml2name)
                        (fn d =>
                          xml_return (AC_Redpair_UR_Proc (a, b, c, d))))))))
        (xml_or
          (xml_do
            [#"a", #"c", #"S", #"u", #"b", #"t", #"e", #"r", #"m", #"P", #"r",
              #"o", #"c"]
            (xml_take (multiset_af (show_lab A2_ B2_) xml2name)
              (fn a =>
                xml_take
                  (xml_do [#"d", #"p", #"s"]
                    (xml_take (rules (show_lab A2_ B2_) xml2name)
                      (fn xa => xml_return (id xa))))
                  (fn b =>
                    xml_take
                      (xml2ac_dp_termination_proof (A1_, A2_) (B1_, B2_)
                        xml2name)
                      (fn c => xml_return (AC_Subterm_Proc (a, b, c)))))))
          (xml_or
            (xml_leaf
              [#"a", #"c", #"T", #"r", #"i", #"v", #"i", #"a", #"l", #"P", #"r",
                #"o", #"c"]
              AC_P_is_Empty)
            (xml_or
              (xml_do
                [#"a", #"c", #"M", #"o", #"n", #"o", #"R", #"e", #"d", #"P",
                  #"a", #"i", #"r", #"P", #"r", #"o", #"c"]
                (xml_take
                  (ordering_constraint_proof (show_lab A2_ B2_) xml2name false)
                  (fn a =>
                    xml_take
                      (xml_do [#"d", #"p", #"s"]
                        (xml_take (rules (show_lab A2_ B2_) xml2name)
                          (fn xa => xml_return (id xa))))
                      (fn b =>
                        xml_take
                          (xml_do [#"t", #"r", #"s"]
                            (xml_take (rules (show_lab A2_ B2_) xml2name)
                              (fn xa => xml_return (id xa))))
                          (fn c =>
                            xml_take
                              (xml_do
                                [#"u", #"s", #"a", #"b", #"l", #"e", #"R", #"u",
                                  #"l", #"e", #"s"]
                                (xml_take (rules (show_lab A2_ B2_) xml2name)
                                  (fn xa => xml_return (id xa))))
                              (fn d =>
                                xml_take
                                  (xml2ac_dp_termination_proof (A1_, A2_)
                                    (B1_, B2_) xml2name)
                                  (fn e =>
                                    xml_return
                                      (AC_Mono_Redpair_UR_Proc
(a, b, c, d, e)))))))))
              (xml_do
                [#"a", #"c", #"D", #"e", #"p", #"G", #"r", #"a", #"p", #"h",
                  #"P", #"r", #"o", #"c"]
                (xml_take_many_sub [] zero_nata Infinity_enat
                  (xml_do [#"c", #"o", #"m", #"p", #"o", #"n", #"e", #"n", #"t"]
                    (xml_take
                      (xml_do [#"d", #"p", #"s"]
                        (xml_take (rules (show_lab A2_ B2_) xml2name)
                          (fn xa => xml_return (id xa))))
                      (fn dps =>
                        xml_take_optional
                          (xml_bool [#"r", #"e", #"a", #"l", #"S", #"c", #"c"])
                          (fn _ =>
                            xml_take_optional
                              (xml2ac_dp_termination_proof (A1_, A2_) (B1_, B2_)
                                xml2name)
                              (fn prfOpt => xml_return (prfOpt, dps))))))
                  (fn ret => xml_return (AC_Dep_Graph_Proc ret))))))))
      (fn xa => xml_return (id xa)))
    x;

fun xml2ac_termination_proof (A1_, A2_) (B1_, B2_) xml2name x =
  xml_do
    [#"a", #"c", #"T", #"e", #"r", #"m", #"i", #"n", #"a", #"t", #"i", #"o",
      #"n", #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_do
          [#"a", #"c", #"D", #"e", #"p", #"e", #"n", #"d", #"e", #"n", #"c",
            #"y", #"P", #"a", #"i", #"r", #"s"]
          (xml_take
            (xml_do [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"s"]
              (xml_take (rules (show_lab A2_ B2_) xml2name)
                (fn xa => xml_return (id xa))))
            (fn e =>
              xml_take
                (xml_do
                  [#"d", #"p", #"E", #"q", #"u", #"a", #"t", #"i", #"o", #"n",
                    #"s"]
                  (xml_take (rules (show_lab A2_ B2_) xml2name)
                    (fn xa => xml_return (id xa))))
                (fn dpe =>
                  xml_take
                    (xml_do [#"d", #"p", #"s"]
                      (xml_take (rules (show_lab A2_ B2_) xml2name)
                        (fn xa => xml_return (id xa))))
                    (fn dp =>
                      xml_take
                        (xml_do
                          [#"e", #"x", #"t", #"e", #"n", #"s", #"i", #"o", #"n",
                            #"s"]
                          (xml_take (rules (show_lab A2_ B2_) xml2name)
                            (fn xa => xml_return (id xa))))
                        (fn rext =>
                          xml_take
                            (xml2ac_dp_termination_proof (A1_, A2_) (B1_, B2_)
                              xml2name)
                            (fn p1 =>
                              xml_take_optional
                                (xml2ac_dp_termination_proof (A1_, A2_)
                                  (B1_, B2_) xml2name)
                                (fn a =>
                                  (case a
                                    of NONE =>
                                      xml_return
(AC_DP_Trans_Single (AC_dependency_pairs_proof (e, dp, dpe, rext), p1))
                                    | SOME p2 =>
                                      xml_return
(AC_DP_Trans (AC_dependency_pairs_proof (e, dp, dpe, rext), p1, p2)))))))))))
        (xml_or
          (xml_do
            [#"a", #"c", #"R", #"u", #"l", #"e", #"R", #"e", #"m", #"o", #"v",
              #"a", #"l"]
            (xml_take
              (ordering_constraint_proof (show_lab A2_ B2_) xml2name false)
              (fn a =>
                xml_take
                  (xml_do [#"t", #"r", #"s"]
                    (xml_take (rules (show_lab A2_ B2_) xml2name)
                      (fn xa => xml_return (id xa))))
                  (fn b =>
                    xml_take
                      (xml2ac_termination_proof (A1_, A2_) (B1_, B2_) xml2name)
                      (fn c => xml_return (AC_Rule_Removal (a, b, c)))))))
          (xml_leaf [#"a", #"c", #"R", #"I", #"s", #"E", #"m", #"p", #"t", #"y"]
            AC_R_is_Empty)))
      (fn xa => xml_return (id xa)))
    x;

fun subsumption_proof A_ xml2name =
  xml_do
    [#"s", #"u", #"b", #"s", #"u", #"m", #"p", #"t", #"i", #"o", #"n", #"P",
      #"r", #"o", #"o", #"f"]
    (xml_take_many_sub [] zero_nata Infinity_enat
      (xml_do
        [#"r", #"u", #"l", #"e", #"S", #"u", #"b", #"s", #"u", #"m", #"p", #"t",
          #"i", #"o", #"n", #"P", #"r", #"o", #"o", #"f"]
        (xml_take (rule A_ xml2name)
          (fn r =>
            xml_take (conversion A_ xml2name)
              (fn (_, e) => xml_return (r, e)))))
      xml_return);

fun xml2completion_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name =
  xml_do
    [#"c", #"o", #"m", #"p", #"l", #"e", #"t", #"i", #"o", #"n", #"P", #"r",
      #"o", #"o", #"f"]
    (xml_take (wcr_proof (show_lab A3_ B3_) xml2name)
      (fn w =>
        xml_take
          (xml2trs_termination_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
          (fn t =>
            xml_take
              (xml_do
                [#"e", #"q", #"u", #"i", #"v", #"a", #"l", #"e", #"n", #"c",
                  #"e", #"P", #"r", #"o", #"o", #"f"]
                (xml_take (subsumption_proof (show_lab A3_ B3_) xml2name)
                  (fn s1 =>
                    xml_take_optional
                      (subsumption_proof (show_lab A3_ B3_) xml2name)
                      (fn s2 => xml_return (s1, s2)))))
              (fn (s1, s2) => xml_return (SN_WCR_Eq (w, t, s1, s2))))));

fun xml2equational_disproof (A1_, A2_, A3_) xml2name =
  xml_do
    [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"D", #"i",
      #"s", #"p", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_do
          [#"c", #"o", #"m", #"p", #"l", #"e", #"t", #"i", #"o", #"n", #"A",
            #"n", #"d", #"N", #"o", #"r", #"m", #"a", #"l", #"i", #"z", #"a",
            #"t", #"i", #"o", #"n"]
          (xml_take
            (xml_do [#"t", #"r", #"s"]
              (xml_take (rules (show_lab A3_ (show_list show_nat)) xml2name)
                (fn x => xml_return (id x))))
            (fn a =>
              xml_take
                (xml2completion_proof (A1_, A2_, A3_)
                  (equal_list equal_nat, key_list (equal_nat, key_nat),
                    show_list show_nat)
                  xml2name)
                (fn b =>
                  xml_return (Completion_and_Normalization_Different (a, b))))))
        (xml_do
          [#"c", #"o", #"n", #"v", #"e", #"r", #"t", #"i", #"b", #"l", #"e",
            #"I", #"n", #"s", #"t", #"a", #"n", #"c", #"e"]
          (xml_take
            (subsumption_proof (show_lab A3_ (show_list show_nat)) xml2name)
            (fn x => xml_return (Convertible_Instance x)))))
      (fn x => xml_return (id x)));

fun xml2unknown_disproof (A1_, A2_) (B1_, B2_) xml2name x =
  xml_do
    [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #"I", #"n", #"p", #"u", #"t",
      #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_do
          [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #"A", #"s", #"s", #"u",
            #"m", #"p", #"t", #"i", #"o", #"n"]
          (xml_take xml2unknown_input
            (fn xa => xml_return (Assume_NT_Unknown (xa, [])))))
        (xml_do
          [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #"P", #"r", #"o", #"o",
            #"f"]
          (xml_take
            (xml_text
              [#"d", #"e", #"s", #"c", #"r", #"i", #"p", #"t", #"i", #"o",
                #"n"])
            (fn _ =>
              xml_take xml2unknown_input
                (fn b =>
                  xml_take_many_sub [] zero_nata Infinity_enat
                    (fn xa => Inr (fst xa))
                    (fn _ => xml_return (Assume_NT_Unknown (b, []))))))))
      (fn xa => xml_return (id xa)))
    x;

fun xml2equational_proof (A1_, A2_, A3_) xml2name =
  xml_do
    [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"P", #"r",
      #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_do
          [#"e", #"q", #"u", #"a", #"t", #"i", #"o", #"n", #"a", #"l", #"P",
            #"r", #"o", #"o", #"f", #"T", #"r", #"e", #"e"]
          (xml_take (xml2eq_proof (show_lab A3_ (show_list show_nat)) xml2name)
            (fn x => xml_return (Equational_Proof_Tree x))))
        (xml_or
          (xml_change (conversion (show_lab A3_ (show_list show_nat)) xml2name)
            (fn (_, e) => xml_return (Conversion e)))
          (xml_or
            (xml_change
              (subsumption_proof (show_lab A3_ (show_list show_nat)) xml2name)
              (xml_return o Conversion_With_History))
            (xml_do
              [#"c", #"o", #"m", #"p", #"l", #"e", #"t", #"i", #"o", #"n", #"A",
                #"n", #"d", #"N", #"o", #"r", #"m", #"a", #"l", #"i", #"z",
                #"a", #"t", #"i", #"o", #"n"]
              (xml_take
                (xml_do [#"t", #"r", #"s"]
                  (xml_take (rules (show_lab A3_ (show_list show_nat)) xml2name)
                    (fn x => xml_return (id x))))
                (fn a =>
                  xml_take
                    (xml2completion_proof (A1_, A2_, A3_)
                      (equal_list equal_nat, key_list (equal_nat, key_nat),
                        show_list show_nat)
                      xml2name)
                    (fn b =>
                      xml_return (Completion_and_Normalization (a, b)))))))))
      (fn x => xml_return (id x)));

fun xml2complexity_inputa (A1_, A2_) xml2name =
  xml_change (xml2complexity_input A2_ xml2name)
    (fn CPX_input (q, s, w, cm, cc) =>
      xml_return
        (strategy_to_Q A1_ (equal_list equal_char) q (s @ w),
          (s, (w, (cm, cc)))));

fun xml2complexity_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name x =
  xml_do
    [#"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i", #"t", #"y", #"P", #"r",
      #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_do
          [#"r", #"u", #"l", #"e", #"S", #"h", #"i", #"f", #"t", #"i", #"n",
            #"g"]
          (xml_take (ordering_constraint_proof (show_lab A3_ B3_) xml2name true)
            (fn rp =>
              xml_take
                (xml_do [#"t", #"r", #"s"]
                  (xml_take (rules (show_lab A3_ B3_) xml2name)
                    (fn xa => xml_return (id xa))))
                (fn del =>
                  xml_take_optional
                    (xml_do
                      [#"u", #"s", #"a", #"b", #"l", #"e", #"R", #"u", #"l",
                        #"e", #"s"]
                      (xml_take (rules (show_lab A3_ B3_) xml2name)
                        (fn xa => xml_return (id xa))))
                    (fn ur =>
                      xml_take
                        (xml2complexity_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                          xml2name)
                        (fn prf =>
                          xml_return
                            (Rule_Shift_Complexity (rp, del, ur, prf))))))))
        (xml_or
          (xml_do
            [#"u", #"s", #"a", #"b", #"l", #"e", #"R", #"u", #"l", #"e", #"s"]
            (xml_take
              (xml_do
                [#"n", #"o", #"n", #"U", #"s", #"a", #"b", #"l", #"e", #"R",
                  #"u", #"l", #"e", #"s"]
                (xml_take (rules (show_lab A3_ B3_) xml2name)
                  (fn xa => xml_return (id xa))))
              (fn a =>
                xml_take
                  (xml2complexity_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                    xml2name)
                  (fn b => xml_return (Usable_Rules_Complexity (a, b))))))
          (xml_or
            (xml_do [#"s", #"p", #"l", #"i", #"t"]
              (xml_take
                (xml_do [#"t", #"r", #"s"]
                  (xml_take (rules (show_lab A3_ B3_) xml2name)
                    (fn xa => xml_return (id xa))))
                (fn a =>
                  xml_take
                    (xml2complexity_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                      xml2name)
                    (fn b =>
                      xml_take
                        (xml2complexity_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                          xml2name)
                        (fn c => xml_return (Split_Complexity (a, b, c)))))))
            (xml_or
              (xml_do
                [#"r", #"e", #"m", #"o", #"v", #"e", #"N", #"o", #"n", #"A",
                  #"p", #"p", #"l", #"i", #"c", #"a", #"b", #"l", #"e", #"R",
                  #"u", #"l", #"e", #"s"]
                (xml_take
                  (xml_do [#"t", #"r", #"s"]
                    (xml_take (rules (show_lab A3_ B3_) xml2name)
                      (fn xa => xml_return (id xa))))
                  (fn a =>
                    xml_take
                      (xml2complexity_proof (A1_, A2_, A3_) (B1_, B2_, B3_)
                        xml2name)
                      (fn b =>
                        xml_return
                          (Remove_Nonapplicable_Rules_Complexity (a, b))))))
              (xml_or
                (xml_change (bounds_info xml2name)
                  (xml_return o Matchbounds_Complexity))
                (xml_or
                  (xml_do
                    [#"r", #"e", #"l", #"a", #"t", #"i", #"v", #"e", #"B", #"o",
                      #"u", #"n", #"d", #"s"]
                    (xml_take (bounds_info xml2name)
                      (fn a =>
                        xml_take
                          (xml_do [#"t", #"r", #"s"]
                            (xml_take (rules (show_lab A3_ B3_) xml2name)
                              (fn xa => xml_return (id xa))))
                          (fn b =>
                            xml_take
                              (xml2complexity_proof (A1_, A2_, A3_)
                                (B1_, B2_, B3_) xml2name)
                              (fn c =>
                                xml_return
                                  (Matchbounds_Rel_Complexity (a, b, c)))))))
                  (xml_or
                    (xml_leaf [#"r", #"I", #"s", #"E", #"m", #"p", #"t", #"y"]
                      RisEmpty_Complexity)
                    (xml_or
                      (xml_do
                        [#"d", #"t", #"T", #"r", #"a", #"n", #"s", #"f", #"o",
                          #"r", #"m", #"a", #"t", #"i", #"o", #"n"]
                        (xml_take
                          (rule_pairs (show_lab A3_ B3_) xml2name
                            [#"s", #"t", #"r", #"i", #"c", #"t", #"D", #"T",
                              #"s"]
                            [#"r", #"u", #"l", #"e", #"W", #"i", #"t", #"h",
                              #"D", #"T"])
                          (fn a =>
                            xml_take
                              (rule_pairs (show_lab A3_ B3_) xml2name
                                [#"w", #"e", #"a", #"k", #"D", #"T", #"s"]
                                [#"r", #"u", #"l", #"e", #"W", #"i", #"t", #"h",
                                  #"D", #"T"])
                              (fn b =>
                                xml_take
                                  (innermostLhss (show_lab A3_ B3_) xml2name)
                                  (fn c =>
                                    xml_take
                                      (xml2complexity_proof (A1_, A2_, A3_)
(B1_, B2_, B3_) xml2name)
                                      (fn d =>
xml_return (DT_Transformation (DT_Transformation_Info (a, b, c), d))))))))
                      (xml_or
                        (xml_do
                          [#"w", #"d", #"p", #"T", #"r", #"a", #"n", #"s", #"f",
                            #"o", #"r", #"m", #"a", #"t", #"i", #"o", #"n"]
                          (xml_take
                            (symbols (show_lab A3_ B3_) xml2name
                              [#"c", #"o", #"m", #"p", #"o", #"u", #"n", #"d",
                                #"S", #"y", #"m", #"b", #"o", #"l", #"s"])
                            (fn a =>
                              xml_take
                                (rule_pairs (show_lab A3_ B3_) xml2name
                                  [#"s", #"t", #"r", #"i", #"c", #"t", #"W",
                                    #"D", #"P", #"s"]
                                  [#"r", #"u", #"l", #"e", #"W", #"i", #"t",
                                    #"h", #"W", #"D", #"P"])
                                (fn b =>
                                  xml_take
                                    (rule_pairs (show_lab A3_ B3_) xml2name
                                      [#"w", #"e", #"a", #"k", #"W", #"D", #"P",
#"s"]
                                      [#"r", #"u", #"l", #"e", #"W", #"i", #"t",
#"h", #"W", #"D", #"P"])
                                    (fn c =>
                                      xml_take
(innermostLhss (show_lab A3_ B3_) xml2name)
(fn d =>
  xml_take (xml2complexity_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
    (fn e =>
      xml_return
        (WDP_Transformation
          (WDP_Trans_Info
             (set (ceq_prod (ceq_lab A1_ B1_) ceq_nat,
                    ccompare_prod
                      (ccompare_lab
                        ((compare_compare_order o compare_order_key) A2_)
                        ((compare_compare_order o compare_order_key) B2_))
                      ccompare_nat,
                    set_impl_prod set_impl_lab set_impl_nat)
                a,
               b, c, d),
            e)))))))))
                        (xml_or
                          (xml_do
                            [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #"P",
                              #"r", #"o", #"o", #"f"]
                            (xml_take
                              (xml_text
                                [#"d", #"e", #"s", #"c", #"r", #"i", #"p", #"t",
                                  #"i", #"o", #"n"])
                              (fn _ =>
                                xml_take
                                  (xml2complexity_inputa
                                    (equal_lab A1_ B1_, show_lab A3_ B3_)
                                    xml2name)
                                  (fn b =>
                                    xml_take_many_sub [] zero_nata Infinity_enat
                                      (xml_do
[#"s", #"u", #"b", #"P", #"r", #"o", #"o", #"f"]
(xml_take (xml2complexity_inputa (equal_lab A1_ B1_, show_lab A3_ B3_) xml2name)
  (fn a =>
    xml_take (xml2complexity_proof (A1_, A2_, A3_) (B1_, B2_, B3_) xml2name)
      (fn ba => xml_return (Complexity_assm_proof (a, ba))))))
                                      (fn c =>
xml_return (Complexity_Assumption (b, c)))))))
                          (xml_do
                            [#"c", #"o", #"m", #"p", #"l", #"e", #"x", #"i",
                              #"t", #"y", #"A", #"s", #"s", #"u", #"m", #"p",
                              #"t", #"i", #"o", #"n"]
                            (xml_take
                              (xml2complexity_inputa
                                (equal_lab A1_ B1_, show_lab A3_ B3_) xml2name)
                              (fn xa =>
                                xml_return
                                  (Complexity_Assumption (xa, [])))))))))))))))
      (fn xa => xml_return (id xa)))
    x;

fun xml2unknown_proof (A1_, A2_) (B1_, B2_) xml2name x =
  xml_do
    [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #"I", #"n", #"p", #"u", #"t",
      #"P", #"r", #"o", #"o", #"f"]
    (xml_take
      (xml_or
        (xml_do
          [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #"A", #"s", #"s", #"u",
            #"m", #"p", #"t", #"i", #"o", #"n"]
          (xml_take xml2unknown_input
            (fn xa => xml_return (Assume_Unknown (xa, [])))))
        (xml_do
          [#"u", #"n", #"k", #"n", #"o", #"w", #"n", #"P", #"r", #"o", #"o",
            #"f"]
          (xml_take
            (xml_text
              [#"d", #"e", #"s", #"c", #"r", #"i", #"p", #"t", #"i", #"o",
                #"n"])
            (fn _ =>
              xml_take xml2unknown_input
                (fn b =>
                  xml_take_many_sub [] zero_nata Infinity_enat
                    (fn xa => Inr (fst xa))
                    (fn _ => xml_return (Assume_Unknown (b, []))))))))
      xml_return)
    x;

fun xml2cert_problem xml2uname xml2name =
  xml_do
    [#"c", #"e", #"r", #"t", #"i", #"f", #"i", #"c", #"a", #"t", #"i", #"o",
      #"n", #"P", #"r", #"o", #"b", #"l", #"e", #"m"]
    (xml_take_optional
      (xml2input (show_lab (show_list show_char) (show_list show_nat)) xml2name)
      (fn inp =>
        xml_take_optional
          (xml_text
            [#"c", #"p", #"f", #"V", #"e", #"r", #"s", #"i", #"o", #"n"])
          (fn _ =>
            xml_take
              (xml_do [#"p", #"r", #"o", #"o", #"f"]
                (xml_take
                  (xml_or
                    (xml_change
                      (xml2trs_termination_proof
                        (equal_list equal_char, key_list (equal_char, key_char),
                          show_list show_char)
                        (equal_list equal_nat, key_list (equal_nat, key_nat),
                          show_list show_nat)
                        xml2name)
                      (xml_return o TRS_Termination_Proof))
                    (xml_or
                      (xml_change
                        (xml2trs_nontermination_proof
                          (equal_list equal_char,
                            key_list (equal_char, key_char),
                            show_list show_char)
                          (equal_list equal_nat, key_list (equal_nat, key_nat),
                            show_list show_nat)
                          xml2name)
                        (xml_return o TRS_Nontermination_Proof))
                      (xml_or
                        (xml_change
                          (xml2reltrs_nontermination_proof
                            (equal_list equal_char,
                              key_list (equal_char, key_char),
                              show_list show_char)
                            (equal_list equal_nat,
                              key_list (equal_nat, key_nat), show_list show_nat)
                            xml2name)
                          (xml_return o Relative_TRS_Nontermination_Proof))
                        (xml_or
                          (xml_change
                            (xml2cr_proof
                              (equal_list equal_char,
                                key_list (equal_char, key_char),
                                show_list show_char)
                              (equal_list equal_nat,
                                key_list (equal_nat, key_nat),
                                show_list show_nat)
                              xml2name)
                            (xml_return o TRS_Confluence_Proof))
                          (xml_or
                            (xml_change (xml2ncr_proof xml2name)
                              (xml_return o TRS_Non_Confluence_Proof))
                            (xml_or
                              (xml_change
                                (xml2dp_termination_proof
                                  (equal_list equal_char,
                                    key_list (equal_char, key_char),
                                    show_list show_char)
                                  (equal_list equal_nat,
                                    key_list (equal_nat, key_nat),
                                    show_list show_nat)
                                  xml2name)
                                (xml_return o DP_Termination_Proof))
                              (xml_or
                                (xml_change
                                  (xml2dp_nontermination_proof
                                    (equal_list equal_char,
                                      key_list (equal_char, key_char),
                                      show_list show_char)
                                    (equal_list equal_nat,
                                      key_list (equal_nat, key_nat),
                                      show_list show_nat)
                                    xml2name)
                                  (xml_return o DP_Nontermination_Proof))
                                (xml_or
                                  (xml_change
                                    (xml2completion_proof
                                      (equal_list equal_char,
key_list (equal_char, key_char), show_list show_char)
                                      (equal_list equal_nat,
key_list (equal_nat, key_nat), show_list show_nat)
                                      xml2name)
                                    (xml_return o Completion_Proof))
                                  (xml_or
                                    (xml_change
                                      (xml2ordered_completion_proof
(key_list (equal_char, key_char), show_list show_char)
(key_list (equal_nat, key_nat), show_list show_nat) xml2name)
                                      (xml_return o Ordered_Completion_Proof))
                                    (xml_or
                                      (xml_change
(xml2equational_proof
  (equal_list equal_char, key_list (equal_char, key_char), show_list show_char)
  xml2name)
(xml_return o Equational_Proof))
                                      (xml_or
(xml_change
  (xml2equational_disproof
    (equal_list equal_char, key_list (equal_char, key_char),
      show_list show_char)
    xml2name)
  (xml_return o Equational_Disproof))
(xml_or
  (xml_change
    (xml2complexity_proof
      (equal_list equal_char, key_list (equal_char, key_char),
        show_list show_char)
      (equal_list equal_nat, key_list (equal_nat, key_nat), show_list show_nat)
      xml2name)
    (xml_return o Complexity_Proof))
  (xml_or
    (xml_change
      (xml2quasi_reductive_proof
        (equal_list equal_char, key_list (equal_char, key_char),
          show_list show_char)
        (equal_list equal_nat, key_list (equal_nat, key_nat),
          show_list show_nat)
        xml2name)
      (xml_return o Quasi_Reductive_Proof))
    (xml_or
      (xml_change
        (xml2conditional_cr_proof
          (equal_list equal_char, key_list (equal_char, key_char),
            show_list show_char)
          (equal_list equal_nat, key_list (equal_nat, key_nat),
            show_list show_nat)
          xml2name)
        (xml_return o Conditional_CR_Proof))
      (xml_or
        (xml_change (xml2conditional_ncr_proof xml2name)
          (xml_return o Conditional_Non_CR_Proof))
        (xml_or
          (xml_do
            [#"t", #"r", #"e", #"e", #"A", #"u", #"t", #"o", #"m", #"a", #"t",
              #"o", #"n", #"C", #"l", #"o", #"s", #"e", #"d", #"P", #"r", #"o",
              #"o", #"f"]
            (xml_take closed_criterion
              (fn x => xml_return (Tree_Automata_Closed_Proof x))))
          (xml_or
            (xml_change
              (xml2ac_termination_proof
                (key_list (equal_char, key_char), show_list show_char)
                (key_list (equal_nat, key_nat), show_list show_nat) xml2name)
              (xml_return o AC_Termination_Proof))
            (xml_or
              (xml_do
                [#"l", #"t", #"s", #"T", #"e", #"r", #"m", #"i", #"n", #"a",
                  #"t", #"i", #"o", #"n", #"P", #"r", #"o", #"o", #"f"]
                (xml_take lts_termination_proof_parser
                  (fn x => xml_return (LTS_Termination_Proof x))))
              (xml_or
                (xml_do
                  [#"l", #"t", #"s", #"S", #"a", #"f", #"e", #"t", #"y", #"P",
                    #"r", #"o", #"o", #"f"]
                  (xml_take lts_safety_proof_parser
                    (fn x => xml_return (LTS_Safety_Proof x))))
                (xml_or
                  (xml_change
                    (xml2unknown_proof
                      (key_list (equal_char, key_char), show_list show_char)
                      (key_list (equal_nat, key_nat), show_list show_nat)
                      xml2name)
                    (xml_return o Unknown_Proof))
                  (xml_change
                    (xml2unknown_disproof
                      (key_list (equal_char, key_char), show_list show_char)
                      (key_list (equal_nat, key_nat), show_list show_nat)
                      xml2name)
                    (xml_return o Unknown_Disproof))))))))))))))))))))))
                  xml_return))
              (fn p =>
                xml_take_optional (fn x => Inr (fst x))
                  (fn _ => xml_return (inp, p))))));

fun impl_ofe B_ (AC_DPP x) = x;

fun rw_implb (p, (pw, (r, (rw, (e, uu))))) = rw;

fun rwb A_ xa = rw_implb (impl_ofe A_ xa);

fun r_implb (p, (pw, (r, (rw, (e, uu))))) = r;

fun rb A_ xa = r_implb (impl_ofe A_ xa);

fun e_impl (p, (pw, (r, (rw, (e, uu))))) = e;

fun e A_ xa = e_impl (impl_ofe A_ xa);

fun eq_rules_non_collapsing A_ d =
  let
    val t = list_all (fn (_, r) => not (is_Var r));
  in
    t (rb A_ d) andalso (t (rwb A_ d) andalso t (e A_ d))
  end;

fun eq_rules_no_left_var A_ d =
  let
    val t = list_all (fn (l, _) => not (is_Var l));
  in
    t (rb A_ d) andalso (t (rwb A_ d) andalso t (e A_ d))
  end;

fun mk_implb (A1_, A2_) B_ p pw r rw e =
  (p, (pw, (r, (rw, (e, insert_rules equal_unit (compare_order_key A2_, A1_) B_
                          () (r @ rw @ e)
                          (empty
                            (linorder_prod
                              ((linorder_compare_order o compare_order_key) A2_)
                              linorder_nat)))))));

fun delete_pairs_rules_impl (A1_, A2_) B_ (p, (pw, (r, (rw, (e, m))))) pd rd =
  (if null rd
    then (list_diff (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) p pd,
           (list_diff (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) pw
              pd,
             (r, (rw, (e, m)))))
    else mk_implb (A1_, A2_) B_
           (list_diff (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) p pd)
           (list_diff (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) pw
             pd)
           (list_diff (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) r rd)
           (list_diff (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) rw
             rd)
           e);

fun delete_pairs_rules (A1_, A2_) B_ xc xd xe =
  AC_DPP (delete_pairs_rules_impl (A1_, A2_) B_ (impl_ofe A2_ xc) xd xe);

fun reverse_rules_mapa (A1_, A2_) d fna =
  maps (fn (l, r) =>
         (if equal_optiona (equal_prod A1_ equal_nat) (root r) (SOME fna)
           then [(r, l)] else []))
    (rb A2_ d @ rwb A2_ d @ e A2_ d);

fun intersect_pairs_impla (A1_, A2_) B_ (p, (pw, (r, (rw, (e, m))))) pd =
  (list_inter (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) p pd,
    (list_inter (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) pw pd,
      (r, (rw, (e, m)))));

fun intersect_pairsa (A1_, A2_) B_ xb xc =
  AC_DPP (intersect_pairs_impla (A1_, A2_) B_ (impl_ofe A2_ xb) xc);

fun rules_map_implb A_ (p, (pw, (r, (rw, (e, m))))) fna =
  (case lookup (compare_order_prod (compare_order_key A_) compare_order_nat) m
          fna
    of NONE => [] | SOME a => map snd a);

fun rules_mapb A_ xa = rules_map_implb A_ (impl_ofe A_ xa);

fun ac_dpp_impl (A1_, A2_) (B1_, B2_) (p, (pw, (r, (rw, (e, uu))))) =
  (set (ceq_prod (ceq_term A1_ B2_) (ceq_term A1_ B2_),
         ccompare_prod
           (ccompare_term ((compare_compare_order o compare_order_key) A2_) B1_)
           (ccompare_term ((compare_compare_order o compare_order_key) A2_)
             B1_),
         set_impl_prod set_impl_term set_impl_term)
     p,
    (set (ceq_prod (ceq_term A1_ B2_) (ceq_term A1_ B2_),
           ccompare_prod
             (ccompare_term ((compare_compare_order o compare_order_key) A2_)
               B1_)
             (ccompare_term ((compare_compare_order o compare_order_key) A2_)
               B1_),
           set_impl_prod set_impl_term set_impl_term)
       pw,
      (set (ceq_prod (ceq_term A1_ B2_) (ceq_term A1_ B2_),
             ccompare_prod
               (ccompare_term ((compare_compare_order o compare_order_key) A2_)
                 B1_)
               (ccompare_term ((compare_compare_order o compare_order_key) A2_)
                 B1_),
             set_impl_prod set_impl_term set_impl_term)
         r,
        (set (ceq_prod (ceq_term A1_ B2_) (ceq_term A1_ B2_),
               ccompare_prod
                 (ccompare_term
                   ((compare_compare_order o compare_order_key) A2_) B1_)
                 (ccompare_term
                   ((compare_compare_order o compare_order_key) A2_) B1_),
               set_impl_prod set_impl_term set_impl_term)
           rw,
          set (ceq_prod (ceq_term A1_ B2_) (ceq_term A1_ B2_),
                ccompare_prod
                  (ccompare_term
                    ((compare_compare_order o compare_order_key) A2_) B1_)
                  (ccompare_term
                    ((compare_compare_order o compare_order_key) A2_) B1_),
                set_impl_prod set_impl_term set_impl_term)
            e))));

fun ac_dpp (A1_, A2_) (B1_, B2_) xa =
  ac_dpp_impl (A1_, A2_) (B1_, B2_) (impl_ofe A2_ xa);

fun rules_implc (p, (pw, (r, (rw, (e, uu))))) = r @ rw;

fun rulesc A_ xa = rules_implc (impl_ofe A_ xa);

fun pairs_impla (p, (pw, (r, (rw, (e, uu))))) = p @ pw;

fun pairsa A_ xa = pairs_impla (impl_ofe A_ xa);

fun mkb (A1_, A2_) B_ xc xd xe xf xg =
  AC_DPP (mk_implb (A1_, A2_) B_ xc xd xe xf xg);

fun pw_impla (p, (pw, (r, (rw, (e, uu))))) = pw;

fun pwa A_ xa = pw_impla (impl_ofe A_ xa);

fun p_impla (p, (pw, (r, (rw, (e, uu))))) = p;

fun pa A_ xa = p_impla (impl_ofe A_ xa);

fun ac_dpp_rbt_impl (A1_, A2_) (B1_, B2_) =
  Ac_dpp_ops_ext
    (ac_dpp (A1_, A2_) (B1_, B2_), pa A2_, pwa A2_, pairsa A2_, rb A2_, rwb A2_,
      rulesc A2_, e A2_, mkb (A1_, A2_) B2_, rules_mapb A2_,
      reverse_rules_mapa (A1_, A2_), delete_pairs_rules (A1_, A2_) B2_,
      eq_rules_no_left_var A2_, eq_rules_non_collapsing A2_,
      intersect_pairsa (A1_, A2_) B2_, ());

fun c_rules_impl c = let
                       val x = Var [#"x"];
                       val y = Var [#"y"];
                     in
                       map (fn f => (Fun (f, [x, y]), Fun (f, [y, x]))) c
                     end;

fun a_trs_impl a =
  let
    val x = Var [#"x"];
    val y = Var [#"y"];
    val z = Var [#"z"];
  in
    map (fn f => (Fun (f, [Fun (f, [x, y]), z]), Fun (f, [x, Fun (f, [y, z])])))
      a @
      map (fn f =>
            (Fun (f, [x, Fun (f, [y, z])]), Fun (f, [Fun (f, [x, y]), z])))
        a
  end;

fun aC_trs_impl a c = a_trs_impl a @ c_rules_impl c;

fun ac_tp_list_impl (A1_, A2_, A3_, A4_, A5_) =
  Ac_tp_ops_ext
    ((fn (r, a) =>
       let
         val (aa, c) = a;
       in
         (set (ceq_prod (ceq_term A4_ (equal_list equal_char))
                 (ceq_term A4_ (equal_list equal_char)),
                ccompare_prod (ccompare_term A3_ (compare_list compare_char))
                  (ccompare_term A3_ (compare_list compare_char)),
                set_impl_prod set_impl_term set_impl_term)
            r,
           (set (A1_, A2_, A5_) aa, set (A1_, A2_, A5_) c))
       end),
      (fn (r, (_, _)) => r), (fn (_, a) => let
     val (aa, _) = a;
   in
     aa
   end),
      (fn (_, (_, c)) => c), (fn r => fn a => fn c => (r, (a, c))),
      (fn (r, a) =>
        let
          val (aa, c) = a;
        in
          (fn dr =>
            (list_diff
               (equal_prod (equal_term A4_ (equal_list equal_char))
                 (equal_term A4_ (equal_list equal_char)))
               r dr,
              (aa, c)))
        end),
      (fn (_, a) => let
                      val (aa, b) = a;
                    in
                      aC_trs_impl aa b
                    end),
      ());

fun rules_non_collapsing_impl (uu, (uv, (uw, (ux, (uy, (uz, (nc, va))))))) = nc;

fun impl_ofd B_ (DPP x) = x;

fun rules_non_collapsing A_ d = rules_non_collapsing_impl (impl_ofd A_ d);

fun nFQ_subset_NF_rules_impla (uu, (uv, (uw, (ux, (uy, (b, uz)))))) = b;

fun nFQ_subset_NF_rulesa A_ d = nFQ_subset_NF_rules_impla (impl_ofd A_ d);

fun rules_no_left_var_impl
  (uu, (uv, (uw, (ux, (uy, (uz, (va, ([], ([], vb))))))))) = true
  | rules_no_left_var_impl
    (v, (vb, (ve, (vg, (vi, (vk, (vm, (vq :: vr, vp)))))))) = false
  | rules_no_left_var_impl
    (v, (vb, (ve, (vg, (vi, (vk, (vm, (vo, (vs :: vt, vr))))))))) = false;

fun rules_no_left_var A_ d = rules_no_left_var_impl (impl_ofd A_ d);

fun reverse_rules_map_impl A_
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (m, ve))))))))))) fna =
  (case lookup (compare_order_prod (compare_order_key A_) compare_order_nat) m
          fna
    of NONE => [] | SOME a => map snd a);

fun reverse_rules_map A_ d = reverse_rules_map_impl A_ (impl_ofd A_ d);

fun is_NF_trs_subset is_Q_nf r = is_NF_subset is_Q_nf (map fst r);

fun wwf_qtrs_impl B_ nf r =
  list_all (fn ra => wf_rule B_ ra orelse not (applicable_rule_impl nf ra)) r;

fun intersect_rules_impl (A1_, A2_) B_ d ri =
  let
    val (nfs, (mi, (p, (pw, (q, (nfq, (nc,
(vR, (vRw, (m, (rm, (wwf, isnf))))))))))))
      = d;
    val (vri, ria) = partition (is_Var o fst) ri;
    val vr =
      list_inter (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) vR vri;
    val vrw =
      list_inter (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) vRw vri;
    val ma = intersect_rules (compare_order_key A2_, A1_) B_ ria m;
    val rma =
      intersect_rules (compare_order_key A2_, A1_) B_ (reverse_rules ri) rm;
    val rs =
      vr @ vrw @ map snd
                   (values
                     (linorder_prod
                       ((linorder_compare_order o compare_order_key) A2_)
                       linorder_nat)
                     ma);
  in
    (nfs, (mi, (p, (pw, (q, (nfq orelse is_NF_trs_subset isnf rs,
                              (nc orelse
                                 list_all (fn r => not (is_Var (snd r))) rs,
                                (vr, (vrw, (ma,
     (rma, (wwf orelse wwf_qtrs_impl B_ isnf rs, isnf))))))))))))
  end;

fun intersect_rulesa (A1_, A2_) B_ d rs =
  DPP (intersect_rules_impl (A1_, A2_) B_ (impl_ofd A2_ d) rs);

fun intersect_pairs_impl A_ B_ (nfs, (mi, (p, (pw, rest)))) ps =
  (nfs, (mi, (list_inter (equal_prod (equal_term A_ B_) (equal_term A_ B_)) p
                ps,
               (list_inter (equal_prod (equal_term A_ B_) (equal_term A_ B_)) pw
                  ps,
                 rest))));

fun intersect_pairs (A1_, A2_) B_ d ps =
  DPP (intersect_pairs_impl A1_ B_ (impl_ofd A2_ d) ps);

fun replace_pair_impl A_ B_ (nfs, (mi, (p, (pw, rest)))) pair ps =
  (nfs, (mi, (replace_impl (equal_prod (equal_term A_ B_) (equal_term A_ B_))
                pair ps p,
               (replace_impl (equal_prod (equal_term A_ B_) (equal_term A_ B_))
                  pair ps pw,
                 rest))));

fun replace_pair (A1_, A2_) B_ d pair ps =
  DPP (replace_pair_impl A1_ B_ (impl_ofd A2_ d) pair ps);

fun rules_implb A_
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vr, (vrw, (m, vb)))))))))) =
  vr @ vrw @ map snd
               (values
                 (linorder_prod
                   ((linorder_compare_order o compare_order_key) A_)
                   linorder_nat)
                 m);

fun split_rules_impla (A1_, A2_) B_ d rs =
  partition (membera (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) rs)
    (rules_implb A2_ d);

fun split_rulesa (A1_, A2_) B_ d =
  split_rules_impla (A1_, A2_) B_ (impl_ofd A2_ d);

fun pairs_impl (uu, (uv, (p, (pw, uw)))) = p @ pw;

fun split_pairs_impl A_ B_ d ps =
  partition (membera (equal_prod (equal_term A_ B_) (equal_term A_ B_)) ps)
    (pairs_impl d);

fun split_pairs (A1_, A2_) B_ d = split_pairs_impl A1_ B_ (impl_ofd A2_ d);

fun delete_R_Rw_impla (A1_, A2_) B_ d r rw =
  let
    val (nfs, (mi, (p, (pw, (q, (nfq, (nc,
(vR, (vRw, (m, (rm, (wwf, isnf))))))))))))
      = d;
    val (vr, ra) = partition (is_Var o fst) r;
    val (vrw, rwa) = partition (is_Var o fst) rw;
    val vra =
      list_diff (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) vR vr;
    val vrwa =
      list_diff (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) vRw vrw;
    val ma =
      delete_rules equal_bool (compare_order_key A2_, A1_) B_ true ra
        (delete_rules equal_bool (compare_order_key A2_, A1_) B_ false rwa m);
    val rma =
      delete_rules equal_bool (compare_order_key A2_, A1_) B_ true
        (reverse_rules r)
        (delete_rules equal_bool (compare_order_key A2_, A1_) B_ false
          (reverse_rules rw) rm);
    val rs =
      vra @ vrwa @
              map snd
                (values
                  (linorder_prod
                    ((linorder_compare_order o compare_order_key) A2_)
                    linorder_nat)
                  ma);
  in
    (nfs, (mi, (p, (pw, (q, (nfq orelse is_NF_trs_subset isnf rs,
                              (nc orelse
                                 list_all (fn rb => not (is_Var (snd rb))) rs,
                                (vra, (vrwa,
(ma, (rma, (wwf orelse wwf_qtrs_impl B_ isnf rs, isnf))))))))))))
  end;

fun delete_R_Rwa (A1_, A2_) B_ d r rw =
  DPP (delete_R_Rw_impla (A1_, A2_) B_ (impl_ofd A2_ d) r rw);

fun delete_P_Pw_impl A_ B_ (nfs, (mi, (p, (pw, rest)))) pd pwd =
  (nfs, (mi, (list_diff (equal_prod (equal_term A_ B_) (equal_term A_ B_)) p pd,
               (list_diff (equal_prod (equal_term A_ B_) (equal_term A_ B_)) pw
                  pwd,
                 rest))));

fun delete_P_Pw (A1_, A2_) B_ d p pw =
  DPP (delete_P_Pw_impl A1_ B_ (impl_ofd A2_ d) p pw);

fun rules_map_impla A_
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (m, vd)))))))))) fna =
  (case lookup (compare_order_prod (compare_order_key A_) compare_order_nat) m
          fna
    of NONE => [] | SOME a => map snd a);

fun rules_mapa A_ d = rules_map_impla A_ (impl_ofd A_ d);

fun wwf_rules_impl
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (ve, (wwf, vf)))))))))))) =
  wwf;

fun wwf_rules A_ d = wwf_rules_impl (impl_ofd A_ d);

fun q_empty_impla (uu, (uv, (uw, (ux, (q, uy))))) = null q;

fun q_emptya A_ d = q_empty_impla (impl_ofd A_ d);

fun is_QNF_impla
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (ve, (vf, isnf)))))))))))) =
  isnf;

fun is_QNFa A_ d = is_QNF_impla (impl_ofd A_ d);

fun rulesb A_ d = rules_implb A_ (impl_ofd A_ d);

fun pairs A_ d = pairs_impl (impl_ofd A_ d);

fun dpp_impl (A1_, A2_) (B1_, B2_)
  (nfs, (mi, (p, (pw, (q, (uu, (uv, (vr, (vrw, (m, uw)))))))))) =
  (nfs, (mi, (set (ceq_prod (ceq_term A1_ B2_) (ceq_term A1_ B2_),
                    ccompare_prod
                      (ccompare_term
                        ((compare_compare_order o compare_order_key) A2_) B1_)
                      (ccompare_term
                        ((compare_compare_order o compare_order_key) A2_) B1_),
                    set_impl_prod set_impl_term set_impl_term)
                p,
               (set (ceq_prod (ceq_term A1_ B2_) (ceq_term A1_ B2_),
                      ccompare_prod
                        (ccompare_term
                          ((compare_compare_order o compare_order_key) A2_) B1_)
                        (ccompare_term
                          ((compare_compare_order o compare_order_key) A2_)
                          B1_),
                      set_impl_prod set_impl_term set_impl_term)
                  pw,
                 (set (ceq_term A1_ B2_,
                        ccompare_term
                          ((compare_compare_order o compare_order_key) A2_) B1_,
                        set_impl_term)
                    q,
                   (set (ceq_prod (ceq_term A1_ B2_) (ceq_term A1_ B2_),
                          ccompare_prod
                            (ccompare_term
                              ((compare_compare_order o compare_order_key) A2_)
                              B1_)
                            (ccompare_term
                              ((compare_compare_order o compare_order_key) A2_)
                              B1_),
                          set_impl_prod set_impl_term set_impl_term)
                      (vr @ rules_with
                              ((linorder_compare_order o compare_order_key) A2_)
                              id m),
                     set (ceq_prod (ceq_term A1_ B2_) (ceq_term A1_ B2_),
                           ccompare_prod
                             (ccompare_term
                               ((compare_compare_order o compare_order_key) A2_)
                               B1_)
                             (ccompare_term
                               ((compare_compare_order o compare_order_key) A2_)
                               B1_),
                           set_impl_prod set_impl_term set_impl_term)
                       (vrw @
                         rules_with
                           ((linorder_compare_order o compare_order_key) A2_)
                           not m)))))));

fun dpp (A1_, A2_) (B1_, B2_) d =
  dpp_impl (A1_, A2_) (B1_, B2_) (impl_ofd A2_ d);

fun nfs_impla (nfs, uu) = nfs;

fun nfsa A_ d = nfs_impla (impl_ofd A_ d);

fun mk_impla (A1_, A2_) (B1_, B2_, B3_) nfs mi p pw q r rw =
  let
    val (vr, ra) = partition (is_Var o fst) r;
    val (vrw, rwa) = partition (is_Var o fst) rw;
    val rs = r @ rw;
    val isnf = is_NF_terms (A1_, A2_) (B1_, B2_, B3_) q;
  in
    (nfs, (mi, (p, (pw, (q, (is_NF_trs_subset isnf rs,
                              (list_all (fn rb => not (is_Var (snd rb))) rs,
                                (vr, (vrw, (insert_rules equal_bool
      (compare_order_key A2_, A1_) B2_ true ra
      (insert_rules equal_bool (compare_order_key A2_, A1_) B2_ false rwa
        (empty
          (linorder_prod ((linorder_compare_order o compare_order_key) A2_)
            linorder_nat))),
     (insert_rules equal_bool (compare_order_key A2_, A1_) B2_ true
        (reverse_rules r)
        (insert_rules equal_bool (compare_order_key A2_, A1_) B2_ false
          (reverse_rules rw)
          (empty
            (linorder_prod ((linorder_compare_order o compare_order_key) A2_)
              linorder_nat))),
       (wwf_qtrs_impl B2_ isnf rs, isnf))))))))))))
  end;

fun mka (A1_, A2_) (B1_, B2_, B3_) nfs mi p pw q r rw =
  DPP (mk_impla (A1_, A2_) (B1_, B2_, B3_) nfs mi p pw q r rw);

fun rw_impla A_ (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vrw, (m, vc)))))))))) =
  vrw @ rules_with ((linorder_compare_order o compare_order_key) A_) not m;

fun rwa A_ d = rw_impla A_ (impl_ofd A_ d);

fun pw_impl (uu, (uv, (uw, (pw, ux)))) = pw;

fun pw A_ d = pw_impl (impl_ofd A_ d);

fun r_impla A_ (uu, (uv, (uw, (ux, (uy, (uz, (va, (vr, (vb, (m, vc)))))))))) =
  vr @ rules_with ((linorder_compare_order o compare_order_key) A_) id m;

fun ra A_ d = r_impla A_ (impl_ofd A_ d);

fun q_impla (uu, (uv, (uw, (ux, (q, uy))))) = q;

fun qa A_ d = q_impla (impl_ofd A_ d);

fun p_impl (uu, (uv, (p, uw))) = p;

fun p A_ d = p_impl (impl_ofd A_ d);

fun m_impl (uu, (mi, uv)) = mi;

fun ma A_ d = m_impl (impl_ofd A_ d);

fun dpp_rbt_impl (A1_, A2_) (B1_, B2_, B3_, B4_) =
  Dpp_ops_ext
    (dpp (A1_, A2_) (B2_, B3_), p A2_, pw A2_, pairs A2_, qa A2_, ra A2_,
      rwa A2_, rulesb A2_, q_emptya A2_, rules_no_left_var A2_,
      rules_non_collapsing A2_, is_QNFa A2_, nFQ_subset_NF_rulesa A2_,
      rules_mapa A2_, reverse_rules_map A2_, intersect_pairs (A1_, A2_) B3_,
      replace_pair (A1_, A2_) B3_, intersect_rulesa (A1_, A2_) B3_,
      delete_P_Pw (A1_, A2_) B3_, delete_R_Rwa (A1_, A2_) B3_,
      split_pairs (A1_, A2_) B3_, split_rulesa (A1_, A2_) B3_,
      mka (A1_, A2_) (B1_, B3_, B4_), ma A2_, nfsa A2_, wwf_rules A2_, ());

fun nFQ_subset_NF_rules_impl (uu, (uv, (b, uw))) = b;

fun nFQ_subset_NF_rules A_ B_ tp = nFQ_subset_NF_rules_impl (impl_ofc A_ B_ tp);

fun rules_impla A_ (uu, (uv, (uw, (vR, (vRw, (m, ux)))))) =
  vR @ vRw @ map snd
               (values
                 (linorder_prod
                   ((linorder_compare_order o compare_order_key) A_)
                   linorder_nat)
                 m);

fun split_rules_impl A_ B_ tp rs =
  let
    val m = ceta_set_of (key_prod (key_term A_ B_) (key_term A_ B_)) rs;
  in
    partition m (rules_impla A_ tp)
  end;

fun split_rules A_ B_ tp = split_rules_impl A_ B_ (impl_ofc A_ B_ tp);

fun delete_R_Rw_impl (A1_, A2_) B_ (nfs, (q, (uu, (vR, (vRw, (m, isnf)))))) r rw
  = let
      val (vr, ra) = partition (is_Var o fst) r;
      val (vrw, rwa) = partition (is_Var o fst) rw;
      val vra =
        list_diff (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) vR vr;
      val vrwa =
        list_diff (equal_prod (equal_term A1_ B_) (equal_term A1_ B_)) vRw vrw;
      val ma =
        delete_rules equal_bool (compare_order_key A2_, A1_) B_ true ra
          (delete_rules equal_bool (compare_order_key A2_, A1_) B_ false rwa m);
    in
      (nfs, (q, (is_NF_trs_subset isnf
                   (vra @
                     vrwa @
                       map snd
                         (values
                           (linorder_prod
                             ((linorder_compare_order o compare_order_key) A2_)
                             linorder_nat)
                           ma)),
                  (vra, (vrwa, (ma, isnf))))))
    end;

fun delete_R_Rw (A1_, A2_) (B1_, B2_) tp r rw =
  TP (delete_R_Rw_impl (A1_, A2_) B1_ (impl_ofc A2_ B2_ tp) r rw);

fun rules_map_impl A_ (uu, (uv, (uw, (ux, (uy, (m, uz)))))) fna =
  (case lookup (compare_order_prod (compare_order_key A_) compare_order_nat) m
          fna
    of NONE => [] | SOME a => map snd a);

fun rules_map A_ B_ tp = rules_map_impl A_ (impl_ofc A_ B_ tp);

fun qreltrs_impl (A1_, A2_) (B1_, B2_) (nfs, (q, (uu, (vR, (vRw, (m, isnf))))))
  = (nfs, (set (ceq_term A1_ B2_,
                 ccompare_term ((compare_compare_order o compare_order_key) A2_)
                   B1_,
                 set_impl_term)
             q,
            (set (ceq_prod (ceq_term A1_ B2_) (ceq_term A1_ B2_),
                   ccompare_prod
                     (ccompare_term
                       ((compare_compare_order o compare_order_key) A2_) B1_)
                     (ccompare_term
                       ((compare_compare_order o compare_order_key) A2_) B1_),
                   set_impl_prod set_impl_term set_impl_term)
               (vR @ rules_with
                       ((linorder_compare_order o compare_order_key) A2_) id m),
              set (ceq_prod (ceq_term A1_ B2_) (ceq_term A1_ B2_),
                    ccompare_prod
                      (ccompare_term
                        ((compare_compare_order o compare_order_key) A2_) B1_)
                      (ccompare_term
                        ((compare_compare_order o compare_order_key) A2_) B1_),
                    set_impl_prod set_impl_term set_impl_term)
                (vRw @
                  rules_with ((linorder_compare_order o compare_order_key) A2_)
                    not m))));

fun qreltrs (A1_, A2_) (B1_, B2_) tp =
  qreltrs_impl (A1_, A2_) ((compare_compare_order o compare_order_key) B2_, B1_)
    (impl_ofc A2_ B2_ tp);

fun q_empty_impl (uu, (q, uv)) = null q;

fun q_empty A_ B_ tp = q_empty_impl (impl_ofc A_ B_ tp);

fun is_QNF_impl (uu, (uv, (uw, (ux, (uy, (uz, isnf)))))) = isnf;

fun is_QNF A_ B_ tp = is_QNF_impl (impl_ofc A_ B_ tp);

fun rulesa A_ B_ tp = rules_impla A_ (impl_ofc A_ B_ tp);

fun nfs_impl A_ (nfs, uu) = nfs;

fun nfs A_ B_ tp = nfs_impl A_ (impl_ofc A_ B_ tp);

fun mk_impl (A1_, A2_) (B1_, B2_, B3_) nfs q r rw =
  let
    val (vr, ra) = partition (is_Var o fst) r;
    val (vrw, rwa) = partition (is_Var o fst) rw;
    val isnf = is_NF_terms (A1_, A2_) (B1_, B2_, B3_) q;
  in
    (nfs, (q, (is_NF_trs_subset isnf (r @ rw),
                (vr, (vrw, (insert_rules equal_bool (compare_order_key A2_, A1_)
                              B2_ true ra
                              (insert_rules equal_bool
                                (compare_order_key A2_, A1_) B2_ false rwa
                                (empty
                                  (linorder_prod
                                    ((linorder_compare_order o
                                       compare_order_key)
                                      A2_)
                                    linorder_nat))),
                             isnf))))))
  end;

fun mk (A1_, A2_) (B1_, B2_, B3_, B4_) nfs q r rw =
  TP (mk_impl (A1_, A2_) (B1_, B2_, B4_) nfs q r rw);

fun rw_impl A_ (uu, (uv, (uw, (ux, (vRw, (m, uy)))))) =
  vRw @ rules_with ((linorder_compare_order o compare_order_key) A_) not m;

fun rw A_ B_ tp = rw_impl A_ (impl_ofc A_ B_ tp);

fun tp_rbt_impl (A1_, A2_) (B1_, B2_, B3_, B4_) =
  Tp_ops_ext
    (qreltrs (A1_, A2_) (B2_, B3_), q A2_ B3_, r A2_ B3_, rw A2_ B3_,
      rulesa A2_ B3_, q_empty A2_ B3_, is_QNF A2_ B3_,
      nFQ_subset_NF_rules A2_ B3_, rules_map A2_ B3_,
      delete_R_Rw (A1_, A2_) (B2_, B3_), split_rules A2_ B3_,
      mk (A1_, A2_) (B1_, B2_, B3_, B4_), nfs A2_ B3_, ());

fun certify_cert_problem (B1_, B2_, B3_, B4_, B5_) i j k l a input claim proof =
  (case check_cert (B1_, B2_, B3_, B4_, B5_) i j k l a input claim proof
    of Inl err => Error (err []) | Inr _ => Certified);

fun parse_cert_problem x =
  parse_xmlfile
    (debug [#"0"]
      [#"p", #"a", #"r", #"s", #"i", #"n", #"g", #" ", #"x", #"m", #"l", #" ",
        #"t", #"o", #" ", #"c", #"e", #"r", #"t", #"i", #"f", #"i", #"c", #"a",
        #"t", #"i", #"o", #"n", #" ", #"p", #"r", #"o", #"b", #"l", #"e", #"m"]
      (xml2cert_problem (xml_text [#"n", #"a", #"m", #"e"]) plain_name))
    x;

fun certify_proof a xtc_o claim_o cpf =
  (case (case xtc_o of NONE => Inr NONE
          | SOME xtc =>
            (case parse_xmlfile
                    (problem
                      (show_lab (show_list show_char) (show_list show_nat))
                      plain_name)
                    xtc
              of Inl aa => Inl aa | Inr input => Inr (SOME input)))
    of Inl aa => Error aa
    | Inr input_o1 =>
      (case (case claim_o of Inl aa => Inr aa
              | Inr aa => parse_claim plain_name aa)
        of Inl aa => Error aa
        | Inr claim =>
          (case parse_cert_problem cpf of Inl aa => Error aa
            | Inr (input_o2, proof) =>
              (case (input_o1, input_o2)
                of (NONE, NONE) =>
                  Error [#"m", #"i", #"s", #"s", #"i", #"n", #"g", #" ", #"i",
                          #"n", #"p", #"u", #"t", #" ", #"p", #"r", #"o", #"b",
                          #"l", #"e", #"m"]
                | (NONE, SOME input) =>
                  certify_cert_problem
                    (countable_list countable_char, default_list,
                      equal_list equal_char, key_list (equal_char, key_char),
                      show_list show_char)
                    (tp_rbt_impl
                      (equal_lab (equal_list equal_char) (equal_list equal_nat),
                        key_lab (key_list (equal_char, key_char))
                          (key_list (equal_nat, key_nat)))
                      (ccompare_list ccompare_char, equal_list equal_char,
                        key_list (equal_char, key_char), mapping_impl_list))
                    (dpp_rbt_impl
                      (equal_lab (equal_list equal_char) (equal_list equal_nat),
                        key_lab (key_list (equal_char, key_char))
                          (key_list (equal_nat, key_nat)))
                      (ccompare_list ccompare_char, compare_list compare_char,
                        equal_list equal_char, mapping_impl_list))
                    (ac_tp_list_impl
                      (ceq_lab (equal_list equal_char) (equal_list equal_nat),
                        ccompare_lab (compare_list compare_char)
                          (compare_list compare_nat),
                        compare_lab (compare_list compare_char)
                          (compare_list compare_nat),
                        equal_lab (equal_list equal_char)
                          (equal_list equal_nat),
                        set_impl_lab))
                    (ac_dpp_rbt_impl
                      (equal_lab (equal_list equal_char) (equal_list equal_nat),
                        key_lab (key_list (equal_char, key_char))
                          (key_list (equal_nat, key_nat)))
                      (compare_list compare_char, equal_list equal_char))
                    a input claim proof
                | (SOME input, _) =>
                  certify_cert_problem
                    (countable_list countable_char, default_list,
                      equal_list equal_char, key_list (equal_char, key_char),
                      show_list show_char)
                    (tp_rbt_impl
                      (equal_lab (equal_list equal_char) (equal_list equal_nat),
                        key_lab (key_list (equal_char, key_char))
                          (key_list (equal_nat, key_nat)))
                      (ccompare_list ccompare_char, equal_list equal_char,
                        key_list (equal_char, key_char), mapping_impl_list))
                    (dpp_rbt_impl
                      (equal_lab (equal_list equal_char) (equal_list equal_nat),
                        key_lab (key_list (equal_char, key_char))
                          (key_list (equal_nat, key_nat)))
                      (ccompare_list ccompare_char, compare_list compare_char,
                        equal_list equal_char, mapping_impl_list))
                    (ac_tp_list_impl
                      (ceq_lab (equal_list equal_char) (equal_list equal_nat),
                        ccompare_lab (compare_list compare_char)
                          (compare_list compare_nat),
                        compare_lab (compare_list compare_char)
                          (compare_list compare_nat),
                        equal_lab (equal_list equal_char)
                          (equal_list equal_nat),
                        set_impl_lab))
                    (ac_dpp_rbt_impl
                      (equal_lab (equal_list equal_char) (equal_list equal_nat),
                        key_lab (key_list (equal_char, key_char))
                          (key_list (equal_nat, key_nat)))
                      (compare_list compare_char, equal_list equal_char))
                    a input claim proof))));

end; (*struct Ceta*)
